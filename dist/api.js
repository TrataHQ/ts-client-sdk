"use strict";
// tslint:disable
/**
 * Trata AI API
 * Human like conversation to answer calls, drive engagement, automate follow-ups & schedule bookings 24/7  with end to end integrations ensuring you never miss a sales enquiry.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkflowsSubWorkflowsApi = exports.WorkflowsSubWorkflowsApiFactory = exports.WorkflowsSubWorkflowsApiFp = exports.WorkflowsSubWorkflowsApiAxiosParamCreator = exports.WorkflowsExecutionsApi = exports.WorkflowsExecutionsApiFactory = exports.WorkflowsExecutionsApiFp = exports.WorkflowsExecutionsApiAxiosParamCreator = exports.WorkflowsConnectionsApi = exports.WorkflowsConnectionsApiFactory = exports.WorkflowsConnectionsApiFp = exports.WorkflowsConnectionsApiAxiosParamCreator = exports.WorkflowsAppsApi = exports.WorkflowsAppsApiFactory = exports.WorkflowsAppsApiFp = exports.WorkflowsAppsApiAxiosParamCreator = exports.WorkflowsApiHubspotApi = exports.WorkflowsApiHubspotApiFactory = exports.WorkflowsApiHubspotApiFp = exports.WorkflowsApiHubspotApiAxiosParamCreator = exports.WorkflowsApi = exports.WorkflowsApiFactory = exports.WorkflowsApiFp = exports.WorkflowsApiAxiosParamCreator = exports.VoiceModelsApi = exports.VoiceModelsApiFactory = exports.VoiceModelsApiFp = exports.VoiceModelsApiAxiosParamCreator = exports.UIApi = exports.UIApiFactory = exports.UIApiFp = exports.UIApiAxiosParamCreator = exports.TelephonyApi = exports.TelephonyApiFactory = exports.TelephonyApiFp = exports.TelephonyApiAxiosParamCreator = exports.SparringApi = exports.SparringApiFactory = exports.SparringApiFp = exports.SparringApiAxiosParamCreator = exports.SparrResellerApi = exports.SparrResellerApiFactory = exports.SparrResellerApiFp = exports.SparrResellerApiAxiosParamCreator = exports.SparrApi = exports.SparrApiFactory = exports.SparrApiFp = exports.SparrApiAxiosParamCreator = exports.ResellerUserApi = exports.ResellerUserApiFactory = exports.ResellerUserApiFp = exports.ResellerUserApiAxiosParamCreator = exports.ResellerSettingsApi = exports.ResellerSettingsApiFactory = exports.ResellerSettingsApiFp = exports.ResellerSettingsApiAxiosParamCreator = exports.ResellerPricingApi = exports.ResellerPricingApiFactory = exports.ResellerPricingApiFp = exports.ResellerPricingApiAxiosParamCreator = exports.ResellerOrganizationApi = exports.ResellerOrganizationApiFactory = exports.ResellerOrganizationApiFp = exports.ResellerOrganizationApiAxiosParamCreator = exports.ResellerMetricsApi = exports.ResellerMetricsApiFactory = exports.ResellerMetricsApiFp = exports.ResellerMetricsApiAxiosParamCreator = exports.ResellerFilesApi = exports.ResellerFilesApiFactory = exports.ResellerFilesApiFp = exports.ResellerFilesApiAxiosParamCreator = exports.ResellerCustomerUserApi = exports.ResellerCustomerUserApiFactory = exports.ResellerCustomerUserApiFp = exports.ResellerCustomerUserApiAxiosParamCreator = exports.ResellerCustomerPricingApi = exports.ResellerCustomerPricingApiFactory = exports.ResellerCustomerPricingApiFp = exports.ResellerCustomerPricingApiAxiosParamCreator = exports.ResellerCustomerPortalApi = exports.ResellerCustomerPortalApiFactory = exports.ResellerCustomerPortalApiFp = exports.ResellerCustomerPortalApiAxiosParamCreator = exports.ResellerCustomerDefaultPricingApi = exports.ResellerCustomerDefaultPricingApiFactory = exports.ResellerCustomerDefaultPricingApiFp = exports.ResellerCustomerDefaultPricingApiAxiosParamCreator = exports.ResellerCustomerCheckoutApi = exports.ResellerCustomerCheckoutApiFactory = exports.ResellerCustomerCheckoutApiFp = exports.ResellerCustomerCheckoutApiAxiosParamCreator = exports.ResellerCustomerAuditLogsApi = exports.ResellerCustomerAuditLogsApiFactory = exports.ResellerCustomerAuditLogsApiFp = exports.ResellerCustomerAuditLogsApiAxiosParamCreator = exports.ResellerCustomerApi = exports.ResellerCustomerApiFactory = exports.ResellerCustomerApiFp = exports.ResellerCustomerApiAxiosParamCreator = exports.ResellerCourseAssignmentsApi = exports.ResellerCourseAssignmentsApiFactory = exports.ResellerCourseAssignmentsApiFp = exports.ResellerCourseAssignmentsApiAxiosParamCreator = exports.ProspectsApi = exports.ProspectsApiFactory = exports.ProspectsApiFp = exports.ProspectsApiAxiosParamCreator = exports.ProductsApi = exports.ProductsApiFactory = exports.ProductsApiFp = exports.ProductsApiAxiosParamCreator = exports.InternalApi = exports.InternalApiFactory = exports.InternalApiFp = exports.InternalApiAxiosParamCreator = exports.HiveAgentLinkApi = exports.HiveAgentLinkApiFactory = exports.HiveAgentLinkApiFp = exports.HiveAgentLinkApiAxiosParamCreator = exports.HiveApi = exports.HiveApiFactory = exports.HiveApiFp = exports.HiveApiAxiosParamCreator = exports.HealthApi = exports.HealthApiFactory = exports.HealthApiFp = exports.HealthApiAxiosParamCreator = exports.FilesApi = exports.FilesApiFactory = exports.FilesApiFp = exports.FilesApiAxiosParamCreator = exports.DataPlaneApi = exports.DataPlaneApiFactory = exports.DataPlaneApiFp = exports.DataPlaneApiAxiosParamCreator = exports.ConversationsApi = exports.ConversationsApiFactory = exports.ConversationsApiFp = exports.ConversationsApiAxiosParamCreator = exports.ConversationProspectLinkApi = exports.ConversationProspectLinkApiFactory = exports.ConversationProspectLinkApiFp = exports.ConversationProspectLinkApiAxiosParamCreator = exports.BillingApi = exports.BillingApiFactory = exports.BillingApiFp = exports.BillingApiAxiosParamCreator = exports.ApiKeyApi = exports.ApiKeyApiFactory = exports.ApiKeyApiFp = exports.ApiKeyApiAxiosParamCreator = exports.AnalyticsApi = exports.AnalyticsApiFactory = exports.AnalyticsApiFp = exports.AnalyticsApiAxiosParamCreator = exports.AgentsApi = exports.AgentsApiFactory = exports.AgentsApiFp = exports.AgentsApiAxiosParamCreator = exports.ActionsApi = exports.ActionsApiFactory = exports.ActionsApiFp = exports.ActionsApiAxiosParamCreator = exports.ActionAgentLinkApi = exports.ActionAgentLinkApiFactory = exports.ActionAgentLinkApiFp = exports.ActionAgentLinkApiAxiosParamCreator = exports.VoiceOutputGenderEnum = exports.VoiceInputGenderEnum = exports.VirtualProspectTypeEnum = exports.UiNodeType = exports.Status = exports.SparrVoiceLanguage = exports.SparrVoiceAccent = exports.SparrRudenessLevel = exports.SparrPatienceLevel = exports.SparrNegotiationStyle = exports.SparrModelsAnalyticsMetricName = exports.SparrInteractionTone = exports.SparrFrustrationTolerance = exports.SparrExcitementLevel = exports.SparrEngagementLevel = exports.SparrDialogLineWithSentimentSentimentEnum = exports.SparrDialogLineSpeakerEnum = exports.SparrDecisionMakingStyle = exports.SparrCommunicationStyle = exports.SparrAdaptability = exports.SortOrder = exports.Role = exports.ProspectStatus = exports.ProductInputCurrencyEnum = exports.PriceInterval = exports.PatienceLevel = exports.OrganizationInitializationStatus = exports.OAuthCredentialsCredentialsTypeEnum = exports.OAuthAuthTypeEnum = exports.NoAuthCredentialsCredentialsTypeEnum = exports.NoAuthAuthTypeEnum = exports.NegotiationStyle = exports.ModuleAttemptStatus = exports.MetricNameInput = exports.Language = exports.InteractionTone = exports.HttpActionEndpointMethodEnum = exports.HiveType = exports.FrustrationTolerance = exports.EngagementLevel = exports.DialogLineSpeakerEnum = exports.DecisionMakingStyle = exports.CreditTypeEnum = exports.CourseCompletionStatus = exports.CourseAssignmentStatus = exports.ConversationStartEventPayloadTypeEnum = exports.ConversationSourceType = exports.ConnectionSourceSourceNameEnum = exports.CommunicationStyle = exports.ChangeAssignmentOperation = exports.CallSentiment = exports.BasicAuthCredentialsCredentialsTypeEnum = exports.BasicAuthAuthTypeEnum = exports.AuthRole = exports.AppEnumOutput = exports.AppEnumInput = exports.AppActionType = exports.ApiKeyCredentialsCredentialsTypeEnum = exports.ApiKeyAuthAuthTypeEnum = exports.AggregationPeriod = exports.AggregationFormula = exports.AgenticWorkflowAdkModelsWorkflowAppEnum = exports.Adaptability = exports.ActionInvocationTrigger = exports.Accent = void 0;
const globalImportUrl = require("url");
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const base_1 = require("./base");
/**
 *
 * @export
 * @enum {string}
 */
var Accent;
(function (Accent) {
    Accent["American"] = "American";
    Accent["Indian"] = "Indian";
    Accent["Australian"] = "Australian";
    Accent["British"] = "British";
    Accent["Hindi"] = "Hindi";
    Accent["MiddleEastern"] = "Middle Eastern";
})(Accent = exports.Accent || (exports.Accent = {}));
/**
 *
 * @export
 * @enum {string}
 */
var ActionInvocationTrigger;
(function (ActionInvocationTrigger) {
    ActionInvocationTrigger["UserQuery"] = "user_query";
    ActionInvocationTrigger["WebhookConversationStart"] = "webhook.conversation_start";
    ActionInvocationTrigger["WebhookConversationEnd"] = "webhook.conversation_end";
})(ActionInvocationTrigger = exports.ActionInvocationTrigger || (exports.ActionInvocationTrigger = {}));
/**
 *
 * @export
 * @enum {string}
 */
var Adaptability;
(function (Adaptability) {
    Adaptability["OpenToChange"] = "open to change";
    Adaptability["Resistant"] = "resistant";
    Adaptability["Indifferent"] = "indifferent";
})(Adaptability = exports.Adaptability || (exports.Adaptability = {}));
/**
 * Enum which stores the list of apps which are used to create the conversation
 * @export
 * @enum {string}
 */
var AgenticWorkflowAdkModelsWorkflowAppEnum;
(function (AgenticWorkflowAdkModelsWorkflowAppEnum) {
    AgenticWorkflowAdkModelsWorkflowAppEnum["TRATA"] = "TRATA";
    AgenticWorkflowAdkModelsWorkflowAppEnum["TRATASPARR"] = "TRATA_SPARR";
})(AgenticWorkflowAdkModelsWorkflowAppEnum = exports.AgenticWorkflowAdkModelsWorkflowAppEnum || (exports.AgenticWorkflowAdkModelsWorkflowAppEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var AggregationFormula;
(function (AggregationFormula) {
    AggregationFormula["COUNT"] = "COUNT";
    AggregationFormula["SUM"] = "SUM";
    AggregationFormula["MEDIAN"] = "MEDIAN";
})(AggregationFormula = exports.AggregationFormula || (exports.AggregationFormula = {}));
/**
 *
 * @export
 * @enum {string}
 */
var AggregationPeriod;
(function (AggregationPeriod) {
    AggregationPeriod["MONTHLY"] = "MONTHLY";
    AggregationPeriod["WEEKLY"] = "WEEKLY";
    AggregationPeriod["DAILY"] = "DAILY";
})(AggregationPeriod = exports.AggregationPeriod || (exports.AggregationPeriod = {}));
/**
    * @export
    * @enum {string}
    */
var ApiKeyAuthAuthTypeEnum;
(function (ApiKeyAuthAuthTypeEnum) {
    ApiKeyAuthAuthTypeEnum["Apikey"] = "apikey";
})(ApiKeyAuthAuthTypeEnum = exports.ApiKeyAuthAuthTypeEnum || (exports.ApiKeyAuthAuthTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ApiKeyCredentialsCredentialsTypeEnum;
(function (ApiKeyCredentialsCredentialsTypeEnum) {
    ApiKeyCredentialsCredentialsTypeEnum["Apikey"] = "apikey";
})(ApiKeyCredentialsCredentialsTypeEnum = exports.ApiKeyCredentialsCredentialsTypeEnum || (exports.ApiKeyCredentialsCredentialsTypeEnum = {}));
/**
 * Enum for step types
 * @export
 * @enum {string}
 */
var AppActionType;
(function (AppActionType) {
    AppActionType["TRIGGER"] = "TRIGGER";
    AppActionType["ACTION"] = "ACTION";
})(AppActionType = exports.AppActionType || (exports.AppActionType = {}));
/**
 * Enum which stores the list of apps which are used to create the conversation
 * @export
 * @enum {string}
 */
var AppEnumInput;
(function (AppEnumInput) {
    AppEnumInput["TRATA"] = "TRATA";
    AppEnumInput["TRATASPARR"] = "TRATA_SPARR";
    AppEnumInput["TRATASPARRV1"] = "TRATA_SPARR_V1";
})(AppEnumInput = exports.AppEnumInput || (exports.AppEnumInput = {}));
/**
 * Enum which stores the list of apps which are used to create the conversation
 * @export
 * @enum {string}
 */
var AppEnumOutput;
(function (AppEnumOutput) {
    AppEnumOutput["TRATA"] = "TRATA";
    AppEnumOutput["TRATASPARR"] = "TRATA_SPARR";
    AppEnumOutput["TRATASPARRV1"] = "TRATA_SPARR_V1";
})(AppEnumOutput = exports.AppEnumOutput || (exports.AppEnumOutput = {}));
/**
 *
 * @export
 * @enum {string}
 */
var AuthRole;
(function (AuthRole) {
    AuthRole["Owner"] = "Owner";
    AuthRole["Admin"] = "Admin";
    AuthRole["Member"] = "Member";
})(AuthRole = exports.AuthRole || (exports.AuthRole = {}));
/**
    * @export
    * @enum {string}
    */
var BasicAuthAuthTypeEnum;
(function (BasicAuthAuthTypeEnum) {
    BasicAuthAuthTypeEnum["Basic"] = "basic";
})(BasicAuthAuthTypeEnum = exports.BasicAuthAuthTypeEnum || (exports.BasicAuthAuthTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var BasicAuthCredentialsCredentialsTypeEnum;
(function (BasicAuthCredentialsCredentialsTypeEnum) {
    BasicAuthCredentialsCredentialsTypeEnum["Basic"] = "basic";
})(BasicAuthCredentialsCredentialsTypeEnum = exports.BasicAuthCredentialsCredentialsTypeEnum || (exports.BasicAuthCredentialsCredentialsTypeEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var CallSentiment;
(function (CallSentiment) {
    CallSentiment["Positive"] = "positive";
    CallSentiment["Negative"] = "negative";
    CallSentiment["Neutral"] = "neutral";
})(CallSentiment = exports.CallSentiment || (exports.CallSentiment = {}));
/**
 *
 * @export
 * @enum {string}
 */
var ChangeAssignmentOperation;
(function (ChangeAssignmentOperation) {
    ChangeAssignmentOperation["Assign"] = "assign";
    ChangeAssignmentOperation["Remove"] = "remove";
})(ChangeAssignmentOperation = exports.ChangeAssignmentOperation || (exports.ChangeAssignmentOperation = {}));
/**
 *
 * @export
 * @enum {string}
 */
var CommunicationStyle;
(function (CommunicationStyle) {
    CommunicationStyle["Direct"] = "direct";
    CommunicationStyle["Indirect"] = "indirect";
    CommunicationStyle["Verbose"] = "verbose";
    CommunicationStyle["Brief"] = "brief";
})(CommunicationStyle = exports.CommunicationStyle || (exports.CommunicationStyle = {}));
/**
    * @export
    * @enum {string}
    */
var ConnectionSourceSourceNameEnum;
(function (ConnectionSourceSourceNameEnum) {
    ConnectionSourceSourceNameEnum["TWILIO"] = "TWILIO";
    ConnectionSourceSourceNameEnum["PLIVO"] = "PLIVO";
    ConnectionSourceSourceNameEnum["BROWSER"] = "BROWSER";
})(ConnectionSourceSourceNameEnum = exports.ConnectionSourceSourceNameEnum || (exports.ConnectionSourceSourceNameEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var ConversationSourceType;
(function (ConversationSourceType) {
    ConversationSourceType["BROWSER"] = "BROWSER";
    ConversationSourceType["TWILIO"] = "TWILIO";
    ConversationSourceType["PLIVO"] = "PLIVO";
})(ConversationSourceType = exports.ConversationSourceType || (exports.ConversationSourceType = {}));
/**
    * @export
    * @enum {string}
    */
var ConversationStartEventPayloadTypeEnum;
(function (ConversationStartEventPayloadTypeEnum) {
    ConversationStartEventPayloadTypeEnum["ConversationStart"] = "conversation_start";
})(ConversationStartEventPayloadTypeEnum = exports.ConversationStartEventPayloadTypeEnum || (exports.ConversationStartEventPayloadTypeEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var CourseAssignmentStatus;
(function (CourseAssignmentStatus) {
    CourseAssignmentStatus["Assigned"] = "assigned";
    CourseAssignmentStatus["Unassigned"] = "unassigned";
})(CourseAssignmentStatus = exports.CourseAssignmentStatus || (exports.CourseAssignmentStatus = {}));
/**
 *
 * @export
 * @enum {string}
 */
var CourseCompletionStatus;
(function (CourseCompletionStatus) {
    CourseCompletionStatus["NOTSTARTED"] = "NOT_STARTED";
    CourseCompletionStatus["INPROGRESS"] = "IN_PROGRESS";
    CourseCompletionStatus["COMPLETED"] = "COMPLETED";
})(CourseCompletionStatus = exports.CourseCompletionStatus || (exports.CourseCompletionStatus = {}));
/**
 * Enum for the type of credit
 * @export
 * @enum {string}
 */
var CreditTypeEnum;
(function (CreditTypeEnum) {
    CreditTypeEnum["PhoneNumbers"] = "phone_numbers";
    CreditTypeEnum["CallSeconds"] = "call_seconds";
    CreditTypeEnum["CallHours"] = "call_hours";
    CreditTypeEnum["Emails"] = "emails";
    CreditTypeEnum["LinkedInScraping"] = "linked_in_scraping";
    CreditTypeEnum["Courses"] = "courses";
    CreditTypeEnum["RecordingAndTranscription"] = "recording_and_transcription";
    CreditTypeEnum["Users"] = "users";
    CreditTypeEnum["AdvancedIntelligence"] = "advanced_intelligence";
    CreditTypeEnum["RolePlayCustomization"] = "role_play_customization";
})(CreditTypeEnum = exports.CreditTypeEnum || (exports.CreditTypeEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var DecisionMakingStyle;
(function (DecisionMakingStyle) {
    DecisionMakingStyle["Logical"] = "logical";
    DecisionMakingStyle["Emotional"] = "emotional";
    DecisionMakingStyle["Impulsive"] = "impulsive";
    DecisionMakingStyle["Hesitant"] = "hesitant";
})(DecisionMakingStyle = exports.DecisionMakingStyle || (exports.DecisionMakingStyle = {}));
/**
    * @export
    * @enum {string}
    */
var DialogLineSpeakerEnum;
(function (DialogLineSpeakerEnum) {
    DialogLineSpeakerEnum["USER"] = "USER";
    DialogLineSpeakerEnum["AI"] = "AI";
    DialogLineSpeakerEnum["TOOL"] = "TOOL";
    DialogLineSpeakerEnum["AITOOLREQUEST"] = "AI - TOOL REQUEST";
})(DialogLineSpeakerEnum = exports.DialogLineSpeakerEnum || (exports.DialogLineSpeakerEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var EngagementLevel;
(function (EngagementLevel) {
    EngagementLevel["HighlyEngaged"] = "highly engaged";
    EngagementLevel["Distracted"] = "distracted";
    EngagementLevel["Uninterested"] = "uninterested";
})(EngagementLevel = exports.EngagementLevel || (exports.EngagementLevel = {}));
/**
 *
 * @export
 * @enum {string}
 */
var FrustrationTolerance;
(function (FrustrationTolerance) {
    FrustrationTolerance["QuickToAnger"] = "quick to anger";
    FrustrationTolerance["Understanding"] = "understanding";
    FrustrationTolerance["Neutral"] = "neutral";
})(FrustrationTolerance = exports.FrustrationTolerance || (exports.FrustrationTolerance = {}));
/**
 *
 * @export
 * @enum {string}
 */
var HiveType;
(function (HiveType) {
    HiveType["WEBSITE"] = "WEBSITE";
    HiveType["GOOGLEDOCS"] = "GOOGLE_DOCS";
    HiveType["DOCS"] = "DOCS";
    HiveType["TRANSCRIPTS"] = "TRANSCRIPTS";
})(HiveType = exports.HiveType || (exports.HiveType = {}));
/**
    * @export
    * @enum {string}
    */
var HttpActionEndpointMethodEnum;
(function (HttpActionEndpointMethodEnum) {
    HttpActionEndpointMethodEnum["GET"] = "GET";
    HttpActionEndpointMethodEnum["POST"] = "POST";
})(HttpActionEndpointMethodEnum = exports.HttpActionEndpointMethodEnum || (exports.HttpActionEndpointMethodEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var InteractionTone;
(function (InteractionTone) {
    InteractionTone["Professional"] = "professional";
    InteractionTone["Casual"] = "casual";
    InteractionTone["Friendly"] = "friendly";
    InteractionTone["Authoritative"] = "authoritative";
})(InteractionTone = exports.InteractionTone || (exports.InteractionTone = {}));
/**
 *
 * @export
 * @enum {string}
 */
var Language;
(function (Language) {
    Language["English"] = "English";
    Language["Spanish"] = "Spanish";
    Language["Hindi"] = "Hindi";
})(Language = exports.Language || (exports.Language = {}));
/**
 *
 * @export
 * @enum {string}
 */
var MetricNameInput;
(function (MetricNameInput) {
    MetricNameInput["CALLS"] = "CALLS";
    MetricNameInput["CALLDURATION"] = "CALL_DURATION";
    MetricNameInput["SPARRCALLS"] = "SPARR_CALLS";
    MetricNameInput["SPARRCALLDURATION"] = "SPARR_CALL_DURATION";
    MetricNameInput["APPOINTMENTSCHEDULED"] = "APPOINTMENT_SCHEDULED";
    MetricNameInput["CREDITSCONSUMED"] = "CREDITS_CONSUMED";
    MetricNameInput["CREDITSCONSUMEDPHONENUMBERS"] = "CREDITS_CONSUMED_PHONE_NUMBERS";
    MetricNameInput["CREDITSCONSUMEDCALLSECONDS"] = "CREDITS_CONSUMED_CALL_SECONDS";
    MetricNameInput["CREDITSCONSUMEDEMAILS"] = "CREDITS_CONSUMED_EMAILS";
    MetricNameInput["CREDITSCONSUMEDLEADGENERATION"] = "CREDITS_CONSUMED_LEAD_GENERATION";
    MetricNameInput["CREDITSCONSUMEDLINKEDINSCRAPING"] = "CREDITS_CONSUMED_LINKED_IN_SCRAPING";
    MetricNameInput["CREDITSCONSUMEDCOURSES"] = "CREDITS_CONSUMED_COURSES";
    MetricNameInput["CREDITSTOTAL"] = "CREDITS_TOTAL";
    MetricNameInput["CREDITSTOTALPHONENUMBERS"] = "CREDITS_TOTAL_PHONE_NUMBERS";
    MetricNameInput["CREDITSTOTALCALLSECONDS"] = "CREDITS_TOTAL_CALL_SECONDS";
    MetricNameInput["CREDITSTOTALEMAILS"] = "CREDITS_TOTAL_EMAILS";
    MetricNameInput["CREDITSTOTALLEADGENERATION"] = "CREDITS_TOTAL_LEAD_GENERATION";
    MetricNameInput["CREDITSTOTALLINKEDINSCRAPING"] = "CREDITS_TOTAL_LINKED_IN_SCRAPING";
    MetricNameInput["CREDITSTOTALCOURSES"] = "CREDITS_TOTAL_COURSES";
    MetricNameInput["CREDITBURNRATE"] = "CREDIT_BURN_RATE";
    MetricNameInput["CREDITBURNRATEPHONENUMBERS"] = "CREDIT_BURN_RATE_PHONE_NUMBERS";
    MetricNameInput["CREDITBURNRATECALLSECONDS"] = "CREDIT_BURN_RATE_CALL_SECONDS";
    MetricNameInput["CREDITBURNRATEEMAILS"] = "CREDIT_BURN_RATE_EMAILS";
    MetricNameInput["CREDITBURNRATELEADGENERATION"] = "CREDIT_BURN_RATE_LEAD_GENERATION";
    MetricNameInput["CREDITBURNRATELINKEDINSCRAPING"] = "CREDIT_BURN_RATE_LINKED_IN_SCRAPING";
    MetricNameInput["CREDITBURNRATECOURSES"] = "CREDIT_BURN_RATE_COURSES";
    MetricNameInput["TOTALREVENUE"] = "TOTAL_REVENUE";
    MetricNameInput["PROFIT"] = "PROFIT";
    MetricNameInput["REVENUEBYSUBSCRIPTION"] = "REVENUE_BY_SUBSCRIPTION";
    MetricNameInput["REVENUEBYADDONS"] = "REVENUE_BY_ADD_ONS";
    MetricNameInput["MONTHLYRECURRINGREVENUE"] = "MONTHLY_RECURRING_REVENUE";
    MetricNameInput["ONETIMEREVENUE"] = "ONE_TIME_REVENUE";
    MetricNameInput["ACTIVESUBSCRIPTIONS"] = "ACTIVE_SUBSCRIPTIONS";
    MetricNameInput["NUMBEROFACTIVEPAYINGCUSTOMERS"] = "NUMBER_OF_ACTIVE_PAYING_CUSTOMERS";
    MetricNameInput["AVERAGEREVENUEPERACTIVEPAYINGCUSTOMER"] = "AVERAGE_REVENUE_PER_ACTIVE_PAYING_CUSTOMER";
    MetricNameInput["TOTALHOURSCONSUMED"] = "TOTAL_HOURS_CONSUMED";
    MetricNameInput["PROSPECTS"] = "PROSPECTS";
    MetricNameInput["INTERESTED"] = "INTERESTED";
    MetricNameInput["NOTINTERESTED"] = "NOT_INTERESTED";
    MetricNameInput["NEWCUSTOMERS"] = "NEW_CUSTOMERS";
})(MetricNameInput = exports.MetricNameInput || (exports.MetricNameInput = {}));
/**
 *
 * @export
 * @enum {string}
 */
var ModuleAttemptStatus;
(function (ModuleAttemptStatus) {
    ModuleAttemptStatus["PASSED"] = "PASSED";
    ModuleAttemptStatus["FAILED"] = "FAILED";
    ModuleAttemptStatus["NOTATTEMPTED"] = "NOT_ATTEMPTED";
})(ModuleAttemptStatus = exports.ModuleAttemptStatus || (exports.ModuleAttemptStatus = {}));
/**
 *
 * @export
 * @enum {string}
 */
var NegotiationStyle;
(function (NegotiationStyle) {
    NegotiationStyle["HardBargainer"] = "hard bargainer";
    NegotiationStyle["FriendlyNegotiator"] = "friendly negotiator";
    NegotiationStyle["NonNegotiator"] = "non-negotiator";
})(NegotiationStyle = exports.NegotiationStyle || (exports.NegotiationStyle = {}));
/**
    * @export
    * @enum {string}
    */
var NoAuthAuthTypeEnum;
(function (NoAuthAuthTypeEnum) {
    NoAuthAuthTypeEnum["Noauth"] = "noauth";
})(NoAuthAuthTypeEnum = exports.NoAuthAuthTypeEnum || (exports.NoAuthAuthTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var NoAuthCredentialsCredentialsTypeEnum;
(function (NoAuthCredentialsCredentialsTypeEnum) {
    NoAuthCredentialsCredentialsTypeEnum["Noauth"] = "noauth";
})(NoAuthCredentialsCredentialsTypeEnum = exports.NoAuthCredentialsCredentialsTypeEnum || (exports.NoAuthCredentialsCredentialsTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var OAuthAuthTypeEnum;
(function (OAuthAuthTypeEnum) {
    OAuthAuthTypeEnum["Oauth"] = "oauth";
})(OAuthAuthTypeEnum = exports.OAuthAuthTypeEnum || (exports.OAuthAuthTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var OAuthCredentialsCredentialsTypeEnum;
(function (OAuthCredentialsCredentialsTypeEnum) {
    OAuthCredentialsCredentialsTypeEnum["Oauth"] = "oauth";
})(OAuthCredentialsCredentialsTypeEnum = exports.OAuthCredentialsCredentialsTypeEnum || (exports.OAuthCredentialsCredentialsTypeEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var OrganizationInitializationStatus;
(function (OrganizationInitializationStatus) {
    OrganizationInitializationStatus["PENDING"] = "PENDING";
    OrganizationInitializationStatus["COMPLETED"] = "COMPLETED";
    OrganizationInitializationStatus["FAILED"] = "FAILED";
})(OrganizationInitializationStatus = exports.OrganizationInitializationStatus || (exports.OrganizationInitializationStatus = {}));
/**
 *
 * @export
 * @enum {string}
 */
var PatienceLevel;
(function (PatienceLevel) {
    PatienceLevel["Impatient"] = "impatient";
    PatienceLevel["Neutral"] = "neutral";
    PatienceLevel["VeryPatient"] = "very patient";
})(PatienceLevel = exports.PatienceLevel || (exports.PatienceLevel = {}));
/**
 *
 * @export
 * @enum {string}
 */
var PriceInterval;
(function (PriceInterval) {
    PriceInterval["OneTime"] = "one_time";
    PriceInterval["Monthly"] = "monthly";
    PriceInterval["Quarterly"] = "quarterly";
    PriceInterval["Yearly"] = "yearly";
})(PriceInterval = exports.PriceInterval || (exports.PriceInterval = {}));
/**
    * @export
    * @enum {string}
    */
var ProductInputCurrencyEnum;
(function (ProductInputCurrencyEnum) {
    ProductInputCurrencyEnum["AED"] = "AED";
    ProductInputCurrencyEnum["AFN"] = "AFN";
    ProductInputCurrencyEnum["ALL"] = "ALL";
    ProductInputCurrencyEnum["AMD"] = "AMD";
    ProductInputCurrencyEnum["ANG"] = "ANG";
    ProductInputCurrencyEnum["AOA"] = "AOA";
    ProductInputCurrencyEnum["ARS"] = "ARS";
    ProductInputCurrencyEnum["AUD"] = "AUD";
    ProductInputCurrencyEnum["AWG"] = "AWG";
    ProductInputCurrencyEnum["AZN"] = "AZN";
    ProductInputCurrencyEnum["BAM"] = "BAM";
    ProductInputCurrencyEnum["BBD"] = "BBD";
    ProductInputCurrencyEnum["BDT"] = "BDT";
    ProductInputCurrencyEnum["BGN"] = "BGN";
    ProductInputCurrencyEnum["BHD"] = "BHD";
    ProductInputCurrencyEnum["BIF"] = "BIF";
    ProductInputCurrencyEnum["BMD"] = "BMD";
    ProductInputCurrencyEnum["BND"] = "BND";
    ProductInputCurrencyEnum["BOB"] = "BOB";
    ProductInputCurrencyEnum["BOV"] = "BOV";
    ProductInputCurrencyEnum["BRL"] = "BRL";
    ProductInputCurrencyEnum["BSD"] = "BSD";
    ProductInputCurrencyEnum["BTN"] = "BTN";
    ProductInputCurrencyEnum["BWP"] = "BWP";
    ProductInputCurrencyEnum["BYN"] = "BYN";
    ProductInputCurrencyEnum["BZD"] = "BZD";
    ProductInputCurrencyEnum["CAD"] = "CAD";
    ProductInputCurrencyEnum["CDF"] = "CDF";
    ProductInputCurrencyEnum["CHE"] = "CHE";
    ProductInputCurrencyEnum["CHF"] = "CHF";
    ProductInputCurrencyEnum["CHW"] = "CHW";
    ProductInputCurrencyEnum["CLF"] = "CLF";
    ProductInputCurrencyEnum["CLP"] = "CLP";
    ProductInputCurrencyEnum["CNY"] = "CNY";
    ProductInputCurrencyEnum["COP"] = "COP";
    ProductInputCurrencyEnum["COU"] = "COU";
    ProductInputCurrencyEnum["CRC"] = "CRC";
    ProductInputCurrencyEnum["CUC"] = "CUC";
    ProductInputCurrencyEnum["CUP"] = "CUP";
    ProductInputCurrencyEnum["CVE"] = "CVE";
    ProductInputCurrencyEnum["CZK"] = "CZK";
    ProductInputCurrencyEnum["DJF"] = "DJF";
    ProductInputCurrencyEnum["DKK"] = "DKK";
    ProductInputCurrencyEnum["DOP"] = "DOP";
    ProductInputCurrencyEnum["DZD"] = "DZD";
    ProductInputCurrencyEnum["EGP"] = "EGP";
    ProductInputCurrencyEnum["ERN"] = "ERN";
    ProductInputCurrencyEnum["ETB"] = "ETB";
    ProductInputCurrencyEnum["EUR"] = "EUR";
    ProductInputCurrencyEnum["FJD"] = "FJD";
    ProductInputCurrencyEnum["FKP"] = "FKP";
    ProductInputCurrencyEnum["GBP"] = "GBP";
    ProductInputCurrencyEnum["GEL"] = "GEL";
    ProductInputCurrencyEnum["GHS"] = "GHS";
    ProductInputCurrencyEnum["GIP"] = "GIP";
    ProductInputCurrencyEnum["GMD"] = "GMD";
    ProductInputCurrencyEnum["GNF"] = "GNF";
    ProductInputCurrencyEnum["GTQ"] = "GTQ";
    ProductInputCurrencyEnum["GYD"] = "GYD";
    ProductInputCurrencyEnum["HKD"] = "HKD";
    ProductInputCurrencyEnum["HNL"] = "HNL";
    ProductInputCurrencyEnum["HRK"] = "HRK";
    ProductInputCurrencyEnum["HTG"] = "HTG";
    ProductInputCurrencyEnum["HUF"] = "HUF";
    ProductInputCurrencyEnum["IDR"] = "IDR";
    ProductInputCurrencyEnum["ILS"] = "ILS";
    ProductInputCurrencyEnum["INR"] = "INR";
    ProductInputCurrencyEnum["IQD"] = "IQD";
    ProductInputCurrencyEnum["IRR"] = "IRR";
    ProductInputCurrencyEnum["ISK"] = "ISK";
    ProductInputCurrencyEnum["JMD"] = "JMD";
    ProductInputCurrencyEnum["JOD"] = "JOD";
    ProductInputCurrencyEnum["JPY"] = "JPY";
    ProductInputCurrencyEnum["KES"] = "KES";
    ProductInputCurrencyEnum["KGS"] = "KGS";
    ProductInputCurrencyEnum["KHR"] = "KHR";
    ProductInputCurrencyEnum["KMF"] = "KMF";
    ProductInputCurrencyEnum["KPW"] = "KPW";
    ProductInputCurrencyEnum["KRW"] = "KRW";
    ProductInputCurrencyEnum["KWD"] = "KWD";
    ProductInputCurrencyEnum["KYD"] = "KYD";
    ProductInputCurrencyEnum["KZT"] = "KZT";
    ProductInputCurrencyEnum["LAK"] = "LAK";
    ProductInputCurrencyEnum["LBP"] = "LBP";
    ProductInputCurrencyEnum["LKR"] = "LKR";
    ProductInputCurrencyEnum["LRD"] = "LRD";
    ProductInputCurrencyEnum["LSL"] = "LSL";
    ProductInputCurrencyEnum["LYD"] = "LYD";
    ProductInputCurrencyEnum["MAD"] = "MAD";
    ProductInputCurrencyEnum["MDL"] = "MDL";
    ProductInputCurrencyEnum["MGA"] = "MGA";
    ProductInputCurrencyEnum["MKD"] = "MKD";
    ProductInputCurrencyEnum["MMK"] = "MMK";
    ProductInputCurrencyEnum["MNT"] = "MNT";
    ProductInputCurrencyEnum["MOP"] = "MOP";
    ProductInputCurrencyEnum["MRU"] = "MRU";
    ProductInputCurrencyEnum["MUR"] = "MUR";
    ProductInputCurrencyEnum["MVR"] = "MVR";
    ProductInputCurrencyEnum["MWK"] = "MWK";
    ProductInputCurrencyEnum["MXN"] = "MXN";
    ProductInputCurrencyEnum["MXV"] = "MXV";
    ProductInputCurrencyEnum["MYR"] = "MYR";
    ProductInputCurrencyEnum["MZN"] = "MZN";
    ProductInputCurrencyEnum["NAD"] = "NAD";
    ProductInputCurrencyEnum["NGN"] = "NGN";
    ProductInputCurrencyEnum["NIO"] = "NIO";
    ProductInputCurrencyEnum["NOK"] = "NOK";
    ProductInputCurrencyEnum["NPR"] = "NPR";
    ProductInputCurrencyEnum["NZD"] = "NZD";
    ProductInputCurrencyEnum["OMR"] = "OMR";
    ProductInputCurrencyEnum["PAB"] = "PAB";
    ProductInputCurrencyEnum["PEN"] = "PEN";
    ProductInputCurrencyEnum["PGK"] = "PGK";
    ProductInputCurrencyEnum["PHP"] = "PHP";
    ProductInputCurrencyEnum["PKR"] = "PKR";
    ProductInputCurrencyEnum["PLN"] = "PLN";
    ProductInputCurrencyEnum["PYG"] = "PYG";
    ProductInputCurrencyEnum["QAR"] = "QAR";
    ProductInputCurrencyEnum["RON"] = "RON";
    ProductInputCurrencyEnum["RSD"] = "RSD";
    ProductInputCurrencyEnum["RUB"] = "RUB";
    ProductInputCurrencyEnum["RWF"] = "RWF";
    ProductInputCurrencyEnum["SAR"] = "SAR";
    ProductInputCurrencyEnum["SBD"] = "SBD";
    ProductInputCurrencyEnum["SCR"] = "SCR";
    ProductInputCurrencyEnum["SDG"] = "SDG";
    ProductInputCurrencyEnum["SEK"] = "SEK";
    ProductInputCurrencyEnum["SGD"] = "SGD";
    ProductInputCurrencyEnum["SHP"] = "SHP";
    ProductInputCurrencyEnum["SLE"] = "SLE";
    ProductInputCurrencyEnum["SLL"] = "SLL";
    ProductInputCurrencyEnum["SOS"] = "SOS";
    ProductInputCurrencyEnum["SRD"] = "SRD";
    ProductInputCurrencyEnum["SSP"] = "SSP";
    ProductInputCurrencyEnum["STN"] = "STN";
    ProductInputCurrencyEnum["SVC"] = "SVC";
    ProductInputCurrencyEnum["SYP"] = "SYP";
    ProductInputCurrencyEnum["SZL"] = "SZL";
    ProductInputCurrencyEnum["THB"] = "THB";
    ProductInputCurrencyEnum["TJS"] = "TJS";
    ProductInputCurrencyEnum["TMT"] = "TMT";
    ProductInputCurrencyEnum["TND"] = "TND";
    ProductInputCurrencyEnum["TOP"] = "TOP";
    ProductInputCurrencyEnum["TRY"] = "TRY";
    ProductInputCurrencyEnum["TTD"] = "TTD";
    ProductInputCurrencyEnum["TWD"] = "TWD";
    ProductInputCurrencyEnum["TZS"] = "TZS";
    ProductInputCurrencyEnum["UAH"] = "UAH";
    ProductInputCurrencyEnum["UGX"] = "UGX";
    ProductInputCurrencyEnum["USD"] = "USD";
    ProductInputCurrencyEnum["USN"] = "USN";
    ProductInputCurrencyEnum["UYI"] = "UYI";
    ProductInputCurrencyEnum["UYU"] = "UYU";
    ProductInputCurrencyEnum["UYW"] = "UYW";
    ProductInputCurrencyEnum["UZS"] = "UZS";
    ProductInputCurrencyEnum["VED"] = "VED";
    ProductInputCurrencyEnum["VES"] = "VES";
    ProductInputCurrencyEnum["VND"] = "VND";
    ProductInputCurrencyEnum["VUV"] = "VUV";
    ProductInputCurrencyEnum["WST"] = "WST";
    ProductInputCurrencyEnum["XAF"] = "XAF";
    ProductInputCurrencyEnum["XCD"] = "XCD";
    ProductInputCurrencyEnum["XOF"] = "XOF";
    ProductInputCurrencyEnum["XPF"] = "XPF";
    ProductInputCurrencyEnum["XSU"] = "XSU";
    ProductInputCurrencyEnum["XUA"] = "XUA";
    ProductInputCurrencyEnum["YER"] = "YER";
    ProductInputCurrencyEnum["ZAR"] = "ZAR";
    ProductInputCurrencyEnum["ZMW"] = "ZMW";
    ProductInputCurrencyEnum["ZWL"] = "ZWL";
})(ProductInputCurrencyEnum = exports.ProductInputCurrencyEnum || (exports.ProductInputCurrencyEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var ProspectStatus;
(function (ProspectStatus) {
    ProspectStatus["NEW"] = "NEW";
    ProspectStatus["GENERALENQUIRY"] = "GENERAL_ENQUIRY";
    ProspectStatus["SCHEDULEDCALLBACKWITHBOT"] = "SCHEDULED_CALLBACK_WITH_BOT";
    ProspectStatus["SCHEDULEDAPPOINTMENTWITHPERSON"] = "SCHEDULED_APPOINTMENT_WITH_PERSON";
    ProspectStatus["SCHEDULEDAPPOINTMENTFORSERVICE"] = "SCHEDULED_APPOINTMENT_FOR_SERVICE";
    ProspectStatus["NOTINTERESTED"] = "NOT_INTERESTED";
    ProspectStatus["PRODUCTORDERPLACED"] = "PRODUCT_ORDER_PLACED";
    ProspectStatus["SERVICEORDERPLACED"] = "SERVICE_ORDER_PLACED";
})(ProspectStatus = exports.ProspectStatus || (exports.ProspectStatus = {}));
/**
 *
 * @export
 * @enum {string}
 */
var Role;
(function (Role) {
    Role["ADMIN"] = "ADMIN";
    Role["READONLY"] = "READ_ONLY";
    Role["OWNER"] = "OWNER";
    Role["RESELLERADMIN"] = "RESELLER_ADMIN";
})(Role = exports.Role || (exports.Role = {}));
/**
 *
 * @export
 * @enum {string}
 */
var SortOrder;
(function (SortOrder) {
    SortOrder["Asc"] = "asc";
    SortOrder["Desc"] = "desc";
})(SortOrder = exports.SortOrder || (exports.SortOrder = {}));
/**
 *
 * @export
 * @enum {string}
 */
var SparrAdaptability;
(function (SparrAdaptability) {
    SparrAdaptability["OpenToChange"] = "open to change";
    SparrAdaptability["Resistant"] = "resistant";
    SparrAdaptability["Indifferent"] = "indifferent";
})(SparrAdaptability = exports.SparrAdaptability || (exports.SparrAdaptability = {}));
/**
 *
 * @export
 * @enum {string}
 */
var SparrCommunicationStyle;
(function (SparrCommunicationStyle) {
    SparrCommunicationStyle["Direct"] = "direct";
    SparrCommunicationStyle["Indirect"] = "indirect";
    SparrCommunicationStyle["Verbose"] = "verbose";
    SparrCommunicationStyle["Brief"] = "brief";
})(SparrCommunicationStyle = exports.SparrCommunicationStyle || (exports.SparrCommunicationStyle = {}));
/**
 *
 * @export
 * @enum {string}
 */
var SparrDecisionMakingStyle;
(function (SparrDecisionMakingStyle) {
    SparrDecisionMakingStyle["Logical"] = "logical";
    SparrDecisionMakingStyle["Emotional"] = "emotional";
    SparrDecisionMakingStyle["Impulsive"] = "impulsive";
    SparrDecisionMakingStyle["Hesitant"] = "hesitant";
})(SparrDecisionMakingStyle = exports.SparrDecisionMakingStyle || (exports.SparrDecisionMakingStyle = {}));
/**
    * @export
    * @enum {string}
    */
var SparrDialogLineSpeakerEnum;
(function (SparrDialogLineSpeakerEnum) {
    SparrDialogLineSpeakerEnum["USER"] = "USER";
    SparrDialogLineSpeakerEnum["AI"] = "AI";
    SparrDialogLineSpeakerEnum["TOOL"] = "TOOL";
    SparrDialogLineSpeakerEnum["AITOOLREQUEST"] = "AI - TOOL REQUEST";
})(SparrDialogLineSpeakerEnum = exports.SparrDialogLineSpeakerEnum || (exports.SparrDialogLineSpeakerEnum = {}));
/**
    * @export
    * @enum {string}
    */
var SparrDialogLineWithSentimentSentimentEnum;
(function (SparrDialogLineWithSentimentSentimentEnum) {
    SparrDialogLineWithSentimentSentimentEnum["POSITIVE"] = "POSITIVE";
    SparrDialogLineWithSentimentSentimentEnum["NEGATIVE"] = "NEGATIVE";
    SparrDialogLineWithSentimentSentimentEnum["NEUTRAL"] = "NEUTRAL";
})(SparrDialogLineWithSentimentSentimentEnum = exports.SparrDialogLineWithSentimentSentimentEnum || (exports.SparrDialogLineWithSentimentSentimentEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var SparrEngagementLevel;
(function (SparrEngagementLevel) {
    SparrEngagementLevel["HighlyEngaged"] = "highly engaged";
    SparrEngagementLevel["Distracted"] = "distracted";
    SparrEngagementLevel["Uninterested"] = "uninterested";
})(SparrEngagementLevel = exports.SparrEngagementLevel || (exports.SparrEngagementLevel = {}));
/**
 *
 * @export
 * @enum {string}
 */
var SparrExcitementLevel;
(function (SparrExcitementLevel) {
    SparrExcitementLevel["Neutral"] = "neutral";
    SparrExcitementLevel["Interested"] = "interested";
    SparrExcitementLevel["Excited"] = "excited";
    SparrExcitementLevel["Overjoyed"] = "overjoyed";
    SparrExcitementLevel["Euphoric"] = "euphoric";
})(SparrExcitementLevel = exports.SparrExcitementLevel || (exports.SparrExcitementLevel = {}));
/**
 *
 * @export
 * @enum {string}
 */
var SparrFrustrationTolerance;
(function (SparrFrustrationTolerance) {
    SparrFrustrationTolerance["Neutral"] = "neutral";
    SparrFrustrationTolerance["QuickToAnger"] = "quick to anger";
    SparrFrustrationTolerance["Understanding"] = "understanding";
})(SparrFrustrationTolerance = exports.SparrFrustrationTolerance || (exports.SparrFrustrationTolerance = {}));
/**
 *
 * @export
 * @enum {string}
 */
var SparrInteractionTone;
(function (SparrInteractionTone) {
    SparrInteractionTone["Casual"] = "casual";
    SparrInteractionTone["Professional"] = "professional";
    SparrInteractionTone["Friendly"] = "friendly";
    SparrInteractionTone["Authoritative"] = "authoritative";
})(SparrInteractionTone = exports.SparrInteractionTone || (exports.SparrInteractionTone = {}));
/**
 *
 * @export
 * @enum {string}
 */
var SparrModelsAnalyticsMetricName;
(function (SparrModelsAnalyticsMetricName) {
    SparrModelsAnalyticsMetricName["CALLS"] = "CALLS";
    SparrModelsAnalyticsMetricName["CALLDURATION"] = "CALL_DURATION";
    SparrModelsAnalyticsMetricName["TALKRATIO"] = "TALK_RATIO";
    SparrModelsAnalyticsMetricName["AVERAGEFILLERWORDSCOUNT"] = "AVERAGE_FILLER_WORDS_COUNT";
    SparrModelsAnalyticsMetricName["AVERAGEOVERALLSCORE"] = "AVERAGE_OVERALL_SCORE";
    SparrModelsAnalyticsMetricName["AVERAGELONGESTMONOLOGUE"] = "AVERAGE_LONGEST_MONOLOGUE";
    SparrModelsAnalyticsMetricName["AVERAGEMODULESCOMPLETED"] = "AVERAGE_MODULES_COMPLETED";
    SparrModelsAnalyticsMetricName["AVERAGEACTIVEDAYS"] = "AVERAGE_ACTIVE_DAYS";
})(SparrModelsAnalyticsMetricName = exports.SparrModelsAnalyticsMetricName || (exports.SparrModelsAnalyticsMetricName = {}));
/**
 *
 * @export
 * @enum {string}
 */
var SparrNegotiationStyle;
(function (SparrNegotiationStyle) {
    SparrNegotiationStyle["HardBargainer"] = "hard bargainer";
    SparrNegotiationStyle["FriendlyNegotiator"] = "friendly negotiator";
    SparrNegotiationStyle["NonNegotiator"] = "non-negotiator";
})(SparrNegotiationStyle = exports.SparrNegotiationStyle || (exports.SparrNegotiationStyle = {}));
/**
 *
 * @export
 * @enum {string}
 */
var SparrPatienceLevel;
(function (SparrPatienceLevel) {
    SparrPatienceLevel["Neutral"] = "neutral";
    SparrPatienceLevel["VeryPatient"] = "very patient";
    SparrPatienceLevel["Impatient"] = "impatient";
})(SparrPatienceLevel = exports.SparrPatienceLevel || (exports.SparrPatienceLevel = {}));
/**
 *
 * @export
 * @enum {string}
 */
var SparrRudenessLevel;
(function (SparrRudenessLevel) {
    SparrRudenessLevel["Courteous"] = "courteous";
    SparrRudenessLevel["Direct"] = "direct";
    SparrRudenessLevel["Irritable"] = "irritable";
    SparrRudenessLevel["Aggressive"] = "aggressive";
    SparrRudenessLevel["Toxic"] = "toxic";
})(SparrRudenessLevel = exports.SparrRudenessLevel || (exports.SparrRudenessLevel = {}));
/**
 *
 * @export
 * @enum {string}
 */
var SparrVoiceAccent;
(function (SparrVoiceAccent) {
    SparrVoiceAccent["American"] = "American";
    SparrVoiceAccent["Indian"] = "Indian";
    SparrVoiceAccent["Australian"] = "Australian";
    SparrVoiceAccent["British"] = "British";
    SparrVoiceAccent["Hindi"] = "Hindi";
    SparrVoiceAccent["MiddleEastern"] = "Middle Eastern";
})(SparrVoiceAccent = exports.SparrVoiceAccent || (exports.SparrVoiceAccent = {}));
/**
 *
 * @export
 * @enum {string}
 */
var SparrVoiceLanguage;
(function (SparrVoiceLanguage) {
    SparrVoiceLanguage["English"] = "English";
    SparrVoiceLanguage["Spanish"] = "Spanish";
    SparrVoiceLanguage["Hindi"] = "Hindi";
})(SparrVoiceLanguage = exports.SparrVoiceLanguage || (exports.SparrVoiceLanguage = {}));
/**
 *
 * @export
 * @enum {string}
 */
var Status;
(function (Status) {
    Status["Active"] = "active";
    Status["Inactive"] = "inactive";
    Status["Pending"] = "pending";
    Status["Archived"] = "archived";
})(Status = exports.Status || (exports.Status = {}));
/**
 * Enum for UI node types
 * @export
 * @enum {string}
 */
var UiNodeType;
(function (UiNodeType) {
    UiNodeType["ACTION"] = "ACTION";
    UiNodeType["CONDITION"] = "CONDITION";
    UiNodeType["LOOP"] = "LOOP";
    UiNodeType["SUBFLOW"] = "SUBFLOW";
})(UiNodeType = exports.UiNodeType || (exports.UiNodeType = {}));
/**
 * Enum which stores the list of types of sparring calls
 * @export
 * @enum {string}
 */
var VirtualProspectTypeEnum;
(function (VirtualProspectTypeEnum) {
    VirtualProspectTypeEnum["INBOUND"] = "INBOUND";
    VirtualProspectTypeEnum["OUTBOUND"] = "OUTBOUND";
})(VirtualProspectTypeEnum = exports.VirtualProspectTypeEnum || (exports.VirtualProspectTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var VoiceInputGenderEnum;
(function (VoiceInputGenderEnum) {
    VoiceInputGenderEnum["Male"] = "Male";
    VoiceInputGenderEnum["Female"] = "Female";
    VoiceInputGenderEnum["Neutral"] = "Neutral";
})(VoiceInputGenderEnum = exports.VoiceInputGenderEnum || (exports.VoiceInputGenderEnum = {}));
/**
    * @export
    * @enum {string}
    */
var VoiceOutputGenderEnum;
(function (VoiceOutputGenderEnum) {
    VoiceOutputGenderEnum["Male"] = "Male";
    VoiceOutputGenderEnum["Female"] = "Female";
    VoiceOutputGenderEnum["Neutral"] = "Neutral";
})(VoiceOutputGenderEnum = exports.VoiceOutputGenderEnum || (exports.VoiceOutputGenderEnum = {}));
/**
 * ActionAgentLinkApi - axios parameter creator
 * @export
 */
exports.ActionAgentLinkApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionAgentLinkV1: (actionId, agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new base_1.RequiredError('actionId', 'Required parameter actionId was null or undefined when calling createActionAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling createActionAgentLinkV1.');
            }
            const localVarPath = `/v1/actions/{action_id}/ai-agents/{agent_id}/link`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionAgentLinkV1: (actionId, agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new base_1.RequiredError('actionId', 'Required parameter actionId was null or undefined when calling deleteActionAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling deleteActionAgentLinkV1.');
            }
            const localVarPath = `/v1/actions/{action_id}/ai-agents/{agent_id}/link`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsOfAgentV1: (agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling listActionsOfAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}/actions`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ActionAgentLinkApi - functional programming interface
 * @export
 */
exports.ActionAgentLinkApiFp = function (configuration) {
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionAgentLinkV1(actionId, agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ActionAgentLinkApiAxiosParamCreator(configuration).createActionAgentLinkV1(actionId, agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionAgentLinkV1(actionId, agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ActionAgentLinkApiAxiosParamCreator(configuration).deleteActionAgentLinkV1(actionId, agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsOfAgentV1(agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ActionAgentLinkApiAxiosParamCreator(configuration).listActionsOfAgentV1(agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ActionAgentLinkApi - factory interface
 * @export
 */
exports.ActionAgentLinkApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionAgentLinkV1(actionId, agentId, options) {
            return exports.ActionAgentLinkApiFp(configuration).createActionAgentLinkV1(actionId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionAgentLinkV1(actionId, agentId, options) {
            return exports.ActionAgentLinkApiFp(configuration).deleteActionAgentLinkV1(actionId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsOfAgentV1(agentId, options) {
            return exports.ActionAgentLinkApiFp(configuration).listActionsOfAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ActionAgentLinkApi - object-oriented interface
 * @export
 * @class ActionAgentLinkApi
 * @extends {BaseAPI}
 */
class ActionAgentLinkApi extends base_1.BaseAPI {
    /**
     * Create a Link Between an Action and an Agent
     * @summary Create a Link Between an Action and an Agent
     * @param {string} actionId ID of the action
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    createActionAgentLinkV1(actionId, agentId, options) {
        return exports.ActionAgentLinkApiFp(this.configuration).createActionAgentLinkV1(actionId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Link Between an Action and an Agent
     * @summary Delete a Link Between an Action and an Agent
     * @param {string} actionId ID of the action
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    deleteActionAgentLinkV1(actionId, agentId, options) {
        return exports.ActionAgentLinkApiFp(this.configuration).deleteActionAgentLinkV1(actionId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Actions Linked to a Specific Agent
     * @summary List All Actions Linked to a Specific Agent
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    listActionsOfAgentV1(agentId, options) {
        return exports.ActionAgentLinkApiFp(this.configuration).listActionsOfAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ActionAgentLinkApi = ActionAgentLinkApi;
/**
 * ActionsApi - axios parameter creator
 * @export
 */
exports.ActionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionV1: (actionInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionInput' is not null or undefined
            if (actionInput === null || actionInput === undefined) {
                throw new base_1.RequiredError('actionInput', 'Required parameter actionInput was null or undefined when calling createActionV1.');
            }
            const localVarPath = `/v1/actions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof actionInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(actionInput !== undefined ? actionInput : {}) : (actionInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionV1: (actionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new base_1.RequiredError('actionId', 'Required parameter actionId was null or undefined when calling deleteActionV1.');
            }
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1: (actionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new base_1.RequiredError('actionId', 'Required parameter actionId was null or undefined when calling getActionV1.');
            }
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Actions
         * @summary List All Actions
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/actions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActionV1: (actionId, actionInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new base_1.RequiredError('actionId', 'Required parameter actionId was null or undefined when calling updateActionV1.');
            }
            // verify required parameter 'actionInput' is not null or undefined
            if (actionInput === null || actionInput === undefined) {
                throw new base_1.RequiredError('actionInput', 'Required parameter actionInput was null or undefined when calling updateActionV1.');
            }
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof actionInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(actionInput !== undefined ? actionInput : {}) : (actionInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ActionsApi - functional programming interface
 * @export
 */
exports.ActionsApiFp = function (configuration) {
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionV1(actionInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ActionsApiAxiosParamCreator(configuration).createActionV1(actionInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionV1(actionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ActionsApiAxiosParamCreator(configuration).deleteActionV1(actionId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1(actionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ActionsApiAxiosParamCreator(configuration).getActionV1(actionId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List All Actions
         * @summary List All Actions
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ActionsApiAxiosParamCreator(configuration).listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActionV1(actionId, actionInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ActionsApiAxiosParamCreator(configuration).updateActionV1(actionId, actionInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ActionsApi - factory interface
 * @export
 */
exports.ActionsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionV1(actionInput, options) {
            return exports.ActionsApiFp(configuration).createActionV1(actionInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionV1(actionId, options) {
            return exports.ActionsApiFp(configuration).deleteActionV1(actionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1(actionId, options) {
            return exports.ActionsApiFp(configuration).getActionV1(actionId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Actions
         * @summary List All Actions
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return exports.ActionsApiFp(configuration).listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActionV1(actionId, actionInput, options) {
            return exports.ActionsApiFp(configuration).updateActionV1(actionId, actionInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
class ActionsApi extends base_1.BaseAPI {
    /**
     * Create a New Action
     * @summary Create a New Action
     * @param {ActionInput} actionInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    createActionV1(actionInput, options) {
        return exports.ActionsApiFp(this.configuration).createActionV1(actionInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Specific Action by ID
     * @summary Delete a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    deleteActionV1(actionId, options) {
        return exports.ActionsApiFp(this.configuration).deleteActionV1(actionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Specific Action by ID
     * @summary Get a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    getActionV1(actionId, options) {
        return exports.ActionsApiFp(this.configuration).getActionV1(actionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Actions
     * @summary List All Actions
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [updatedAfter]
     * @param {string} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ActionsApiFp(this.configuration).listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Specific Action by ID
     * @summary Update a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {ActionInput} actionInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    updateActionV1(actionId, actionInput, options) {
        return exports.ActionsApiFp(this.configuration).updateActionV1(actionId, actionInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ActionsApi = ActionsApi;
/**
 * AgentsApi - axios parameter creator
 * @export
 */
exports.AgentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAIAgentV1: (aIAgentInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'aIAgentInput' is not null or undefined
            if (aIAgentInput === null || aIAgentInput === undefined) {
                throw new base_1.RequiredError('aIAgentInput', 'Required parameter aIAgentInput was null or undefined when calling createAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof aIAgentInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(aIAgentInput !== undefined ? aIAgentInput : {}) : (aIAgentInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAIAgentV1: (agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling deleteAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIAgentV1: (agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling getAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All AI Agents
         * @summary List All AI Agents
         * @param {AppEnumInput} [app]
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIAgentsV1: (app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/ai-agents`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIAgentV1: (agentId, aIAgentInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling updateAIAgentV1.');
            }
            // verify required parameter 'aIAgentInput' is not null or undefined
            if (aIAgentInput === null || aIAgentInput === undefined) {
                throw new base_1.RequiredError('aIAgentInput', 'Required parameter aIAgentInput was null or undefined when calling updateAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof aIAgentInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(aIAgentInput !== undefined ? aIAgentInput : {}) : (aIAgentInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * AgentsApi - functional programming interface
 * @export
 */
exports.AgentsApiFp = function (configuration) {
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAIAgentV1(aIAgentInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentsApiAxiosParamCreator(configuration).createAIAgentV1(aIAgentInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAIAgentV1(agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentsApiAxiosParamCreator(configuration).deleteAIAgentV1(agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIAgentV1(agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentsApiAxiosParamCreator(configuration).getAIAgentV1(agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List All AI Agents
         * @summary List All AI Agents
         * @param {AppEnumInput} [app]
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentsApiAxiosParamCreator(configuration).listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIAgentV1(agentId, aIAgentInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentsApiAxiosParamCreator(configuration).updateAIAgentV1(agentId, aIAgentInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * AgentsApi - factory interface
 * @export
 */
exports.AgentsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAIAgentV1(aIAgentInput, options) {
            return exports.AgentsApiFp(configuration).createAIAgentV1(aIAgentInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAIAgentV1(agentId, options) {
            return exports.AgentsApiFp(configuration).deleteAIAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIAgentV1(agentId, options) {
            return exports.AgentsApiFp(configuration).getAIAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All AI Agents
         * @summary List All AI Agents
         * @param {AppEnumInput} [app]
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return exports.AgentsApiFp(configuration).listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIAgentV1(agentId, aIAgentInput, options) {
            return exports.AgentsApiFp(configuration).updateAIAgentV1(agentId, aIAgentInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AgentsApi - object-oriented interface
 * @export
 * @class AgentsApi
 * @extends {BaseAPI}
 */
class AgentsApi extends base_1.BaseAPI {
    /**
     * Create a New AI Agent
     * @summary Create a New AI Agent
     * @param {AIAgentInput} aIAgentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    createAIAgentV1(aIAgentInput, options) {
        return exports.AgentsApiFp(this.configuration).createAIAgentV1(aIAgentInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Specific AI Agent by ID
     * @summary Delete a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    deleteAIAgentV1(agentId, options) {
        return exports.AgentsApiFp(this.configuration).deleteAIAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Specific AI Agent by ID
     * @summary Get a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    getAIAgentV1(agentId, options) {
        return exports.AgentsApiFp(this.configuration).getAIAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All AI Agents
     * @summary List All AI Agents
     * @param {AppEnumInput} [app]
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [updatedAfter]
     * @param {string} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.AgentsApiFp(this.configuration).listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Specific AI Agent by ID
     * @summary Update a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {AIAgentInput} aIAgentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    updateAIAgentV1(agentId, aIAgentInput, options) {
        return exports.AgentsApiFp(this.configuration).updateAIAgentV1(agentId, aIAgentInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AgentsApi = AgentsApi;
/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
exports.AnalyticsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get fine grained analytics data from Trata AI like call, duration stats, etc.
         * @summary Get Metrics
         * @param {BatchMetricsRequestsInput} batchMetricsRequestsInput
         * @param {string} [app]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1MetricsPost: (batchMetricsRequestsInput, app, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'batchMetricsRequestsInput' is not null or undefined
            if (batchMetricsRequestsInput === null || batchMetricsRequestsInput === undefined) {
                throw new base_1.RequiredError('batchMetricsRequestsInput', 'Required parameter batchMetricsRequestsInput was null or undefined when calling getMetricsV1MetricsPost.');
            }
            const localVarPath = `/v1/metrics`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof batchMetricsRequestsInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(batchMetricsRequestsInput !== undefined ? batchMetricsRequestsInput : {}) : (batchMetricsRequestsInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get aggregated stats from Trata AI like call count, prospect count, etc.
         * @summary Get Aggregated Stats
         * @param {AppEnumInput} [app]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallStatsV1StatsGet: (app, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/stats`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * AnalyticsApi - functional programming interface
 * @export
 */
exports.AnalyticsApiFp = function (configuration) {
    return {
        /**
         * Get fine grained analytics data from Trata AI like call, duration stats, etc.
         * @summary Get Metrics
         * @param {BatchMetricsRequestsInput} batchMetricsRequestsInput
         * @param {string} [app]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1MetricsPost(batchMetricsRequestsInput, app, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AnalyticsApiAxiosParamCreator(configuration).getMetricsV1MetricsPost(batchMetricsRequestsInput, app, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get aggregated stats from Trata AI like call count, prospect count, etc.
         * @summary Get Aggregated Stats
         * @param {AppEnumInput} [app]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallStatsV1StatsGet(app, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AnalyticsApiAxiosParamCreator(configuration).getOverallStatsV1StatsGet(app, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * AnalyticsApi - factory interface
 * @export
 */
exports.AnalyticsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Get fine grained analytics data from Trata AI like call, duration stats, etc.
         * @summary Get Metrics
         * @param {BatchMetricsRequestsInput} batchMetricsRequestsInput
         * @param {string} [app]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1MetricsPost(batchMetricsRequestsInput, app, options) {
            return exports.AnalyticsApiFp(configuration).getMetricsV1MetricsPost(batchMetricsRequestsInput, app, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregated stats from Trata AI like call count, prospect count, etc.
         * @summary Get Aggregated Stats
         * @param {AppEnumInput} [app]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallStatsV1StatsGet(app, options) {
            return exports.AnalyticsApiFp(configuration).getOverallStatsV1StatsGet(app, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
class AnalyticsApi extends base_1.BaseAPI {
    /**
     * Get fine grained analytics data from Trata AI like call, duration stats, etc.
     * @summary Get Metrics
     * @param {BatchMetricsRequestsInput} batchMetricsRequestsInput
     * @param {string} [app]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    getMetricsV1MetricsPost(batchMetricsRequestsInput, app, options) {
        return exports.AnalyticsApiFp(this.configuration).getMetricsV1MetricsPost(batchMetricsRequestsInput, app, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get aggregated stats from Trata AI like call count, prospect count, etc.
     * @summary Get Aggregated Stats
     * @param {AppEnumInput} [app]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    getOverallStatsV1StatsGet(app, options) {
        return exports.AnalyticsApiFp(this.configuration).getOverallStatsV1StatsGet(app, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AnalyticsApi = AnalyticsApi;
/**
 * ApiKeyApi - axios parameter creator
 * @export
 */
exports.ApiKeyApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyV1: (apiKeyRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'apiKeyRequest' is not null or undefined
            if (apiKeyRequest === null || apiKeyRequest === undefined) {
                throw new base_1.RequiredError('apiKeyRequest', 'Required parameter apiKeyRequest was null or undefined when calling createApiKeyV1.');
            }
            const localVarPath = `/v1/api-keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof apiKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(apiKeyRequest !== undefined ? apiKeyRequest : {}) : (apiKeyRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete Api Key
         * @param {string} keyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyV1: (keyId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'keyId' is not null or undefined
            if (keyId === null || keyId === undefined) {
                throw new base_1.RequiredError('keyId', 'Required parameter keyId was null or undefined when calling deleteApiKeyV1.');
            }
            const localVarPath = `/v1/api-keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallKeyV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/api-keys/call-key`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/api-keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ApiKeyApi - functional programming interface
 * @export
 */
exports.ApiKeyApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyV1(apiKeyRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ApiKeyApiAxiosParamCreator(configuration).createApiKeyV1(apiKeyRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Delete Api Key
         * @param {string} keyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyV1(keyId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ApiKeyApiAxiosParamCreator(configuration).deleteApiKeyV1(keyId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallKeyV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ApiKeyApiAxiosParamCreator(configuration).getCallKeyV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ApiKeyApiAxiosParamCreator(configuration).listApiKeysV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ApiKeyApi - factory interface
 * @export
 */
exports.ApiKeyApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyV1(apiKeyRequest, options) {
            return exports.ApiKeyApiFp(configuration).createApiKeyV1(apiKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete Api Key
         * @param {string} keyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyV1(keyId, options) {
            return exports.ApiKeyApiFp(configuration).deleteApiKeyV1(keyId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallKeyV1(options) {
            return exports.ApiKeyApiFp(configuration).getCallKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysV1(options) {
            return exports.ApiKeyApiFp(configuration).listApiKeysV1(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ApiKeyApi - object-oriented interface
 * @export
 * @class ApiKeyApi
 * @extends {BaseAPI}
 */
class ApiKeyApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create Api Key
     * @param {ApiKeyRequest} apiKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    createApiKeyV1(apiKeyRequest, options) {
        return exports.ApiKeyApiFp(this.configuration).createApiKeyV1(apiKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete Api Key
     * @param {string} keyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    deleteApiKeyV1(keyId, options) {
        return exports.ApiKeyApiFp(this.configuration).deleteApiKeyV1(keyId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Call Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    getCallKeyV1(options) {
        return exports.ApiKeyApiFp(this.configuration).getCallKeyV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Api Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    listApiKeysV1(options) {
        return exports.ApiKeyApiFp(this.configuration).listApiKeysV1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ApiKeyApi = ApiKeyApi;
/**
 * BillingApi - axios parameter creator
 * @export
 */
exports.BillingApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForBillableProductV1: (billableProductId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'billableProductId' is not null or undefined
            if (billableProductId === null || billableProductId === undefined) {
                throw new base_1.RequiredError('billableProductId', 'Required parameter billableProductId was null or undefined when calling createCheckoutSessionForBillableProductV1.');
            }
            const localVarPath = `/v1/subscription/billable-products/{billable_product_id}/checkout`
                .replace(`{${"billable_product_id"}}`, encodeURIComponent(String(billableProductId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerSessionSecretV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/subscription/customer-session-secret`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionBillableProductsV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/subscription/billable-products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPortalV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/subscription/portal`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/subscription`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * BillingApi - functional programming interface
 * @export
 */
exports.BillingApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForBillableProductV1(billableProductId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BillingApiAxiosParamCreator(configuration).createCheckoutSessionForBillableProductV1(billableProductId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerSessionSecretV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BillingApiAxiosParamCreator(configuration).getCustomerSessionSecretV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionBillableProductsV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BillingApiAxiosParamCreator(configuration).getSubscriptionBillableProductsV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPortalV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BillingApiAxiosParamCreator(configuration).getSubscriptionPortalV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BillingApiAxiosParamCreator(configuration).getSubscriptionV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * BillingApi - factory interface
 * @export
 */
exports.BillingApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForBillableProductV1(billableProductId, options) {
            return exports.BillingApiFp(configuration).createCheckoutSessionForBillableProductV1(billableProductId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerSessionSecretV1(options) {
            return exports.BillingApiFp(configuration).getCustomerSessionSecretV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionBillableProductsV1(options) {
            return exports.BillingApiFp(configuration).getSubscriptionBillableProductsV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPortalV1(options) {
            return exports.BillingApiFp(configuration).getSubscriptionPortalV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionV1(options) {
            return exports.BillingApiFp(configuration).getSubscriptionV1(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
class BillingApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create Checkout Session For Billable Product
     * @param {string} billableProductId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    createCheckoutSessionForBillableProductV1(billableProductId, options) {
        return exports.BillingApiFp(this.configuration).createCheckoutSessionForBillableProductV1(billableProductId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Customer Session Secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getCustomerSessionSecretV1(options) {
        return exports.BillingApiFp(this.configuration).getCustomerSessionSecretV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Subscription Billable Products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getSubscriptionBillableProductsV1(options) {
        return exports.BillingApiFp(this.configuration).getSubscriptionBillableProductsV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Subscription Portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getSubscriptionPortalV1(options) {
        return exports.BillingApiFp(this.configuration).getSubscriptionPortalV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getSubscriptionV1(options) {
        return exports.BillingApiFp(this.configuration).getSubscriptionV1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BillingApi = BillingApi;
/**
 * ConversationProspectLinkApi - axios parameter creator
 * @export
 */
exports.ConversationProspectLinkApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationProspectLinkV1: (conversationId, prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new base_1.RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling createConversationProspectLinkV1.');
            }
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new base_1.RequiredError('prospectId', 'Required parameter prospectId was null or undefined when calling createConversationProspectLinkV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}/prospects/{prospect_id}/links`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationProspectLinkV1: (conversationId, prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new base_1.RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling deleteConversationProspectLinkV1.');
            }
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new base_1.RequiredError('prospectId', 'Required parameter prospectId was null or undefined when calling deleteConversationProspectLinkV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}/prospects/{prospect_id}/links`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsOfProspectsV1: (prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new base_1.RequiredError('prospectId', 'Required parameter prospectId was null or undefined when calling listConversationsOfProspectsV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}/conversations`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ConversationProspectLinkApi - functional programming interface
 * @export
 */
exports.ConversationProspectLinkApiFp = function (configuration) {
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationProspectLinkV1(conversationId, prospectId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ConversationProspectLinkApiAxiosParamCreator(configuration).createConversationProspectLinkV1(conversationId, prospectId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationProspectLinkV1(conversationId, prospectId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ConversationProspectLinkApiAxiosParamCreator(configuration).deleteConversationProspectLinkV1(conversationId, prospectId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsOfProspectsV1(prospectId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ConversationProspectLinkApiAxiosParamCreator(configuration).listConversationsOfProspectsV1(prospectId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ConversationProspectLinkApi - factory interface
 * @export
 */
exports.ConversationProspectLinkApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationProspectLinkV1(conversationId, prospectId, options) {
            return exports.ConversationProspectLinkApiFp(configuration).createConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationProspectLinkV1(conversationId, prospectId, options) {
            return exports.ConversationProspectLinkApiFp(configuration).deleteConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsOfProspectsV1(prospectId, options) {
            return exports.ConversationProspectLinkApiFp(configuration).listConversationsOfProspectsV1(prospectId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ConversationProspectLinkApi - object-oriented interface
 * @export
 * @class ConversationProspectLinkApi
 * @extends {BaseAPI}
 */
class ConversationProspectLinkApi extends base_1.BaseAPI {
    /**
     * Create a link between a conversation and a prospect
     * @summary Create a link between a conversation and a prospect
     * @param {string} conversationId ID of the conversation
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    createConversationProspectLinkV1(conversationId, prospectId, options) {
        return exports.ConversationProspectLinkApiFp(this.configuration).createConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a link between a conversation and a prospect
     * @summary Delete a link between a conversation and a prospect
     * @param {string} conversationId ID of the conversation
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    deleteConversationProspectLinkV1(conversationId, prospectId, options) {
        return exports.ConversationProspectLinkApiFp(this.configuration).deleteConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all conversations linked to a specific prospect
     * @summary List all conversations linked to a specific prospect
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    listConversationsOfProspectsV1(prospectId, options) {
        return exports.ConversationProspectLinkApiFp(this.configuration).listConversationsOfProspectsV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ConversationProspectLinkApi = ConversationProspectLinkApi;
/**
 * ConversationsApi - axios parameter creator
 * @export
 */
exports.ConversationsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedbackV1: (conversationId, comment, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new base_1.RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling addFeedbackV1.');
            }
            // verify required parameter 'comment' is not null or undefined
            if (comment === null || comment === undefined) {
                throw new base_1.RequiredError('comment', 'Required parameter comment was null or undefined when calling addFeedbackV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}/feedback`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof comment !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(comment !== undefined ? comment : {}) : (comment || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationV1: (conversationInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationInput' is not null or undefined
            if (conversationInput === null || conversationInput === undefined) {
                throw new base_1.RequiredError('conversationInput', 'Required parameter conversationInput was null or undefined when calling createConversationV1.');
            }
            const localVarPath = `/v1/conversations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof conversationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(conversationInput !== undefined ? conversationInput : {}) : (conversationInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationV1: (conversationId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new base_1.RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling deleteConversationV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationV1: (conversationId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new base_1.RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling getConversationV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Conversations
         * @summary List All Conversations
         * @param {AppEnumInput} [app]
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsV1: (app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/conversations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationV1: (conversationId, conversationInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new base_1.RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling updateConversationV1.');
            }
            // verify required parameter 'conversationInput' is not null or undefined
            if (conversationInput === null || conversationInput === undefined) {
                throw new base_1.RequiredError('conversationInput', 'Required parameter conversationInput was null or undefined when calling updateConversationV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof conversationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(conversationInput !== undefined ? conversationInput : {}) : (conversationInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ConversationsApi - functional programming interface
 * @export
 */
exports.ConversationsApiFp = function (configuration) {
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedbackV1(conversationId, comment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ConversationsApiAxiosParamCreator(configuration).addFeedbackV1(conversationId, comment, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationV1(conversationInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ConversationsApiAxiosParamCreator(configuration).createConversationV1(conversationInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationV1(conversationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ConversationsApiAxiosParamCreator(configuration).deleteConversationV1(conversationId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationV1(conversationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ConversationsApiAxiosParamCreator(configuration).getConversationV1(conversationId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List All Conversations
         * @summary List All Conversations
         * @param {AppEnumInput} [app]
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ConversationsApiAxiosParamCreator(configuration).listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationV1(conversationId, conversationInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ConversationsApiAxiosParamCreator(configuration).updateConversationV1(conversationId, conversationInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ConversationsApi - factory interface
 * @export
 */
exports.ConversationsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedbackV1(conversationId, comment, options) {
            return exports.ConversationsApiFp(configuration).addFeedbackV1(conversationId, comment, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationV1(conversationInput, options) {
            return exports.ConversationsApiFp(configuration).createConversationV1(conversationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationV1(conversationId, options) {
            return exports.ConversationsApiFp(configuration).deleteConversationV1(conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationV1(conversationId, options) {
            return exports.ConversationsApiFp(configuration).getConversationV1(conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Conversations
         * @summary List All Conversations
         * @param {AppEnumInput} [app]
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return exports.ConversationsApiFp(configuration).listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationV1(conversationId, conversationInput, options) {
            return exports.ConversationsApiFp(configuration).updateConversationV1(conversationId, conversationInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ConversationsApi - object-oriented interface
 * @export
 * @class ConversationsApi
 * @extends {BaseAPI}
 */
class ConversationsApi extends base_1.BaseAPI {
    /**
     * Add Feedback to a Specific Conversation
     * @summary Add Feedback to a Specific Conversation
     * @param {string} conversationId ID of the conversation
     * @param {Comment} comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    addFeedbackV1(conversationId, comment, options) {
        return exports.ConversationsApiFp(this.configuration).addFeedbackV1(conversationId, comment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a New Conversation
     * @summary Create a New Conversation
     * @param {ConversationInput} conversationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    createConversationV1(conversationInput, options) {
        return exports.ConversationsApiFp(this.configuration).createConversationV1(conversationInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Specific Conversation by ID
     * @summary Delete a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    deleteConversationV1(conversationId, options) {
        return exports.ConversationsApiFp(this.configuration).deleteConversationV1(conversationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Specific Conversation by ID
     * @summary Get a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    getConversationV1(conversationId, options) {
        return exports.ConversationsApiFp(this.configuration).getConversationV1(conversationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Conversations
     * @summary List All Conversations
     * @param {AppEnumInput} [app]
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [updatedAfter]
     * @param {string} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ConversationsApiFp(this.configuration).listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Specific Conversation by ID
     * @summary Update a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {ConversationInput} conversationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    updateConversationV1(conversationId, conversationInput, options) {
        return exports.ConversationsApiFp(this.configuration).updateConversationV1(conversationId, conversationInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ConversationsApi = ConversationsApi;
/**
 * DataPlaneApi - axios parameter creator
 * @export
 */
exports.DataPlaneApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new connection for an AI Agent to start a voice conversation
         * @summary Create Connection
         * @param {string} agentId
         * @param {ConnectionSource} connectionSource
         * @param {string} [prospectId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection: (agentId, connectionSource, prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling createConnection.');
            }
            // verify required parameter 'connectionSource' is not null or undefined
            if (connectionSource === null || connectionSource === undefined) {
                throw new base_1.RequiredError('connectionSource', 'Required parameter connectionSource was null or undefined when calling createConnection.');
            }
            const localVarPath = `/v1/connections`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (agentId !== undefined) {
                localVarQueryParameter['agentId'] = agentId;
            }
            if (prospectId !== undefined) {
                localVarQueryParameter['prospect_id'] = prospectId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof connectionSource !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(connectionSource !== undefined ? connectionSource : {}) : (connectionSource || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get the audio stream xml for Plivo to start a voice conversation
         * @summary Get Audio Stream XML For Plivo
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlivoAudioStreamXml: (connectionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'connectionId' is not null or undefined
            if (connectionId === null || connectionId === undefined) {
                throw new base_1.RequiredError('connectionId', 'Required parameter connectionId was null or undefined when calling getPlivoAudioStreamXml.');
            }
            const localVarPath = `/v1/connections/{connection_id}/plivo-audio-stream-xml`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List connections
         * @summary Listconnections
         * @param {string} [sourceName]
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections: (sourceName, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/connections`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (sourceName !== undefined) {
                localVarQueryParameter['sourceName'] = sourceName;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DataPlaneApi - functional programming interface
 * @export
 */
exports.DataPlaneApiFp = function (configuration) {
    return {
        /**
         * Create a new connection for an AI Agent to start a voice conversation
         * @summary Create Connection
         * @param {string} agentId
         * @param {ConnectionSource} connectionSource
         * @param {string} [prospectId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(agentId, connectionSource, prospectId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DataPlaneApiAxiosParamCreator(configuration).createConnection(agentId, connectionSource, prospectId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get the audio stream xml for Plivo to start a voice conversation
         * @summary Get Audio Stream XML For Plivo
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlivoAudioStreamXml(connectionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DataPlaneApiAxiosParamCreator(configuration).getPlivoAudioStreamXml(connectionId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List connections
         * @summary Listconnections
         * @param {string} [sourceName]
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections(sourceName, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DataPlaneApiAxiosParamCreator(configuration).listConnections(sourceName, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * DataPlaneApi - factory interface
 * @export
 */
exports.DataPlaneApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Create a new connection for an AI Agent to start a voice conversation
         * @summary Create Connection
         * @param {string} agentId
         * @param {ConnectionSource} connectionSource
         * @param {string} [prospectId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(agentId, connectionSource, prospectId, options) {
            return exports.DataPlaneApiFp(configuration).createConnection(agentId, connectionSource, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the audio stream xml for Plivo to start a voice conversation
         * @summary Get Audio Stream XML For Plivo
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlivoAudioStreamXml(connectionId, options) {
            return exports.DataPlaneApiFp(configuration).getPlivoAudioStreamXml(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * List connections
         * @summary Listconnections
         * @param {string} [sourceName]
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections(sourceName, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return exports.DataPlaneApiFp(configuration).listConnections(sourceName, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DataPlaneApi - object-oriented interface
 * @export
 * @class DataPlaneApi
 * @extends {BaseAPI}
 */
class DataPlaneApi extends base_1.BaseAPI {
    /**
     * Create a new connection for an AI Agent to start a voice conversation
     * @summary Create Connection
     * @param {string} agentId
     * @param {ConnectionSource} connectionSource
     * @param {string} [prospectId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPlaneApi
     */
    createConnection(agentId, connectionSource, prospectId, options) {
        return exports.DataPlaneApiFp(this.configuration).createConnection(agentId, connectionSource, prospectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the audio stream xml for Plivo to start a voice conversation
     * @summary Get Audio Stream XML For Plivo
     * @param {string} connectionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPlaneApi
     */
    getPlivoAudioStreamXml(connectionId, options) {
        return exports.DataPlaneApiFp(this.configuration).getPlivoAudioStreamXml(connectionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List connections
     * @summary Listconnections
     * @param {string} [sourceName]
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [updatedAfter]
     * @param {string} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPlaneApi
     */
    listConnections(sourceName, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.DataPlaneApiFp(this.configuration).listConnections(sourceName, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DataPlaneApi = DataPlaneApi;
/**
 * FilesApi - axios parameter creator
 * @export
 */
exports.FilesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete files from Trata account
         * @summary Delete Files
         * @param {string} fileIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1: (fileIds, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'fileIds' is not null or undefined
            if (fileIds === null || fileIds === undefined) {
                throw new base_1.RequiredError('fileIds', 'Required parameter fileIds was null or undefined when calling deleteFileV1.');
            }
            const localVarPath = `/v1/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (fileIds !== undefined) {
                localVarQueryParameter['file_ids'] = fileIds;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files
         * @param {string} [validator] Validator type to use for file validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1: (files, validator, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'files' is not null or undefined
            if (files === null || files === undefined) {
                throw new base_1.RequiredError('files', 'Required parameter files was null or undefined when calling uploadFileV1.');
            }
            const localVarPath = `/v1/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (validator !== undefined) {
                localVarQueryParameter['validator'] = validator;
            }
            if (files) {
                localVarFormParams.append('files', files.join(base_1.COLLECTION_FORMATS.csv));
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * FilesApi - functional programming interface
 * @export
 */
exports.FilesApiFp = function (configuration) {
    return {
        /**
         * Delete files from Trata account
         * @summary Delete Files
         * @param {string} fileIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1(fileIds, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.FilesApiAxiosParamCreator(configuration).deleteFileV1(fileIds, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files
         * @param {string} [validator] Validator type to use for file validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1(files, validator, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.FilesApiAxiosParamCreator(configuration).uploadFileV1(files, validator, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * FilesApi - factory interface
 * @export
 */
exports.FilesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Delete files from Trata account
         * @summary Delete Files
         * @param {string} fileIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1(fileIds, options) {
            return exports.FilesApiFp(configuration).deleteFileV1(fileIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files
         * @param {string} [validator] Validator type to use for file validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1(files, validator, options) {
            return exports.FilesApiFp(configuration).uploadFileV1(files, validator, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
class FilesApi extends base_1.BaseAPI {
    /**
     * Delete files from Trata account
     * @summary Delete Files
     * @param {string} fileIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    deleteFileV1(fileIds, options) {
        return exports.FilesApiFp(this.configuration).deleteFileV1(fileIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload file to Trata account to use in AI Agents
     * @summary Upload Files
     * @param {Array<any>} files
     * @param {string} [validator] Validator type to use for file validation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    uploadFileV1(files, validator, options) {
        return exports.FilesApiFp(this.configuration).uploadFileV1(files, validator, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FilesApi = FilesApi;
/**
 * HealthApi - axios parameter creator
 * @export
 */
exports.HealthApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Heart Beat check to check the health of Trata Backend
         * @summary Heart Beat Status Of Trata Backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatusGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Heart Beat check to check the health of Workflow Service
         * @summary Heart Beat Status Of Workflow Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusWorkflowsStatusGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/workflows/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * HealthApi - functional programming interface
 * @export
 */
exports.HealthApiFp = function (configuration) {
    return {
        /**
         * Heart Beat check to check the health of Trata Backend
         * @summary Heart Beat Status Of Trata Backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatusGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HealthApiAxiosParamCreator(configuration).statusStatusGet(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Heart Beat check to check the health of Workflow Service
         * @summary Heart Beat Status Of Workflow Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusWorkflowsStatusGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HealthApiAxiosParamCreator(configuration).statusWorkflowsStatusGet(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * HealthApi - factory interface
 * @export
 */
exports.HealthApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Heart Beat check to check the health of Trata Backend
         * @summary Heart Beat Status Of Trata Backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatusGet(options) {
            return exports.HealthApiFp(configuration).statusStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Heart Beat check to check the health of Workflow Service
         * @summary Heart Beat Status Of Workflow Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusWorkflowsStatusGet(options) {
            return exports.HealthApiFp(configuration).statusWorkflowsStatusGet(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
class HealthApi extends base_1.BaseAPI {
    /**
     * Heart Beat check to check the health of Trata Backend
     * @summary Heart Beat Status Of Trata Backend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    statusStatusGet(options) {
        return exports.HealthApiFp(this.configuration).statusStatusGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Heart Beat check to check the health of Workflow Service
     * @summary Heart Beat Status Of Workflow Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    statusWorkflowsStatusGet(options) {
        return exports.HealthApiFp(this.configuration).statusWorkflowsStatusGet(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.HealthApi = HealthApi;
/**
 * HiveApi - axios parameter creator
 * @export
 */
exports.HiveApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1: (hiveContentInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveContentInput' is not null or undefined
            if (hiveContentInput === null || hiveContentInput === undefined) {
                throw new base_1.RequiredError('hiveContentInput', 'Required parameter hiveContentInput was null or undefined when calling createHiveV1.');
            }
            const localVarPath = `/v1/hives`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof hiveContentInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(hiveContentInput !== undefined ? hiveContentInput : {}) : (hiveContentInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1: (hiveId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new base_1.RequiredError('hiveId', 'Required parameter hiveId was null or undefined when calling deleteHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1: (hiveId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new base_1.RequiredError('hiveId', 'Required parameter hiveId was null or undefined when calling getHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Hives
         * @summary List All Hives
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/hives`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1: (hiveId, hiveContentOutput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new base_1.RequiredError('hiveId', 'Required parameter hiveId was null or undefined when calling updateHiveV1.');
            }
            // verify required parameter 'hiveContentOutput' is not null or undefined
            if (hiveContentOutput === null || hiveContentOutput === undefined) {
                throw new base_1.RequiredError('hiveContentOutput', 'Required parameter hiveContentOutput was null or undefined when calling updateHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof hiveContentOutput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(hiveContentOutput !== undefined ? hiveContentOutput : {}) : (hiveContentOutput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * HiveApi - functional programming interface
 * @export
 */
exports.HiveApiFp = function (configuration) {
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1(hiveContentInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HiveApiAxiosParamCreator(configuration).createHiveV1(hiveContentInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1(hiveId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HiveApiAxiosParamCreator(configuration).deleteHiveV1(hiveId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1(hiveId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HiveApiAxiosParamCreator(configuration).getHiveV1(hiveId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List All Hives
         * @summary List All Hives
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HiveApiAxiosParamCreator(configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1(hiveId, hiveContentOutput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HiveApiAxiosParamCreator(configuration).updateHiveV1(hiveId, hiveContentOutput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * HiveApi - factory interface
 * @export
 */
exports.HiveApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1(hiveContentInput, options) {
            return exports.HiveApiFp(configuration).createHiveV1(hiveContentInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1(hiveId, options) {
            return exports.HiveApiFp(configuration).deleteHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1(hiveId, options) {
            return exports.HiveApiFp(configuration).getHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Hives
         * @summary List All Hives
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return exports.HiveApiFp(configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1(hiveId, hiveContentOutput, options) {
            return exports.HiveApiFp(configuration).updateHiveV1(hiveId, hiveContentOutput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * HiveApi - object-oriented interface
 * @export
 * @class HiveApi
 * @extends {BaseAPI}
 */
class HiveApi extends base_1.BaseAPI {
    /**
     * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
     * @summary Create a New Hive
     * @param {HiveContentInput} hiveContentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    createHiveV1(hiveContentInput, options) {
        return exports.HiveApiFp(this.configuration).createHiveV1(hiveContentInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Specific Hive by ID
     * @summary Delete a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    deleteHiveV1(hiveId, options) {
        return exports.HiveApiFp(this.configuration).deleteHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Specific Hive by ID
     * @summary Get a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    getHiveV1(hiveId, options) {
        return exports.HiveApiFp(this.configuration).getHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Hives
     * @summary List All Hives
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [updatedAfter]
     * @param {string} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.HiveApiFp(this.configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Specific Hive by ID
     * @summary Update a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {HiveContentOutput} hiveContentOutput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    updateHiveV1(hiveId, hiveContentOutput, options) {
        return exports.HiveApiFp(this.configuration).updateHiveV1(hiveId, hiveContentOutput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.HiveApi = HiveApi;
/**
 * HiveAgentLinkApi - axios parameter creator
 * @export
 */
exports.HiveAgentLinkApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveAgentLinkV1: (hiveId, agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new base_1.RequiredError('hiveId', 'Required parameter hiveId was null or undefined when calling createHiveAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling createHiveAgentLinkV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}/ai-agents/{agent_id}/link`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveAgentLinkV1: (hiveId, agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new base_1.RequiredError('hiveId', 'Required parameter hiveId was null or undefined when calling deleteHiveAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling deleteHiveAgentLinkV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}/ai-agents/{agent_id}/link`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfHiveV1: (hiveId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new base_1.RequiredError('hiveId', 'Required parameter hiveId was null or undefined when calling listAgentsOfHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}/ai-agents`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesOfAgentV1: (agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling listHivesOfAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}/hives`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * HiveAgentLinkApi - functional programming interface
 * @export
 */
exports.HiveAgentLinkApiFp = function (configuration) {
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveAgentLinkV1(hiveId, agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HiveAgentLinkApiAxiosParamCreator(configuration).createHiveAgentLinkV1(hiveId, agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveAgentLinkV1(hiveId, agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HiveAgentLinkApiAxiosParamCreator(configuration).deleteHiveAgentLinkV1(hiveId, agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfHiveV1(hiveId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HiveAgentLinkApiAxiosParamCreator(configuration).listAgentsOfHiveV1(hiveId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesOfAgentV1(agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HiveAgentLinkApiAxiosParamCreator(configuration).listHivesOfAgentV1(agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * HiveAgentLinkApi - factory interface
 * @export
 */
exports.HiveAgentLinkApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveAgentLinkV1(hiveId, agentId, options) {
            return exports.HiveAgentLinkApiFp(configuration).createHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveAgentLinkV1(hiveId, agentId, options) {
            return exports.HiveAgentLinkApiFp(configuration).deleteHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfHiveV1(hiveId, options) {
            return exports.HiveAgentLinkApiFp(configuration).listAgentsOfHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesOfAgentV1(agentId, options) {
            return exports.HiveAgentLinkApiFp(configuration).listHivesOfAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * HiveAgentLinkApi - object-oriented interface
 * @export
 * @class HiveAgentLinkApi
 * @extends {BaseAPI}
 */
class HiveAgentLinkApi extends base_1.BaseAPI {
    /**
     * Create a Link Between a Hive and an Agent
     * @summary Create a Link Between a Hive and an Agent
     * @param {string} hiveId ID of the hive
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    createHiveAgentLinkV1(hiveId, agentId, options) {
        return exports.HiveAgentLinkApiFp(this.configuration).createHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Link Between a Hive and an Agent
     * @summary Delete a Link Between a Hive and an Agent
     * @param {string} hiveId ID of the hive
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    deleteHiveAgentLinkV1(hiveId, agentId, options) {
        return exports.HiveAgentLinkApiFp(this.configuration).deleteHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Agents Linked to a Specific Hive
     * @summary List All Agents Linked to a Specific Hive
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    listAgentsOfHiveV1(hiveId, options) {
        return exports.HiveAgentLinkApiFp(this.configuration).listAgentsOfHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Hives Linked to a Specific Agent
     * @summary List All Hives Linked to a Specific Agent
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    listHivesOfAgentV1(agentId, options) {
        return exports.HiveAgentLinkApiFp(this.configuration).listHivesOfAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.HiveAgentLinkApi = HiveAgentLinkApi;
/**
 * InternalApi - axios parameter creator
 * @export
 */
exports.InternalApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteV1: (acceptInviteRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'acceptInviteRequest' is not null or undefined
            if (acceptInviteRequest === null || acceptInviteRequest === undefined) {
                throw new base_1.RequiredError('acceptInviteRequest', 'Required parameter acceptInviteRequest was null or undefined when calling acceptInviteV1.');
            }
            const localVarPath = `/v1/invites/accept`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof acceptInviteRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(acceptInviteRequest !== undefined ? acceptInviteRequest : {}) : (acceptInviteRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationV1: (bodyCreateOrganizationV1, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'bodyCreateOrganizationV1' is not null or undefined
            if (bodyCreateOrganizationV1 === null || bodyCreateOrganizationV1 === undefined) {
                throw new base_1.RequiredError('bodyCreateOrganizationV1', 'Required parameter bodyCreateOrganizationV1 was null or undefined when calling createOrganizationV1.');
            }
            const localVarPath = `/v1/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof bodyCreateOrganizationV1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(bodyCreateOrganizationV1 !== undefined ? bodyCreateOrganizationV1 : {}) : (bodyCreateOrganizationV1 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new user
         * @summary Createuser
         * @param {UserPayload} userPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserV1: (userPayload, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userPayload' is not null or undefined
            if (userPayload === null || userPayload === undefined) {
                throw new base_1.RequiredError('userPayload', 'Required parameter userPayload was null or undefined when calling createUserV1.');
            }
            const localVarPath = `/v1/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof userPayload !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(userPayload !== undefined ? userPayload : {}) : (userPayload || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1: (userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling deleteUserV1.');
            }
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get customer credits
         * @summary Get Customer Credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCreditsV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/customers/credits`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get customer pricing
         * @summary Get Customer Pricing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerPricingV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/customers/pricing`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Getorganizationbranding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBrandingV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/organizations/branding`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Getuserbyid
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIdV1: (userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling getUserByIdV1.');
            }
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/invites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {boolean} [showResellerOwner] Show owner users
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersV1: (showResellerOwner, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (showResellerOwner !== undefined) {
                localVarQueryParameter['showResellerOwner'] = showResellerOwner;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput
         * @param {string} [app] The app to use for the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInviteV1: (guestInput, app, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'guestInput' is not null or undefined
            if (guestInput === null || guestInput === undefined) {
                throw new base_1.RequiredError('guestInput', 'Required parameter guestInput was null or undefined when calling sendInviteV1.');
            }
            const localVarPath = `/v1/invites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof guestInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(guestInput !== undefined ? guestInput : {}) : (guestInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationV1: (orgId, organizationInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'orgId' is not null or undefined
            if (orgId === null || orgId === undefined) {
                throw new base_1.RequiredError('orgId', 'Required parameter orgId was null or undefined when calling updateOrganizationV1.');
            }
            // verify required parameter 'organizationInput' is not null or undefined
            if (organizationInput === null || organizationInput === undefined) {
                throw new base_1.RequiredError('organizationInput', 'Required parameter organizationInput was null or undefined when calling updateOrganizationV1.');
            }
            const localVarPath = `/v1/organizations/{org_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof organizationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(organizationInput !== undefined ? organizationInput : {}) : (organizationInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId
         * @param {UserPayload} userPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1: (userId, userPayload, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling updateUserV1.');
            }
            // verify required parameter 'userPayload' is not null or undefined
            if (userPayload === null || userPayload === undefined) {
                throw new base_1.RequiredError('userPayload', 'Required parameter userPayload was null or undefined when calling updateUserV1.');
            }
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof userPayload !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(userPayload !== undefined ? userPayload : {}) : (userPayload || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * InternalApi - functional programming interface
 * @export
 */
exports.InternalApiFp = function (configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteV1(acceptInviteRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).acceptInviteV1(acceptInviteRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationV1(bodyCreateOrganizationV1, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).createOrganizationV1(bodyCreateOrganizationV1, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new user
         * @summary Createuser
         * @param {UserPayload} userPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserV1(userPayload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).createUserV1(userPayload, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).deleteOrganizationV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1(userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).deleteUserV1(userId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get customer credits
         * @summary Get Customer Credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCreditsV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).getCustomerCreditsV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get customer pricing
         * @summary Get Customer Pricing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerPricingV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).getCustomerPricingV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Getorganizationbranding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBrandingV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).getOrganizationBrandingV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).getOrganizationV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Getuserbyid
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIdV1(userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).getUserByIdV1(userId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {boolean} [showResellerOwner] Show owner users
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersV1(showResellerOwner, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).listUsersV1(showResellerOwner, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput
         * @param {string} [app] The app to use for the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInviteV1(guestInput, app, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).sendInviteV1(guestInput, app, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationV1(orgId, organizationInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).updateOrganizationV1(orgId, organizationInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId
         * @param {UserPayload} userPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1(userId, userPayload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).updateUserV1(userId, userPayload, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * InternalApi - factory interface
 * @export
 */
exports.InternalApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteV1(acceptInviteRequest, options) {
            return exports.InternalApiFp(configuration).acceptInviteV1(acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationV1(bodyCreateOrganizationV1, options) {
            return exports.InternalApiFp(configuration).createOrganizationV1(bodyCreateOrganizationV1, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user
         * @summary Createuser
         * @param {UserPayload} userPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserV1(userPayload, options) {
            return exports.InternalApiFp(configuration).createUserV1(userPayload, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationV1(options) {
            return exports.InternalApiFp(configuration).deleteOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1(userId, options) {
            return exports.InternalApiFp(configuration).deleteUserV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get customer credits
         * @summary Get Customer Credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCreditsV1(options) {
            return exports.InternalApiFp(configuration).getCustomerCreditsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get customer pricing
         * @summary Get Customer Pricing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerPricingV1(options) {
            return exports.InternalApiFp(configuration).getCustomerPricingV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Getorganizationbranding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBrandingV1(options) {
            return exports.InternalApiFp(configuration).getOrganizationBrandingV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationV1(options) {
            return exports.InternalApiFp(configuration).getOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Getuserbyid
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIdV1(userId, options) {
            return exports.InternalApiFp(configuration).getUserByIdV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return exports.InternalApiFp(configuration).listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {boolean} [showResellerOwner] Show owner users
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersV1(showResellerOwner, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return exports.InternalApiFp(configuration).listUsersV1(showResellerOwner, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput
         * @param {string} [app] The app to use for the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInviteV1(guestInput, app, options) {
            return exports.InternalApiFp(configuration).sendInviteV1(guestInput, app, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationV1(orgId, organizationInput, options) {
            return exports.InternalApiFp(configuration).updateOrganizationV1(orgId, organizationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId
         * @param {UserPayload} userPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1(userId, userPayload, options) {
            return exports.InternalApiFp(configuration).updateUserV1(userId, userPayload, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
class InternalApi extends base_1.BaseAPI {
    /**
     * Accept invite and add new user to organization
     * @summary Acceptinvite
     * @param {AcceptInviteRequest} acceptInviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    acceptInviteV1(acceptInviteRequest, options) {
        return exports.InternalApiFp(this.configuration).acceptInviteV1(acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new organization and adds the user as the \"ADMIN\" user for the org
     * @summary Createorganization
     * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    createOrganizationV1(bodyCreateOrganizationV1, options) {
        return exports.InternalApiFp(this.configuration).createOrganizationV1(bodyCreateOrganizationV1, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new user
     * @summary Createuser
     * @param {UserPayload} userPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    createUserV1(userPayload, options) {
        return exports.InternalApiFp(this.configuration).createUserV1(userPayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deleteorganization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    deleteOrganizationV1(options) {
        return exports.InternalApiFp(this.configuration).deleteOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a user
     * @summary Deleteuser
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    deleteUserV1(userId, options) {
        return exports.InternalApiFp(this.configuration).deleteUserV1(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get customer credits
     * @summary Get Customer Credits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    getCustomerCreditsV1(options) {
        return exports.InternalApiFp(this.configuration).getCustomerCreditsV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get customer pricing
     * @summary Get Customer Pricing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    getCustomerPricingV1(options) {
        return exports.InternalApiFp(this.configuration).getCustomerPricingV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Getorganizationbranding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    getOrganizationBrandingV1(options) {
        return exports.InternalApiFp(this.configuration).getOrganizationBrandingV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Getorganization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    getOrganizationV1(options) {
        return exports.InternalApiFp(this.configuration).getOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Getuserbyid
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    getUserByIdV1(userId, options) {
        return exports.InternalApiFp(this.configuration).getUserByIdV1(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List of all open invites from the organization
     * @summary Listinvites
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [updatedAfter]
     * @param {string} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.InternalApiFp(this.configuration).listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all users under the user\'s organization
     * @summary Listusers
     * @param {boolean} [showResellerOwner] Show owner users
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [updatedAfter]
     * @param {string} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    listUsersV1(showResellerOwner, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.InternalApiFp(this.configuration).listUsersV1(showResellerOwner, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Invite a new user to an organization or resend invite to the user if the user is already invited
     * @summary Inviteusers
     * @param {GuestInput} guestInput
     * @param {string} [app] The app to use for the invite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    sendInviteV1(guestInput, app, options) {
        return exports.InternalApiFp(this.configuration).sendInviteV1(guestInput, app, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updateorganization
     * @param {string} orgId ID of the organization
     * @param {OrganizationInput} organizationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    updateOrganizationV1(orgId, organizationInput, options) {
        return exports.InternalApiFp(this.configuration).updateOrganizationV1(orgId, organizationInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update user details
     * @summary Updateuser
     * @param {string} userId
     * @param {UserPayload} userPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    updateUserV1(userId, userPayload, options) {
        return exports.InternalApiFp(this.configuration).updateUserV1(userId, userPayload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.InternalApi = InternalApi;
/**
 * ProductsApi - axios parameter creator
 * @export
 */
exports.ProductsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductV1: (productInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productInput' is not null or undefined
            if (productInput === null || productInput === undefined) {
                throw new base_1.RequiredError('productInput', 'Required parameter productInput was null or undefined when calling createProductV1.');
            }
            const localVarPath = `/v1/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof productInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(productInput !== undefined ? productInput : {}) : (productInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductV1: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling deleteProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductV1: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling getProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfProductV1: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling listAgentsOfProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}/agents`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Products
         * @summary List All Products
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {string} [tags]
         * @param {string} [productIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }
            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }
            if (productIds !== undefined) {
                localVarQueryParameter['product_ids'] = productIds;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductV1: (productId, productInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling updateProductV1.');
            }
            // verify required parameter 'productInput' is not null or undefined
            if (productInput === null || productInput === undefined) {
                throw new base_1.RequiredError('productInput', 'Required parameter productInput was null or undefined when calling updateProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof productInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(productInput !== undefined ? productInput : {}) : (productInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ProductsApi - functional programming interface
 * @export
 */
exports.ProductsApiFp = function (configuration) {
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductV1(productInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).createProductV1(productInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductV1(productId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).deleteProductV1(productId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductV1(productId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).getProductV1(productId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfProductV1(productId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).listAgentsOfProductV1(productId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List All Products
         * @summary List All Products
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {string} [tags]
         * @param {string} [productIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductV1(productId, productInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).updateProductV1(productId, productInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ProductsApi - factory interface
 * @export
 */
exports.ProductsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductV1(productInput, options) {
            return exports.ProductsApiFp(configuration).createProductV1(productInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductV1(productId, options) {
            return exports.ProductsApiFp(configuration).deleteProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductV1(productId, options) {
            return exports.ProductsApiFp(configuration).getProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfProductV1(productId, options) {
            return exports.ProductsApiFp(configuration).listAgentsOfProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Products
         * @summary List All Products
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {string} [tags]
         * @param {string} [productIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options) {
            return exports.ProductsApiFp(configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductV1(productId, productInput, options) {
            return exports.ProductsApiFp(configuration).updateProductV1(productId, productInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
class ProductsApi extends base_1.BaseAPI {
    /**
     * Create a New Product
     * @summary Create a New Product
     * @param {ProductInput} productInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    createProductV1(productInput, options) {
        return exports.ProductsApiFp(this.configuration).createProductV1(productInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Specific Product by ID
     * @summary Delete a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    deleteProductV1(productId, options) {
        return exports.ProductsApiFp(this.configuration).deleteProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Specific Product by ID
     * @summary Get a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getProductV1(productId, options) {
        return exports.ProductsApiFp(this.configuration).getProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Agents Linked to a Specific Product
     * @summary List All Agents Linked to a Specific Product
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    listAgentsOfProductV1(productId, options) {
        return exports.ProductsApiFp(this.configuration).listAgentsOfProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Products
     * @summary List All Products
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [updatedAfter]
     * @param {string} [updatedBefore]
     * @param {string} [tags]
     * @param {string} [productIds]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options) {
        return exports.ProductsApiFp(this.configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Specific Product by ID
     * @summary Update a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {ProductInput} productInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    updateProductV1(productId, productInput, options) {
        return exports.ProductsApiFp(this.configuration).updateProductV1(productId, productInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProductsApi = ProductsApi;
/**
 * ProspectsApi - axios parameter creator
 * @export
 */
exports.ProspectsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProspectV1: (prospectInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectInput' is not null or undefined
            if (prospectInput === null || prospectInput === undefined) {
                throw new base_1.RequiredError('prospectInput', 'Required parameter prospectInput was null or undefined when calling createProspectV1.');
            }
            const localVarPath = `/v1/prospects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof prospectInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(prospectInput !== undefined ? prospectInput : {}) : (prospectInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProspectV1: (prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new base_1.RequiredError('prospectId', 'Required parameter prospectId was null or undefined when calling deleteProspectV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProspectV1: (prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new base_1.RequiredError('prospectId', 'Required parameter prospectId was null or undefined when calling getProspectV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Prospects
         * @summary List All Prospects
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProspectsV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/prospects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProspectV1: (prospectId, prospectInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new base_1.RequiredError('prospectId', 'Required parameter prospectId was null or undefined when calling updateProspectV1.');
            }
            // verify required parameter 'prospectInput' is not null or undefined
            if (prospectInput === null || prospectInput === undefined) {
                throw new base_1.RequiredError('prospectInput', 'Required parameter prospectInput was null or undefined when calling updateProspectV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof prospectInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(prospectInput !== undefined ? prospectInput : {}) : (prospectInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ProspectsApi - functional programming interface
 * @export
 */
exports.ProspectsApiFp = function (configuration) {
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProspectV1(prospectInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProspectsApiAxiosParamCreator(configuration).createProspectV1(prospectInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProspectV1(prospectId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProspectsApiAxiosParamCreator(configuration).deleteProspectV1(prospectId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProspectV1(prospectId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProspectsApiAxiosParamCreator(configuration).getProspectV1(prospectId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List All Prospects
         * @summary List All Prospects
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProspectsApiAxiosParamCreator(configuration).listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProspectV1(prospectId, prospectInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProspectsApiAxiosParamCreator(configuration).updateProspectV1(prospectId, prospectInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ProspectsApi - factory interface
 * @export
 */
exports.ProspectsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProspectV1(prospectInput, options) {
            return exports.ProspectsApiFp(configuration).createProspectV1(prospectInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProspectV1(prospectId, options) {
            return exports.ProspectsApiFp(configuration).deleteProspectV1(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProspectV1(prospectId, options) {
            return exports.ProspectsApiFp(configuration).getProspectV1(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Prospects
         * @summary List All Prospects
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return exports.ProspectsApiFp(configuration).listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProspectV1(prospectId, prospectInput, options) {
            return exports.ProspectsApiFp(configuration).updateProspectV1(prospectId, prospectInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProspectsApi - object-oriented interface
 * @export
 * @class ProspectsApi
 * @extends {BaseAPI}
 */
class ProspectsApi extends base_1.BaseAPI {
    /**
     * Create a New Prospect
     * @summary Create a New Prospect
     * @param {ProspectInput} prospectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    createProspectV1(prospectInput, options) {
        return exports.ProspectsApiFp(this.configuration).createProspectV1(prospectInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Specific Prospect by ID
     * @summary Delete a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    deleteProspectV1(prospectId, options) {
        return exports.ProspectsApiFp(this.configuration).deleteProspectV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Specific Prospect by ID
     * @summary Get a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    getProspectV1(prospectId, options) {
        return exports.ProspectsApiFp(this.configuration).getProspectV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Prospects
     * @summary List All Prospects
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [updatedAfter]
     * @param {string} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ProspectsApiFp(this.configuration).listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Specific Prospect by ID
     * @summary Update a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {ProspectInput} prospectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    updateProspectV1(prospectId, prospectInput, options) {
        return exports.ProspectsApiFp(this.configuration).updateProspectV1(prospectId, prospectInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProspectsApi = ProspectsApi;
/**
 * ResellerCourseAssignmentsApi - axios parameter creator
 * @export
 */
exports.ResellerCourseAssignmentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Assign or remove courses for reseller customers
         * @summary Change Reseller Course Assignments
         * @param {ChangeAssignmentRequest} changeAssignmentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeResellerCourseAssignmentsV1: (changeAssignmentRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'changeAssignmentRequest' is not null or undefined
            if (changeAssignmentRequest === null || changeAssignmentRequest === undefined) {
                throw new base_1.RequiredError('changeAssignmentRequest', 'Required parameter changeAssignmentRequest was null or undefined when calling changeResellerCourseAssignmentsV1.');
            }
            const localVarPath = `/v1/resellers/course-assignments`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof changeAssignmentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(changeAssignmentRequest !== undefined ? changeAssignmentRequest : {}) : (changeAssignmentRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all courses that have been assigned to a specific customer
         * @summary Get Assigned Courses By Customer V1
         * @param {string} customerOrgId
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedCoursesByCustomerV1: (customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling getAssignedCoursesByCustomerV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/courses`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all customers with their course assignment status
         * @summary Get Customers By Assigned Course V1
         * @param {string} courseId
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersByAssignedCourseV1: (courseId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new base_1.RequiredError('courseId', 'Required parameter courseId was null or undefined when calling getCustomersByAssignedCourseV1.');
            }
            const localVarPath = `/v1/resellers/courses/{course_id}/customers`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerCourseAssignmentsApi - functional programming interface
 * @export
 */
exports.ResellerCourseAssignmentsApiFp = function (configuration) {
    return {
        /**
         * Assign or remove courses for reseller customers
         * @summary Change Reseller Course Assignments
         * @param {ChangeAssignmentRequest} changeAssignmentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeResellerCourseAssignmentsV1(changeAssignmentRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCourseAssignmentsApiAxiosParamCreator(configuration).changeResellerCourseAssignmentsV1(changeAssignmentRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get all courses that have been assigned to a specific customer
         * @summary Get Assigned Courses By Customer V1
         * @param {string} customerOrgId
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedCoursesByCustomerV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCourseAssignmentsApiAxiosParamCreator(configuration).getAssignedCoursesByCustomerV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get all customers with their course assignment status
         * @summary Get Customers By Assigned Course V1
         * @param {string} courseId
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersByAssignedCourseV1(courseId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCourseAssignmentsApiAxiosParamCreator(configuration).getCustomersByAssignedCourseV1(courseId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ResellerCourseAssignmentsApi - factory interface
 * @export
 */
exports.ResellerCourseAssignmentsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Assign or remove courses for reseller customers
         * @summary Change Reseller Course Assignments
         * @param {ChangeAssignmentRequest} changeAssignmentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeResellerCourseAssignmentsV1(changeAssignmentRequest, options) {
            return exports.ResellerCourseAssignmentsApiFp(configuration).changeResellerCourseAssignmentsV1(changeAssignmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all courses that have been assigned to a specific customer
         * @summary Get Assigned Courses By Customer V1
         * @param {string} customerOrgId
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedCoursesByCustomerV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return exports.ResellerCourseAssignmentsApiFp(configuration).getAssignedCoursesByCustomerV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all customers with their course assignment status
         * @summary Get Customers By Assigned Course V1
         * @param {string} courseId
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersByAssignedCourseV1(courseId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return exports.ResellerCourseAssignmentsApiFp(configuration).getCustomersByAssignedCourseV1(courseId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerCourseAssignmentsApi - object-oriented interface
 * @export
 * @class ResellerCourseAssignmentsApi
 * @extends {BaseAPI}
 */
class ResellerCourseAssignmentsApi extends base_1.BaseAPI {
    /**
     * Assign or remove courses for reseller customers
     * @summary Change Reseller Course Assignments
     * @param {ChangeAssignmentRequest} changeAssignmentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCourseAssignmentsApi
     */
    changeResellerCourseAssignmentsV1(changeAssignmentRequest, options) {
        return exports.ResellerCourseAssignmentsApiFp(this.configuration).changeResellerCourseAssignmentsV1(changeAssignmentRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all courses that have been assigned to a specific customer
     * @summary Get Assigned Courses By Customer V1
     * @param {string} customerOrgId
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [updatedAfter]
     * @param {string} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCourseAssignmentsApi
     */
    getAssignedCoursesByCustomerV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ResellerCourseAssignmentsApiFp(this.configuration).getAssignedCoursesByCustomerV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all customers with their course assignment status
     * @summary Get Customers By Assigned Course V1
     * @param {string} courseId
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [updatedAfter]
     * @param {string} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCourseAssignmentsApi
     */
    getCustomersByAssignedCourseV1(courseId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ResellerCourseAssignmentsApiFp(this.configuration).getCustomersByAssignedCourseV1(courseId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerCourseAssignmentsApi = ResellerCourseAssignmentsApi;
/**
 * ResellerCustomerApi - axios parameter creator
 * @export
 */
exports.ResellerCustomerApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new customer organization under a reseller organization
         * @summary Create Customer V1
         * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerOrganizationV1: (bodyCreateCustomerOrganizationV1, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'bodyCreateCustomerOrganizationV1' is not null or undefined
            if (bodyCreateCustomerOrganizationV1 === null || bodyCreateCustomerOrganizationV1 === undefined) {
                throw new base_1.RequiredError('bodyCreateCustomerOrganizationV1', 'Required parameter bodyCreateCustomerOrganizationV1 was null or undefined when calling createCustomerOrganizationV1.');
            }
            const localVarPath = `/v1/resellers/customers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof bodyCreateCustomerOrganizationV1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(bodyCreateCustomerOrganizationV1 !== undefined ? bodyCreateCustomerOrganizationV1 : {}) : (bodyCreateCustomerOrganizationV1 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a reseller\'s customer and all associated data
         * @summary Delete Customer V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerCustomerV1: (customerOrgId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling deleteResellerCustomerV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get the basic credentials of a customer organization under a reseller organization.
         * @summary Get Customer Basic Credentials V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerBasicCredentialsV1: (customerOrgId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling getCustomerBasicCredentialsV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/basic_credentials`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
         * @summary Get Customer Credentials V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCredentialsV1: (customerOrgId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling getCustomerCredentialsV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/credentials`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get reseller customer by id
         * @summary Get Reseller Customer By Id V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerByIdV1: (customerOrgId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling getResellerCustomerByIdV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List reseller customers with prices, users and credits
         * @summary List Reseller Customers V1
         * @param {string} [searchQuery] Search query
         * @param {boolean} [expandPrices] Whether to expand the prices
         * @param {boolean} [expandUsers] Whether to expand the users
         * @param {boolean} [expandCredits] Whether to expand the credits
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerCustomersV1: (searchQuery, expandPrices, expandUsers, expandCredits, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/customers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchQuery !== undefined) {
                localVarQueryParameter['search_query'] = searchQuery;
            }
            if (expandPrices !== undefined) {
                localVarQueryParameter['expand_prices'] = expandPrices;
            }
            if (expandUsers !== undefined) {
                localVarQueryParameter['expand_users'] = expandUsers;
            }
            if (expandCredits !== undefined) {
                localVarQueryParameter['expand_credits'] = expandCredits;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a customer organization under a reseller organization
         * @summary Update Customer V1
         * @param {string} customerOrgId
         * @param {OrganizationInput} organizationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerOrganizationV1: (customerOrgId, organizationInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling updateCustomerOrganizationV1.');
            }
            // verify required parameter 'organizationInput' is not null or undefined
            if (organizationInput === null || organizationInput === undefined) {
                throw new base_1.RequiredError('organizationInput', 'Required parameter organizationInput was null or undefined when calling updateCustomerOrganizationV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof organizationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(organizationInput !== undefined ? organizationInput : {}) : (organizationInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerCustomerApi - functional programming interface
 * @export
 */
exports.ResellerCustomerApiFp = function (configuration) {
    return {
        /**
         * Creates a new customer organization under a reseller organization
         * @summary Create Customer V1
         * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerApiAxiosParamCreator(configuration).createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a reseller\'s customer and all associated data
         * @summary Delete Customer V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerCustomerV1(customerOrgId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerApiAxiosParamCreator(configuration).deleteResellerCustomerV1(customerOrgId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get the basic credentials of a customer organization under a reseller organization.
         * @summary Get Customer Basic Credentials V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerBasicCredentialsV1(customerOrgId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerApiAxiosParamCreator(configuration).getCustomerBasicCredentialsV1(customerOrgId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
         * @summary Get Customer Credentials V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCredentialsV1(customerOrgId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerApiAxiosParamCreator(configuration).getCustomerCredentialsV1(customerOrgId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get reseller customer by id
         * @summary Get Reseller Customer By Id V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerByIdV1(customerOrgId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerApiAxiosParamCreator(configuration).getResellerCustomerByIdV1(customerOrgId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List reseller customers with prices, users and credits
         * @summary List Reseller Customers V1
         * @param {string} [searchQuery] Search query
         * @param {boolean} [expandPrices] Whether to expand the prices
         * @param {boolean} [expandUsers] Whether to expand the users
         * @param {boolean} [expandCredits] Whether to expand the credits
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerCustomersV1(searchQuery, expandPrices, expandUsers, expandCredits, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerApiAxiosParamCreator(configuration).listResellerCustomersV1(searchQuery, expandPrices, expandUsers, expandCredits, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a customer organization under a reseller organization
         * @summary Update Customer V1
         * @param {string} customerOrgId
         * @param {OrganizationInput} organizationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerOrganizationV1(customerOrgId, organizationInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerApiAxiosParamCreator(configuration).updateCustomerOrganizationV1(customerOrgId, organizationInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ResellerCustomerApi - factory interface
 * @export
 */
exports.ResellerCustomerApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Creates a new customer organization under a reseller organization
         * @summary Create Customer V1
         * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options) {
            return exports.ResellerCustomerApiFp(configuration).createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a reseller\'s customer and all associated data
         * @summary Delete Customer V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerCustomerV1(customerOrgId, options) {
            return exports.ResellerCustomerApiFp(configuration).deleteResellerCustomerV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the basic credentials of a customer organization under a reseller organization.
         * @summary Get Customer Basic Credentials V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerBasicCredentialsV1(customerOrgId, options) {
            return exports.ResellerCustomerApiFp(configuration).getCustomerBasicCredentialsV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
         * @summary Get Customer Credentials V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCredentialsV1(customerOrgId, options) {
            return exports.ResellerCustomerApiFp(configuration).getCustomerCredentialsV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get reseller customer by id
         * @summary Get Reseller Customer By Id V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerByIdV1(customerOrgId, options) {
            return exports.ResellerCustomerApiFp(configuration).getResellerCustomerByIdV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * List reseller customers with prices, users and credits
         * @summary List Reseller Customers V1
         * @param {string} [searchQuery] Search query
         * @param {boolean} [expandPrices] Whether to expand the prices
         * @param {boolean} [expandUsers] Whether to expand the users
         * @param {boolean} [expandCredits] Whether to expand the credits
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerCustomersV1(searchQuery, expandPrices, expandUsers, expandCredits, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return exports.ResellerCustomerApiFp(configuration).listResellerCustomersV1(searchQuery, expandPrices, expandUsers, expandCredits, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a customer organization under a reseller organization
         * @summary Update Customer V1
         * @param {string} customerOrgId
         * @param {OrganizationInput} organizationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerOrganizationV1(customerOrgId, organizationInput, options) {
            return exports.ResellerCustomerApiFp(configuration).updateCustomerOrganizationV1(customerOrgId, organizationInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerCustomerApi - object-oriented interface
 * @export
 * @class ResellerCustomerApi
 * @extends {BaseAPI}
 */
class ResellerCustomerApi extends base_1.BaseAPI {
    /**
     * Creates a new customer organization under a reseller organization
     * @summary Create Customer V1
     * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options) {
        return exports.ResellerCustomerApiFp(this.configuration).createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a reseller\'s customer and all associated data
     * @summary Delete Customer V1
     * @param {string} customerOrgId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    deleteResellerCustomerV1(customerOrgId, options) {
        return exports.ResellerCustomerApiFp(this.configuration).deleteResellerCustomerV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the basic credentials of a customer organization under a reseller organization.
     * @summary Get Customer Basic Credentials V1
     * @param {string} customerOrgId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    getCustomerBasicCredentialsV1(customerOrgId, options) {
        return exports.ResellerCustomerApiFp(this.configuration).getCustomerBasicCredentialsV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
     * @summary Get Customer Credentials V1
     * @param {string} customerOrgId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    getCustomerCredentialsV1(customerOrgId, options) {
        return exports.ResellerCustomerApiFp(this.configuration).getCustomerCredentialsV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get reseller customer by id
     * @summary Get Reseller Customer By Id V1
     * @param {string} customerOrgId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    getResellerCustomerByIdV1(customerOrgId, options) {
        return exports.ResellerCustomerApiFp(this.configuration).getResellerCustomerByIdV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List reseller customers with prices, users and credits
     * @summary List Reseller Customers V1
     * @param {string} [searchQuery] Search query
     * @param {boolean} [expandPrices] Whether to expand the prices
     * @param {boolean} [expandUsers] Whether to expand the users
     * @param {boolean} [expandCredits] Whether to expand the credits
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [updatedAfter]
     * @param {string} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    listResellerCustomersV1(searchQuery, expandPrices, expandUsers, expandCredits, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ResellerCustomerApiFp(this.configuration).listResellerCustomersV1(searchQuery, expandPrices, expandUsers, expandCredits, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a customer organization under a reseller organization
     * @summary Update Customer V1
     * @param {string} customerOrgId
     * @param {OrganizationInput} organizationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    updateCustomerOrganizationV1(customerOrgId, organizationInput, options) {
        return exports.ResellerCustomerApiFp(this.configuration).updateCustomerOrganizationV1(customerOrgId, organizationInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerCustomerApi = ResellerCustomerApi;
/**
 * ResellerCustomerAuditLogsApi - axios parameter creator
 * @export
 */
exports.ResellerCustomerAuditLogsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get Reseller Customer Audit Logs
         * @param {string} customerOrgId
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet: (customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/audit-logs`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerCustomerAuditLogsApi - functional programming interface
 * @export
 */
exports.ResellerCustomerAuditLogsApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get Reseller Customer Audit Logs
         * @param {string} customerOrgId
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerAuditLogsApiAxiosParamCreator(configuration).getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ResellerCustomerAuditLogsApi - factory interface
 * @export
 */
exports.ResellerCustomerAuditLogsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Get Reseller Customer Audit Logs
         * @param {string} customerOrgId
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return exports.ResellerCustomerAuditLogsApiFp(configuration).getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerCustomerAuditLogsApi - object-oriented interface
 * @export
 * @class ResellerCustomerAuditLogsApi
 * @extends {BaseAPI}
 */
class ResellerCustomerAuditLogsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get Reseller Customer Audit Logs
     * @param {string} customerOrgId
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [updatedAfter]
     * @param {string} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerAuditLogsApi
     */
    getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ResellerCustomerAuditLogsApiFp(this.configuration).getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerCustomerAuditLogsApi = ResellerCustomerAuditLogsApi;
/**
 * ResellerCustomerCheckoutApi - axios parameter creator
 * @export
 */
exports.ResellerCustomerCheckoutApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a checkout session for a reseller customer
         * @summary Create Checkout Session For Reseller Customer
         * @param {string} customerOrgId
         * @param {string} priceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForResellerCustomerV1: (customerOrgId, priceId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling createCheckoutSessionForResellerCustomerV1.');
            }
            // verify required parameter 'priceId' is not null or undefined
            if (priceId === null || priceId === undefined) {
                throw new base_1.RequiredError('priceId', 'Required parameter priceId was null or undefined when calling createCheckoutSessionForResellerCustomerV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/pricing/{price_id}/checkout`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"price_id"}}`, encodeURIComponent(String(priceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerCustomerCheckoutApi - functional programming interface
 * @export
 */
exports.ResellerCustomerCheckoutApiFp = function (configuration) {
    return {
        /**
         * Create a checkout session for a reseller customer
         * @summary Create Checkout Session For Reseller Customer
         * @param {string} customerOrgId
         * @param {string} priceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForResellerCustomerV1(customerOrgId, priceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerCheckoutApiAxiosParamCreator(configuration).createCheckoutSessionForResellerCustomerV1(customerOrgId, priceId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ResellerCustomerCheckoutApi - factory interface
 * @export
 */
exports.ResellerCustomerCheckoutApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Create a checkout session for a reseller customer
         * @summary Create Checkout Session For Reseller Customer
         * @param {string} customerOrgId
         * @param {string} priceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForResellerCustomerV1(customerOrgId, priceId, options) {
            return exports.ResellerCustomerCheckoutApiFp(configuration).createCheckoutSessionForResellerCustomerV1(customerOrgId, priceId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerCustomerCheckoutApi - object-oriented interface
 * @export
 * @class ResellerCustomerCheckoutApi
 * @extends {BaseAPI}
 */
class ResellerCustomerCheckoutApi extends base_1.BaseAPI {
    /**
     * Create a checkout session for a reseller customer
     * @summary Create Checkout Session For Reseller Customer
     * @param {string} customerOrgId
     * @param {string} priceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerCheckoutApi
     */
    createCheckoutSessionForResellerCustomerV1(customerOrgId, priceId, options) {
        return exports.ResellerCustomerCheckoutApiFp(this.configuration).createCheckoutSessionForResellerCustomerV1(customerOrgId, priceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerCustomerCheckoutApi = ResellerCustomerCheckoutApi;
/**
 * ResellerCustomerDefaultPricingApi - axios parameter creator
 * @export
 */
exports.ResellerCustomerDefaultPricingApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get the default pricing for all customers under the reseller organization
         * @summary Get Customer Default Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerDefaultPricingV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/customers/pricing/default`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update customer default pricing
         * @summary Update Customer Default Pricing V1
         * @param {string} priceId
         * @param {PricingRequest} pricingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerDefaultPricingV1: (priceId, pricingRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'priceId' is not null or undefined
            if (priceId === null || priceId === undefined) {
                throw new base_1.RequiredError('priceId', 'Required parameter priceId was null or undefined when calling updateCustomerDefaultPricingV1.');
            }
            // verify required parameter 'pricingRequest' is not null or undefined
            if (pricingRequest === null || pricingRequest === undefined) {
                throw new base_1.RequiredError('pricingRequest', 'Required parameter pricingRequest was null or undefined when calling updateCustomerDefaultPricingV1.');
            }
            const localVarPath = `/v1/resellers/customers/pricing/default/{price_id}`
                .replace(`{${"price_id"}}`, encodeURIComponent(String(priceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof pricingRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(pricingRequest !== undefined ? pricingRequest : {}) : (pricingRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerCustomerDefaultPricingApi - functional programming interface
 * @export
 */
exports.ResellerCustomerDefaultPricingApiFp = function (configuration) {
    return {
        /**
         * Get the default pricing for all customers under the reseller organization
         * @summary Get Customer Default Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerDefaultPricingV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerDefaultPricingApiAxiosParamCreator(configuration).getCustomerDefaultPricingV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update customer default pricing
         * @summary Update Customer Default Pricing V1
         * @param {string} priceId
         * @param {PricingRequest} pricingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerDefaultPricingV1(priceId, pricingRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerDefaultPricingApiAxiosParamCreator(configuration).updateCustomerDefaultPricingV1(priceId, pricingRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ResellerCustomerDefaultPricingApi - factory interface
 * @export
 */
exports.ResellerCustomerDefaultPricingApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Get the default pricing for all customers under the reseller organization
         * @summary Get Customer Default Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerDefaultPricingV1(options) {
            return exports.ResellerCustomerDefaultPricingApiFp(configuration).getCustomerDefaultPricingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Update customer default pricing
         * @summary Update Customer Default Pricing V1
         * @param {string} priceId
         * @param {PricingRequest} pricingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerDefaultPricingV1(priceId, pricingRequest, options) {
            return exports.ResellerCustomerDefaultPricingApiFp(configuration).updateCustomerDefaultPricingV1(priceId, pricingRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerCustomerDefaultPricingApi - object-oriented interface
 * @export
 * @class ResellerCustomerDefaultPricingApi
 * @extends {BaseAPI}
 */
class ResellerCustomerDefaultPricingApi extends base_1.BaseAPI {
    /**
     * Get the default pricing for all customers under the reseller organization
     * @summary Get Customer Default Pricing V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerDefaultPricingApi
     */
    getCustomerDefaultPricingV1(options) {
        return exports.ResellerCustomerDefaultPricingApiFp(this.configuration).getCustomerDefaultPricingV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update customer default pricing
     * @summary Update Customer Default Pricing V1
     * @param {string} priceId
     * @param {PricingRequest} pricingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerDefaultPricingApi
     */
    updateCustomerDefaultPricingV1(priceId, pricingRequest, options) {
        return exports.ResellerCustomerDefaultPricingApiFp(this.configuration).updateCustomerDefaultPricingV1(priceId, pricingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerCustomerDefaultPricingApi = ResellerCustomerDefaultPricingApi;
/**
 * ResellerCustomerPortalApi - axios parameter creator
 * @export
 */
exports.ResellerCustomerPortalApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a customer portal for a reseller customer
         * @summary Create Customer Portal For Reseller Customer
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPortalForResellerCustomerV1: (customerOrgId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling createCustomerPortalForResellerCustomerV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/portal`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerCustomerPortalApi - functional programming interface
 * @export
 */
exports.ResellerCustomerPortalApiFp = function (configuration) {
    return {
        /**
         * Create a customer portal for a reseller customer
         * @summary Create Customer Portal For Reseller Customer
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPortalForResellerCustomerV1(customerOrgId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerPortalApiAxiosParamCreator(configuration).createCustomerPortalForResellerCustomerV1(customerOrgId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ResellerCustomerPortalApi - factory interface
 * @export
 */
exports.ResellerCustomerPortalApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Create a customer portal for a reseller customer
         * @summary Create Customer Portal For Reseller Customer
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPortalForResellerCustomerV1(customerOrgId, options) {
            return exports.ResellerCustomerPortalApiFp(configuration).createCustomerPortalForResellerCustomerV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerCustomerPortalApi - object-oriented interface
 * @export
 * @class ResellerCustomerPortalApi
 * @extends {BaseAPI}
 */
class ResellerCustomerPortalApi extends base_1.BaseAPI {
    /**
     * Create a customer portal for a reseller customer
     * @summary Create Customer Portal For Reseller Customer
     * @param {string} customerOrgId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerPortalApi
     */
    createCustomerPortalForResellerCustomerV1(customerOrgId, options) {
        return exports.ResellerCustomerPortalApiFp(this.configuration).createCustomerPortalForResellerCustomerV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerCustomerPortalApi = ResellerCustomerPortalApi;
/**
 * ResellerCustomerPricingApi - axios parameter creator
 * @export
 */
exports.ResellerCustomerPricingApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Override pricing for customer
         * @summary Create Customer Pricing V1
         * @param {string} customerOrgId
         * @param {PricingRequest} pricingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPricingV1: (customerOrgId, pricingRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling createCustomerPricingV1.');
            }
            // verify required parameter 'pricingRequest' is not null or undefined
            if (pricingRequest === null || pricingRequest === undefined) {
                throw new base_1.RequiredError('pricingRequest', 'Required parameter pricingRequest was null or undefined when calling createCustomerPricingV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/pricing`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof pricingRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(pricingRequest !== undefined ? pricingRequest : {}) : (pricingRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get resellers customer credits
         * @summary Get Reseller Customer Credits V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerCreditsV1: (customerOrgId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling getResellerCustomerCreditsV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/credits`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get resellers customer pricing
         * @summary Get Reseller Customer Pricing V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerPricingV1: (customerOrgId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling getResellerCustomerPricingV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/pricing`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update customer pricing
         * @summary Update Customer Pricing V1
         * @param {string} customerOrgId
         * @param {string} priceId
         * @param {PricingRequest} pricingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerPricingV1: (customerOrgId, priceId, pricingRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling updateCustomerPricingV1.');
            }
            // verify required parameter 'priceId' is not null or undefined
            if (priceId === null || priceId === undefined) {
                throw new base_1.RequiredError('priceId', 'Required parameter priceId was null or undefined when calling updateCustomerPricingV1.');
            }
            // verify required parameter 'pricingRequest' is not null or undefined
            if (pricingRequest === null || pricingRequest === undefined) {
                throw new base_1.RequiredError('pricingRequest', 'Required parameter pricingRequest was null or undefined when calling updateCustomerPricingV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/pricing/{price_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"price_id"}}`, encodeURIComponent(String(priceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof pricingRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(pricingRequest !== undefined ? pricingRequest : {}) : (pricingRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerCustomerPricingApi - functional programming interface
 * @export
 */
exports.ResellerCustomerPricingApiFp = function (configuration) {
    return {
        /**
         * Override pricing for customer
         * @summary Create Customer Pricing V1
         * @param {string} customerOrgId
         * @param {PricingRequest} pricingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPricingV1(customerOrgId, pricingRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerPricingApiAxiosParamCreator(configuration).createCustomerPricingV1(customerOrgId, pricingRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get resellers customer credits
         * @summary Get Reseller Customer Credits V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerCreditsV1(customerOrgId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerPricingApiAxiosParamCreator(configuration).getResellerCustomerCreditsV1(customerOrgId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get resellers customer pricing
         * @summary Get Reseller Customer Pricing V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerPricingV1(customerOrgId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerPricingApiAxiosParamCreator(configuration).getResellerCustomerPricingV1(customerOrgId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update customer pricing
         * @summary Update Customer Pricing V1
         * @param {string} customerOrgId
         * @param {string} priceId
         * @param {PricingRequest} pricingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerPricingV1(customerOrgId, priceId, pricingRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerPricingApiAxiosParamCreator(configuration).updateCustomerPricingV1(customerOrgId, priceId, pricingRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ResellerCustomerPricingApi - factory interface
 * @export
 */
exports.ResellerCustomerPricingApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Override pricing for customer
         * @summary Create Customer Pricing V1
         * @param {string} customerOrgId
         * @param {PricingRequest} pricingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPricingV1(customerOrgId, pricingRequest, options) {
            return exports.ResellerCustomerPricingApiFp(configuration).createCustomerPricingV1(customerOrgId, pricingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get resellers customer credits
         * @summary Get Reseller Customer Credits V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerCreditsV1(customerOrgId, options) {
            return exports.ResellerCustomerPricingApiFp(configuration).getResellerCustomerCreditsV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get resellers customer pricing
         * @summary Get Reseller Customer Pricing V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerPricingV1(customerOrgId, options) {
            return exports.ResellerCustomerPricingApiFp(configuration).getResellerCustomerPricingV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update customer pricing
         * @summary Update Customer Pricing V1
         * @param {string} customerOrgId
         * @param {string} priceId
         * @param {PricingRequest} pricingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerPricingV1(customerOrgId, priceId, pricingRequest, options) {
            return exports.ResellerCustomerPricingApiFp(configuration).updateCustomerPricingV1(customerOrgId, priceId, pricingRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerCustomerPricingApi - object-oriented interface
 * @export
 * @class ResellerCustomerPricingApi
 * @extends {BaseAPI}
 */
class ResellerCustomerPricingApi extends base_1.BaseAPI {
    /**
     * Override pricing for customer
     * @summary Create Customer Pricing V1
     * @param {string} customerOrgId
     * @param {PricingRequest} pricingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerPricingApi
     */
    createCustomerPricingV1(customerOrgId, pricingRequest, options) {
        return exports.ResellerCustomerPricingApiFp(this.configuration).createCustomerPricingV1(customerOrgId, pricingRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get resellers customer credits
     * @summary Get Reseller Customer Credits V1
     * @param {string} customerOrgId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerPricingApi
     */
    getResellerCustomerCreditsV1(customerOrgId, options) {
        return exports.ResellerCustomerPricingApiFp(this.configuration).getResellerCustomerCreditsV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get resellers customer pricing
     * @summary Get Reseller Customer Pricing V1
     * @param {string} customerOrgId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerPricingApi
     */
    getResellerCustomerPricingV1(customerOrgId, options) {
        return exports.ResellerCustomerPricingApiFp(this.configuration).getResellerCustomerPricingV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update customer pricing
     * @summary Update Customer Pricing V1
     * @param {string} customerOrgId
     * @param {string} priceId
     * @param {PricingRequest} pricingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerPricingApi
     */
    updateCustomerPricingV1(customerOrgId, priceId, pricingRequest, options) {
        return exports.ResellerCustomerPricingApiFp(this.configuration).updateCustomerPricingV1(customerOrgId, priceId, pricingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerCustomerPricingApi = ResellerCustomerPricingApi;
/**
 * ResellerCustomerUserApi - axios parameter creator
 * @export
 */
exports.ResellerCustomerUserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete reseller customer user
         * @summary Delete Reseller Customer User V1
         * @param {string} customerOrgId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerCustomerUserV1: (customerOrgId, userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling deleteResellerCustomerUserV1.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling deleteResellerCustomerUserV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/users/{user_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get resellers customer users and invites by id
         * @summary Get Reseller Customer User And Invites V1
         * @param {string} customerOrgId
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerUserAndInvitesV1: (customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling getResellerCustomerUserAndInvitesV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/users_and_invites`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get resellers customer user by id
         * @summary Get Reseller Customer User By Id V1
         * @param {string} customerOrgId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerUserByIdV1: (customerOrgId, userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling getResellerCustomerUserByIdV1.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling getResellerCustomerUserByIdV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/users/{user_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all invites for a customer organization
         * @summary List Customer Invites V1
         * @param {string} customerOrgId
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomerInvitesV1: (customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling listCustomerInvitesV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/invites`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List resellers customer users
         * @summary List Reseller Customer Users V1
         * @param {string} customerOrgId
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerCustomerUsersV1: (customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling listResellerCustomerUsersV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/users`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Revoke an invite for a customer organization
         * @summary Revoke Customer Invite V1
         * @param {string} customerOrgId
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCustomerInviteV1: (customerOrgId, email, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling revokeCustomerInviteV1.');
            }
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new base_1.RequiredError('email', 'Required parameter email was null or undefined when calling revokeCustomerInviteV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/invites/{email}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Send invite to a user on behalf of a customer organization
         * @summary Invite Customer Users V1
         * @param {string} customerOrgId
         * @param {GuestInput} guestInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCustomerUserInviteV1: (customerOrgId, guestInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling sendCustomerUserInviteV1.');
            }
            // verify required parameter 'guestInput' is not null or undefined
            if (guestInput === null || guestInput === undefined) {
                throw new base_1.RequiredError('guestInput', 'Required parameter guestInput was null or undefined when calling sendCustomerUserInviteV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/invites`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof guestInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(guestInput !== undefined ? guestInput : {}) : (guestInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update reseller customer user
         * @summary Update Reseller Customer User V1
         * @param {string} customerOrgId
         * @param {string} userId
         * @param {UpdateUserRequest} updateUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerCustomerUserV1: (customerOrgId, userId, updateUserRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling updateResellerCustomerUserV1.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling updateResellerCustomerUserV1.');
            }
            // verify required parameter 'updateUserRequest' is not null or undefined
            if (updateUserRequest === null || updateUserRequest === undefined) {
                throw new base_1.RequiredError('updateUserRequest', 'Required parameter updateUserRequest was null or undefined when calling updateResellerCustomerUserV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/users/{user_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof updateUserRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(updateUserRequest !== undefined ? updateUserRequest : {}) : (updateUserRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerCustomerUserApi - functional programming interface
 * @export
 */
exports.ResellerCustomerUserApiFp = function (configuration) {
    return {
        /**
         * Delete reseller customer user
         * @summary Delete Reseller Customer User V1
         * @param {string} customerOrgId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerCustomerUserV1(customerOrgId, userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerUserApiAxiosParamCreator(configuration).deleteResellerCustomerUserV1(customerOrgId, userId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get resellers customer users and invites by id
         * @summary Get Reseller Customer User And Invites V1
         * @param {string} customerOrgId
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerUserAndInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerUserApiAxiosParamCreator(configuration).getResellerCustomerUserAndInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get resellers customer user by id
         * @summary Get Reseller Customer User By Id V1
         * @param {string} customerOrgId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerUserByIdV1(customerOrgId, userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerUserApiAxiosParamCreator(configuration).getResellerCustomerUserByIdV1(customerOrgId, userId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List all invites for a customer organization
         * @summary List Customer Invites V1
         * @param {string} customerOrgId
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomerInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerUserApiAxiosParamCreator(configuration).listCustomerInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List resellers customer users
         * @summary List Reseller Customer Users V1
         * @param {string} customerOrgId
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerCustomerUsersV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerUserApiAxiosParamCreator(configuration).listResellerCustomerUsersV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Revoke an invite for a customer organization
         * @summary Revoke Customer Invite V1
         * @param {string} customerOrgId
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCustomerInviteV1(customerOrgId, email, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerUserApiAxiosParamCreator(configuration).revokeCustomerInviteV1(customerOrgId, email, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Send invite to a user on behalf of a customer organization
         * @summary Invite Customer Users V1
         * @param {string} customerOrgId
         * @param {GuestInput} guestInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCustomerUserInviteV1(customerOrgId, guestInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerUserApiAxiosParamCreator(configuration).sendCustomerUserInviteV1(customerOrgId, guestInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update reseller customer user
         * @summary Update Reseller Customer User V1
         * @param {string} customerOrgId
         * @param {string} userId
         * @param {UpdateUserRequest} updateUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerCustomerUserV1(customerOrgId, userId, updateUserRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerCustomerUserApiAxiosParamCreator(configuration).updateResellerCustomerUserV1(customerOrgId, userId, updateUserRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ResellerCustomerUserApi - factory interface
 * @export
 */
exports.ResellerCustomerUserApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Delete reseller customer user
         * @summary Delete Reseller Customer User V1
         * @param {string} customerOrgId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerCustomerUserV1(customerOrgId, userId, options) {
            return exports.ResellerCustomerUserApiFp(configuration).deleteResellerCustomerUserV1(customerOrgId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get resellers customer users and invites by id
         * @summary Get Reseller Customer User And Invites V1
         * @param {string} customerOrgId
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerUserAndInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return exports.ResellerCustomerUserApiFp(configuration).getResellerCustomerUserAndInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Get resellers customer user by id
         * @summary Get Reseller Customer User By Id V1
         * @param {string} customerOrgId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerUserByIdV1(customerOrgId, userId, options) {
            return exports.ResellerCustomerUserApiFp(configuration).getResellerCustomerUserByIdV1(customerOrgId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all invites for a customer organization
         * @summary List Customer Invites V1
         * @param {string} customerOrgId
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomerInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return exports.ResellerCustomerUserApiFp(configuration).listCustomerInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * List resellers customer users
         * @summary List Reseller Customer Users V1
         * @param {string} customerOrgId
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerCustomerUsersV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return exports.ResellerCustomerUserApiFp(configuration).listResellerCustomerUsersV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke an invite for a customer organization
         * @summary Revoke Customer Invite V1
         * @param {string} customerOrgId
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCustomerInviteV1(customerOrgId, email, options) {
            return exports.ResellerCustomerUserApiFp(configuration).revokeCustomerInviteV1(customerOrgId, email, options).then((request) => request(axios, basePath));
        },
        /**
         * Send invite to a user on behalf of a customer organization
         * @summary Invite Customer Users V1
         * @param {string} customerOrgId
         * @param {GuestInput} guestInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCustomerUserInviteV1(customerOrgId, guestInput, options) {
            return exports.ResellerCustomerUserApiFp(configuration).sendCustomerUserInviteV1(customerOrgId, guestInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update reseller customer user
         * @summary Update Reseller Customer User V1
         * @param {string} customerOrgId
         * @param {string} userId
         * @param {UpdateUserRequest} updateUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerCustomerUserV1(customerOrgId, userId, updateUserRequest, options) {
            return exports.ResellerCustomerUserApiFp(configuration).updateResellerCustomerUserV1(customerOrgId, userId, updateUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerCustomerUserApi - object-oriented interface
 * @export
 * @class ResellerCustomerUserApi
 * @extends {BaseAPI}
 */
class ResellerCustomerUserApi extends base_1.BaseAPI {
    /**
     * Delete reseller customer user
     * @summary Delete Reseller Customer User V1
     * @param {string} customerOrgId
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    deleteResellerCustomerUserV1(customerOrgId, userId, options) {
        return exports.ResellerCustomerUserApiFp(this.configuration).deleteResellerCustomerUserV1(customerOrgId, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get resellers customer users and invites by id
     * @summary Get Reseller Customer User And Invites V1
     * @param {string} customerOrgId
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [updatedAfter]
     * @param {string} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    getResellerCustomerUserAndInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ResellerCustomerUserApiFp(this.configuration).getResellerCustomerUserAndInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get resellers customer user by id
     * @summary Get Reseller Customer User By Id V1
     * @param {string} customerOrgId
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    getResellerCustomerUserByIdV1(customerOrgId, userId, options) {
        return exports.ResellerCustomerUserApiFp(this.configuration).getResellerCustomerUserByIdV1(customerOrgId, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all invites for a customer organization
     * @summary List Customer Invites V1
     * @param {string} customerOrgId
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [updatedAfter]
     * @param {string} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    listCustomerInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ResellerCustomerUserApiFp(this.configuration).listCustomerInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List resellers customer users
     * @summary List Reseller Customer Users V1
     * @param {string} customerOrgId
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [updatedAfter]
     * @param {string} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    listResellerCustomerUsersV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ResellerCustomerUserApiFp(this.configuration).listResellerCustomerUsersV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Revoke an invite for a customer organization
     * @summary Revoke Customer Invite V1
     * @param {string} customerOrgId
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    revokeCustomerInviteV1(customerOrgId, email, options) {
        return exports.ResellerCustomerUserApiFp(this.configuration).revokeCustomerInviteV1(customerOrgId, email, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Send invite to a user on behalf of a customer organization
     * @summary Invite Customer Users V1
     * @param {string} customerOrgId
     * @param {GuestInput} guestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    sendCustomerUserInviteV1(customerOrgId, guestInput, options) {
        return exports.ResellerCustomerUserApiFp(this.configuration).sendCustomerUserInviteV1(customerOrgId, guestInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update reseller customer user
     * @summary Update Reseller Customer User V1
     * @param {string} customerOrgId
     * @param {string} userId
     * @param {UpdateUserRequest} updateUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    updateResellerCustomerUserV1(customerOrgId, userId, updateUserRequest, options) {
        return exports.ResellerCustomerUserApiFp(this.configuration).updateResellerCustomerUserV1(customerOrgId, userId, updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerCustomerUserApi = ResellerCustomerUserApi;
/**
 * ResellerFilesApi - axios parameter creator
 * @export
 */
exports.ResellerFilesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete files from Trata reseller account
         * @summary Delete Files
         * @param {string} fileIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerFilesV1: (fileIds, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'fileIds' is not null or undefined
            if (fileIds === null || fileIds === undefined) {
                throw new base_1.RequiredError('fileIds', 'Required parameter fileIds was null or undefined when calling deleteResellerFilesV1.');
            }
            const localVarPath = `/v1/resellers/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (fileIds !== undefined) {
                localVarQueryParameter['file_ids'] = fileIds;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadResellerFilesV1: (files, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'files' is not null or undefined
            if (files === null || files === undefined) {
                throw new base_1.RequiredError('files', 'Required parameter files was null or undefined when calling uploadResellerFilesV1.');
            }
            const localVarPath = `/v1/resellers/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (files) {
                localVarFormParams.append('files', files.join(base_1.COLLECTION_FORMATS.csv));
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerFilesApi - functional programming interface
 * @export
 */
exports.ResellerFilesApiFp = function (configuration) {
    return {
        /**
         * Delete files from Trata reseller account
         * @summary Delete Files
         * @param {string} fileIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerFilesV1(fileIds, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerFilesApiAxiosParamCreator(configuration).deleteResellerFilesV1(fileIds, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadResellerFilesV1(files, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerFilesApiAxiosParamCreator(configuration).uploadResellerFilesV1(files, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ResellerFilesApi - factory interface
 * @export
 */
exports.ResellerFilesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Delete files from Trata reseller account
         * @summary Delete Files
         * @param {string} fileIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerFilesV1(fileIds, options) {
            return exports.ResellerFilesApiFp(configuration).deleteResellerFilesV1(fileIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadResellerFilesV1(files, options) {
            return exports.ResellerFilesApiFp(configuration).uploadResellerFilesV1(files, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerFilesApi - object-oriented interface
 * @export
 * @class ResellerFilesApi
 * @extends {BaseAPI}
 */
class ResellerFilesApi extends base_1.BaseAPI {
    /**
     * Delete files from Trata reseller account
     * @summary Delete Files
     * @param {string} fileIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerFilesApi
     */
    deleteResellerFilesV1(fileIds, options) {
        return exports.ResellerFilesApiFp(this.configuration).deleteResellerFilesV1(fileIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload file to Trata account to use in AI Agents
     * @summary Upload Files
     * @param {Array<any>} files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerFilesApi
     */
    uploadResellerFilesV1(files, options) {
        return exports.ResellerFilesApiFp(this.configuration).uploadResellerFilesV1(files, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerFilesApi = ResellerFilesApi;
/**
 * ResellerMetricsApi - axios parameter creator
 * @export
 */
exports.ResellerMetricsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get analytics data for Reseller
         * @summary Get Reseller Metrics
         * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerMetricsV1: (resellerBatchMetricsRequests, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'resellerBatchMetricsRequests' is not null or undefined
            if (resellerBatchMetricsRequests === null || resellerBatchMetricsRequests === undefined) {
                throw new base_1.RequiredError('resellerBatchMetricsRequests', 'Required parameter resellerBatchMetricsRequests was null or undefined when calling getResellerMetricsV1.');
            }
            const localVarPath = `/v1/resellers/metrics`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof resellerBatchMetricsRequests !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(resellerBatchMetricsRequests !== undefined ? resellerBatchMetricsRequests : {}) : (resellerBatchMetricsRequests || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerMetricsApi - functional programming interface
 * @export
 */
exports.ResellerMetricsApiFp = function (configuration) {
    return {
        /**
         * Get analytics data for Reseller
         * @summary Get Reseller Metrics
         * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerMetricsV1(resellerBatchMetricsRequests, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerMetricsApiAxiosParamCreator(configuration).getResellerMetricsV1(resellerBatchMetricsRequests, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ResellerMetricsApi - factory interface
 * @export
 */
exports.ResellerMetricsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Get analytics data for Reseller
         * @summary Get Reseller Metrics
         * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerMetricsV1(resellerBatchMetricsRequests, options) {
            return exports.ResellerMetricsApiFp(configuration).getResellerMetricsV1(resellerBatchMetricsRequests, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerMetricsApi - object-oriented interface
 * @export
 * @class ResellerMetricsApi
 * @extends {BaseAPI}
 */
class ResellerMetricsApi extends base_1.BaseAPI {
    /**
     * Get analytics data for Reseller
     * @summary Get Reseller Metrics
     * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerMetricsApi
     */
    getResellerMetricsV1(resellerBatchMetricsRequests, options) {
        return exports.ResellerMetricsApiFp(this.configuration).getResellerMetricsV1(resellerBatchMetricsRequests, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerMetricsApi = ResellerMetricsApi;
/**
 * ResellerOrganizationApi - axios parameter creator
 * @export
 */
exports.ResellerOrganizationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
         * @summary Create Reseller Organization V1
         * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResellerOrganizationV1: (bodyCreateResellerOrganizationV1, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'bodyCreateResellerOrganizationV1' is not null or undefined
            if (bodyCreateResellerOrganizationV1 === null || bodyCreateResellerOrganizationV1 === undefined) {
                throw new base_1.RequiredError('bodyCreateResellerOrganizationV1', 'Required parameter bodyCreateResellerOrganizationV1 was null or undefined when calling createResellerOrganizationV1.');
            }
            const localVarPath = `/v1/resellers/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof bodyCreateResellerOrganizationV1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(bodyCreateResellerOrganizationV1 !== undefined ? bodyCreateResellerOrganizationV1 : {}) : (bodyCreateResellerOrganizationV1 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a reseller organization
         * @summary Delete Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerOrganizationV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a reseller organization by id
         * @summary Get Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerOrganizationV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a reseller organization
         * @summary Update Reseller Organization V1
         * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerOrganizationV1: (updateResellerOrganizationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'updateResellerOrganizationRequest' is not null or undefined
            if (updateResellerOrganizationRequest === null || updateResellerOrganizationRequest === undefined) {
                throw new base_1.RequiredError('updateResellerOrganizationRequest', 'Required parameter updateResellerOrganizationRequest was null or undefined when calling updateResellerOrganizationV1.');
            }
            const localVarPath = `/v1/resellers/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof updateResellerOrganizationRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(updateResellerOrganizationRequest !== undefined ? updateResellerOrganizationRequest : {}) : (updateResellerOrganizationRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerOrganizationApi - functional programming interface
 * @export
 */
exports.ResellerOrganizationApiFp = function (configuration) {
    return {
        /**
         * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
         * @summary Create Reseller Organization V1
         * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerOrganizationApiAxiosParamCreator(configuration).createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a reseller organization
         * @summary Delete Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerOrganizationV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerOrganizationApiAxiosParamCreator(configuration).deleteResellerOrganizationV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a reseller organization by id
         * @summary Get Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerOrganizationV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerOrganizationApiAxiosParamCreator(configuration).getResellerOrganizationV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a reseller organization
         * @summary Update Reseller Organization V1
         * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerOrganizationV1(updateResellerOrganizationRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerOrganizationApiAxiosParamCreator(configuration).updateResellerOrganizationV1(updateResellerOrganizationRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ResellerOrganizationApi - factory interface
 * @export
 */
exports.ResellerOrganizationApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
         * @summary Create Reseller Organization V1
         * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options) {
            return exports.ResellerOrganizationApiFp(configuration).createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a reseller organization
         * @summary Delete Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerOrganizationV1(options) {
            return exports.ResellerOrganizationApiFp(configuration).deleteResellerOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a reseller organization by id
         * @summary Get Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerOrganizationV1(options) {
            return exports.ResellerOrganizationApiFp(configuration).getResellerOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a reseller organization
         * @summary Update Reseller Organization V1
         * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerOrganizationV1(updateResellerOrganizationRequest, options) {
            return exports.ResellerOrganizationApiFp(configuration).updateResellerOrganizationV1(updateResellerOrganizationRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerOrganizationApi - object-oriented interface
 * @export
 * @class ResellerOrganizationApi
 * @extends {BaseAPI}
 */
class ResellerOrganizationApi extends base_1.BaseAPI {
    /**
     * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
     * @summary Create Reseller Organization V1
     * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerOrganizationApi
     */
    createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options) {
        return exports.ResellerOrganizationApiFp(this.configuration).createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a reseller organization
     * @summary Delete Reseller Organization V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerOrganizationApi
     */
    deleteResellerOrganizationV1(options) {
        return exports.ResellerOrganizationApiFp(this.configuration).deleteResellerOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a reseller organization by id
     * @summary Get Reseller Organization V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerOrganizationApi
     */
    getResellerOrganizationV1(options) {
        return exports.ResellerOrganizationApiFp(this.configuration).getResellerOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a reseller organization
     * @summary Update Reseller Organization V1
     * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerOrganizationApi
     */
    updateResellerOrganizationV1(updateResellerOrganizationRequest, options) {
        return exports.ResellerOrganizationApiFp(this.configuration).updateResellerOrganizationV1(updateResellerOrganizationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerOrganizationApi = ResellerOrganizationApi;
/**
 * ResellerPricingApi - axios parameter creator
 * @export
 */
exports.ResellerPricingApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Adds a new account link to the reseller organization
         * @summary Add Stripe Account Link To Reseller Org
         * @param {string} code
         * @param {string} state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addStripeAccountLinkToResellerOrgV1: (code, state, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new base_1.RequiredError('code', 'Required parameter code was null or undefined when calling addStripeAccountLinkToResellerOrgV1.');
            }
            // verify required parameter 'state' is not null or undefined
            if (state === null || state === undefined) {
                throw new base_1.RequiredError('state', 'Required parameter state was null or undefined when calling addStripeAccountLinkToResellerOrgV1.');
            }
            const localVarPath = `/v1/resellers/stripe-account/link`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }
            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new account link URL for the reseller
         * @summary Create Stripe Account Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStripeAccountLinkV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/stripe-account/connect-link`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get stripe account details
         * @summary Get Stripe Account Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripeAccountDetailsV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/stripe-account`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Disconnect reseller stripe account connection
         * @summary Revoke Stripe Connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeDisconnectV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/stripe-account`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerPricingApi - functional programming interface
 * @export
 */
exports.ResellerPricingApiFp = function (configuration) {
    return {
        /**
         * Adds a new account link to the reseller organization
         * @summary Add Stripe Account Link To Reseller Org
         * @param {string} code
         * @param {string} state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addStripeAccountLinkToResellerOrgV1(code, state, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerPricingApiAxiosParamCreator(configuration).addStripeAccountLinkToResellerOrgV1(code, state, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Creates a new account link URL for the reseller
         * @summary Create Stripe Account Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStripeAccountLinkV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerPricingApiAxiosParamCreator(configuration).createStripeAccountLinkV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get stripe account details
         * @summary Get Stripe Account Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripeAccountDetailsV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerPricingApiAxiosParamCreator(configuration).getStripeAccountDetailsV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Disconnect reseller stripe account connection
         * @summary Revoke Stripe Connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeDisconnectV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerPricingApiAxiosParamCreator(configuration).stripeDisconnectV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ResellerPricingApi - factory interface
 * @export
 */
exports.ResellerPricingApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Adds a new account link to the reseller organization
         * @summary Add Stripe Account Link To Reseller Org
         * @param {string} code
         * @param {string} state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addStripeAccountLinkToResellerOrgV1(code, state, options) {
            return exports.ResellerPricingApiFp(configuration).addStripeAccountLinkToResellerOrgV1(code, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new account link URL for the reseller
         * @summary Create Stripe Account Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStripeAccountLinkV1(options) {
            return exports.ResellerPricingApiFp(configuration).createStripeAccountLinkV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get stripe account details
         * @summary Get Stripe Account Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripeAccountDetailsV1(options) {
            return exports.ResellerPricingApiFp(configuration).getStripeAccountDetailsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Disconnect reseller stripe account connection
         * @summary Revoke Stripe Connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeDisconnectV1(options) {
            return exports.ResellerPricingApiFp(configuration).stripeDisconnectV1(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerPricingApi - object-oriented interface
 * @export
 * @class ResellerPricingApi
 * @extends {BaseAPI}
 */
class ResellerPricingApi extends base_1.BaseAPI {
    /**
     * Adds a new account link to the reseller organization
     * @summary Add Stripe Account Link To Reseller Org
     * @param {string} code
     * @param {string} state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerPricingApi
     */
    addStripeAccountLinkToResellerOrgV1(code, state, options) {
        return exports.ResellerPricingApiFp(this.configuration).addStripeAccountLinkToResellerOrgV1(code, state, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new account link URL for the reseller
     * @summary Create Stripe Account Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerPricingApi
     */
    createStripeAccountLinkV1(options) {
        return exports.ResellerPricingApiFp(this.configuration).createStripeAccountLinkV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get stripe account details
     * @summary Get Stripe Account Details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerPricingApi
     */
    getStripeAccountDetailsV1(options) {
        return exports.ResellerPricingApiFp(this.configuration).getStripeAccountDetailsV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Disconnect reseller stripe account connection
     * @summary Revoke Stripe Connection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerPricingApi
     */
    stripeDisconnectV1(options) {
        return exports.ResellerPricingApiFp(this.configuration).stripeDisconnectV1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerPricingApi = ResellerPricingApi;
/**
 * ResellerSettingsApi - axios parameter creator
 * @export
 */
exports.ResellerSettingsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add Reseller settings
         * @summary Organization Settings V1
         * @param {OrganizationSettings} organizationSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResellerSettingsV1: (organizationSettings, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organizationSettings' is not null or undefined
            if (organizationSettings === null || organizationSettings === undefined) {
                throw new base_1.RequiredError('organizationSettings', 'Required parameter organizationSettings was null or undefined when calling addResellerSettingsV1.');
            }
            const localVarPath = `/v1/resellers/settings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof organizationSettings !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(organizationSettings !== undefined ? organizationSettings : {}) : (organizationSettings || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get organization settings
         * @summary Get Organization Settings V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSettingsV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/settings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update organization settings
         * @summary Organization Settings Update V1
         * @param {OrganizationSettings} organizationSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerSettingsV1: (organizationSettings, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organizationSettings' is not null or undefined
            if (organizationSettings === null || organizationSettings === undefined) {
                throw new base_1.RequiredError('organizationSettings', 'Required parameter organizationSettings was null or undefined when calling updateResellerSettingsV1.');
            }
            const localVarPath = `/v1/resellers/settings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof organizationSettings !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(organizationSettings !== undefined ? organizationSettings : {}) : (organizationSettings || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerSettingsApi - functional programming interface
 * @export
 */
exports.ResellerSettingsApiFp = function (configuration) {
    return {
        /**
         * Add Reseller settings
         * @summary Organization Settings V1
         * @param {OrganizationSettings} organizationSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResellerSettingsV1(organizationSettings, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerSettingsApiAxiosParamCreator(configuration).addResellerSettingsV1(organizationSettings, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get organization settings
         * @summary Get Organization Settings V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSettingsV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerSettingsApiAxiosParamCreator(configuration).getOrganizationSettingsV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update organization settings
         * @summary Organization Settings Update V1
         * @param {OrganizationSettings} organizationSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerSettingsV1(organizationSettings, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerSettingsApiAxiosParamCreator(configuration).updateResellerSettingsV1(organizationSettings, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ResellerSettingsApi - factory interface
 * @export
 */
exports.ResellerSettingsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Add Reseller settings
         * @summary Organization Settings V1
         * @param {OrganizationSettings} organizationSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResellerSettingsV1(organizationSettings, options) {
            return exports.ResellerSettingsApiFp(configuration).addResellerSettingsV1(organizationSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization settings
         * @summary Get Organization Settings V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSettingsV1(options) {
            return exports.ResellerSettingsApiFp(configuration).getOrganizationSettingsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Update organization settings
         * @summary Organization Settings Update V1
         * @param {OrganizationSettings} organizationSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerSettingsV1(organizationSettings, options) {
            return exports.ResellerSettingsApiFp(configuration).updateResellerSettingsV1(organizationSettings, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerSettingsApi - object-oriented interface
 * @export
 * @class ResellerSettingsApi
 * @extends {BaseAPI}
 */
class ResellerSettingsApi extends base_1.BaseAPI {
    /**
     * Add Reseller settings
     * @summary Organization Settings V1
     * @param {OrganizationSettings} organizationSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerSettingsApi
     */
    addResellerSettingsV1(organizationSettings, options) {
        return exports.ResellerSettingsApiFp(this.configuration).addResellerSettingsV1(organizationSettings, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get organization settings
     * @summary Get Organization Settings V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerSettingsApi
     */
    getOrganizationSettingsV1(options) {
        return exports.ResellerSettingsApiFp(this.configuration).getOrganizationSettingsV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update organization settings
     * @summary Organization Settings Update V1
     * @param {OrganizationSettings} organizationSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerSettingsApi
     */
    updateResellerSettingsV1(organizationSettings, options) {
        return exports.ResellerSettingsApiFp(this.configuration).updateResellerSettingsV1(organizationSettings, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerSettingsApi = ResellerSettingsApi;
/**
 * ResellerUserApi - axios parameter creator
 * @export
 */
exports.ResellerUserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Accept Invite V1
         * @param {AcceptInviteRequest} acceptInviteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptResellerUserInviteV1: (acceptInviteRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'acceptInviteRequest' is not null or undefined
            if (acceptInviteRequest === null || acceptInviteRequest === undefined) {
                throw new base_1.RequiredError('acceptInviteRequest', 'Required parameter acceptInviteRequest was null or undefined when calling acceptResellerUserInviteV1.');
            }
            const localVarPath = `/v1/resellers/invites/accept`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof acceptInviteRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(acceptInviteRequest !== undefined ? acceptInviteRequest : {}) : (acceptInviteRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a user
         * @summary Delete Reseller User V1
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerUserV1: (userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling deleteResellerUserV1.');
            }
            const localVarPath = `/v1/resellers/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Reseller User By Id V1
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerUserByIdV1: (userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling getResellerUserByIdV1.');
            }
            const localVarPath = `/v1/resellers/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List of all open invites from the organization
         * @summary List Reseller User Invites V1
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUserInvitesV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/invites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all users under the user\'s organization
         * @summary List Reseller Users V1
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUsersV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Invite Users V1
         * @param {GuestInput} guestInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendResellerUserInviteV1: (guestInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'guestInput' is not null or undefined
            if (guestInput === null || guestInput === undefined) {
                throw new base_1.RequiredError('guestInput', 'Required parameter guestInput was null or undefined when calling sendResellerUserInviteV1.');
            }
            const localVarPath = `/v1/resellers/invites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof guestInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(guestInput !== undefined ? guestInput : {}) : (guestInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update user details
         * @summary Update Reseller User V1
         * @param {string} userId
         * @param {UserPayload} userPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerUserV1: (userId, userPayload, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling updateResellerUserV1.');
            }
            // verify required parameter 'userPayload' is not null or undefined
            if (userPayload === null || userPayload === undefined) {
                throw new base_1.RequiredError('userPayload', 'Required parameter userPayload was null or undefined when calling updateResellerUserV1.');
            }
            const localVarPath = `/v1/resellers/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof userPayload !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(userPayload !== undefined ? userPayload : {}) : (userPayload || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerUserApi - functional programming interface
 * @export
 */
exports.ResellerUserApiFp = function (configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Accept Invite V1
         * @param {AcceptInviteRequest} acceptInviteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptResellerUserInviteV1(acceptInviteRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerUserApiAxiosParamCreator(configuration).acceptResellerUserInviteV1(acceptInviteRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a user
         * @summary Delete Reseller User V1
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerUserV1(userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerUserApiAxiosParamCreator(configuration).deleteResellerUserV1(userId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Reseller User By Id V1
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerUserByIdV1(userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerUserApiAxiosParamCreator(configuration).getResellerUserByIdV1(userId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List of all open invites from the organization
         * @summary List Reseller User Invites V1
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerUserApiAxiosParamCreator(configuration).listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Lists all users under the user\'s organization
         * @summary List Reseller Users V1
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerUserApiAxiosParamCreator(configuration).listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Invite Users V1
         * @param {GuestInput} guestInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendResellerUserInviteV1(guestInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerUserApiAxiosParamCreator(configuration).sendResellerUserInviteV1(guestInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update user details
         * @summary Update Reseller User V1
         * @param {string} userId
         * @param {UserPayload} userPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerUserV1(userId, userPayload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerUserApiAxiosParamCreator(configuration).updateResellerUserV1(userId, userPayload, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ResellerUserApi - factory interface
 * @export
 */
exports.ResellerUserApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Accept Invite V1
         * @param {AcceptInviteRequest} acceptInviteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptResellerUserInviteV1(acceptInviteRequest, options) {
            return exports.ResellerUserApiFp(configuration).acceptResellerUserInviteV1(acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user
         * @summary Delete Reseller User V1
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerUserV1(userId, options) {
            return exports.ResellerUserApiFp(configuration).deleteResellerUserV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Reseller User By Id V1
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerUserByIdV1(userId, options) {
            return exports.ResellerUserApiFp(configuration).getResellerUserByIdV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List of all open invites from the organization
         * @summary List Reseller User Invites V1
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return exports.ResellerUserApiFp(configuration).listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all users under the user\'s organization
         * @summary List Reseller Users V1
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return exports.ResellerUserApiFp(configuration).listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Invite Users V1
         * @param {GuestInput} guestInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendResellerUserInviteV1(guestInput, options) {
            return exports.ResellerUserApiFp(configuration).sendResellerUserInviteV1(guestInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user details
         * @summary Update Reseller User V1
         * @param {string} userId
         * @param {UserPayload} userPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerUserV1(userId, userPayload, options) {
            return exports.ResellerUserApiFp(configuration).updateResellerUserV1(userId, userPayload, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerUserApi - object-oriented interface
 * @export
 * @class ResellerUserApi
 * @extends {BaseAPI}
 */
class ResellerUserApi extends base_1.BaseAPI {
    /**
     * Accept invite and add new user to organization
     * @summary Accept Invite V1
     * @param {AcceptInviteRequest} acceptInviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    acceptResellerUserInviteV1(acceptInviteRequest, options) {
        return exports.ResellerUserApiFp(this.configuration).acceptResellerUserInviteV1(acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a user
     * @summary Delete Reseller User V1
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    deleteResellerUserV1(userId, options) {
        return exports.ResellerUserApiFp(this.configuration).deleteResellerUserV1(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Reseller User By Id V1
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    getResellerUserByIdV1(userId, options) {
        return exports.ResellerUserApiFp(this.configuration).getResellerUserByIdV1(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List of all open invites from the organization
     * @summary List Reseller User Invites V1
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [updatedAfter]
     * @param {string} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ResellerUserApiFp(this.configuration).listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all users under the user\'s organization
     * @summary List Reseller Users V1
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [updatedAfter]
     * @param {string} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ResellerUserApiFp(this.configuration).listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Invite a new user to an organization or resend invite to the user if the user is already invited
     * @summary Invite Users V1
     * @param {GuestInput} guestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    sendResellerUserInviteV1(guestInput, options) {
        return exports.ResellerUserApiFp(this.configuration).sendResellerUserInviteV1(guestInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update user details
     * @summary Update Reseller User V1
     * @param {string} userId
     * @param {UserPayload} userPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    updateResellerUserV1(userId, userPayload, options) {
        return exports.ResellerUserApiFp(this.configuration).updateResellerUserV1(userId, userPayload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerUserApi = ResellerUserApi;
/**
 * SparrApi - axios parameter creator
 * @export
 */
exports.SparrApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add a module attempt for a user
         * @summary Add Module Attempt
         * @param {string} moduleId
         * @param {UserModuleAttemptCore} userModuleAttemptCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addModuleAttemptV1: (moduleId, userModuleAttemptCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'moduleId' is not null or undefined
            if (moduleId === null || moduleId === undefined) {
                throw new base_1.RequiredError('moduleId', 'Required parameter moduleId was null or undefined when calling addModuleAttemptV1.');
            }
            // verify required parameter 'userModuleAttemptCore' is not null or undefined
            if (userModuleAttemptCore === null || userModuleAttemptCore === undefined) {
                throw new base_1.RequiredError('userModuleAttemptCore', 'Required parameter userModuleAttemptCore was null or undefined when calling addModuleAttemptV1.');
            }
            const localVarPath = `/v1/sparr/courses/modules/{module_id}/attempts`
                .replace(`{${"module_id"}}`, encodeURIComponent(String(moduleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof userModuleAttemptCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(userModuleAttemptCore !== undefined ? userModuleAttemptCore : {}) : (userModuleAttemptCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Assign a course to a user
         * @summary Assign Course
         * @param {string} courseId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignCourseV1: (courseId, userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new base_1.RequiredError('courseId', 'Required parameter courseId was null or undefined when calling assignCourseV1.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling assignCourseV1.');
            }
            const localVarPath = `/v1/sparr/courses/{course_id}/assign/{user_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Attach a tag to an entity
         * @summary Attach Tag
         * @param {string} entityType
         * @param {string} entityId
         * @param {TagCreate} tagCreate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost: (entityType, entityId, tagCreate, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new base_1.RequiredError('entityType', 'Required parameter entityType was null or undefined when calling attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new base_1.RequiredError('entityId', 'Required parameter entityId was null or undefined when calling attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost.');
            }
            // verify required parameter 'tagCreate' is not null or undefined
            if (tagCreate === null || tagCreate === undefined) {
                throw new base_1.RequiredError('tagCreate', 'Required parameter tagCreate was null or undefined when calling attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost.');
            }
            const localVarPath = `/v1/sparr/entity-tags/{entity_type}/{entity_id}/tags`
                .replace(`{${"entity_type"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof tagCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(tagCreate !== undefined ? tagCreate : {}) : (tagCreate || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a checkout session for a price
         * @summary Create Checkout Session For Price
         * @param {string} priceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForPriceV1: (priceId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'priceId' is not null or undefined
            if (priceId === null || priceId === undefined) {
                throw new base_1.RequiredError('priceId', 'Required parameter priceId was null or undefined when calling createCheckoutSessionForPriceV1.');
            }
            const localVarPath = `/v1/sparr/pricing/{price_id}/checkout`
                .replace(`{${"price_id"}}`, encodeURIComponent(String(priceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseV1: (courseRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseRequest' is not null or undefined
            if (courseRequest === null || courseRequest === undefined) {
                throw new base_1.RequiredError('courseRequest', 'Required parameter courseRequest was null or undefined when calling createCourseV1.');
            }
            const localVarPath = `/v1/sparr/courses/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof courseRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(courseRequest !== undefined ? courseRequest : {}) : (courseRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a customer portal for customer
         * @summary Create Customer Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPortalV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/customers/portal`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new feedback
         * @summary Create Feedback
         * @param {FeedbackCore} feedbackCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedbackV1: (feedbackCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'feedbackCore' is not null or undefined
            if (feedbackCore === null || feedbackCore === undefined) {
                throw new base_1.RequiredError('feedbackCore', 'Required parameter feedbackCore was null or undefined when calling createFeedbackV1.');
            }
            const localVarPath = `/v1/sparr/feedbacks/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof feedbackCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(feedbackCore !== undefined ? feedbackCore : {}) : (feedbackCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new goals collection
         * @summary Create Goals
         * @param {GoalCore} goalCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoalsV1: (goalCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'goalCore' is not null or undefined
            if (goalCore === null || goalCore === undefined) {
                throw new base_1.RequiredError('goalCore', 'Required parameter goalCore was null or undefined when calling createGoalsV1.');
            }
            const localVarPath = `/v1/sparr/goals/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof goalCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(goalCore !== undefined ? goalCore : {}) : (goalCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonaV1: (personaCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'personaCore' is not null or undefined
            if (personaCore === null || personaCore === undefined) {
                throw new base_1.RequiredError('personaCore', 'Required parameter personaCore was null or undefined when calling createPersonaV1.');
            }
            const localVarPath = `/v1/sparr/personas/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof personaCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(personaCore !== undefined ? personaCore : {}) : (personaCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new evaluator
         * @summary Create Evaluator
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPostCallEvaluationParamsV1: (evaluatorCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'evaluatorCore' is not null or undefined
            if (evaluatorCore === null || evaluatorCore === undefined) {
                throw new base_1.RequiredError('evaluatorCore', 'Required parameter evaluatorCore was null or undefined when calling createPostCallEvaluationParamsV1.');
            }
            const localVarPath = `/v1/sparr/evaluators/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof evaluatorCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(evaluatorCore !== undefined ? evaluatorCore : {}) : (evaluatorCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {ScenarioCore} scenarioCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenarioV1: (scenarioCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'scenarioCore' is not null or undefined
            if (scenarioCore === null || scenarioCore === undefined) {
                throw new base_1.RequiredError('scenarioCore', 'Required parameter scenarioCore was null or undefined when calling createScenarioV1.');
            }
            const localVarPath = `/v1/sparr/scenarios/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof scenarioCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(scenarioCore !== undefined ? scenarioCore : {}) : (scenarioCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new tracker
         * @summary Create Tracker
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackerV1: (trackerCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'trackerCore' is not null or undefined
            if (trackerCore === null || trackerCore === undefined) {
                throw new base_1.RequiredError('trackerCore', 'Required parameter trackerCore was null or undefined when calling createTrackerV1.');
            }
            const localVarPath = `/v1/sparr/trackers/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof trackerCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(trackerCore !== undefined ? trackerCore : {}) : (trackerCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseV1: (courseId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new base_1.RequiredError('courseId', 'Required parameter courseId was null or undefined when calling deleteCourseV1.');
            }
            const localVarPath = `/v1/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete evaluator
         * @summary Delete Evaluator
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvaluatorV1: (paramsId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'paramsId' is not null or undefined
            if (paramsId === null || paramsId === undefined) {
                throw new base_1.RequiredError('paramsId', 'Required parameter paramsId was null or undefined when calling deleteEvaluatorV1.');
            }
            const localVarPath = `/v1/sparr/evaluators/{params_id}`
                .replace(`{${"params_id"}}`, encodeURIComponent(String(paramsId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a feedback
         * @summary Delete Feedback
         * @param {string} feedbackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedbackV1: (feedbackId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'feedbackId' is not null or undefined
            if (feedbackId === null || feedbackId === undefined) {
                throw new base_1.RequiredError('feedbackId', 'Required parameter feedbackId was null or undefined when calling deleteFeedbackV1.');
            }
            const localVarPath = `/v1/sparr/feedbacks/{feedback_id}`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a file
         * @summary Delete File
         * @param {string} fileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1: (fileId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new base_1.RequiredError('fileId', 'Required parameter fileId was null or undefined when calling deleteFileV1.');
            }
            const localVarPath = `/v1/sparr/files/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a goals collection
         * @summary Delete Goals
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoalsV1: (goalsId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'goalsId' is not null or undefined
            if (goalsId === null || goalsId === undefined) {
                throw new base_1.RequiredError('goalsId', 'Required parameter goalsId was null or undefined when calling deleteGoalsV1.');
            }
            const localVarPath = `/v1/sparr/goals/{goals_id}`
                .replace(`{${"goals_id"}}`, encodeURIComponent(String(goalsId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonaV1: (personaId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'personaId' is not null or undefined
            if (personaId === null || personaId === undefined) {
                throw new base_1.RequiredError('personaId', 'Required parameter personaId was null or undefined when calling deletePersonaV1.');
            }
            const localVarPath = `/v1/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioV1: (scenarioId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'scenarioId' is not null or undefined
            if (scenarioId === null || scenarioId === undefined) {
                throw new base_1.RequiredError('scenarioId', 'Required parameter scenarioId was null or undefined when calling deleteScenarioV1.');
            }
            const localVarPath = `/v1/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a tracker
         * @summary Delete Tracker
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackerV1: (trackerId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'trackerId' is not null or undefined
            if (trackerId === null || trackerId === undefined) {
                throw new base_1.RequiredError('trackerId', 'Required parameter trackerId was null or undefined when calling deleteTrackerV1.');
            }
            const localVarPath = `/v1/sparr/trackers/{tracker_id}`
                .replace(`{${"tracker_id"}}`, encodeURIComponent(String(trackerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Detach a tag from an entity
         * @summary Detach Tag
         * @param {string} entityType
         * @param {string} entityId
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete: (entityType, entityId, tagName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new base_1.RequiredError('entityType', 'Required parameter entityType was null or undefined when calling detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new base_1.RequiredError('entityId', 'Required parameter entityId was null or undefined when calling detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete.');
            }
            // verify required parameter 'tagName' is not null or undefined
            if (tagName === null || tagName === undefined) {
                throw new base_1.RequiredError('tagName', 'Required parameter tagName was null or undefined when calling detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete.');
            }
            const localVarPath = `/v1/sparr/entity-tags/{entity_type}/{entity_id}/tags/{tag_name}`
                .replace(`{${"entity_type"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Generate evaluator data from files and/or existing core components
         * @summary Generate Evaluator
         * @param {FlexibleGenerationRequest} flexibleGenerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEvaluatorV1: (flexibleGenerationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'flexibleGenerationRequest' is not null or undefined
            if (flexibleGenerationRequest === null || flexibleGenerationRequest === undefined) {
                throw new base_1.RequiredError('flexibleGenerationRequest', 'Required parameter flexibleGenerationRequest was null or undefined when calling generateEvaluatorV1.');
            }
            const localVarPath = `/v1/sparr/evaluators/generate`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof flexibleGenerationRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(flexibleGenerationRequest !== undefined ? flexibleGenerationRequest : {}) : (flexibleGenerationRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseV1: (courseId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new base_1.RequiredError('courseId', 'Required parameter courseId was null or undefined when calling getCourseV1.');
            }
            const localVarPath = `/v1/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get credits
         * @summary Get Credits V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditsV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/credits`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all entities of a type that have a specific tag
         * @summary Get Entities By Tag
         * @param {string} entityType
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet: (entityType, tagName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new base_1.RequiredError('entityType', 'Required parameter entityType was null or undefined when calling getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet.');
            }
            // verify required parameter 'tagName' is not null or undefined
            if (tagName === null || tagName === undefined) {
                throw new base_1.RequiredError('tagName', 'Required parameter tagName was null or undefined when calling getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet.');
            }
            const localVarPath = `/v1/sparr/entity-tags/{entity_type}/by-tag/{tag_name}`
                .replace(`{${"entity_type"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all tags for an entity
         * @summary Get Entity Tags
         * @param {string} entityType
         * @param {string} entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet: (entityType, entityId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new base_1.RequiredError('entityType', 'Required parameter entityType was null or undefined when calling getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new base_1.RequiredError('entityId', 'Required parameter entityId was null or undefined when calling getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet.');
            }
            const localVarPath = `/v1/sparr/entity-tags/{entity_type}/{entity_id}/tags`
                .replace(`{${"entity_type"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
         * @summary Get Evaluator By Id
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluatorV1: (paramsId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'paramsId' is not null or undefined
            if (paramsId === null || paramsId === undefined) {
                throw new base_1.RequiredError('paramsId', 'Required parameter paramsId was null or undefined when calling getEvaluatorV1.');
            }
            const localVarPath = `/v1/sparr/evaluators/{params_id}`
                .replace(`{${"params_id"}}`, encodeURIComponent(String(paramsId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific feedback by ID
         * @summary Get Feedback
         * @param {string} feedbackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedbackV1: (feedbackId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'feedbackId' is not null or undefined
            if (feedbackId === null || feedbackId === undefined) {
                throw new base_1.RequiredError('feedbackId', 'Required parameter feedbackId was null or undefined when calling getFeedbackV1.');
            }
            const localVarPath = `/v1/sparr/feedbacks/{feedback_id}`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific file by ID
         * @summary Get File
         * @param {string} fileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileV1: (fileId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new base_1.RequiredError('fileId', 'Required parameter fileId was null or undefined when calling getFileV1.');
            }
            const localVarPath = `/v1/sparr/files/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
         * @summary Get Goals By Id
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalsV1: (goalsId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'goalsId' is not null or undefined
            if (goalsId === null || goalsId === undefined) {
                throw new base_1.RequiredError('goalsId', 'Required parameter goalsId was null or undefined when calling getGoalsV1.');
            }
            const localVarPath = `/v1/sparr/goals/{goals_id}`
                .replace(`{${"goals_id"}}`, encodeURIComponent(String(goalsId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get metrics for a given batch of metrics requests
         * @summary Get Metrics
         * @param {SparrModelsAnalyticsBatchMetricsRequests} sparrModelsAnalyticsBatchMetricsRequests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1: (sparrModelsAnalyticsBatchMetricsRequests, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'sparrModelsAnalyticsBatchMetricsRequests' is not null or undefined
            if (sparrModelsAnalyticsBatchMetricsRequests === null || sparrModelsAnalyticsBatchMetricsRequests === undefined) {
                throw new base_1.RequiredError('sparrModelsAnalyticsBatchMetricsRequests', 'Required parameter sparrModelsAnalyticsBatchMetricsRequests was null or undefined when calling getMetricsV1.');
            }
            const localVarPath = `/v1/sparr/feedbacks/metrics`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof sparrModelsAnalyticsBatchMetricsRequests !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(sparrModelsAnalyticsBatchMetricsRequests !== undefined ? sparrModelsAnalyticsBatchMetricsRequests : {}) : (sparrModelsAnalyticsBatchMetricsRequests || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific persona by ID that is either directly owned or available through reseller course assignments
         * @summary Get Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaV1: (personaId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'personaId' is not null or undefined
            if (personaId === null || personaId === undefined) {
                throw new base_1.RequiredError('personaId', 'Required parameter personaId was null or undefined when calling getPersonaV1.');
            }
            const localVarPath = `/v1/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get pricing
         * @summary Get Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/pricing`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
         * @summary Get Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioV1: (scenarioId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'scenarioId' is not null or undefined
            if (scenarioId === null || scenarioId === undefined) {
                throw new base_1.RequiredError('scenarioId', 'Required parameter scenarioId was null or undefined when calling getScenarioV1.');
            }
            const localVarPath = `/v1/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
         * @summary Get Tracker By Id
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackerV1: (trackerId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'trackerId' is not null or undefined
            if (trackerId === null || trackerId === undefined) {
                throw new base_1.RequiredError('trackerId', 'Required parameter trackerId was null or undefined when calling getTrackerV1.');
            }
            const localVarPath = `/v1/sparr/trackers/{tracker_id}`
                .replace(`{${"tracker_id"}}`, encodeURIComponent(String(trackerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search personas by name, title and company
         * @summary Get User Stats
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStatsV1: (userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling getUserStatsV1.');
            }
            const localVarPath = `/v1/sparr/user_stats/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLinkedinPersonaV1: (linkedinUrl, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'linkedinUrl' is not null or undefined
            if (linkedinUrl === null || linkedinUrl === undefined) {
                throw new base_1.RequiredError('linkedinUrl', 'Required parameter linkedinUrl was null or undefined when calling importLinkedinPersonaV1.');
            }
            const localVarPath = `/v1/sparr/personas/import-linkedin`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (linkedinUrl !== undefined) {
                localVarQueryParameter['linkedin_url'] = linkedinUrl;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoursesV1: (skip, limit, status, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/courses/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all evaluator that are either directly owned or available through reseller course assignments
         * @summary Get Evaluator
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvaluatorV1: (skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/evaluators/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all feedbacks
         * @summary Get Feedbacks
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string} [fromDate] Start date for filtering feedbacks
         * @param {string} [toDate] End date for filtering feedbacks
         * @param {string} [userFilter] User filter for filtering feedbacks. Comma separated list of user ids.
         * @param {string} [statusFilter] Status filter for filtering feedbacks. Comma separated list of statuses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeedbacksV1: (skip, limit, fromDate, toDate, userFilter, statusFilter, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/feedbacks/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = fromDate;
            }
            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = toDate;
            }
            if (userFilter !== undefined) {
                localVarQueryParameter['user_filter'] = userFilter;
            }
            if (statusFilter !== undefined) {
                localVarQueryParameter['status_filter'] = statusFilter;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all goals that are either directly owned or available through reseller course assignments
         * @summary Get Goals
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGoalsV1: (skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/goals/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all personas that are either directly owned or available through reseller course assignments
         * @summary Get Personas
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter personas by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonasV1: (skip, limit, tags, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/personas/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all scenarios that are either directly owned or available through reseller course assignments
         * @summary Get Scenarios
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter scenarios by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenariosV1: (skip, limit, tags, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/scenarios/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all trackers that are either directly owned or available through reseller course assignments
         * @summary Get Trackers
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrackerV1: (skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/trackers/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all course assignments for a user with analytics
         * @summary Get User Assignments
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAssignmentsV1: (userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling listUserAssignmentsV1.');
            }
            const localVarPath = `/v1/sparr/courses/users/{user_id}/assignments`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all module attempts with module information for a user in a specific course
         * @summary Get User Course Attempts
         * @param {string} courseId
         * @param {string} userId
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCourseAttemptsV1: (courseId, userId, skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new base_1.RequiredError('courseId', 'Required parameter courseId was null or undefined when calling listUserCourseAttemptsV1.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling listUserCourseAttemptsV1.');
            }
            const localVarPath = `/v1/sparr/courses/{course_id}/attempts/users/{user_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all module attempts for a user
         * @summary Get User Module Attempts
         * @param {string} moduleId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserModuleAttemptsV1: (moduleId, userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'moduleId' is not null or undefined
            if (moduleId === null || moduleId === undefined) {
                throw new base_1.RequiredError('moduleId', 'Required parameter moduleId was null or undefined when calling listUserModuleAttemptsV1.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling listUserModuleAttemptsV1.');
            }
            const localVarPath = `/v1/sparr/courses/modules/{module_id}/attempts/{user_id}`
                .replace(`{${"module_id"}}`, encodeURIComponent(String(moduleId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Revoke a course from a user
         * @summary Revoke Course
         * @param {string} courseId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCourseV1: (courseId, userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new base_1.RequiredError('courseId', 'Required parameter courseId was null or undefined when calling revokeCourseV1.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling revokeCourseV1.');
            }
            const localVarPath = `/v1/sparr/courses/{course_id}/assign/{user_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search goals by name and description
         * @summary Search Goals
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGoalsV1: (query, page, size, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new base_1.RequiredError('query', 'Required parameter query was null or undefined when calling searchGoalsV1.');
            }
            const localVarPath = `/v1/sparr/goals/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonasV1: (query, page, size, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new base_1.RequiredError('query', 'Required parameter query was null or undefined when calling searchPersonasV1.');
            }
            const localVarPath = `/v1/sparr/personas/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenariosV1: (query, page, size, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new base_1.RequiredError('query', 'Required parameter query was null or undefined when calling searchScenariosV1.');
            }
            const localVarPath = `/v1/sparr/scenarios/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search trackers by name and description
         * @summary Search Tracker
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTrackerV1: (query, page, size, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new base_1.RequiredError('query', 'Required parameter query was null or undefined when calling searchTrackerV1.');
            }
            const localVarPath = `/v1/sparr/trackers/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Heart Beat check to check the health of Sparr Service
         * @summary Heart Beat Status Of Sparr Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusSparrStatusGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/sparr/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update course completion status
         * @summary Update Course Completion Status
         * @param {string} courseId
         * @param {string} userId
         * @param {CourseCompletionStatus} completionStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseCompletionStatusV1: (courseId, userId, completionStatus, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new base_1.RequiredError('courseId', 'Required parameter courseId was null or undefined when calling updateCourseCompletionStatusV1.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling updateCourseCompletionStatusV1.');
            }
            // verify required parameter 'completionStatus' is not null or undefined
            if (completionStatus === null || completionStatus === undefined) {
                throw new base_1.RequiredError('completionStatus', 'Required parameter completionStatus was null or undefined when calling updateCourseCompletionStatusV1.');
            }
            const localVarPath = `/v1/sparr/courses/{course_id}/assign/{user_id}/status`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (completionStatus !== undefined) {
                localVarQueryParameter['completionStatus'] = completionStatus;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId
         * @param {CourseUpdateRequest} courseUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseV1: (courseId, courseUpdateRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new base_1.RequiredError('courseId', 'Required parameter courseId was null or undefined when calling updateCourseV1.');
            }
            // verify required parameter 'courseUpdateRequest' is not null or undefined
            if (courseUpdateRequest === null || courseUpdateRequest === undefined) {
                throw new base_1.RequiredError('courseUpdateRequest', 'Required parameter courseUpdateRequest was null or undefined when calling updateCourseV1.');
            }
            const localVarPath = `/v1/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof courseUpdateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(courseUpdateRequest !== undefined ? courseUpdateRequest : {}) : (courseUpdateRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update evaluator
         * @summary Update Evaluator
         * @param {string} paramsId
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvaluatorV1: (paramsId, evaluatorCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'paramsId' is not null or undefined
            if (paramsId === null || paramsId === undefined) {
                throw new base_1.RequiredError('paramsId', 'Required parameter paramsId was null or undefined when calling updateEvaluatorV1.');
            }
            // verify required parameter 'evaluatorCore' is not null or undefined
            if (evaluatorCore === null || evaluatorCore === undefined) {
                throw new base_1.RequiredError('evaluatorCore', 'Required parameter evaluatorCore was null or undefined when calling updateEvaluatorV1.');
            }
            const localVarPath = `/v1/sparr/evaluators/{params_id}`
                .replace(`{${"params_id"}}`, encodeURIComponent(String(paramsId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof evaluatorCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(evaluatorCore !== undefined ? evaluatorCore : {}) : (evaluatorCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a feedback
         * @summary Update Feedback
         * @param {string} feedbackId
         * @param {FeedbackCore} feedbackCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedbackV1: (feedbackId, feedbackCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'feedbackId' is not null or undefined
            if (feedbackId === null || feedbackId === undefined) {
                throw new base_1.RequiredError('feedbackId', 'Required parameter feedbackId was null or undefined when calling updateFeedbackV1.');
            }
            // verify required parameter 'feedbackCore' is not null or undefined
            if (feedbackCore === null || feedbackCore === undefined) {
                throw new base_1.RequiredError('feedbackCore', 'Required parameter feedbackCore was null or undefined when calling updateFeedbackV1.');
            }
            const localVarPath = `/v1/sparr/feedbacks/{feedback_id}`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof feedbackCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(feedbackCore !== undefined ? feedbackCore : {}) : (feedbackCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a goals collection
         * @summary Update Goals
         * @param {string} goalsId
         * @param {GoalCore} goalCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalsV1: (goalsId, goalCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'goalsId' is not null or undefined
            if (goalsId === null || goalsId === undefined) {
                throw new base_1.RequiredError('goalsId', 'Required parameter goalsId was null or undefined when calling updateGoalsV1.');
            }
            // verify required parameter 'goalCore' is not null or undefined
            if (goalCore === null || goalCore === undefined) {
                throw new base_1.RequiredError('goalCore', 'Required parameter goalCore was null or undefined when calling updateGoalsV1.');
            }
            const localVarPath = `/v1/sparr/goals/{goals_id}`
                .replace(`{${"goals_id"}}`, encodeURIComponent(String(goalsId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof goalCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(goalCore !== undefined ? goalCore : {}) : (goalCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonaV1: (personaId, personaCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'personaId' is not null or undefined
            if (personaId === null || personaId === undefined) {
                throw new base_1.RequiredError('personaId', 'Required parameter personaId was null or undefined when calling updatePersonaV1.');
            }
            // verify required parameter 'personaCore' is not null or undefined
            if (personaCore === null || personaCore === undefined) {
                throw new base_1.RequiredError('personaCore', 'Required parameter personaCore was null or undefined when calling updatePersonaV1.');
            }
            const localVarPath = `/v1/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof personaCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(personaCore !== undefined ? personaCore : {}) : (personaCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId
         * @param {ScenarioCore} scenarioCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenarioV1: (scenarioId, scenarioCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'scenarioId' is not null or undefined
            if (scenarioId === null || scenarioId === undefined) {
                throw new base_1.RequiredError('scenarioId', 'Required parameter scenarioId was null or undefined when calling updateScenarioV1.');
            }
            // verify required parameter 'scenarioCore' is not null or undefined
            if (scenarioCore === null || scenarioCore === undefined) {
                throw new base_1.RequiredError('scenarioCore', 'Required parameter scenarioCore was null or undefined when calling updateScenarioV1.');
            }
            const localVarPath = `/v1/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof scenarioCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(scenarioCore !== undefined ? scenarioCore : {}) : (scenarioCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a tracker
         * @summary Update Tracker
         * @param {string} trackerId
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackerV1: (trackerId, trackerCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'trackerId' is not null or undefined
            if (trackerId === null || trackerId === undefined) {
                throw new base_1.RequiredError('trackerId', 'Required parameter trackerId was null or undefined when calling updateTrackerV1.');
            }
            // verify required parameter 'trackerCore' is not null or undefined
            if (trackerCore === null || trackerCore === undefined) {
                throw new base_1.RequiredError('trackerCore', 'Required parameter trackerCore was null or undefined when calling updateTrackerV1.');
            }
            const localVarPath = `/v1/sparr/trackers/{tracker_id}`
                .replace(`{${"tracker_id"}}`, encodeURIComponent(String(trackerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof trackerCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(trackerCore !== undefined ? trackerCore : {}) : (trackerCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Upload multiple files and create file records. Maximum 5 files per request, each file max 10MB.
         * @summary Upload Files
         * @param {Array<any>} files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilesV1: (files, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'files' is not null or undefined
            if (files === null || files === undefined) {
                throw new base_1.RequiredError('files', 'Required parameter files was null or undefined when calling uploadFilesV1.');
            }
            const localVarPath = `/v1/sparr/files/upload`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (files) {
                localVarFormParams.append('files', files.join(base_1.COLLECTION_FORMATS.csv));
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * SparrApi - functional programming interface
 * @export
 */
exports.SparrApiFp = function (configuration) {
    return {
        /**
         * Add a module attempt for a user
         * @summary Add Module Attempt
         * @param {string} moduleId
         * @param {UserModuleAttemptCore} userModuleAttemptCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addModuleAttemptV1(moduleId, userModuleAttemptCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).addModuleAttemptV1(moduleId, userModuleAttemptCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Assign a course to a user
         * @summary Assign Course
         * @param {string} courseId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignCourseV1(courseId, userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).assignCourseV1(courseId, userId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Attach a tag to an entity
         * @summary Attach Tag
         * @param {string} entityType
         * @param {string} entityId
         * @param {TagCreate} tagCreate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost(entityType, entityId, tagCreate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost(entityType, entityId, tagCreate, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a checkout session for a price
         * @summary Create Checkout Session For Price
         * @param {string} priceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForPriceV1(priceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).createCheckoutSessionForPriceV1(priceId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseV1(courseRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).createCourseV1(courseRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a customer portal for customer
         * @summary Create Customer Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPortalV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).createCustomerPortalV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new feedback
         * @summary Create Feedback
         * @param {FeedbackCore} feedbackCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedbackV1(feedbackCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).createFeedbackV1(feedbackCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new goals collection
         * @summary Create Goals
         * @param {GoalCore} goalCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoalsV1(goalCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).createGoalsV1(goalCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonaV1(personaCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).createPersonaV1(personaCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new evaluator
         * @summary Create Evaluator
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPostCallEvaluationParamsV1(evaluatorCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).createPostCallEvaluationParamsV1(evaluatorCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {ScenarioCore} scenarioCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenarioV1(scenarioCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).createScenarioV1(scenarioCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new tracker
         * @summary Create Tracker
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackerV1(trackerCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).createTrackerV1(trackerCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseV1(courseId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).deleteCourseV1(courseId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete evaluator
         * @summary Delete Evaluator
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvaluatorV1(paramsId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).deleteEvaluatorV1(paramsId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a feedback
         * @summary Delete Feedback
         * @param {string} feedbackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedbackV1(feedbackId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).deleteFeedbackV1(feedbackId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a file
         * @summary Delete File
         * @param {string} fileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1(fileId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).deleteFileV1(fileId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a goals collection
         * @summary Delete Goals
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoalsV1(goalsId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).deleteGoalsV1(goalsId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonaV1(personaId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).deletePersonaV1(personaId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioV1(scenarioId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).deleteScenarioV1(scenarioId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a tracker
         * @summary Delete Tracker
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackerV1(trackerId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).deleteTrackerV1(trackerId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Detach a tag from an entity
         * @summary Detach Tag
         * @param {string} entityType
         * @param {string} entityId
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete(entityType, entityId, tagName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete(entityType, entityId, tagName, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Generate evaluator data from files and/or existing core components
         * @summary Generate Evaluator
         * @param {FlexibleGenerationRequest} flexibleGenerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEvaluatorV1(flexibleGenerationRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).generateEvaluatorV1(flexibleGenerationRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseV1(courseId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).getCourseV1(courseId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get credits
         * @summary Get Credits V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditsV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).getCreditsV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get all entities of a type that have a specific tag
         * @summary Get Entities By Tag
         * @param {string} entityType
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet(entityType, tagName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet(entityType, tagName, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get all tags for an entity
         * @summary Get Entity Tags
         * @param {string} entityType
         * @param {string} entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet(entityType, entityId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet(entityType, entityId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
         * @summary Get Evaluator By Id
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluatorV1(paramsId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).getEvaluatorV1(paramsId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a specific feedback by ID
         * @summary Get Feedback
         * @param {string} feedbackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedbackV1(feedbackId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).getFeedbackV1(feedbackId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a specific file by ID
         * @summary Get File
         * @param {string} fileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileV1(fileId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).getFileV1(fileId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
         * @summary Get Goals By Id
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalsV1(goalsId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).getGoalsV1(goalsId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get metrics for a given batch of metrics requests
         * @summary Get Metrics
         * @param {SparrModelsAnalyticsBatchMetricsRequests} sparrModelsAnalyticsBatchMetricsRequests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a specific persona by ID that is either directly owned or available through reseller course assignments
         * @summary Get Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaV1(personaId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).getPersonaV1(personaId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get pricing
         * @summary Get Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).getPricingV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
         * @summary Get Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioV1(scenarioId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).getScenarioV1(scenarioId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
         * @summary Get Tracker By Id
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackerV1(trackerId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).getTrackerV1(trackerId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Search personas by name, title and company
         * @summary Get User Stats
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStatsV1(userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).getUserStatsV1(userId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLinkedinPersonaV1(linkedinUrl, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).importLinkedinPersonaV1(linkedinUrl, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoursesV1(skip, limit, status, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).listCoursesV1(skip, limit, status, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get all evaluator that are either directly owned or available through reseller course assignments
         * @summary Get Evaluator
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvaluatorV1(skip, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).listEvaluatorV1(skip, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get all feedbacks
         * @summary Get Feedbacks
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string} [fromDate] Start date for filtering feedbacks
         * @param {string} [toDate] End date for filtering feedbacks
         * @param {string} [userFilter] User filter for filtering feedbacks. Comma separated list of user ids.
         * @param {string} [statusFilter] Status filter for filtering feedbacks. Comma separated list of statuses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeedbacksV1(skip, limit, fromDate, toDate, userFilter, statusFilter, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).listFeedbacksV1(skip, limit, fromDate, toDate, userFilter, statusFilter, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get all goals that are either directly owned or available through reseller course assignments
         * @summary Get Goals
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGoalsV1(skip, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).listGoalsV1(skip, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get all personas that are either directly owned or available through reseller course assignments
         * @summary Get Personas
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter personas by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonasV1(skip, limit, tags, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).listPersonasV1(skip, limit, tags, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get all scenarios that are either directly owned or available through reseller course assignments
         * @summary Get Scenarios
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter scenarios by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenariosV1(skip, limit, tags, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).listScenariosV1(skip, limit, tags, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get all trackers that are either directly owned or available through reseller course assignments
         * @summary Get Trackers
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrackerV1(skip, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).listTrackerV1(skip, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get all course assignments for a user with analytics
         * @summary Get User Assignments
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAssignmentsV1(userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).listUserAssignmentsV1(userId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get all module attempts with module information for a user in a specific course
         * @summary Get User Course Attempts
         * @param {string} courseId
         * @param {string} userId
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCourseAttemptsV1(courseId, userId, skip, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).listUserCourseAttemptsV1(courseId, userId, skip, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get all module attempts for a user
         * @summary Get User Module Attempts
         * @param {string} moduleId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserModuleAttemptsV1(moduleId, userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).listUserModuleAttemptsV1(moduleId, userId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Revoke a course from a user
         * @summary Revoke Course
         * @param {string} courseId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCourseV1(courseId, userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).revokeCourseV1(courseId, userId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Search goals by name and description
         * @summary Search Goals
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGoalsV1(query, page, size, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).searchGoalsV1(query, page, size, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonasV1(query, page, size, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).searchPersonasV1(query, page, size, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenariosV1(query, page, size, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).searchScenariosV1(query, page, size, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Search trackers by name and description
         * @summary Search Tracker
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTrackerV1(query, page, size, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).searchTrackerV1(query, page, size, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Heart Beat check to check the health of Sparr Service
         * @summary Heart Beat Status Of Sparr Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusSparrStatusGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).statusSparrStatusGet(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update course completion status
         * @summary Update Course Completion Status
         * @param {string} courseId
         * @param {string} userId
         * @param {CourseCompletionStatus} completionStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseCompletionStatusV1(courseId, userId, completionStatus, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).updateCourseCompletionStatusV1(courseId, userId, completionStatus, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId
         * @param {CourseUpdateRequest} courseUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseV1(courseId, courseUpdateRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).updateCourseV1(courseId, courseUpdateRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update evaluator
         * @summary Update Evaluator
         * @param {string} paramsId
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvaluatorV1(paramsId, evaluatorCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).updateEvaluatorV1(paramsId, evaluatorCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a feedback
         * @summary Update Feedback
         * @param {string} feedbackId
         * @param {FeedbackCore} feedbackCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedbackV1(feedbackId, feedbackCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).updateFeedbackV1(feedbackId, feedbackCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a goals collection
         * @summary Update Goals
         * @param {string} goalsId
         * @param {GoalCore} goalCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalsV1(goalsId, goalCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).updateGoalsV1(goalsId, goalCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonaV1(personaId, personaCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).updatePersonaV1(personaId, personaCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId
         * @param {ScenarioCore} scenarioCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenarioV1(scenarioId, scenarioCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).updateScenarioV1(scenarioId, scenarioCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a tracker
         * @summary Update Tracker
         * @param {string} trackerId
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackerV1(trackerId, trackerCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).updateTrackerV1(trackerId, trackerCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Upload multiple files and create file records. Maximum 5 files per request, each file max 10MB.
         * @summary Upload Files
         * @param {Array<any>} files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilesV1(files, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrApiAxiosParamCreator(configuration).uploadFilesV1(files, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * SparrApi - factory interface
 * @export
 */
exports.SparrApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Add a module attempt for a user
         * @summary Add Module Attempt
         * @param {string} moduleId
         * @param {UserModuleAttemptCore} userModuleAttemptCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addModuleAttemptV1(moduleId, userModuleAttemptCore, options) {
            return exports.SparrApiFp(configuration).addModuleAttemptV1(moduleId, userModuleAttemptCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign a course to a user
         * @summary Assign Course
         * @param {string} courseId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignCourseV1(courseId, userId, options) {
            return exports.SparrApiFp(configuration).assignCourseV1(courseId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Attach a tag to an entity
         * @summary Attach Tag
         * @param {string} entityType
         * @param {string} entityId
         * @param {TagCreate} tagCreate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost(entityType, entityId, tagCreate, options) {
            return exports.SparrApiFp(configuration).attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost(entityType, entityId, tagCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a checkout session for a price
         * @summary Create Checkout Session For Price
         * @param {string} priceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForPriceV1(priceId, options) {
            return exports.SparrApiFp(configuration).createCheckoutSessionForPriceV1(priceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseV1(courseRequest, options) {
            return exports.SparrApiFp(configuration).createCourseV1(courseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a customer portal for customer
         * @summary Create Customer Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPortalV1(options) {
            return exports.SparrApiFp(configuration).createCustomerPortalV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new feedback
         * @summary Create Feedback
         * @param {FeedbackCore} feedbackCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedbackV1(feedbackCore, options) {
            return exports.SparrApiFp(configuration).createFeedbackV1(feedbackCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new goals collection
         * @summary Create Goals
         * @param {GoalCore} goalCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoalsV1(goalCore, options) {
            return exports.SparrApiFp(configuration).createGoalsV1(goalCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonaV1(personaCore, options) {
            return exports.SparrApiFp(configuration).createPersonaV1(personaCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new evaluator
         * @summary Create Evaluator
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPostCallEvaluationParamsV1(evaluatorCore, options) {
            return exports.SparrApiFp(configuration).createPostCallEvaluationParamsV1(evaluatorCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {ScenarioCore} scenarioCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenarioV1(scenarioCore, options) {
            return exports.SparrApiFp(configuration).createScenarioV1(scenarioCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new tracker
         * @summary Create Tracker
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackerV1(trackerCore, options) {
            return exports.SparrApiFp(configuration).createTrackerV1(trackerCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseV1(courseId, options) {
            return exports.SparrApiFp(configuration).deleteCourseV1(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete evaluator
         * @summary Delete Evaluator
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvaluatorV1(paramsId, options) {
            return exports.SparrApiFp(configuration).deleteEvaluatorV1(paramsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a feedback
         * @summary Delete Feedback
         * @param {string} feedbackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedbackV1(feedbackId, options) {
            return exports.SparrApiFp(configuration).deleteFeedbackV1(feedbackId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a file
         * @summary Delete File
         * @param {string} fileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1(fileId, options) {
            return exports.SparrApiFp(configuration).deleteFileV1(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a goals collection
         * @summary Delete Goals
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoalsV1(goalsId, options) {
            return exports.SparrApiFp(configuration).deleteGoalsV1(goalsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonaV1(personaId, options) {
            return exports.SparrApiFp(configuration).deletePersonaV1(personaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioV1(scenarioId, options) {
            return exports.SparrApiFp(configuration).deleteScenarioV1(scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a tracker
         * @summary Delete Tracker
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackerV1(trackerId, options) {
            return exports.SparrApiFp(configuration).deleteTrackerV1(trackerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detach a tag from an entity
         * @summary Detach Tag
         * @param {string} entityType
         * @param {string} entityId
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete(entityType, entityId, tagName, options) {
            return exports.SparrApiFp(configuration).detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete(entityType, entityId, tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate evaluator data from files and/or existing core components
         * @summary Generate Evaluator
         * @param {FlexibleGenerationRequest} flexibleGenerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEvaluatorV1(flexibleGenerationRequest, options) {
            return exports.SparrApiFp(configuration).generateEvaluatorV1(flexibleGenerationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseV1(courseId, options) {
            return exports.SparrApiFp(configuration).getCourseV1(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get credits
         * @summary Get Credits V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditsV1(options) {
            return exports.SparrApiFp(configuration).getCreditsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all entities of a type that have a specific tag
         * @summary Get Entities By Tag
         * @param {string} entityType
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet(entityType, tagName, options) {
            return exports.SparrApiFp(configuration).getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet(entityType, tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all tags for an entity
         * @summary Get Entity Tags
         * @param {string} entityType
         * @param {string} entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet(entityType, entityId, options) {
            return exports.SparrApiFp(configuration).getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet(entityType, entityId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
         * @summary Get Evaluator By Id
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluatorV1(paramsId, options) {
            return exports.SparrApiFp(configuration).getEvaluatorV1(paramsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific feedback by ID
         * @summary Get Feedback
         * @param {string} feedbackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedbackV1(feedbackId, options) {
            return exports.SparrApiFp(configuration).getFeedbackV1(feedbackId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific file by ID
         * @summary Get File
         * @param {string} fileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileV1(fileId, options) {
            return exports.SparrApiFp(configuration).getFileV1(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
         * @summary Get Goals By Id
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalsV1(goalsId, options) {
            return exports.SparrApiFp(configuration).getGoalsV1(goalsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get metrics for a given batch of metrics requests
         * @summary Get Metrics
         * @param {SparrModelsAnalyticsBatchMetricsRequests} sparrModelsAnalyticsBatchMetricsRequests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests, options) {
            return exports.SparrApiFp(configuration).getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific persona by ID that is either directly owned or available through reseller course assignments
         * @summary Get Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaV1(personaId, options) {
            return exports.SparrApiFp(configuration).getPersonaV1(personaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pricing
         * @summary Get Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingV1(options) {
            return exports.SparrApiFp(configuration).getPricingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
         * @summary Get Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioV1(scenarioId, options) {
            return exports.SparrApiFp(configuration).getScenarioV1(scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
         * @summary Get Tracker By Id
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackerV1(trackerId, options) {
            return exports.SparrApiFp(configuration).getTrackerV1(trackerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search personas by name, title and company
         * @summary Get User Stats
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStatsV1(userId, options) {
            return exports.SparrApiFp(configuration).getUserStatsV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLinkedinPersonaV1(linkedinUrl, options) {
            return exports.SparrApiFp(configuration).importLinkedinPersonaV1(linkedinUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoursesV1(skip, limit, status, options) {
            return exports.SparrApiFp(configuration).listCoursesV1(skip, limit, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all evaluator that are either directly owned or available through reseller course assignments
         * @summary Get Evaluator
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvaluatorV1(skip, limit, options) {
            return exports.SparrApiFp(configuration).listEvaluatorV1(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all feedbacks
         * @summary Get Feedbacks
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string} [fromDate] Start date for filtering feedbacks
         * @param {string} [toDate] End date for filtering feedbacks
         * @param {string} [userFilter] User filter for filtering feedbacks. Comma separated list of user ids.
         * @param {string} [statusFilter] Status filter for filtering feedbacks. Comma separated list of statuses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeedbacksV1(skip, limit, fromDate, toDate, userFilter, statusFilter, options) {
            return exports.SparrApiFp(configuration).listFeedbacksV1(skip, limit, fromDate, toDate, userFilter, statusFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all goals that are either directly owned or available through reseller course assignments
         * @summary Get Goals
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGoalsV1(skip, limit, options) {
            return exports.SparrApiFp(configuration).listGoalsV1(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all personas that are either directly owned or available through reseller course assignments
         * @summary Get Personas
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter personas by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonasV1(skip, limit, tags, options) {
            return exports.SparrApiFp(configuration).listPersonasV1(skip, limit, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all scenarios that are either directly owned or available through reseller course assignments
         * @summary Get Scenarios
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter scenarios by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenariosV1(skip, limit, tags, options) {
            return exports.SparrApiFp(configuration).listScenariosV1(skip, limit, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all trackers that are either directly owned or available through reseller course assignments
         * @summary Get Trackers
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrackerV1(skip, limit, options) {
            return exports.SparrApiFp(configuration).listTrackerV1(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all course assignments for a user with analytics
         * @summary Get User Assignments
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAssignmentsV1(userId, options) {
            return exports.SparrApiFp(configuration).listUserAssignmentsV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all module attempts with module information for a user in a specific course
         * @summary Get User Course Attempts
         * @param {string} courseId
         * @param {string} userId
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCourseAttemptsV1(courseId, userId, skip, limit, options) {
            return exports.SparrApiFp(configuration).listUserCourseAttemptsV1(courseId, userId, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all module attempts for a user
         * @summary Get User Module Attempts
         * @param {string} moduleId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserModuleAttemptsV1(moduleId, userId, options) {
            return exports.SparrApiFp(configuration).listUserModuleAttemptsV1(moduleId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke a course from a user
         * @summary Revoke Course
         * @param {string} courseId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCourseV1(courseId, userId, options) {
            return exports.SparrApiFp(configuration).revokeCourseV1(courseId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search goals by name and description
         * @summary Search Goals
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGoalsV1(query, page, size, options) {
            return exports.SparrApiFp(configuration).searchGoalsV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonasV1(query, page, size, options) {
            return exports.SparrApiFp(configuration).searchPersonasV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenariosV1(query, page, size, options) {
            return exports.SparrApiFp(configuration).searchScenariosV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Search trackers by name and description
         * @summary Search Tracker
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTrackerV1(query, page, size, options) {
            return exports.SparrApiFp(configuration).searchTrackerV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Heart Beat check to check the health of Sparr Service
         * @summary Heart Beat Status Of Sparr Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusSparrStatusGet(options) {
            return exports.SparrApiFp(configuration).statusSparrStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update course completion status
         * @summary Update Course Completion Status
         * @param {string} courseId
         * @param {string} userId
         * @param {CourseCompletionStatus} completionStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseCompletionStatusV1(courseId, userId, completionStatus, options) {
            return exports.SparrApiFp(configuration).updateCourseCompletionStatusV1(courseId, userId, completionStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId
         * @param {CourseUpdateRequest} courseUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseV1(courseId, courseUpdateRequest, options) {
            return exports.SparrApiFp(configuration).updateCourseV1(courseId, courseUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update evaluator
         * @summary Update Evaluator
         * @param {string} paramsId
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvaluatorV1(paramsId, evaluatorCore, options) {
            return exports.SparrApiFp(configuration).updateEvaluatorV1(paramsId, evaluatorCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a feedback
         * @summary Update Feedback
         * @param {string} feedbackId
         * @param {FeedbackCore} feedbackCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedbackV1(feedbackId, feedbackCore, options) {
            return exports.SparrApiFp(configuration).updateFeedbackV1(feedbackId, feedbackCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a goals collection
         * @summary Update Goals
         * @param {string} goalsId
         * @param {GoalCore} goalCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalsV1(goalsId, goalCore, options) {
            return exports.SparrApiFp(configuration).updateGoalsV1(goalsId, goalCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonaV1(personaId, personaCore, options) {
            return exports.SparrApiFp(configuration).updatePersonaV1(personaId, personaCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId
         * @param {ScenarioCore} scenarioCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenarioV1(scenarioId, scenarioCore, options) {
            return exports.SparrApiFp(configuration).updateScenarioV1(scenarioId, scenarioCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a tracker
         * @summary Update Tracker
         * @param {string} trackerId
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackerV1(trackerId, trackerCore, options) {
            return exports.SparrApiFp(configuration).updateTrackerV1(trackerId, trackerCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload multiple files and create file records. Maximum 5 files per request, each file max 10MB.
         * @summary Upload Files
         * @param {Array<any>} files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilesV1(files, options) {
            return exports.SparrApiFp(configuration).uploadFilesV1(files, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SparrApi - object-oriented interface
 * @export
 * @class SparrApi
 * @extends {BaseAPI}
 */
class SparrApi extends base_1.BaseAPI {
    /**
     * Add a module attempt for a user
     * @summary Add Module Attempt
     * @param {string} moduleId
     * @param {UserModuleAttemptCore} userModuleAttemptCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    addModuleAttemptV1(moduleId, userModuleAttemptCore, options) {
        return exports.SparrApiFp(this.configuration).addModuleAttemptV1(moduleId, userModuleAttemptCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Assign a course to a user
     * @summary Assign Course
     * @param {string} courseId
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    assignCourseV1(courseId, userId, options) {
        return exports.SparrApiFp(this.configuration).assignCourseV1(courseId, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Attach a tag to an entity
     * @summary Attach Tag
     * @param {string} entityType
     * @param {string} entityId
     * @param {TagCreate} tagCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost(entityType, entityId, tagCreate, options) {
        return exports.SparrApiFp(this.configuration).attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost(entityType, entityId, tagCreate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a checkout session for a price
     * @summary Create Checkout Session For Price
     * @param {string} priceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    createCheckoutSessionForPriceV1(priceId, options) {
        return exports.SparrApiFp(this.configuration).createCheckoutSessionForPriceV1(priceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new course
     * @summary Create Course
     * @param {CourseRequest} courseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    createCourseV1(courseRequest, options) {
        return exports.SparrApiFp(this.configuration).createCourseV1(courseRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a customer portal for customer
     * @summary Create Customer Portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    createCustomerPortalV1(options) {
        return exports.SparrApiFp(this.configuration).createCustomerPortalV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new feedback
     * @summary Create Feedback
     * @param {FeedbackCore} feedbackCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    createFeedbackV1(feedbackCore, options) {
        return exports.SparrApiFp(this.configuration).createFeedbackV1(feedbackCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new goals collection
     * @summary Create Goals
     * @param {GoalCore} goalCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    createGoalsV1(goalCore, options) {
        return exports.SparrApiFp(this.configuration).createGoalsV1(goalCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new persona
     * @summary Create Persona
     * @param {PersonaCore} personaCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    createPersonaV1(personaCore, options) {
        return exports.SparrApiFp(this.configuration).createPersonaV1(personaCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new evaluator
     * @summary Create Evaluator
     * @param {EvaluatorCore} evaluatorCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    createPostCallEvaluationParamsV1(evaluatorCore, options) {
        return exports.SparrApiFp(this.configuration).createPostCallEvaluationParamsV1(evaluatorCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new scenario
     * @summary Create Scenario
     * @param {ScenarioCore} scenarioCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    createScenarioV1(scenarioCore, options) {
        return exports.SparrApiFp(this.configuration).createScenarioV1(scenarioCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new tracker
     * @summary Create Tracker
     * @param {TrackerCore} trackerCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    createTrackerV1(trackerCore, options) {
        return exports.SparrApiFp(this.configuration).createTrackerV1(trackerCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a course
     * @summary Delete Course
     * @param {string} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    deleteCourseV1(courseId, options) {
        return exports.SparrApiFp(this.configuration).deleteCourseV1(courseId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete evaluator
     * @summary Delete Evaluator
     * @param {string} paramsId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    deleteEvaluatorV1(paramsId, options) {
        return exports.SparrApiFp(this.configuration).deleteEvaluatorV1(paramsId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a feedback
     * @summary Delete Feedback
     * @param {string} feedbackId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    deleteFeedbackV1(feedbackId, options) {
        return exports.SparrApiFp(this.configuration).deleteFeedbackV1(feedbackId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a file
     * @summary Delete File
     * @param {string} fileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    deleteFileV1(fileId, options) {
        return exports.SparrApiFp(this.configuration).deleteFileV1(fileId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a goals collection
     * @summary Delete Goals
     * @param {string} goalsId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    deleteGoalsV1(goalsId, options) {
        return exports.SparrApiFp(this.configuration).deleteGoalsV1(goalsId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a persona
     * @summary Delete Persona
     * @param {string} personaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    deletePersonaV1(personaId, options) {
        return exports.SparrApiFp(this.configuration).deletePersonaV1(personaId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a scenario
     * @summary Delete Scenario
     * @param {string} scenarioId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    deleteScenarioV1(scenarioId, options) {
        return exports.SparrApiFp(this.configuration).deleteScenarioV1(scenarioId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a tracker
     * @summary Delete Tracker
     * @param {string} trackerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    deleteTrackerV1(trackerId, options) {
        return exports.SparrApiFp(this.configuration).deleteTrackerV1(trackerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Detach a tag from an entity
     * @summary Detach Tag
     * @param {string} entityType
     * @param {string} entityId
     * @param {string} tagName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete(entityType, entityId, tagName, options) {
        return exports.SparrApiFp(this.configuration).detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete(entityType, entityId, tagName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generate evaluator data from files and/or existing core components
     * @summary Generate Evaluator
     * @param {FlexibleGenerationRequest} flexibleGenerationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    generateEvaluatorV1(flexibleGenerationRequest, options) {
        return exports.SparrApiFp(this.configuration).generateEvaluatorV1(flexibleGenerationRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific course by ID
     * @summary Get Course
     * @param {string} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getCourseV1(courseId, options) {
        return exports.SparrApiFp(this.configuration).getCourseV1(courseId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get credits
     * @summary Get Credits V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getCreditsV1(options) {
        return exports.SparrApiFp(this.configuration).getCreditsV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all entities of a type that have a specific tag
     * @summary Get Entities By Tag
     * @param {string} entityType
     * @param {string} tagName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet(entityType, tagName, options) {
        return exports.SparrApiFp(this.configuration).getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet(entityType, tagName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all tags for an entity
     * @summary Get Entity Tags
     * @param {string} entityType
     * @param {string} entityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet(entityType, entityId, options) {
        return exports.SparrApiFp(this.configuration).getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet(entityType, entityId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
     * @summary Get Evaluator By Id
     * @param {string} paramsId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getEvaluatorV1(paramsId, options) {
        return exports.SparrApiFp(this.configuration).getEvaluatorV1(paramsId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific feedback by ID
     * @summary Get Feedback
     * @param {string} feedbackId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getFeedbackV1(feedbackId, options) {
        return exports.SparrApiFp(this.configuration).getFeedbackV1(feedbackId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific file by ID
     * @summary Get File
     * @param {string} fileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getFileV1(fileId, options) {
        return exports.SparrApiFp(this.configuration).getFileV1(fileId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
     * @summary Get Goals By Id
     * @param {string} goalsId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getGoalsV1(goalsId, options) {
        return exports.SparrApiFp(this.configuration).getGoalsV1(goalsId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get metrics for a given batch of metrics requests
     * @summary Get Metrics
     * @param {SparrModelsAnalyticsBatchMetricsRequests} sparrModelsAnalyticsBatchMetricsRequests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests, options) {
        return exports.SparrApiFp(this.configuration).getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific persona by ID that is either directly owned or available through reseller course assignments
     * @summary Get Persona
     * @param {string} personaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getPersonaV1(personaId, options) {
        return exports.SparrApiFp(this.configuration).getPersonaV1(personaId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get pricing
     * @summary Get Pricing V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getPricingV1(options) {
        return exports.SparrApiFp(this.configuration).getPricingV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
     * @summary Get Scenario
     * @param {string} scenarioId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getScenarioV1(scenarioId, options) {
        return exports.SparrApiFp(this.configuration).getScenarioV1(scenarioId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
     * @summary Get Tracker By Id
     * @param {string} trackerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getTrackerV1(trackerId, options) {
        return exports.SparrApiFp(this.configuration).getTrackerV1(trackerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search personas by name, title and company
     * @summary Get User Stats
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getUserStatsV1(userId, options) {
        return exports.SparrApiFp(this.configuration).getUserStatsV1(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Import a persona from LinkedIn URL
     * @summary Import Linkedin Persona
     * @param {string} linkedinUrl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    importLinkedinPersonaV1(linkedinUrl, options) {
        return exports.SparrApiFp(this.configuration).importLinkedinPersonaV1(linkedinUrl, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all courses including reseller assignments
     * @summary Get Courses
     * @param {number} [skip] Skip for pagination
     * @param {number} [limit] Limit for pagination
     * @param {string} [status] Filter by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    listCoursesV1(skip, limit, status, options) {
        return exports.SparrApiFp(this.configuration).listCoursesV1(skip, limit, status, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all evaluator that are either directly owned or available through reseller course assignments
     * @summary Get Evaluator
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    listEvaluatorV1(skip, limit, options) {
        return exports.SparrApiFp(this.configuration).listEvaluatorV1(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all feedbacks
     * @summary Get Feedbacks
     * @param {number} [skip] Skip for pagination
     * @param {number} [limit] Limit for pagination
     * @param {string} [fromDate] Start date for filtering feedbacks
     * @param {string} [toDate] End date for filtering feedbacks
     * @param {string} [userFilter] User filter for filtering feedbacks. Comma separated list of user ids.
     * @param {string} [statusFilter] Status filter for filtering feedbacks. Comma separated list of statuses.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    listFeedbacksV1(skip, limit, fromDate, toDate, userFilter, statusFilter, options) {
        return exports.SparrApiFp(this.configuration).listFeedbacksV1(skip, limit, fromDate, toDate, userFilter, statusFilter, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all goals that are either directly owned or available through reseller course assignments
     * @summary Get Goals
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    listGoalsV1(skip, limit, options) {
        return exports.SparrApiFp(this.configuration).listGoalsV1(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all personas that are either directly owned or available through reseller course assignments
     * @summary Get Personas
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [tags] Filter personas by tag, comma separated names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    listPersonasV1(skip, limit, tags, options) {
        return exports.SparrApiFp(this.configuration).listPersonasV1(skip, limit, tags, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all scenarios that are either directly owned or available through reseller course assignments
     * @summary Get Scenarios
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [tags] Filter scenarios by tag, comma separated names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    listScenariosV1(skip, limit, tags, options) {
        return exports.SparrApiFp(this.configuration).listScenariosV1(skip, limit, tags, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all trackers that are either directly owned or available through reseller course assignments
     * @summary Get Trackers
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    listTrackerV1(skip, limit, options) {
        return exports.SparrApiFp(this.configuration).listTrackerV1(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all course assignments for a user with analytics
     * @summary Get User Assignments
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    listUserAssignmentsV1(userId, options) {
        return exports.SparrApiFp(this.configuration).listUserAssignmentsV1(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all module attempts with module information for a user in a specific course
     * @summary Get User Course Attempts
     * @param {string} courseId
     * @param {string} userId
     * @param {number} [skip] Skip for pagination
     * @param {number} [limit] Limit for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    listUserCourseAttemptsV1(courseId, userId, skip, limit, options) {
        return exports.SparrApiFp(this.configuration).listUserCourseAttemptsV1(courseId, userId, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all module attempts for a user
     * @summary Get User Module Attempts
     * @param {string} moduleId
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    listUserModuleAttemptsV1(moduleId, userId, options) {
        return exports.SparrApiFp(this.configuration).listUserModuleAttemptsV1(moduleId, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Revoke a course from a user
     * @summary Revoke Course
     * @param {string} courseId
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    revokeCourseV1(courseId, userId, options) {
        return exports.SparrApiFp(this.configuration).revokeCourseV1(courseId, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search goals by name and description
     * @summary Search Goals
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    searchGoalsV1(query, page, size, options) {
        return exports.SparrApiFp(this.configuration).searchGoalsV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search personas by name, title and company
     * @summary Search Personas
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    searchPersonasV1(query, page, size, options) {
        return exports.SparrApiFp(this.configuration).searchPersonasV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search scenarios by name and description
     * @summary Search Scenarios
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    searchScenariosV1(query, page, size, options) {
        return exports.SparrApiFp(this.configuration).searchScenariosV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search trackers by name and description
     * @summary Search Tracker
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    searchTrackerV1(query, page, size, options) {
        return exports.SparrApiFp(this.configuration).searchTrackerV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Heart Beat check to check the health of Sparr Service
     * @summary Heart Beat Status Of Sparr Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    statusSparrStatusGet(options) {
        return exports.SparrApiFp(this.configuration).statusSparrStatusGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update course completion status
     * @summary Update Course Completion Status
     * @param {string} courseId
     * @param {string} userId
     * @param {CourseCompletionStatus} completionStatus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    updateCourseCompletionStatusV1(courseId, userId, completionStatus, options) {
        return exports.SparrApiFp(this.configuration).updateCourseCompletionStatusV1(courseId, userId, completionStatus, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a course
     * @summary Update Course
     * @param {string} courseId
     * @param {CourseUpdateRequest} courseUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    updateCourseV1(courseId, courseUpdateRequest, options) {
        return exports.SparrApiFp(this.configuration).updateCourseV1(courseId, courseUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update evaluator
     * @summary Update Evaluator
     * @param {string} paramsId
     * @param {EvaluatorCore} evaluatorCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    updateEvaluatorV1(paramsId, evaluatorCore, options) {
        return exports.SparrApiFp(this.configuration).updateEvaluatorV1(paramsId, evaluatorCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a feedback
     * @summary Update Feedback
     * @param {string} feedbackId
     * @param {FeedbackCore} feedbackCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    updateFeedbackV1(feedbackId, feedbackCore, options) {
        return exports.SparrApiFp(this.configuration).updateFeedbackV1(feedbackId, feedbackCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a goals collection
     * @summary Update Goals
     * @param {string} goalsId
     * @param {GoalCore} goalCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    updateGoalsV1(goalsId, goalCore, options) {
        return exports.SparrApiFp(this.configuration).updateGoalsV1(goalsId, goalCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a persona
     * @summary Update Persona
     * @param {string} personaId
     * @param {PersonaCore} personaCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    updatePersonaV1(personaId, personaCore, options) {
        return exports.SparrApiFp(this.configuration).updatePersonaV1(personaId, personaCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a scenario
     * @summary Update Scenario
     * @param {string} scenarioId
     * @param {ScenarioCore} scenarioCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    updateScenarioV1(scenarioId, scenarioCore, options) {
        return exports.SparrApiFp(this.configuration).updateScenarioV1(scenarioId, scenarioCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a tracker
     * @summary Update Tracker
     * @param {string} trackerId
     * @param {TrackerCore} trackerCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    updateTrackerV1(trackerId, trackerCore, options) {
        return exports.SparrApiFp(this.configuration).updateTrackerV1(trackerId, trackerCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload multiple files and create file records. Maximum 5 files per request, each file max 10MB.
     * @summary Upload Files
     * @param {Array<any>} files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    uploadFilesV1(files, options) {
        return exports.SparrApiFp(this.configuration).uploadFilesV1(files, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SparrApi = SparrApi;
/**
 * SparrResellerApi - axios parameter creator
 * @export
 */
exports.SparrResellerApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseResellerV1: (courseRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseRequest' is not null or undefined
            if (courseRequest === null || courseRequest === undefined) {
                throw new base_1.RequiredError('courseRequest', 'Required parameter courseRequest was null or undefined when calling createCourseResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/courses/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof courseRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(courseRequest !== undefined ? courseRequest : {}) : (courseRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new evaluator
         * @summary Create Evaluator
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvaluatorResellerV1: (evaluatorCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'evaluatorCore' is not null or undefined
            if (evaluatorCore === null || evaluatorCore === undefined) {
                throw new base_1.RequiredError('evaluatorCore', 'Required parameter evaluatorCore was null or undefined when calling createEvaluatorResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/evaluators/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof evaluatorCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(evaluatorCore !== undefined ? evaluatorCore : {}) : (evaluatorCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new goals collection
         * @summary Create Goals
         * @param {GoalCore} goalCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoalsResellerV1: (goalCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'goalCore' is not null or undefined
            if (goalCore === null || goalCore === undefined) {
                throw new base_1.RequiredError('goalCore', 'Required parameter goalCore was null or undefined when calling createGoalsResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/goals/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof goalCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(goalCore !== undefined ? goalCore : {}) : (goalCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonaResellerV1: (personaCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'personaCore' is not null or undefined
            if (personaCore === null || personaCore === undefined) {
                throw new base_1.RequiredError('personaCore', 'Required parameter personaCore was null or undefined when calling createPersonaResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/personas/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof personaCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(personaCore !== undefined ? personaCore : {}) : (personaCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {ScenarioCore} scenarioCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenarioResellerV1: (scenarioCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'scenarioCore' is not null or undefined
            if (scenarioCore === null || scenarioCore === undefined) {
                throw new base_1.RequiredError('scenarioCore', 'Required parameter scenarioCore was null or undefined when calling createScenarioResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/scenarios/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof scenarioCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(scenarioCore !== undefined ? scenarioCore : {}) : (scenarioCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new tracker
         * @summary Create Tracker
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackerResellerV1: (trackerCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'trackerCore' is not null or undefined
            if (trackerCore === null || trackerCore === undefined) {
                throw new base_1.RequiredError('trackerCore', 'Required parameter trackerCore was null or undefined when calling createTrackerResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/trackers/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof trackerCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(trackerCore !== undefined ? trackerCore : {}) : (trackerCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseResellerV1: (courseId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new base_1.RequiredError('courseId', 'Required parameter courseId was null or undefined when calling deleteCourseResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete evaluator
         * @summary Delete Evaluator
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvaluatorResellerV1: (paramsId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'paramsId' is not null or undefined
            if (paramsId === null || paramsId === undefined) {
                throw new base_1.RequiredError('paramsId', 'Required parameter paramsId was null or undefined when calling deleteEvaluatorResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/evaluators/{params_id}`
                .replace(`{${"params_id"}}`, encodeURIComponent(String(paramsId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a goals collection
         * @summary Delete Goals
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoalsResellerV1: (goalsId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'goalsId' is not null or undefined
            if (goalsId === null || goalsId === undefined) {
                throw new base_1.RequiredError('goalsId', 'Required parameter goalsId was null or undefined when calling deleteGoalsResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/goals/{goals_id}`
                .replace(`{${"goals_id"}}`, encodeURIComponent(String(goalsId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonaResellerV1: (personaId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'personaId' is not null or undefined
            if (personaId === null || personaId === undefined) {
                throw new base_1.RequiredError('personaId', 'Required parameter personaId was null or undefined when calling deletePersonaResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioResellerV1: (scenarioId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'scenarioId' is not null or undefined
            if (scenarioId === null || scenarioId === undefined) {
                throw new base_1.RequiredError('scenarioId', 'Required parameter scenarioId was null or undefined when calling deleteScenarioResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a tracker
         * @summary Delete Tracker
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackerResellerV1: (trackerId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'trackerId' is not null or undefined
            if (trackerId === null || trackerId === undefined) {
                throw new base_1.RequiredError('trackerId', 'Required parameter trackerId was null or undefined when calling deleteTrackerResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/trackers/{tracker_id}`
                .replace(`{${"tracker_id"}}`, encodeURIComponent(String(trackerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Generate evaluator data from files and/or existing core components
         * @summary Generate Evaluator
         * @param {FlexibleGenerationRequest} flexibleGenerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEvaluatorResellerV1: (flexibleGenerationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'flexibleGenerationRequest' is not null or undefined
            if (flexibleGenerationRequest === null || flexibleGenerationRequest === undefined) {
                throw new base_1.RequiredError('flexibleGenerationRequest', 'Required parameter flexibleGenerationRequest was null or undefined when calling generateEvaluatorResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/evaluators/generate`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof flexibleGenerationRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(flexibleGenerationRequest !== undefined ? flexibleGenerationRequest : {}) : (flexibleGenerationRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseResellerV1: (courseId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new base_1.RequiredError('courseId', 'Required parameter courseId was null or undefined when calling getCourseResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
         * @summary Get Evaluator By Id
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluatorResellerV1: (paramsId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'paramsId' is not null or undefined
            if (paramsId === null || paramsId === undefined) {
                throw new base_1.RequiredError('paramsId', 'Required parameter paramsId was null or undefined when calling getEvaluatorResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/evaluators/{params_id}`
                .replace(`{${"params_id"}}`, encodeURIComponent(String(paramsId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
         * @summary Get Goals By Id
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalsResellerV1: (goalsId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'goalsId' is not null or undefined
            if (goalsId === null || goalsId === undefined) {
                throw new base_1.RequiredError('goalsId', 'Required parameter goalsId was null or undefined when calling getGoalsResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/goals/{goals_id}`
                .replace(`{${"goals_id"}}`, encodeURIComponent(String(goalsId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific persona by ID that is either directly owned or available through reseller course assignments
         * @summary Get Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaResellerV1: (personaId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'personaId' is not null or undefined
            if (personaId === null || personaId === undefined) {
                throw new base_1.RequiredError('personaId', 'Required parameter personaId was null or undefined when calling getPersonaResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
         * @summary Get Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioResellerV1: (scenarioId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'scenarioId' is not null or undefined
            if (scenarioId === null || scenarioId === undefined) {
                throw new base_1.RequiredError('scenarioId', 'Required parameter scenarioId was null or undefined when calling getScenarioResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
         * @summary Get Tracker By Id
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackerResellerV1: (trackerId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'trackerId' is not null or undefined
            if (trackerId === null || trackerId === undefined) {
                throw new base_1.RequiredError('trackerId', 'Required parameter trackerId was null or undefined when calling getTrackerResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/trackers/{tracker_id}`
                .replace(`{${"tracker_id"}}`, encodeURIComponent(String(trackerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLinkedinPersonaResellerV1: (linkedinUrl, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'linkedinUrl' is not null or undefined
            if (linkedinUrl === null || linkedinUrl === undefined) {
                throw new base_1.RequiredError('linkedinUrl', 'Required parameter linkedinUrl was null or undefined when calling importLinkedinPersonaResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/personas/import-linkedin`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (linkedinUrl !== undefined) {
                localVarQueryParameter['linkedin_url'] = linkedinUrl;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoursesResellerV1: (skip, limit, status, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/sparr/courses/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all evaluator that are either directly owned or available through reseller course assignments
         * @summary Get Evaluator
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvaluatorResellerV1: (skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/sparr/evaluators/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all goals that are either directly owned or available through reseller course assignments
         * @summary Get Goals
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGoalsResellerV1: (skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/sparr/goals/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all personas that are either directly owned or available through reseller course assignments
         * @summary Get Personas
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter personas by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonasResellerV1: (skip, limit, tags, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/sparr/personas/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all scenarios that are either directly owned or available through reseller course assignments
         * @summary Get Scenarios
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter scenarios by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenariosResellerV1: (skip, limit, tags, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/sparr/scenarios/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all trackers that are either directly owned or available through reseller course assignments
         * @summary Get Trackers
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrackerResellerV1: (skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/sparr/trackers/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search goals by name and description
         * @summary Search Goals
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGoalsResellerV1: (query, page, size, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new base_1.RequiredError('query', 'Required parameter query was null or undefined when calling searchGoalsResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/goals/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonasResellerV1: (query, page, size, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new base_1.RequiredError('query', 'Required parameter query was null or undefined when calling searchPersonasResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/personas/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenariosResellerV1: (query, page, size, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new base_1.RequiredError('query', 'Required parameter query was null or undefined when calling searchScenariosResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/scenarios/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search trackers by name and description
         * @summary Search Tracker
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTrackerResellerV1: (query, page, size, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new base_1.RequiredError('query', 'Required parameter query was null or undefined when calling searchTrackerResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/trackers/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId
         * @param {CourseUpdateRequest} courseUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseResellerV1: (courseId, courseUpdateRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new base_1.RequiredError('courseId', 'Required parameter courseId was null or undefined when calling updateCourseResellerV1.');
            }
            // verify required parameter 'courseUpdateRequest' is not null or undefined
            if (courseUpdateRequest === null || courseUpdateRequest === undefined) {
                throw new base_1.RequiredError('courseUpdateRequest', 'Required parameter courseUpdateRequest was null or undefined when calling updateCourseResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof courseUpdateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(courseUpdateRequest !== undefined ? courseUpdateRequest : {}) : (courseUpdateRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update evaluator
         * @summary Update Evaluator
         * @param {string} paramsId
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvaluatorResellerV1: (paramsId, evaluatorCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'paramsId' is not null or undefined
            if (paramsId === null || paramsId === undefined) {
                throw new base_1.RequiredError('paramsId', 'Required parameter paramsId was null or undefined when calling updateEvaluatorResellerV1.');
            }
            // verify required parameter 'evaluatorCore' is not null or undefined
            if (evaluatorCore === null || evaluatorCore === undefined) {
                throw new base_1.RequiredError('evaluatorCore', 'Required parameter evaluatorCore was null or undefined when calling updateEvaluatorResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/evaluators/{params_id}`
                .replace(`{${"params_id"}}`, encodeURIComponent(String(paramsId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof evaluatorCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(evaluatorCore !== undefined ? evaluatorCore : {}) : (evaluatorCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a goals collection
         * @summary Update Goals
         * @param {string} goalsId
         * @param {GoalCore} goalCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalsResellerV1: (goalsId, goalCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'goalsId' is not null or undefined
            if (goalsId === null || goalsId === undefined) {
                throw new base_1.RequiredError('goalsId', 'Required parameter goalsId was null or undefined when calling updateGoalsResellerV1.');
            }
            // verify required parameter 'goalCore' is not null or undefined
            if (goalCore === null || goalCore === undefined) {
                throw new base_1.RequiredError('goalCore', 'Required parameter goalCore was null or undefined when calling updateGoalsResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/goals/{goals_id}`
                .replace(`{${"goals_id"}}`, encodeURIComponent(String(goalsId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof goalCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(goalCore !== undefined ? goalCore : {}) : (goalCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonaResellerV1: (personaId, personaCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'personaId' is not null or undefined
            if (personaId === null || personaId === undefined) {
                throw new base_1.RequiredError('personaId', 'Required parameter personaId was null or undefined when calling updatePersonaResellerV1.');
            }
            // verify required parameter 'personaCore' is not null or undefined
            if (personaCore === null || personaCore === undefined) {
                throw new base_1.RequiredError('personaCore', 'Required parameter personaCore was null or undefined when calling updatePersonaResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof personaCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(personaCore !== undefined ? personaCore : {}) : (personaCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId
         * @param {ScenarioCore} scenarioCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenarioResellerV1: (scenarioId, scenarioCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'scenarioId' is not null or undefined
            if (scenarioId === null || scenarioId === undefined) {
                throw new base_1.RequiredError('scenarioId', 'Required parameter scenarioId was null or undefined when calling updateScenarioResellerV1.');
            }
            // verify required parameter 'scenarioCore' is not null or undefined
            if (scenarioCore === null || scenarioCore === undefined) {
                throw new base_1.RequiredError('scenarioCore', 'Required parameter scenarioCore was null or undefined when calling updateScenarioResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof scenarioCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(scenarioCore !== undefined ? scenarioCore : {}) : (scenarioCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a tracker
         * @summary Update Tracker
         * @param {string} trackerId
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackerResellerV1: (trackerId, trackerCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'trackerId' is not null or undefined
            if (trackerId === null || trackerId === undefined) {
                throw new base_1.RequiredError('trackerId', 'Required parameter trackerId was null or undefined when calling updateTrackerResellerV1.');
            }
            // verify required parameter 'trackerCore' is not null or undefined
            if (trackerCore === null || trackerCore === undefined) {
                throw new base_1.RequiredError('trackerCore', 'Required parameter trackerCore was null or undefined when calling updateTrackerResellerV1.');
            }
            const localVarPath = `/v1/resellers/sparr/trackers/{tracker_id}`
                .replace(`{${"tracker_id"}}`, encodeURIComponent(String(trackerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof trackerCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(trackerCore !== undefined ? trackerCore : {}) : (trackerCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * SparrResellerApi - functional programming interface
 * @export
 */
exports.SparrResellerApiFp = function (configuration) {
    return {
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseResellerV1(courseRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).createCourseResellerV1(courseRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new evaluator
         * @summary Create Evaluator
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvaluatorResellerV1(evaluatorCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).createEvaluatorResellerV1(evaluatorCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new goals collection
         * @summary Create Goals
         * @param {GoalCore} goalCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoalsResellerV1(goalCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).createGoalsResellerV1(goalCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonaResellerV1(personaCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).createPersonaResellerV1(personaCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {ScenarioCore} scenarioCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenarioResellerV1(scenarioCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).createScenarioResellerV1(scenarioCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new tracker
         * @summary Create Tracker
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackerResellerV1(trackerCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).createTrackerResellerV1(trackerCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseResellerV1(courseId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).deleteCourseResellerV1(courseId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete evaluator
         * @summary Delete Evaluator
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvaluatorResellerV1(paramsId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).deleteEvaluatorResellerV1(paramsId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a goals collection
         * @summary Delete Goals
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoalsResellerV1(goalsId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).deleteGoalsResellerV1(goalsId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonaResellerV1(personaId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).deletePersonaResellerV1(personaId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioResellerV1(scenarioId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).deleteScenarioResellerV1(scenarioId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a tracker
         * @summary Delete Tracker
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackerResellerV1(trackerId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).deleteTrackerResellerV1(trackerId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Generate evaluator data from files and/or existing core components
         * @summary Generate Evaluator
         * @param {FlexibleGenerationRequest} flexibleGenerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEvaluatorResellerV1(flexibleGenerationRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).generateEvaluatorResellerV1(flexibleGenerationRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseResellerV1(courseId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).getCourseResellerV1(courseId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
         * @summary Get Evaluator By Id
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluatorResellerV1(paramsId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).getEvaluatorResellerV1(paramsId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
         * @summary Get Goals By Id
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalsResellerV1(goalsId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).getGoalsResellerV1(goalsId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a specific persona by ID that is either directly owned or available through reseller course assignments
         * @summary Get Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaResellerV1(personaId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).getPersonaResellerV1(personaId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
         * @summary Get Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioResellerV1(scenarioId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).getScenarioResellerV1(scenarioId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
         * @summary Get Tracker By Id
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackerResellerV1(trackerId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).getTrackerResellerV1(trackerId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLinkedinPersonaResellerV1(linkedinUrl, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).importLinkedinPersonaResellerV1(linkedinUrl, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoursesResellerV1(skip, limit, status, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).listCoursesResellerV1(skip, limit, status, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get all evaluator that are either directly owned or available through reseller course assignments
         * @summary Get Evaluator
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvaluatorResellerV1(skip, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).listEvaluatorResellerV1(skip, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get all goals that are either directly owned or available through reseller course assignments
         * @summary Get Goals
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGoalsResellerV1(skip, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).listGoalsResellerV1(skip, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get all personas that are either directly owned or available through reseller course assignments
         * @summary Get Personas
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter personas by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonasResellerV1(skip, limit, tags, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).listPersonasResellerV1(skip, limit, tags, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get all scenarios that are either directly owned or available through reseller course assignments
         * @summary Get Scenarios
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter scenarios by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenariosResellerV1(skip, limit, tags, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).listScenariosResellerV1(skip, limit, tags, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get all trackers that are either directly owned or available through reseller course assignments
         * @summary Get Trackers
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrackerResellerV1(skip, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).listTrackerResellerV1(skip, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Search goals by name and description
         * @summary Search Goals
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGoalsResellerV1(query, page, size, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).searchGoalsResellerV1(query, page, size, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonasResellerV1(query, page, size, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).searchPersonasResellerV1(query, page, size, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenariosResellerV1(query, page, size, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).searchScenariosResellerV1(query, page, size, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Search trackers by name and description
         * @summary Search Tracker
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTrackerResellerV1(query, page, size, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).searchTrackerResellerV1(query, page, size, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId
         * @param {CourseUpdateRequest} courseUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseResellerV1(courseId, courseUpdateRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).updateCourseResellerV1(courseId, courseUpdateRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update evaluator
         * @summary Update Evaluator
         * @param {string} paramsId
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvaluatorResellerV1(paramsId, evaluatorCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).updateEvaluatorResellerV1(paramsId, evaluatorCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a goals collection
         * @summary Update Goals
         * @param {string} goalsId
         * @param {GoalCore} goalCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalsResellerV1(goalsId, goalCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).updateGoalsResellerV1(goalsId, goalCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonaResellerV1(personaId, personaCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).updatePersonaResellerV1(personaId, personaCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId
         * @param {ScenarioCore} scenarioCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenarioResellerV1(scenarioId, scenarioCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).updateScenarioResellerV1(scenarioId, scenarioCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a tracker
         * @summary Update Tracker
         * @param {string} trackerId
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackerResellerV1(trackerId, trackerCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparrResellerApiAxiosParamCreator(configuration).updateTrackerResellerV1(trackerId, trackerCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * SparrResellerApi - factory interface
 * @export
 */
exports.SparrResellerApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseResellerV1(courseRequest, options) {
            return exports.SparrResellerApiFp(configuration).createCourseResellerV1(courseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new evaluator
         * @summary Create Evaluator
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvaluatorResellerV1(evaluatorCore, options) {
            return exports.SparrResellerApiFp(configuration).createEvaluatorResellerV1(evaluatorCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new goals collection
         * @summary Create Goals
         * @param {GoalCore} goalCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoalsResellerV1(goalCore, options) {
            return exports.SparrResellerApiFp(configuration).createGoalsResellerV1(goalCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonaResellerV1(personaCore, options) {
            return exports.SparrResellerApiFp(configuration).createPersonaResellerV1(personaCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {ScenarioCore} scenarioCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenarioResellerV1(scenarioCore, options) {
            return exports.SparrResellerApiFp(configuration).createScenarioResellerV1(scenarioCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new tracker
         * @summary Create Tracker
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackerResellerV1(trackerCore, options) {
            return exports.SparrResellerApiFp(configuration).createTrackerResellerV1(trackerCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseResellerV1(courseId, options) {
            return exports.SparrResellerApiFp(configuration).deleteCourseResellerV1(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete evaluator
         * @summary Delete Evaluator
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvaluatorResellerV1(paramsId, options) {
            return exports.SparrResellerApiFp(configuration).deleteEvaluatorResellerV1(paramsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a goals collection
         * @summary Delete Goals
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoalsResellerV1(goalsId, options) {
            return exports.SparrResellerApiFp(configuration).deleteGoalsResellerV1(goalsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonaResellerV1(personaId, options) {
            return exports.SparrResellerApiFp(configuration).deletePersonaResellerV1(personaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioResellerV1(scenarioId, options) {
            return exports.SparrResellerApiFp(configuration).deleteScenarioResellerV1(scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a tracker
         * @summary Delete Tracker
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackerResellerV1(trackerId, options) {
            return exports.SparrResellerApiFp(configuration).deleteTrackerResellerV1(trackerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate evaluator data from files and/or existing core components
         * @summary Generate Evaluator
         * @param {FlexibleGenerationRequest} flexibleGenerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEvaluatorResellerV1(flexibleGenerationRequest, options) {
            return exports.SparrResellerApiFp(configuration).generateEvaluatorResellerV1(flexibleGenerationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseResellerV1(courseId, options) {
            return exports.SparrResellerApiFp(configuration).getCourseResellerV1(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
         * @summary Get Evaluator By Id
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluatorResellerV1(paramsId, options) {
            return exports.SparrResellerApiFp(configuration).getEvaluatorResellerV1(paramsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
         * @summary Get Goals By Id
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalsResellerV1(goalsId, options) {
            return exports.SparrResellerApiFp(configuration).getGoalsResellerV1(goalsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific persona by ID that is either directly owned or available through reseller course assignments
         * @summary Get Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaResellerV1(personaId, options) {
            return exports.SparrResellerApiFp(configuration).getPersonaResellerV1(personaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
         * @summary Get Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioResellerV1(scenarioId, options) {
            return exports.SparrResellerApiFp(configuration).getScenarioResellerV1(scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
         * @summary Get Tracker By Id
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackerResellerV1(trackerId, options) {
            return exports.SparrResellerApiFp(configuration).getTrackerResellerV1(trackerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLinkedinPersonaResellerV1(linkedinUrl, options) {
            return exports.SparrResellerApiFp(configuration).importLinkedinPersonaResellerV1(linkedinUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoursesResellerV1(skip, limit, status, options) {
            return exports.SparrResellerApiFp(configuration).listCoursesResellerV1(skip, limit, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all evaluator that are either directly owned or available through reseller course assignments
         * @summary Get Evaluator
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvaluatorResellerV1(skip, limit, options) {
            return exports.SparrResellerApiFp(configuration).listEvaluatorResellerV1(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all goals that are either directly owned or available through reseller course assignments
         * @summary Get Goals
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGoalsResellerV1(skip, limit, options) {
            return exports.SparrResellerApiFp(configuration).listGoalsResellerV1(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all personas that are either directly owned or available through reseller course assignments
         * @summary Get Personas
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter personas by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonasResellerV1(skip, limit, tags, options) {
            return exports.SparrResellerApiFp(configuration).listPersonasResellerV1(skip, limit, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all scenarios that are either directly owned or available through reseller course assignments
         * @summary Get Scenarios
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter scenarios by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenariosResellerV1(skip, limit, tags, options) {
            return exports.SparrResellerApiFp(configuration).listScenariosResellerV1(skip, limit, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all trackers that are either directly owned or available through reseller course assignments
         * @summary Get Trackers
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrackerResellerV1(skip, limit, options) {
            return exports.SparrResellerApiFp(configuration).listTrackerResellerV1(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Search goals by name and description
         * @summary Search Goals
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGoalsResellerV1(query, page, size, options) {
            return exports.SparrResellerApiFp(configuration).searchGoalsResellerV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonasResellerV1(query, page, size, options) {
            return exports.SparrResellerApiFp(configuration).searchPersonasResellerV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenariosResellerV1(query, page, size, options) {
            return exports.SparrResellerApiFp(configuration).searchScenariosResellerV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Search trackers by name and description
         * @summary Search Tracker
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTrackerResellerV1(query, page, size, options) {
            return exports.SparrResellerApiFp(configuration).searchTrackerResellerV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId
         * @param {CourseUpdateRequest} courseUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseResellerV1(courseId, courseUpdateRequest, options) {
            return exports.SparrResellerApiFp(configuration).updateCourseResellerV1(courseId, courseUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update evaluator
         * @summary Update Evaluator
         * @param {string} paramsId
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvaluatorResellerV1(paramsId, evaluatorCore, options) {
            return exports.SparrResellerApiFp(configuration).updateEvaluatorResellerV1(paramsId, evaluatorCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a goals collection
         * @summary Update Goals
         * @param {string} goalsId
         * @param {GoalCore} goalCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalsResellerV1(goalsId, goalCore, options) {
            return exports.SparrResellerApiFp(configuration).updateGoalsResellerV1(goalsId, goalCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonaResellerV1(personaId, personaCore, options) {
            return exports.SparrResellerApiFp(configuration).updatePersonaResellerV1(personaId, personaCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId
         * @param {ScenarioCore} scenarioCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenarioResellerV1(scenarioId, scenarioCore, options) {
            return exports.SparrResellerApiFp(configuration).updateScenarioResellerV1(scenarioId, scenarioCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a tracker
         * @summary Update Tracker
         * @param {string} trackerId
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackerResellerV1(trackerId, trackerCore, options) {
            return exports.SparrResellerApiFp(configuration).updateTrackerResellerV1(trackerId, trackerCore, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SparrResellerApi - object-oriented interface
 * @export
 * @class SparrResellerApi
 * @extends {BaseAPI}
 */
class SparrResellerApi extends base_1.BaseAPI {
    /**
     * Create a new course
     * @summary Create Course
     * @param {CourseRequest} courseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    createCourseResellerV1(courseRequest, options) {
        return exports.SparrResellerApiFp(this.configuration).createCourseResellerV1(courseRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new evaluator
     * @summary Create Evaluator
     * @param {EvaluatorCore} evaluatorCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    createEvaluatorResellerV1(evaluatorCore, options) {
        return exports.SparrResellerApiFp(this.configuration).createEvaluatorResellerV1(evaluatorCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new goals collection
     * @summary Create Goals
     * @param {GoalCore} goalCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    createGoalsResellerV1(goalCore, options) {
        return exports.SparrResellerApiFp(this.configuration).createGoalsResellerV1(goalCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new persona
     * @summary Create Persona
     * @param {PersonaCore} personaCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    createPersonaResellerV1(personaCore, options) {
        return exports.SparrResellerApiFp(this.configuration).createPersonaResellerV1(personaCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new scenario
     * @summary Create Scenario
     * @param {ScenarioCore} scenarioCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    createScenarioResellerV1(scenarioCore, options) {
        return exports.SparrResellerApiFp(this.configuration).createScenarioResellerV1(scenarioCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new tracker
     * @summary Create Tracker
     * @param {TrackerCore} trackerCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    createTrackerResellerV1(trackerCore, options) {
        return exports.SparrResellerApiFp(this.configuration).createTrackerResellerV1(trackerCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a course
     * @summary Delete Course
     * @param {string} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    deleteCourseResellerV1(courseId, options) {
        return exports.SparrResellerApiFp(this.configuration).deleteCourseResellerV1(courseId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete evaluator
     * @summary Delete Evaluator
     * @param {string} paramsId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    deleteEvaluatorResellerV1(paramsId, options) {
        return exports.SparrResellerApiFp(this.configuration).deleteEvaluatorResellerV1(paramsId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a goals collection
     * @summary Delete Goals
     * @param {string} goalsId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    deleteGoalsResellerV1(goalsId, options) {
        return exports.SparrResellerApiFp(this.configuration).deleteGoalsResellerV1(goalsId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a persona
     * @summary Delete Persona
     * @param {string} personaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    deletePersonaResellerV1(personaId, options) {
        return exports.SparrResellerApiFp(this.configuration).deletePersonaResellerV1(personaId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a scenario
     * @summary Delete Scenario
     * @param {string} scenarioId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    deleteScenarioResellerV1(scenarioId, options) {
        return exports.SparrResellerApiFp(this.configuration).deleteScenarioResellerV1(scenarioId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a tracker
     * @summary Delete Tracker
     * @param {string} trackerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    deleteTrackerResellerV1(trackerId, options) {
        return exports.SparrResellerApiFp(this.configuration).deleteTrackerResellerV1(trackerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generate evaluator data from files and/or existing core components
     * @summary Generate Evaluator
     * @param {FlexibleGenerationRequest} flexibleGenerationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    generateEvaluatorResellerV1(flexibleGenerationRequest, options) {
        return exports.SparrResellerApiFp(this.configuration).generateEvaluatorResellerV1(flexibleGenerationRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific course by ID
     * @summary Get Course
     * @param {string} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    getCourseResellerV1(courseId, options) {
        return exports.SparrResellerApiFp(this.configuration).getCourseResellerV1(courseId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
     * @summary Get Evaluator By Id
     * @param {string} paramsId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    getEvaluatorResellerV1(paramsId, options) {
        return exports.SparrResellerApiFp(this.configuration).getEvaluatorResellerV1(paramsId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
     * @summary Get Goals By Id
     * @param {string} goalsId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    getGoalsResellerV1(goalsId, options) {
        return exports.SparrResellerApiFp(this.configuration).getGoalsResellerV1(goalsId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific persona by ID that is either directly owned or available through reseller course assignments
     * @summary Get Persona
     * @param {string} personaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    getPersonaResellerV1(personaId, options) {
        return exports.SparrResellerApiFp(this.configuration).getPersonaResellerV1(personaId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
     * @summary Get Scenario
     * @param {string} scenarioId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    getScenarioResellerV1(scenarioId, options) {
        return exports.SparrResellerApiFp(this.configuration).getScenarioResellerV1(scenarioId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
     * @summary Get Tracker By Id
     * @param {string} trackerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    getTrackerResellerV1(trackerId, options) {
        return exports.SparrResellerApiFp(this.configuration).getTrackerResellerV1(trackerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Import a persona from LinkedIn URL
     * @summary Import Linkedin Persona
     * @param {string} linkedinUrl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    importLinkedinPersonaResellerV1(linkedinUrl, options) {
        return exports.SparrResellerApiFp(this.configuration).importLinkedinPersonaResellerV1(linkedinUrl, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all courses including reseller assignments
     * @summary Get Courses
     * @param {number} [skip] Skip for pagination
     * @param {number} [limit] Limit for pagination
     * @param {string} [status] Filter by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    listCoursesResellerV1(skip, limit, status, options) {
        return exports.SparrResellerApiFp(this.configuration).listCoursesResellerV1(skip, limit, status, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all evaluator that are either directly owned or available through reseller course assignments
     * @summary Get Evaluator
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    listEvaluatorResellerV1(skip, limit, options) {
        return exports.SparrResellerApiFp(this.configuration).listEvaluatorResellerV1(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all goals that are either directly owned or available through reseller course assignments
     * @summary Get Goals
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    listGoalsResellerV1(skip, limit, options) {
        return exports.SparrResellerApiFp(this.configuration).listGoalsResellerV1(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all personas that are either directly owned or available through reseller course assignments
     * @summary Get Personas
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [tags] Filter personas by tag, comma separated names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    listPersonasResellerV1(skip, limit, tags, options) {
        return exports.SparrResellerApiFp(this.configuration).listPersonasResellerV1(skip, limit, tags, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all scenarios that are either directly owned or available through reseller course assignments
     * @summary Get Scenarios
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [tags] Filter scenarios by tag, comma separated names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    listScenariosResellerV1(skip, limit, tags, options) {
        return exports.SparrResellerApiFp(this.configuration).listScenariosResellerV1(skip, limit, tags, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all trackers that are either directly owned or available through reseller course assignments
     * @summary Get Trackers
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    listTrackerResellerV1(skip, limit, options) {
        return exports.SparrResellerApiFp(this.configuration).listTrackerResellerV1(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search goals by name and description
     * @summary Search Goals
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    searchGoalsResellerV1(query, page, size, options) {
        return exports.SparrResellerApiFp(this.configuration).searchGoalsResellerV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search personas by name, title and company
     * @summary Search Personas
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    searchPersonasResellerV1(query, page, size, options) {
        return exports.SparrResellerApiFp(this.configuration).searchPersonasResellerV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search scenarios by name and description
     * @summary Search Scenarios
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    searchScenariosResellerV1(query, page, size, options) {
        return exports.SparrResellerApiFp(this.configuration).searchScenariosResellerV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search trackers by name and description
     * @summary Search Tracker
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    searchTrackerResellerV1(query, page, size, options) {
        return exports.SparrResellerApiFp(this.configuration).searchTrackerResellerV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a course
     * @summary Update Course
     * @param {string} courseId
     * @param {CourseUpdateRequest} courseUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    updateCourseResellerV1(courseId, courseUpdateRequest, options) {
        return exports.SparrResellerApiFp(this.configuration).updateCourseResellerV1(courseId, courseUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update evaluator
     * @summary Update Evaluator
     * @param {string} paramsId
     * @param {EvaluatorCore} evaluatorCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    updateEvaluatorResellerV1(paramsId, evaluatorCore, options) {
        return exports.SparrResellerApiFp(this.configuration).updateEvaluatorResellerV1(paramsId, evaluatorCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a goals collection
     * @summary Update Goals
     * @param {string} goalsId
     * @param {GoalCore} goalCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    updateGoalsResellerV1(goalsId, goalCore, options) {
        return exports.SparrResellerApiFp(this.configuration).updateGoalsResellerV1(goalsId, goalCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a persona
     * @summary Update Persona
     * @param {string} personaId
     * @param {PersonaCore} personaCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    updatePersonaResellerV1(personaId, personaCore, options) {
        return exports.SparrResellerApiFp(this.configuration).updatePersonaResellerV1(personaId, personaCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a scenario
     * @summary Update Scenario
     * @param {string} scenarioId
     * @param {ScenarioCore} scenarioCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    updateScenarioResellerV1(scenarioId, scenarioCore, options) {
        return exports.SparrResellerApiFp(this.configuration).updateScenarioResellerV1(scenarioId, scenarioCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a tracker
     * @summary Update Tracker
     * @param {string} trackerId
     * @param {TrackerCore} trackerCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    updateTrackerResellerV1(trackerId, trackerCore, options) {
        return exports.SparrResellerApiFp(this.configuration).updateTrackerResellerV1(trackerId, trackerCore, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SparrResellerApi = SparrResellerApi;
/**
 * SparringApi - axios parameter creator
 * @export
 */
exports.SparringApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a virtual prospect
         * @summary Create Virtual Prospect
         * @param {VirtualProspectInput} virtualProspectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualProspectV1SparrVirtualProspectsPost: (virtualProspectInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'virtualProspectInput' is not null or undefined
            if (virtualProspectInput === null || virtualProspectInput === undefined) {
                throw new base_1.RequiredError('virtualProspectInput', 'Required parameter virtualProspectInput was null or undefined when calling createVirtualProspectV1SparrVirtualProspectsPost.');
            }
            const localVarPath = `/v1/sparr/virtual-prospects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof virtualProspectInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(virtualProspectInput !== undefined ? virtualProspectInput : {}) : (virtualProspectInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a virtual prospect
         * @summary Delete Virtual Prospect
         * @param {string} prospectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete: (prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new base_1.RequiredError('prospectId', 'Required parameter prospectId was null or undefined when calling deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete.');
            }
            const localVarPath = `/v1/sparr/virtual-prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get sparring stats from Trata AI like call count, prospect count, etc.
         * @summary Get Sparring Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSparringStatsV1SparrSparringStatsGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/sparring-stats`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get virtual prospect associated with an agent
         * @summary Get Virtual Prospect by Agent ID
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet: (agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet.');
            }
            const localVarPath = `/v1/sparr/agent/{agent_id}/virtual-prospect`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a virtual prospect
         * @summary Get Virtual Prospect
         * @param {string} prospectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectV1SparrVirtualProspectsProspectIdGet: (prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new base_1.RequiredError('prospectId', 'Required parameter prospectId was null or undefined when calling getVirtualProspectV1SparrVirtualProspectsProspectIdGet.');
            }
            const localVarPath = `/v1/sparr/virtual-prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Link a virtual prospect to an agent
         * @summary Link Virtual Prospect to Agent
         * @param {string} prospectId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost: (prospectId, agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new base_1.RequiredError('prospectId', 'Required parameter prospectId was null or undefined when calling linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost.');
            }
            const localVarPath = `/v1/sparr/virtual-prospects/{prospect_id}/agent/{agent_id}/link`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all virtual prospects
         * @summary List Virtual Prospects
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualProspectsV1SparrVirtualProspectsGet: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/virtual-prospects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a virtual prospect
         * @summary Update Virtual Prospect
         * @param {string} prospectId
         * @param {VirtualProspectInput} virtualProspectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVirtualProspectV1SparrVirtualProspectsProspectIdPut: (prospectId, virtualProspectInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new base_1.RequiredError('prospectId', 'Required parameter prospectId was null or undefined when calling updateVirtualProspectV1SparrVirtualProspectsProspectIdPut.');
            }
            // verify required parameter 'virtualProspectInput' is not null or undefined
            if (virtualProspectInput === null || virtualProspectInput === undefined) {
                throw new base_1.RequiredError('virtualProspectInput', 'Required parameter virtualProspectInput was null or undefined when calling updateVirtualProspectV1SparrVirtualProspectsProspectIdPut.');
            }
            const localVarPath = `/v1/sparr/virtual-prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof virtualProspectInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(virtualProspectInput !== undefined ? virtualProspectInput : {}) : (virtualProspectInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * SparringApi - functional programming interface
 * @export
 */
exports.SparringApiFp = function (configuration) {
    return {
        /**
         * Create a virtual prospect
         * @summary Create Virtual Prospect
         * @param {VirtualProspectInput} virtualProspectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparringApiAxiosParamCreator(configuration).createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a virtual prospect
         * @summary Delete Virtual Prospect
         * @param {string} prospectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparringApiAxiosParamCreator(configuration).deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get sparring stats from Trata AI like call count, prospect count, etc.
         * @summary Get Sparring Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSparringStatsV1SparrSparringStatsGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparringApiAxiosParamCreator(configuration).getSparringStatsV1SparrSparringStatsGet(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get virtual prospect associated with an agent
         * @summary Get Virtual Prospect by Agent ID
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparringApiAxiosParamCreator(configuration).getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a virtual prospect
         * @summary Get Virtual Prospect
         * @param {string} prospectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparringApiAxiosParamCreator(configuration).getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Link a virtual prospect to an agent
         * @summary Link Virtual Prospect to Agent
         * @param {string} prospectId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparringApiAxiosParamCreator(configuration).linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List all virtual prospects
         * @summary List Virtual Prospects
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparringApiAxiosParamCreator(configuration).listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a virtual prospect
         * @summary Update Virtual Prospect
         * @param {string} prospectId
         * @param {VirtualProspectInput} virtualProspectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SparringApiAxiosParamCreator(configuration).updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * SparringApi - factory interface
 * @export
 */
exports.SparringApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Create a virtual prospect
         * @summary Create Virtual Prospect
         * @param {VirtualProspectInput} virtualProspectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options) {
            return exports.SparringApiFp(configuration).createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a virtual prospect
         * @summary Delete Virtual Prospect
         * @param {string} prospectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options) {
            return exports.SparringApiFp(configuration).deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get sparring stats from Trata AI like call count, prospect count, etc.
         * @summary Get Sparring Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSparringStatsV1SparrSparringStatsGet(options) {
            return exports.SparringApiFp(configuration).getSparringStatsV1SparrSparringStatsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get virtual prospect associated with an agent
         * @summary Get Virtual Prospect by Agent ID
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options) {
            return exports.SparringApiFp(configuration).getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a virtual prospect
         * @summary Get Virtual Prospect
         * @param {string} prospectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options) {
            return exports.SparringApiFp(configuration).getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Link a virtual prospect to an agent
         * @summary Link Virtual Prospect to Agent
         * @param {string} prospectId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options) {
            return exports.SparringApiFp(configuration).linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all virtual prospects
         * @summary List Virtual Prospects
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return exports.SparringApiFp(configuration).listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a virtual prospect
         * @summary Update Virtual Prospect
         * @param {string} prospectId
         * @param {VirtualProspectInput} virtualProspectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options) {
            return exports.SparringApiFp(configuration).updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SparringApi - object-oriented interface
 * @export
 * @class SparringApi
 * @extends {BaseAPI}
 */
class SparringApi extends base_1.BaseAPI {
    /**
     * Create a virtual prospect
     * @summary Create Virtual Prospect
     * @param {VirtualProspectInput} virtualProspectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options) {
        return exports.SparringApiFp(this.configuration).createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a virtual prospect
     * @summary Delete Virtual Prospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options) {
        return exports.SparringApiFp(this.configuration).deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get sparring stats from Trata AI like call count, prospect count, etc.
     * @summary Get Sparring Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    getSparringStatsV1SparrSparringStatsGet(options) {
        return exports.SparringApiFp(this.configuration).getSparringStatsV1SparrSparringStatsGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get virtual prospect associated with an agent
     * @summary Get Virtual Prospect by Agent ID
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options) {
        return exports.SparringApiFp(this.configuration).getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a virtual prospect
     * @summary Get Virtual Prospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options) {
        return exports.SparringApiFp(this.configuration).getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Link a virtual prospect to an agent
     * @summary Link Virtual Prospect to Agent
     * @param {string} prospectId
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options) {
        return exports.SparringApiFp(this.configuration).linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all virtual prospects
     * @summary List Virtual Prospects
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [updatedAfter]
     * @param {string} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.SparringApiFp(this.configuration).listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a virtual prospect
     * @summary Update Virtual Prospect
     * @param {string} prospectId
     * @param {VirtualProspectInput} virtualProspectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options) {
        return exports.SparringApiFp(this.configuration).updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SparringApi = SparringApi;
/**
 * TelephonyApi - axios parameter creator
 * @export
 */
exports.TelephonyApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get Agent Phones
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentPhonesV1: (agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling getAgentPhonesV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}/phones`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Link Phone To Agent
         * @param {string} phoneId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPhoneToAgentV1: (phoneId, agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'phoneId' is not null or undefined
            if (phoneId === null || phoneId === undefined) {
                throw new base_1.RequiredError('phoneId', 'Required parameter phoneId was null or undefined when calling linkPhoneToAgentV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling linkPhoneToAgentV1.');
            }
            const localVarPath = `/v1/telephony/phones/{phone_id}/ai-agents/{agent_id}/link`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Available Phones
         * @param {string} countryCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailablePhonesV1: (countryCode, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'countryCode' is not null or undefined
            if (countryCode === null || countryCode === undefined) {
                throw new base_1.RequiredError('countryCode', 'Required parameter countryCode was null or undefined when calling listAvailablePhonesV1.');
            }
            const localVarPath = `/v1/telephony/countries/{country_code}/available-phones`
                .replace(`{${"country_code"}}`, encodeURIComponent(String(countryCode)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Purchased Phones
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPurchasedPhonesV1: (countryCode, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/telephony/phones`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedCountriesV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/telephony/countries`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePhoneV1: (numberPurchaseRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'numberPurchaseRequest' is not null or undefined
            if (numberPurchaseRequest === null || numberPurchaseRequest === undefined) {
                throw new base_1.RequiredError('numberPurchaseRequest', 'Required parameter numberPurchaseRequest was null or undefined when calling purchasePhoneV1.');
            }
            const localVarPath = `/v1/telephony/phones`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof numberPurchaseRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(numberPurchaseRequest !== undefined ? numberPurchaseRequest : {}) : (numberPurchaseRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Release Phone
         * @param {string} phoneId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePhoneV1: (phoneId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'phoneId' is not null or undefined
            if (phoneId === null || phoneId === undefined) {
                throw new base_1.RequiredError('phoneId', 'Required parameter phoneId was null or undefined when calling releasePhoneV1.');
            }
            const localVarPath = `/v1/telephony/phones/{phone_id}`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Unlink Phone From Agent
         * @param {string} phoneId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPhoneFromAgentV1: (phoneId, agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'phoneId' is not null or undefined
            if (phoneId === null || phoneId === undefined) {
                throw new base_1.RequiredError('phoneId', 'Required parameter phoneId was null or undefined when calling unlinkPhoneFromAgentV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling unlinkPhoneFromAgentV1.');
            }
            const localVarPath = `/v1/telephony/phones/{phone_id}/ai-agents/{agent_id}/link`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TelephonyApi - functional programming interface
 * @export
 */
exports.TelephonyApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get Agent Phones
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentPhonesV1(agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TelephonyApiAxiosParamCreator(configuration).getAgentPhonesV1(agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Link Phone To Agent
         * @param {string} phoneId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPhoneToAgentV1(phoneId, agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TelephonyApiAxiosParamCreator(configuration).linkPhoneToAgentV1(phoneId, agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary List Available Phones
         * @param {string} countryCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailablePhonesV1(countryCode, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TelephonyApiAxiosParamCreator(configuration).listAvailablePhonesV1(countryCode, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary List Purchased Phones
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPurchasedPhonesV1(countryCode, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TelephonyApiAxiosParamCreator(configuration).listPurchasedPhonesV1(countryCode, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedCountriesV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TelephonyApiAxiosParamCreator(configuration).listSupportedCountriesV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePhoneV1(numberPurchaseRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TelephonyApiAxiosParamCreator(configuration).purchasePhoneV1(numberPurchaseRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Release Phone
         * @param {string} phoneId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePhoneV1(phoneId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TelephonyApiAxiosParamCreator(configuration).releasePhoneV1(phoneId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Unlink Phone From Agent
         * @param {string} phoneId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPhoneFromAgentV1(phoneId, agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TelephonyApiAxiosParamCreator(configuration).unlinkPhoneFromAgentV1(phoneId, agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * TelephonyApi - factory interface
 * @export
 */
exports.TelephonyApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Get Agent Phones
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentPhonesV1(agentId, options) {
            return exports.TelephonyApiFp(configuration).getAgentPhonesV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Link Phone To Agent
         * @param {string} phoneId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPhoneToAgentV1(phoneId, agentId, options) {
            return exports.TelephonyApiFp(configuration).linkPhoneToAgentV1(phoneId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Available Phones
         * @param {string} countryCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailablePhonesV1(countryCode, options) {
            return exports.TelephonyApiFp(configuration).listAvailablePhonesV1(countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Purchased Phones
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPurchasedPhonesV1(countryCode, options) {
            return exports.TelephonyApiFp(configuration).listPurchasedPhonesV1(countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedCountriesV1(options) {
            return exports.TelephonyApiFp(configuration).listSupportedCountriesV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePhoneV1(numberPurchaseRequest, options) {
            return exports.TelephonyApiFp(configuration).purchasePhoneV1(numberPurchaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Release Phone
         * @param {string} phoneId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePhoneV1(phoneId, options) {
            return exports.TelephonyApiFp(configuration).releasePhoneV1(phoneId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Unlink Phone From Agent
         * @param {string} phoneId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPhoneFromAgentV1(phoneId, agentId, options) {
            return exports.TelephonyApiFp(configuration).unlinkPhoneFromAgentV1(phoneId, agentId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TelephonyApi - object-oriented interface
 * @export
 * @class TelephonyApi
 * @extends {BaseAPI}
 */
class TelephonyApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get Agent Phones
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    getAgentPhonesV1(agentId, options) {
        return exports.TelephonyApiFp(this.configuration).getAgentPhonesV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Link Phone To Agent
     * @param {string} phoneId
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    linkPhoneToAgentV1(phoneId, agentId, options) {
        return exports.TelephonyApiFp(this.configuration).linkPhoneToAgentV1(phoneId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Available Phones
     * @param {string} countryCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    listAvailablePhonesV1(countryCode, options) {
        return exports.TelephonyApiFp(this.configuration).listAvailablePhonesV1(countryCode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Purchased Phones
     * @param {string} [countryCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    listPurchasedPhonesV1(countryCode, options) {
        return exports.TelephonyApiFp(this.configuration).listPurchasedPhonesV1(countryCode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Supported Countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    listSupportedCountriesV1(options) {
        return exports.TelephonyApiFp(this.configuration).listSupportedCountriesV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Purchase Phone
     * @param {NumberPurchaseRequest} numberPurchaseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    purchasePhoneV1(numberPurchaseRequest, options) {
        return exports.TelephonyApiFp(this.configuration).purchasePhoneV1(numberPurchaseRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Release Phone
     * @param {string} phoneId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    releasePhoneV1(phoneId, options) {
        return exports.TelephonyApiFp(this.configuration).releasePhoneV1(phoneId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Unlink Phone From Agent
     * @param {string} phoneId
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    unlinkPhoneFromAgentV1(phoneId, agentId, options) {
        return exports.TelephonyApiFp(this.configuration).unlinkPhoneFromAgentV1(phoneId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TelephonyApi = TelephonyApi;
/**
 * UIApi - axios parameter creator
 * @export
 */
exports.UIApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary List Action Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionTemplatesV1: (language, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/ui/action-templates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Products
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {string} [tags]
         * @param {string} [productIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsDetailedV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/ui/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }
            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }
            if (productIds !== undefined) {
                localVarQueryParameter['product_ids'] = productIds;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Prompt Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptTemplatesV1: (language, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/ui/prompt-templates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Role Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleTemplatesV1: (language, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/ui/role-templates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * UIApi - functional programming interface
 * @export
 */
exports.UIApiFp = function (configuration) {
    return {
        /**
         *
         * @summary List Action Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionTemplatesV1(language, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UIApiAxiosParamCreator(configuration).listActionTemplatesV1(language, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary List Products
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {string} [tags]
         * @param {string} [productIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UIApiAxiosParamCreator(configuration).listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary List Prompt Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptTemplatesV1(language, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UIApiAxiosParamCreator(configuration).listPromptTemplatesV1(language, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary List Role Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleTemplatesV1(language, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UIApiAxiosParamCreator(configuration).listRoleTemplatesV1(language, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * UIApi - factory interface
 * @export
 */
exports.UIApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary List Action Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionTemplatesV1(language, options) {
            return exports.UIApiFp(configuration).listActionTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Products
         * @param {string} [searchBy]
         * @param {string} [searchValue]
         * @param {string} [status]
         * @param {string} [sortBy]
         * @param {SortOrder} [sortOrder]
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {string} [tags]
         * @param {string} [productIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options) {
            return exports.UIApiFp(configuration).listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Prompt Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptTemplatesV1(language, options) {
            return exports.UIApiFp(configuration).listPromptTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Role Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleTemplatesV1(language, options) {
            return exports.UIApiFp(configuration).listRoleTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UIApi - object-oriented interface
 * @export
 * @class UIApi
 * @extends {BaseAPI}
 */
class UIApi extends base_1.BaseAPI {
    /**
     *
     * @summary List Action Templates
     * @param {string} [language]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    listActionTemplatesV1(language, options) {
        return exports.UIApiFp(this.configuration).listActionTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Products
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [updatedAfter]
     * @param {string} [updatedBefore]
     * @param {string} [tags]
     * @param {string} [productIds]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options) {
        return exports.UIApiFp(this.configuration).listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Prompt Templates
     * @param {string} [language]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    listPromptTemplatesV1(language, options) {
        return exports.UIApiFp(this.configuration).listPromptTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Role Templates
     * @param {string} [language]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    listRoleTemplatesV1(language, options) {
        return exports.UIApiFp(this.configuration).listRoleTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UIApi = UIApi;
/**
 * VoiceModelsApi - axios parameter creator
 * @export
 */
exports.VoiceModelsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get List Of Voices Available For Sparr
         * @summary Get List Of Voices Available For Sparr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSparrVoiceModelsV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr-voice-models`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get List Of Voices Available For Conversations
         * @summary Get List Of Voices Available For Conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceModelsV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/voice-models`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * VoiceModelsApi - functional programming interface
 * @export
 */
exports.VoiceModelsApiFp = function (configuration) {
    return {
        /**
         * Get List Of Voices Available For Sparr
         * @summary Get List Of Voices Available For Sparr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSparrVoiceModelsV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.VoiceModelsApiAxiosParamCreator(configuration).listSparrVoiceModelsV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get List Of Voices Available For Conversations
         * @summary Get List Of Voices Available For Conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceModelsV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.VoiceModelsApiAxiosParamCreator(configuration).listVoiceModelsV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * VoiceModelsApi - factory interface
 * @export
 */
exports.VoiceModelsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Get List Of Voices Available For Sparr
         * @summary Get List Of Voices Available For Sparr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSparrVoiceModelsV1(options) {
            return exports.VoiceModelsApiFp(configuration).listSparrVoiceModelsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get List Of Voices Available For Conversations
         * @summary Get List Of Voices Available For Conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceModelsV1(options) {
            return exports.VoiceModelsApiFp(configuration).listVoiceModelsV1(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * VoiceModelsApi - object-oriented interface
 * @export
 * @class VoiceModelsApi
 * @extends {BaseAPI}
 */
class VoiceModelsApi extends base_1.BaseAPI {
    /**
     * Get List Of Voices Available For Sparr
     * @summary Get List Of Voices Available For Sparr
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceModelsApi
     */
    listSparrVoiceModelsV1(options) {
        return exports.VoiceModelsApiFp(this.configuration).listSparrVoiceModelsV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get List Of Voices Available For Conversations
     * @summary Get List Of Voices Available For Conversations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceModelsApi
     */
    listVoiceModelsV1(options) {
        return exports.VoiceModelsApiFp(this.configuration).listVoiceModelsV1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.VoiceModelsApi = VoiceModelsApi;
/**
 * WorkflowsApi - axios parameter creator
 * @export
 */
exports.WorkflowsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create Workflow
         * @param {WorkflowCore} workflowCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowV1WorkflowsPost: (workflowCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowCore' is not null or undefined
            if (workflowCore === null || workflowCore === undefined) {
                throw new base_1.RequiredError('workflowCore', 'Required parameter workflowCore was null or undefined when calling createWorkflowV1WorkflowsPost.');
            }
            const localVarPath = `/v1/workflows/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof workflowCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(workflowCore !== undefined ? workflowCore : {}) : (workflowCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete Workflow
         * @param {string} workflowId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowV1WorkflowsWorkflowIdDelete: (workflowId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new base_1.RequiredError('workflowId', 'Required parameter workflowId was null or undefined when calling deleteWorkflowV1WorkflowsWorkflowIdDelete.');
            }
            const localVarPath = `/v1/workflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Read Workflow
         * @param {string} workflowId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowV1WorkflowsWorkflowIdGet: (workflowId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new base_1.RequiredError('workflowId', 'Required parameter workflowId was null or undefined when calling readWorkflowV1WorkflowsWorkflowIdGet.');
            }
            const localVarPath = `/v1/workflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Read Workflows
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {AgenticWorkflowAdkModelsWorkflowAppEnum} [app]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowsV1WorkflowsGet: (skip, limit, app, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/workflows/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Trigger Workflow Step
         * @param {string} workflowId
         * @param {string} stepId
         * @param {WorkflowStepTriggerRequest} workflowStepTriggerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost: (workflowId, stepId, workflowStepTriggerRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new base_1.RequiredError('workflowId', 'Required parameter workflowId was null or undefined when calling triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost.');
            }
            // verify required parameter 'stepId' is not null or undefined
            if (stepId === null || stepId === undefined) {
                throw new base_1.RequiredError('stepId', 'Required parameter stepId was null or undefined when calling triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost.');
            }
            // verify required parameter 'workflowStepTriggerRequest' is not null or undefined
            if (workflowStepTriggerRequest === null || workflowStepTriggerRequest === undefined) {
                throw new base_1.RequiredError('workflowStepTriggerRequest', 'Required parameter workflowStepTriggerRequest was null or undefined when calling triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost.');
            }
            const localVarPath = `/v1/workflows/{workflow_id}/step/{step_id}/trigger`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)))
                .replace(`{${"step_id"}}`, encodeURIComponent(String(stepId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof workflowStepTriggerRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(workflowStepTriggerRequest !== undefined ? workflowStepTriggerRequest : {}) : (workflowStepTriggerRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update Workflow
         * @param {string} workflowId
         * @param {WorkflowCore} workflowCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowV1WorkflowsWorkflowIdPut: (workflowId, workflowCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new base_1.RequiredError('workflowId', 'Required parameter workflowId was null or undefined when calling updateWorkflowV1WorkflowsWorkflowIdPut.');
            }
            // verify required parameter 'workflowCore' is not null or undefined
            if (workflowCore === null || workflowCore === undefined) {
                throw new base_1.RequiredError('workflowCore', 'Required parameter workflowCore was null or undefined when calling updateWorkflowV1WorkflowsWorkflowIdPut.');
            }
            const localVarPath = `/v1/workflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof workflowCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(workflowCore !== undefined ? workflowCore : {}) : (workflowCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Upload File
         * @param {string} workflowId
         * @param {any} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1WorkflowsWorkflowIdFilePost: (workflowId, file, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new base_1.RequiredError('workflowId', 'Required parameter workflowId was null or undefined when calling uploadFileV1WorkflowsWorkflowIdFilePost.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new base_1.RequiredError('file', 'Required parameter file was null or undefined when calling uploadFileV1WorkflowsWorkflowIdFilePost.');
            }
            const localVarPath = `/v1/workflows/{workflow_id}/file`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * WorkflowsApi - functional programming interface
 * @export
 */
exports.WorkflowsApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Create Workflow
         * @param {WorkflowCore} workflowCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowV1WorkflowsPost(workflowCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsApiAxiosParamCreator(configuration).createWorkflowV1WorkflowsPost(workflowCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Delete Workflow
         * @param {string} workflowId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsApiAxiosParamCreator(configuration).deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Read Workflow
         * @param {string} workflowId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsApiAxiosParamCreator(configuration).readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Read Workflows
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {AgenticWorkflowAdkModelsWorkflowAppEnum} [app]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowsV1WorkflowsGet(skip, limit, app, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsApiAxiosParamCreator(configuration).readWorkflowsV1WorkflowsGet(skip, limit, app, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Trigger Workflow Step
         * @param {string} workflowId
         * @param {string} stepId
         * @param {WorkflowStepTriggerRequest} workflowStepTriggerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsApiAxiosParamCreator(configuration).triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Update Workflow
         * @param {string} workflowId
         * @param {WorkflowCore} workflowCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsApiAxiosParamCreator(configuration).updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Upload File
         * @param {string} workflowId
         * @param {any} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1WorkflowsWorkflowIdFilePost(workflowId, file, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsApiAxiosParamCreator(configuration).uploadFileV1WorkflowsWorkflowIdFilePost(workflowId, file, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * WorkflowsApi - factory interface
 * @export
 */
exports.WorkflowsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Create Workflow
         * @param {WorkflowCore} workflowCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowV1WorkflowsPost(workflowCore, options) {
            return exports.WorkflowsApiFp(configuration).createWorkflowV1WorkflowsPost(workflowCore, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete Workflow
         * @param {string} workflowId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, options) {
            return exports.WorkflowsApiFp(configuration).deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Read Workflow
         * @param {string} workflowId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options) {
            return exports.WorkflowsApiFp(configuration).readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Read Workflows
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {AgenticWorkflowAdkModelsWorkflowAppEnum} [app]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowsV1WorkflowsGet(skip, limit, app, options) {
            return exports.WorkflowsApiFp(configuration).readWorkflowsV1WorkflowsGet(skip, limit, app, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Trigger Workflow Step
         * @param {string} workflowId
         * @param {string} stepId
         * @param {WorkflowStepTriggerRequest} workflowStepTriggerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options) {
            return exports.WorkflowsApiFp(configuration).triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update Workflow
         * @param {string} workflowId
         * @param {WorkflowCore} workflowCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options) {
            return exports.WorkflowsApiFp(configuration).updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Upload File
         * @param {string} workflowId
         * @param {any} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1WorkflowsWorkflowIdFilePost(workflowId, file, options) {
            return exports.WorkflowsApiFp(configuration).uploadFileV1WorkflowsWorkflowIdFilePost(workflowId, file, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * WorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsApi
 * @extends {BaseAPI}
 */
class WorkflowsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create Workflow
     * @param {WorkflowCore} workflowCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    createWorkflowV1WorkflowsPost(workflowCore, options) {
        return exports.WorkflowsApiFp(this.configuration).createWorkflowV1WorkflowsPost(workflowCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete Workflow
     * @param {string} workflowId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, options) {
        return exports.WorkflowsApiFp(this.configuration).deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Read Workflow
     * @param {string} workflowId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options) {
        return exports.WorkflowsApiFp(this.configuration).readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Read Workflows
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {AgenticWorkflowAdkModelsWorkflowAppEnum} [app]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    readWorkflowsV1WorkflowsGet(skip, limit, app, options) {
        return exports.WorkflowsApiFp(this.configuration).readWorkflowsV1WorkflowsGet(skip, limit, app, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Trigger Workflow Step
     * @param {string} workflowId
     * @param {string} stepId
     * @param {WorkflowStepTriggerRequest} workflowStepTriggerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options) {
        return exports.WorkflowsApiFp(this.configuration).triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update Workflow
     * @param {string} workflowId
     * @param {WorkflowCore} workflowCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options) {
        return exports.WorkflowsApiFp(this.configuration).updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Upload File
     * @param {string} workflowId
     * @param {any} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    uploadFileV1WorkflowsWorkflowIdFilePost(workflowId, file, options) {
        return exports.WorkflowsApiFp(this.configuration).uploadFileV1WorkflowsWorkflowIdFilePost(workflowId, file, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WorkflowsApi = WorkflowsApi;
/**
 * WorkflowsApiHubspotApi - axios parameter creator
 * @export
 */
exports.WorkflowsApiHubspotApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Handle Hubspot Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/workflows/api/hubspot/webhook`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * WorkflowsApiHubspotApi - functional programming interface
 * @export
 */
exports.WorkflowsApiHubspotApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Handle Hubspot Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsApiHubspotApiAxiosParamCreator(configuration).handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * WorkflowsApiHubspotApi - factory interface
 * @export
 */
exports.WorkflowsApiHubspotApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Handle Hubspot Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options) {
            return exports.WorkflowsApiHubspotApiFp(configuration).handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * WorkflowsApiHubspotApi - object-oriented interface
 * @export
 * @class WorkflowsApiHubspotApi
 * @extends {BaseAPI}
 */
class WorkflowsApiHubspotApi extends base_1.BaseAPI {
    /**
     *
     * @summary Handle Hubspot Webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApiHubspotApi
     */
    handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options) {
        return exports.WorkflowsApiHubspotApiFp(this.configuration).handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WorkflowsApiHubspotApi = WorkflowsApiHubspotApi;
/**
 * WorkflowsAppsApi - axios parameter creator
 * @export
 */
exports.WorkflowsAppsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create App
         * @param {AppEntity} appEntity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAppV1WorkflowsAppsPost: (appEntity, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'appEntity' is not null or undefined
            if (appEntity === null || appEntity === undefined) {
                throw new base_1.RequiredError('appEntity', 'Required parameter appEntity was null or undefined when calling createAppV1WorkflowsAppsPost.');
            }
            const localVarPath = `/v1/workflows/apps/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof appEntity !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(appEntity !== undefined ? appEntity : {}) : (appEntity || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete App
         * @param {string} appId
         * @param {string} [version]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppV1WorkflowsAppsAppIdDelete: (appId, version, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new base_1.RequiredError('appId', 'Required parameter appId was null or undefined when calling deleteAppV1WorkflowsAppsAppIdDelete.');
            }
            const localVarPath = `/v1/workflows/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Connections By App Id
         * @param {string} appId
         * @param {string} version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet: (appId, version, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new base_1.RequiredError('appId', 'Required parameter appId was null or undefined when calling getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new base_1.RequiredError('version', 'Required parameter version was null or undefined when calling getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet.');
            }
            const localVarPath = `/v1/workflows/apps/{app_id}/versions/{version}/connections`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Read App
         * @param {string} appId
         * @param {string} [version]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppV1WorkflowsAppsAppIdGet: (appId, version, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new base_1.RequiredError('appId', 'Required parameter appId was null or undefined when calling readAppV1WorkflowsAppsAppIdGet.');
            }
            const localVarPath = `/v1/workflows/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Read Apps
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppsV1WorkflowsAppsGet: (skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/workflows/apps/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update App
         * @param {string} appId
         * @param {AppEntity} appEntity
         * @param {string} [version]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppV1WorkflowsAppsAppIdPut: (appId, appEntity, version, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new base_1.RequiredError('appId', 'Required parameter appId was null or undefined when calling updateAppV1WorkflowsAppsAppIdPut.');
            }
            // verify required parameter 'appEntity' is not null or undefined
            if (appEntity === null || appEntity === undefined) {
                throw new base_1.RequiredError('appEntity', 'Required parameter appEntity was null or undefined when calling updateAppV1WorkflowsAppsAppIdPut.');
            }
            const localVarPath = `/v1/workflows/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof appEntity !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(appEntity !== undefined ? appEntity : {}) : (appEntity || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * WorkflowsAppsApi - functional programming interface
 * @export
 */
exports.WorkflowsAppsApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Create App
         * @param {AppEntity} appEntity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAppV1WorkflowsAppsPost(appEntity, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsAppsApiAxiosParamCreator(configuration).createAppV1WorkflowsAppsPost(appEntity, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Delete App
         * @param {string} appId
         * @param {string} [version]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsAppsApiAxiosParamCreator(configuration).deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Connections By App Id
         * @param {string} appId
         * @param {string} version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsAppsApiAxiosParamCreator(configuration).getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Read App
         * @param {string} appId
         * @param {string} [version]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppV1WorkflowsAppsAppIdGet(appId, version, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsAppsApiAxiosParamCreator(configuration).readAppV1WorkflowsAppsAppIdGet(appId, version, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Read Apps
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppsV1WorkflowsAppsGet(skip, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsAppsApiAxiosParamCreator(configuration).readAppsV1WorkflowsAppsGet(skip, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Update App
         * @param {string} appId
         * @param {AppEntity} appEntity
         * @param {string} [version]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsAppsApiAxiosParamCreator(configuration).updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * WorkflowsAppsApi - factory interface
 * @export
 */
exports.WorkflowsAppsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Create App
         * @param {AppEntity} appEntity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAppV1WorkflowsAppsPost(appEntity, options) {
            return exports.WorkflowsAppsApiFp(configuration).createAppV1WorkflowsAppsPost(appEntity, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete App
         * @param {string} appId
         * @param {string} [version]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options) {
            return exports.WorkflowsAppsApiFp(configuration).deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Connections By App Id
         * @param {string} appId
         * @param {string} version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options) {
            return exports.WorkflowsAppsApiFp(configuration).getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Read App
         * @param {string} appId
         * @param {string} [version]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppV1WorkflowsAppsAppIdGet(appId, version, options) {
            return exports.WorkflowsAppsApiFp(configuration).readAppV1WorkflowsAppsAppIdGet(appId, version, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Read Apps
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppsV1WorkflowsAppsGet(skip, limit, options) {
            return exports.WorkflowsAppsApiFp(configuration).readAppsV1WorkflowsAppsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update App
         * @param {string} appId
         * @param {AppEntity} appEntity
         * @param {string} [version]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options) {
            return exports.WorkflowsAppsApiFp(configuration).updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * WorkflowsAppsApi - object-oriented interface
 * @export
 * @class WorkflowsAppsApi
 * @extends {BaseAPI}
 */
class WorkflowsAppsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create App
     * @param {AppEntity} appEntity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    createAppV1WorkflowsAppsPost(appEntity, options) {
        return exports.WorkflowsAppsApiFp(this.configuration).createAppV1WorkflowsAppsPost(appEntity, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete App
     * @param {string} appId
     * @param {string} [version]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options) {
        return exports.WorkflowsAppsApiFp(this.configuration).deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Connections By App Id
     * @param {string} appId
     * @param {string} version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options) {
        return exports.WorkflowsAppsApiFp(this.configuration).getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Read App
     * @param {string} appId
     * @param {string} [version]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    readAppV1WorkflowsAppsAppIdGet(appId, version, options) {
        return exports.WorkflowsAppsApiFp(this.configuration).readAppV1WorkflowsAppsAppIdGet(appId, version, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Read Apps
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    readAppsV1WorkflowsAppsGet(skip, limit, options) {
        return exports.WorkflowsAppsApiFp(this.configuration).readAppsV1WorkflowsAppsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update App
     * @param {string} appId
     * @param {AppEntity} appEntity
     * @param {string} [version]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options) {
        return exports.WorkflowsAppsApiFp(this.configuration).updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WorkflowsAppsApi = WorkflowsAppsApi;
/**
 * WorkflowsConnectionsApi - axios parameter creator
 * @export
 */
exports.WorkflowsConnectionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create Connection
         * @param {ConnectionCore} connectionCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectionV1WorkflowsConnectionsPost: (connectionCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'connectionCore' is not null or undefined
            if (connectionCore === null || connectionCore === undefined) {
                throw new base_1.RequiredError('connectionCore', 'Required parameter connectionCore was null or undefined when calling createConnectionV1WorkflowsConnectionsPost.');
            }
            const localVarPath = `/v1/workflows/connections/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof connectionCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(connectionCore !== undefined ? connectionCore : {}) : (connectionCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete Connection
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectionV1WorkflowsConnectionsConnectionIdDelete: (connectionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'connectionId' is not null or undefined
            if (connectionId === null || connectionId === undefined) {
                throw new base_1.RequiredError('connectionId', 'Required parameter connectionId was null or undefined when calling deleteConnectionV1WorkflowsConnectionsConnectionIdDelete.');
            }
            const localVarPath = `/v1/workflows/connections/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Read Connection
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionV1WorkflowsConnectionsConnectionIdGet: (connectionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'connectionId' is not null or undefined
            if (connectionId === null || connectionId === undefined) {
                throw new base_1.RequiredError('connectionId', 'Required parameter connectionId was null or undefined when calling readConnectionV1WorkflowsConnectionsConnectionIdGet.');
            }
            const localVarPath = `/v1/workflows/connections/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Read Connections
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionsV1WorkflowsConnectionsGet: (skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/workflows/connections/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update Connection
         * @param {string} connectionId
         * @param {ConnectionCore} connectionCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnectionV1WorkflowsConnectionsConnectionIdPut: (connectionId, connectionCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'connectionId' is not null or undefined
            if (connectionId === null || connectionId === undefined) {
                throw new base_1.RequiredError('connectionId', 'Required parameter connectionId was null or undefined when calling updateConnectionV1WorkflowsConnectionsConnectionIdPut.');
            }
            // verify required parameter 'connectionCore' is not null or undefined
            if (connectionCore === null || connectionCore === undefined) {
                throw new base_1.RequiredError('connectionCore', 'Required parameter connectionCore was null or undefined when calling updateConnectionV1WorkflowsConnectionsConnectionIdPut.');
            }
            const localVarPath = `/v1/workflows/connections/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof connectionCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(connectionCore !== undefined ? connectionCore : {}) : (connectionCore || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * WorkflowsConnectionsApi - functional programming interface
 * @export
 */
exports.WorkflowsConnectionsApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Create Connection
         * @param {ConnectionCore} connectionCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectionV1WorkflowsConnectionsPost(connectionCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsConnectionsApiAxiosParamCreator(configuration).createConnectionV1WorkflowsConnectionsPost(connectionCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Delete Connection
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsConnectionsApiAxiosParamCreator(configuration).deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Read Connection
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsConnectionsApiAxiosParamCreator(configuration).readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Read Connections
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionsV1WorkflowsConnectionsGet(skip, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsConnectionsApiAxiosParamCreator(configuration).readConnectionsV1WorkflowsConnectionsGet(skip, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Update Connection
         * @param {string} connectionId
         * @param {ConnectionCore} connectionCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsConnectionsApiAxiosParamCreator(configuration).updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * WorkflowsConnectionsApi - factory interface
 * @export
 */
exports.WorkflowsConnectionsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Create Connection
         * @param {ConnectionCore} connectionCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectionV1WorkflowsConnectionsPost(connectionCore, options) {
            return exports.WorkflowsConnectionsApiFp(configuration).createConnectionV1WorkflowsConnectionsPost(connectionCore, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete Connection
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options) {
            return exports.WorkflowsConnectionsApiFp(configuration).deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Read Connection
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options) {
            return exports.WorkflowsConnectionsApiFp(configuration).readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Read Connections
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionsV1WorkflowsConnectionsGet(skip, limit, options) {
            return exports.WorkflowsConnectionsApiFp(configuration).readConnectionsV1WorkflowsConnectionsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update Connection
         * @param {string} connectionId
         * @param {ConnectionCore} connectionCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options) {
            return exports.WorkflowsConnectionsApiFp(configuration).updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * WorkflowsConnectionsApi - object-oriented interface
 * @export
 * @class WorkflowsConnectionsApi
 * @extends {BaseAPI}
 */
class WorkflowsConnectionsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create Connection
     * @param {ConnectionCore} connectionCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    createConnectionV1WorkflowsConnectionsPost(connectionCore, options) {
        return exports.WorkflowsConnectionsApiFp(this.configuration).createConnectionV1WorkflowsConnectionsPost(connectionCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete Connection
     * @param {string} connectionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options) {
        return exports.WorkflowsConnectionsApiFp(this.configuration).deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Read Connection
     * @param {string} connectionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options) {
        return exports.WorkflowsConnectionsApiFp(this.configuration).readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Read Connections
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    readConnectionsV1WorkflowsConnectionsGet(skip, limit, options) {
        return exports.WorkflowsConnectionsApiFp(this.configuration).readConnectionsV1WorkflowsConnectionsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update Connection
     * @param {string} connectionId
     * @param {ConnectionCore} connectionCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options) {
        return exports.WorkflowsConnectionsApiFp(this.configuration).updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WorkflowsConnectionsApi = WorkflowsConnectionsApi;
/**
 * WorkflowsExecutionsApi - axios parameter creator
 * @export
 */
exports.WorkflowsExecutionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Execute a workflow. This is an Sync call. This returns the status of the workflow
         * @summary Execute Workflow
         * @param {string} workflowId
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost: (workflowId, body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new base_1.RequiredError('workflowId', 'Required parameter workflowId was null or undefined when calling executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError('body', 'Required parameter body was null or undefined when calling executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost.');
            }
            const localVarPath = `/v1/workflows/executions/{workflow_id}/execute`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get the status of a workflow given the run id
         * @summary Get Workflow Status
         * @param {string} runId
         * @param {string} workflowId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet: (runId, workflowId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new base_1.RequiredError('runId', 'Required parameter runId was null or undefined when calling getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet.');
            }
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new base_1.RequiredError('workflowId', 'Required parameter workflowId was null or undefined when calling getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet.');
            }
            const localVarPath = `/v1/workflows/executions/{workflow_id}/runs/{run_id}`
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)))
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Workflow Runs
         * @param {string} workflowId
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet: (workflowId, skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new base_1.RequiredError('workflowId', 'Required parameter workflowId was null or undefined when calling listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet.');
            }
            const localVarPath = `/v1/workflows/executions/{workflow_id}/runs`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Trigger a workflow execution. This is an Async call. This returns a workflow id which can be queried to get the status of the workflow
         * @summary Trigger Workflow
         * @param {string} workflowId
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost: (workflowId, body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new base_1.RequiredError('workflowId', 'Required parameter workflowId was null or undefined when calling triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError('body', 'Required parameter body was null or undefined when calling triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost.');
            }
            const localVarPath = `/v1/workflows/executions/{workflow_id}/trigger`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * WorkflowsExecutionsApi - functional programming interface
 * @export
 */
exports.WorkflowsExecutionsApiFp = function (configuration) {
    return {
        /**
         * Execute a workflow. This is an Sync call. This returns the status of the workflow
         * @summary Execute Workflow
         * @param {string} workflowId
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsExecutionsApiAxiosParamCreator(configuration).executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, body, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get the status of a workflow given the run id
         * @summary Get Workflow Status
         * @param {string} runId
         * @param {string} workflowId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsExecutionsApiAxiosParamCreator(configuration).getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary List Workflow Runs
         * @param {string} workflowId
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsExecutionsApiAxiosParamCreator(configuration).listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Trigger a workflow execution. This is an Async call. This returns a workflow id which can be queried to get the status of the workflow
         * @summary Trigger Workflow
         * @param {string} workflowId
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsExecutionsApiAxiosParamCreator(configuration).triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, body, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * WorkflowsExecutionsApi - factory interface
 * @export
 */
exports.WorkflowsExecutionsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Execute a workflow. This is an Sync call. This returns the status of the workflow
         * @summary Execute Workflow
         * @param {string} workflowId
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, body, options) {
            return exports.WorkflowsExecutionsApiFp(configuration).executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status of a workflow given the run id
         * @summary Get Workflow Status
         * @param {string} runId
         * @param {string} workflowId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options) {
            return exports.WorkflowsExecutionsApiFp(configuration).getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Workflow Runs
         * @param {string} workflowId
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options) {
            return exports.WorkflowsExecutionsApiFp(configuration).listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger a workflow execution. This is an Async call. This returns a workflow id which can be queried to get the status of the workflow
         * @summary Trigger Workflow
         * @param {string} workflowId
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, body, options) {
            return exports.WorkflowsExecutionsApiFp(configuration).triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, body, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * WorkflowsExecutionsApi - object-oriented interface
 * @export
 * @class WorkflowsExecutionsApi
 * @extends {BaseAPI}
 */
class WorkflowsExecutionsApi extends base_1.BaseAPI {
    /**
     * Execute a workflow. This is an Sync call. This returns the status of the workflow
     * @summary Execute Workflow
     * @param {string} workflowId
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsExecutionsApi
     */
    executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, body, options) {
        return exports.WorkflowsExecutionsApiFp(this.configuration).executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the status of a workflow given the run id
     * @summary Get Workflow Status
     * @param {string} runId
     * @param {string} workflowId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsExecutionsApi
     */
    getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options) {
        return exports.WorkflowsExecutionsApiFp(this.configuration).getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Workflow Runs
     * @param {string} workflowId
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsExecutionsApi
     */
    listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options) {
        return exports.WorkflowsExecutionsApiFp(this.configuration).listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Trigger a workflow execution. This is an Async call. This returns a workflow id which can be queried to get the status of the workflow
     * @summary Trigger Workflow
     * @param {string} workflowId
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsExecutionsApi
     */
    triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, body, options) {
        return exports.WorkflowsExecutionsApiFp(this.configuration).triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, body, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WorkflowsExecutionsApi = WorkflowsExecutionsApi;
/**
 * WorkflowsSubWorkflowsApi - axios parameter creator
 * @export
 */
exports.WorkflowsSubWorkflowsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns all sub workflows which can be invoked for a given workflow step
         * @summary Get Sub Workflows
         * @param {WorkflowStepInput} workflowStepInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost: (workflowStepInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowStepInput' is not null or undefined
            if (workflowStepInput === null || workflowStepInput === undefined) {
                throw new base_1.RequiredError('workflowStepInput', 'Required parameter workflowStepInput was null or undefined when calling getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost.');
            }
            const localVarPath = `/v1/workflows/steps/sub_workflows`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof workflowStepInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(workflowStepInput !== undefined ? workflowStepInput : {}) : (workflowStepInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * WorkflowsSubWorkflowsApi - functional programming interface
 * @export
 */
exports.WorkflowsSubWorkflowsApiFp = function (configuration) {
    return {
        /**
         * Returns all sub workflows which can be invoked for a given workflow step
         * @summary Get Sub Workflows
         * @param {WorkflowStepInput} workflowStepInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WorkflowsSubWorkflowsApiAxiosParamCreator(configuration).getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * WorkflowsSubWorkflowsApi - factory interface
 * @export
 */
exports.WorkflowsSubWorkflowsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Returns all sub workflows which can be invoked for a given workflow step
         * @summary Get Sub Workflows
         * @param {WorkflowStepInput} workflowStepInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options) {
            return exports.WorkflowsSubWorkflowsApiFp(configuration).getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * WorkflowsSubWorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsSubWorkflowsApi
 * @extends {BaseAPI}
 */
class WorkflowsSubWorkflowsApi extends base_1.BaseAPI {
    /**
     * Returns all sub workflows which can be invoked for a given workflow step
     * @summary Get Sub Workflows
     * @param {WorkflowStepInput} workflowStepInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsSubWorkflowsApi
     */
    getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options) {
        return exports.WorkflowsSubWorkflowsApiFp(this.configuration).getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WorkflowsSubWorkflowsApi = WorkflowsSubWorkflowsApi;
