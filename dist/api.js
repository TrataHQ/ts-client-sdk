"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Trata AI API
 * Human like conversation to answer calls, drive engagement, automate follow-ups & schedule bookings 24/7  with end to end integrations ensuring you never miss a sales enquiry.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkflowsSubWorkflowsApi = exports.WorkflowsSubWorkflowsApiFactory = exports.WorkflowsSubWorkflowsApiFp = exports.WorkflowsSubWorkflowsApiAxiosParamCreator = exports.WorkflowsExecutionsApi = exports.WorkflowsExecutionsApiFactory = exports.WorkflowsExecutionsApiFp = exports.WorkflowsExecutionsApiAxiosParamCreator = exports.WorkflowsConnectionsApi = exports.WorkflowsConnectionsApiFactory = exports.WorkflowsConnectionsApiFp = exports.WorkflowsConnectionsApiAxiosParamCreator = exports.WorkflowsAppsApi = exports.WorkflowsAppsApiFactory = exports.WorkflowsAppsApiFp = exports.WorkflowsAppsApiAxiosParamCreator = exports.WorkflowsApiHubspotApi = exports.WorkflowsApiHubspotApiFactory = exports.WorkflowsApiHubspotApiFp = exports.WorkflowsApiHubspotApiAxiosParamCreator = exports.WorkflowsApi = exports.WorkflowsApiFactory = exports.WorkflowsApiFp = exports.WorkflowsApiAxiosParamCreator = exports.VoiceModelsApi = exports.VoiceModelsApiFactory = exports.VoiceModelsApiFp = exports.VoiceModelsApiAxiosParamCreator = exports.UIApi = exports.UIApiFactory = exports.UIApiFp = exports.UIApiAxiosParamCreator = exports.TelephonyApi = exports.TelephonyApiFactory = exports.TelephonyApiFp = exports.TelephonyApiAxiosParamCreator = exports.SparringApi = exports.SparringApiFactory = exports.SparringApiFp = exports.SparringApiAxiosParamCreator = exports.SparrResellerApi = exports.SparrResellerApiFactory = exports.SparrResellerApiFp = exports.SparrResellerApiAxiosParamCreator = exports.SparrApi = exports.SparrApiFactory = exports.SparrApiFp = exports.SparrApiAxiosParamCreator = exports.ResellerUserApi = exports.ResellerUserApiFactory = exports.ResellerUserApiFp = exports.ResellerUserApiAxiosParamCreator = exports.ResellerSettingsApi = exports.ResellerSettingsApiFactory = exports.ResellerSettingsApiFp = exports.ResellerSettingsApiAxiosParamCreator = exports.ResellerPricingApi = exports.ResellerPricingApiFactory = exports.ResellerPricingApiFp = exports.ResellerPricingApiAxiosParamCreator = exports.ResellerOrganizationApi = exports.ResellerOrganizationApiFactory = exports.ResellerOrganizationApiFp = exports.ResellerOrganizationApiAxiosParamCreator = exports.ResellerMetricsApi = exports.ResellerMetricsApiFactory = exports.ResellerMetricsApiFp = exports.ResellerMetricsApiAxiosParamCreator = exports.ResellerFilesApi = exports.ResellerFilesApiFactory = exports.ResellerFilesApiFp = exports.ResellerFilesApiAxiosParamCreator = exports.ResellerCustomerUserApi = exports.ResellerCustomerUserApiFactory = exports.ResellerCustomerUserApiFp = exports.ResellerCustomerUserApiAxiosParamCreator = exports.ResellerCustomerPricingApi = exports.ResellerCustomerPricingApiFactory = exports.ResellerCustomerPricingApiFp = exports.ResellerCustomerPricingApiAxiosParamCreator = exports.ResellerCustomerPortalApi = exports.ResellerCustomerPortalApiFactory = exports.ResellerCustomerPortalApiFp = exports.ResellerCustomerPortalApiAxiosParamCreator = exports.ResellerCustomerDefaultPricingApi = exports.ResellerCustomerDefaultPricingApiFactory = exports.ResellerCustomerDefaultPricingApiFp = exports.ResellerCustomerDefaultPricingApiAxiosParamCreator = exports.ResellerCustomerCheckoutApi = exports.ResellerCustomerCheckoutApiFactory = exports.ResellerCustomerCheckoutApiFp = exports.ResellerCustomerCheckoutApiAxiosParamCreator = exports.ResellerCustomerAuditLogsApi = exports.ResellerCustomerAuditLogsApiFactory = exports.ResellerCustomerAuditLogsApiFp = exports.ResellerCustomerAuditLogsApiAxiosParamCreator = exports.ResellerCustomerApi = exports.ResellerCustomerApiFactory = exports.ResellerCustomerApiFp = exports.ResellerCustomerApiAxiosParamCreator = exports.ResellerCourseAssignmentsApi = exports.ResellerCourseAssignmentsApiFactory = exports.ResellerCourseAssignmentsApiFp = exports.ResellerCourseAssignmentsApiAxiosParamCreator = exports.ProspectsApi = exports.ProspectsApiFactory = exports.ProspectsApiFp = exports.ProspectsApiAxiosParamCreator = exports.ProductsApi = exports.ProductsApiFactory = exports.ProductsApiFp = exports.ProductsApiAxiosParamCreator = exports.SendInviteV1AppEnum = exports.InternalApi = exports.InternalApiFactory = exports.InternalApiFp = exports.InternalApiAxiosParamCreator = exports.HiveAgentLinkApi = exports.HiveAgentLinkApiFactory = exports.HiveAgentLinkApiFp = exports.HiveAgentLinkApiAxiosParamCreator = exports.HiveApi = exports.HiveApiFactory = exports.HiveApiFp = exports.HiveApiAxiosParamCreator = exports.HealthApi = exports.HealthApiFactory = exports.HealthApiFp = exports.HealthApiAxiosParamCreator = exports.UploadFileV1ValidatorEnum = exports.FilesApi = exports.FilesApiFactory = exports.FilesApiFp = exports.FilesApiAxiosParamCreator = exports.DataPlaneApi = exports.DataPlaneApiFactory = exports.DataPlaneApiFp = exports.DataPlaneApiAxiosParamCreator = exports.ConversationsApi = exports.ConversationsApiFactory = exports.ConversationsApiFp = exports.ConversationsApiAxiosParamCreator = exports.ConversationProspectLinkApi = exports.ConversationProspectLinkApiFactory = exports.ConversationProspectLinkApiFp = exports.ConversationProspectLinkApiAxiosParamCreator = exports.BillingApi = exports.BillingApiFactory = exports.BillingApiFp = exports.BillingApiAxiosParamCreator = exports.ApiKeyApi = exports.ApiKeyApiFactory = exports.ApiKeyApiFp = exports.ApiKeyApiAxiosParamCreator = exports.AnalyticsApi = exports.AnalyticsApiFactory = exports.AnalyticsApiFp = exports.AnalyticsApiAxiosParamCreator = exports.AgentsApi = exports.AgentsApiFactory = exports.AgentsApiFp = exports.AgentsApiAxiosParamCreator = exports.ActionsApi = exports.ActionsApiFactory = exports.ActionsApiFp = exports.ActionsApiAxiosParamCreator = exports.ActionAgentLinkApi = exports.ActionAgentLinkApiFactory = exports.ActionAgentLinkApiFp = exports.ActionAgentLinkApiAxiosParamCreator = exports.VoiceOutputGenderEnum = exports.VoiceInputGenderEnum = exports.VirtualProspectTypeEnum = exports.UserPerformanceSummaryRequestSortOrderEnum = exports.UiNodeType = exports.TranscriberConfig = exports.SystemMetricsAverageSentimentEnum = exports.SynthesizerConfig = exports.Status = exports.SparrVoiceLanguage = exports.SparrVoiceAccent = exports.SparrRudenessLevel = exports.SparrPatienceLevel = exports.SparrNegotiationStyle = exports.SparrModelsAnalyticsMetricName = exports.SparrModelsAnalyticsAggregationFormula = exports.SparrInteractionTone = exports.SparrFrustrationTolerance = exports.SparrExcitementLevel = exports.SparrEngagementLevel = exports.SparrDialogLineWithSentimentSentimentEnum = exports.SparrDialogLineSpeakerEnum = exports.SparrDecisionMakingStyle = exports.SparrCommunicationStyle = exports.SparrAdaptability = exports.SortOrder = exports.RubricLevel = exports.Role = exports.ProspectStatus = exports.ProductInputCurrencyEnum = exports.PriceInterval = exports.OrganizationInitializationStatus = exports.OAuthCredentialsCredentialsTypeEnum = exports.OAuthAuthTypeEnum = exports.NoAuthCredentialsCredentialsTypeEnum = exports.NoAuthAuthTypeEnum = exports.ModuleAttemptStatus = exports.MetricNameInput = exports.Language = exports.InteractionTone = exports.IntelligenceProviderConfig = exports.HttpActionEndpointMethodEnum = exports.HiveType = exports.HiveStorageConfig = exports.FilterOperator = exports.FillersConfig = exports.EndpointMethodEnum = exports.EmbeddingsModelConfig = exports.DialogLineSpeakerEnum = exports.CreditTypeEnum = exports.CredentialsCredentialsTypeEnum = exports.CourseCompletionStatus = exports.CourseAssignmentStatus = exports.ConversationStartEventPayloadTypeEnum = exports.ConversationSourceType = exports.ConnectionSourceSourceNameEnum = exports.ChangeAssignmentOperation = exports.CallSentiment = exports.BasicAuthCredentialsCredentialsTypeEnum = exports.BasicAuthAuthTypeEnum = exports.AuthRole = exports.AuthInnerAuthTypeEnum = exports.AppEnumOutput = exports.AppEnumInput = exports.AppActionType = exports.ApiKeyRequestKeyTypeEnum = exports.ApiKeyCredentialsCredentialsTypeEnum = exports.ApiKeyAuthAuthTypeEnum = exports.AggregationPeriod = exports.AggregationFormulaOutput = exports.AggregationFormulaInput = exports.AgenticWorkflowAdkModelsWorkflowAppEnum = exports.Adaptability = exports.ActionInvocationTrigger = exports.Accent = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 *
 * @export
 * @enum {string}
 */
exports.Accent = {
    American: 'American',
    Indian: 'Indian',
    Australian: 'Australian',
    British: 'British',
    Hindi: 'Hindi',
    MiddleEastern: 'Middle Eastern'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.ActionInvocationTrigger = {
    UserQuery: 'user_query',
    WebhookConversationStart: 'webhook.conversation_start',
    WebhookConversationEnd: 'webhook.conversation_end'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.Adaptability = {
    OpenToChange: 'open to change',
    Resistant: 'resistant',
    Indifferent: 'indifferent'
};
/**
 * Enum which stores the list of apps which are used to create the conversation
 * @export
 * @enum {string}
 */
exports.AgenticWorkflowAdkModelsWorkflowAppEnum = {
    Trata: 'TRATA',
    TrataSparr: 'TRATA_SPARR'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.AggregationFormulaInput = {
    Count: 'COUNT',
    Sum: 'SUM',
    Median: 'MEDIAN'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.AggregationFormulaOutput = {
    Count: 'COUNT',
    Sum: 'SUM',
    Avg: 'AVG',
    Min: 'MIN',
    Max: 'MAX',
    Median: 'MEDIAN'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.AggregationPeriod = {
    Monthly: 'MONTHLY',
    Weekly: 'WEEKLY',
    Daily: 'DAILY'
};
exports.ApiKeyAuthAuthTypeEnum = {
    Apikey: 'apikey'
};
exports.ApiKeyCredentialsCredentialsTypeEnum = {
    Apikey: 'apikey'
};
exports.ApiKeyRequestKeyTypeEnum = {
    ApiKey: 'api_key',
    CallKey: 'call_key'
};
/**
 * Enum for step types
 * @export
 * @enum {string}
 */
exports.AppActionType = {
    Trigger: 'TRIGGER',
    Action: 'ACTION'
};
/**
 * Enum which stores the list of apps which are used to create the conversation
 * @export
 * @enum {string}
 */
exports.AppEnumInput = {
    Trata: 'TRATA',
    TrataSparr: 'TRATA_SPARR',
    TrataSparrV1: 'TRATA_SPARR_V1'
};
/**
 * Enum which stores the list of apps which are used to create the conversation
 * @export
 * @enum {string}
 */
exports.AppEnumOutput = {
    Trata: 'TRATA',
    TrataSparr: 'TRATA_SPARR',
    TrataSparrV1: 'TRATA_SPARR_V1'
};
exports.AuthInnerAuthTypeEnum = {
    Noauth: 'noauth'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.AuthRole = {
    Owner: 'Owner',
    Admin: 'Admin',
    Member: 'Member'
};
exports.BasicAuthAuthTypeEnum = {
    Basic: 'basic'
};
exports.BasicAuthCredentialsCredentialsTypeEnum = {
    Basic: 'basic'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.CallSentiment = {
    Positive: 'positive',
    Negative: 'negative',
    Neutral: 'neutral'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.ChangeAssignmentOperation = {
    Assign: 'assign',
    Remove: 'remove'
};
exports.ConnectionSourceSourceNameEnum = {
    Twilio: 'TWILIO',
    Plivo: 'PLIVO',
    Browser: 'BROWSER'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.ConversationSourceType = {
    Browser: 'BROWSER',
    Twilio: 'TWILIO',
    Plivo: 'PLIVO'
};
exports.ConversationStartEventPayloadTypeEnum = {
    ConversationStart: 'conversation_start'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.CourseAssignmentStatus = {
    Assigned: 'assigned',
    Unassigned: 'unassigned'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.CourseCompletionStatus = {
    NotStarted: 'NOT_STARTED',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED'
};
exports.CredentialsCredentialsTypeEnum = {
    Noauth: 'noauth'
};
/**
 * Enum for the type of credit
 * @export
 * @enum {string}
 */
exports.CreditTypeEnum = {
    PhoneNumbers: 'phone_numbers',
    CallSeconds: 'call_seconds',
    CallHours: 'call_hours',
    Emails: 'emails',
    LinkedInScraping: 'linked_in_scraping',
    Courses: 'courses',
    RecordingAndTranscription: 'recording_and_transcription',
    Users: 'users',
    AdvancedIntelligence: 'advanced_intelligence',
    RolePlayCustomization: 'role_play_customization'
};
exports.DialogLineSpeakerEnum = {
    User: 'USER',
    Ai: 'AI',
    Tool: 'TOOL',
    AiToolRequest: 'AI - TOOL REQUEST'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.EmbeddingsModelConfig = {
    CustomPropsDimensionLength1536maxInputToken8192ModelNameTextEmbeddingsOpenaiModelProviderOpenai: '{\"CustomProps\":{\"dimension_length\":1536,\"max_input_token\":8192},\"ModelName\":\"text-embeddings-openai\",\"ModelProvider\":\"openai\"}',
    CustomPropsModelNameTextEmbeddingsGeminiModelProviderGoogle: '{\"CustomProps\":{},\"ModelName\":\"text-embeddings-gemini\",\"ModelProvider\":\"google\"}',
    CustomPropsDimensionLength768maxInputToken8192modelKwargsDeviceCputrustRemoteCodeTrueModelNameNomicAiNomicEmbedTextV1ModelProviderHuggingface: '{\"CustomProps\":{\"dimension_length\":768,\"max_input_token\":8192,\"model_kwargs\":{\"device\":\"cpu\",\"trust_remote_code\":true}},\"ModelName\":\"nomic-ai/nomic-embed-text-v1\",\"ModelProvider\":\"huggingface\"}',
    CustomPropsDimensionLength1024maxInputToken512ModelNameIntfloatE5LargeModelProviderHuggingface: '{\"CustomProps\":{\"dimension_length\":1024,\"max_input_token\":512},\"ModelName\":\"intfloat/e5-large\",\"ModelProvider\":\"huggingface\"}',
    CustomPropsDimensionLength384maxInputToken256ModelNameSentenceTransformersAllMiniLmL6V2ModelProviderHuggingface: '{\"CustomProps\":{\"dimension_length\":384,\"max_input_token\":256},\"ModelName\":\"sentence-transformers/all-MiniLM-L6-v2\",\"ModelProvider\":\"huggingface\"}'
};
exports.EndpointMethodEnum = {
    Get: 'GET',
    Post: 'POST'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.FillersConfig = {
    ModelProviderDecisionTree: '{\"ModelProvider\":\"decision_tree\"}',
    ModelProviderNaiveBayes: '{\"ModelProvider\":\"naive_bayes\"}',
    ModelProviderRandom: '{\"ModelProvider\":\"random\"}'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.FilterOperator = {
    Eq: 'eq',
    Neq: 'neq',
    In: 'in',
    Nin: 'nin',
    And: 'and',
    Or: 'or',
    Gte: 'gte',
    Lte: 'lte'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.HiveStorageConfig = {
    CloudProviderGoogleCustomProps: '{\"CloudProvider\":\"google\",\"CustomProps\":{}}',
    CloudProviderAwsCustomProps: '{\"CloudProvider\":\"aws\",\"CustomProps\":{}}'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.HiveType = {
    Website: 'WEBSITE',
    GoogleDocs: 'GOOGLE_DOCS',
    Docs: 'DOCS',
    Transcripts: 'TRANSCRIPTS'
};
exports.HttpActionEndpointMethodEnum = {
    Get: 'GET',
    Post: 'POST'
};
/**
 * Enum class representing intelligence provider
 * @export
 * @enum {string}
 */
exports.IntelligenceProviderConfig = {
    CustomPropsModelNameGpt4o20240806ModelProviderOpenai: '{\"CustomProps\":{},\"ModelName\":\"gpt-4o-2024-08-06\",\"ModelProvider\":\"openai\"}',
    CustomPropsModelNameGpt4oRealtimePreviewModelProviderOpenaiRealtime: '{\"CustomProps\":{},\"ModelName\":\"gpt-4o-realtime-preview\",\"ModelProvider\":\"openai-realtime\"}',
    CustomPropsModelNameLlama3170bVersatileModelProviderGroq: '{\"CustomProps\":{},\"ModelName\":\"llama-3.1-70b-versatile\",\"ModelProvider\":\"groq\"}',
    CustomPropsModelNameClaude3Haiku20240307ModelProviderAnthropic: '{\"CustomProps\":{},\"ModelName\":\"claude-3-haiku-20240307\",\"ModelProvider\":\"anthropic\"}',
    CustomPropsModelNameGemini15Flash001ModelProviderGoogle: '{\"CustomProps\":{},\"ModelName\":\"gemini-1.5-flash-001\",\"ModelProvider\":\"google\"}',
    CustomPropsModelNameMistralaiMixtral8x7BInstructV01ModelProviderTogetherAi: '{\"CustomProps\":{},\"ModelName\":\"mistralai/Mixtral-8x7B-Instruct-v0.1\",\"ModelProvider\":\"together-ai\"}',
    CustomPropsModelNameMetaLlamaMetaLlama3170BInstructTurboModelProviderTogetherAi: '{\"CustomProps\":{},\"ModelName\":\"meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo\",\"ModelProvider\":\"together-ai\"}',
    CustomPropsModelNameGoogleGemma7bModelProviderHuggingface: '{\"CustomProps\":{},\"ModelName\":\"google/gemma-7b\",\"ModelProvider\":\"huggingface\"}',
    CustomPropsModelNameMetaLlamaMetaLlama318BInstructModelProviderHuggingface: '{\"CustomProps\":{},\"ModelName\":\"meta-llama/Meta-Llama-3.1-8B-Instruct\",\"ModelProvider\":\"huggingface\"}',
    CustomPropsModelNameMistralaiMistral7BInstructV03ModelProviderHuggingface: '{\"CustomProps\":{},\"ModelName\":\"mistralai/Mistral-7B-Instruct-v0.3\",\"ModelProvider\":\"huggingface\"}',
    CustomPropsModelNameMetaLlama38bInstructV10ModelProviderBedrock: '{\"CustomProps\":{},\"ModelName\":\"meta.llama3-8b-instruct-v1:0\",\"ModelProvider\":\"bedrock\"}'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.InteractionTone = {
    Professional: 'professional',
    Casual: 'casual',
    Friendly: 'friendly',
    Authoritative: 'authoritative'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.Language = {
    English: 'English',
    Spanish: 'Spanish',
    Hindi: 'Hindi'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.MetricNameInput = {
    Calls: 'CALLS',
    CallDuration: 'CALL_DURATION',
    SparrCalls: 'SPARR_CALLS',
    SparrCallDuration: 'SPARR_CALL_DURATION',
    AppointmentScheduled: 'APPOINTMENT_SCHEDULED',
    CreditsConsumed: 'CREDITS_CONSUMED',
    CreditsConsumedPhoneNumbers: 'CREDITS_CONSUMED_PHONE_NUMBERS',
    CreditsConsumedCallSeconds: 'CREDITS_CONSUMED_CALL_SECONDS',
    CreditsConsumedEmails: 'CREDITS_CONSUMED_EMAILS',
    CreditsConsumedLeadGeneration: 'CREDITS_CONSUMED_LEAD_GENERATION',
    CreditsConsumedLinkedInScraping: 'CREDITS_CONSUMED_LINKED_IN_SCRAPING',
    CreditsConsumedCourses: 'CREDITS_CONSUMED_COURSES',
    CreditsTotal: 'CREDITS_TOTAL',
    CreditsTotalPhoneNumbers: 'CREDITS_TOTAL_PHONE_NUMBERS',
    CreditsTotalCallSeconds: 'CREDITS_TOTAL_CALL_SECONDS',
    CreditsTotalEmails: 'CREDITS_TOTAL_EMAILS',
    CreditsTotalLeadGeneration: 'CREDITS_TOTAL_LEAD_GENERATION',
    CreditsTotalLinkedInScraping: 'CREDITS_TOTAL_LINKED_IN_SCRAPING',
    CreditsTotalCourses: 'CREDITS_TOTAL_COURSES',
    CreditBurnRate: 'CREDIT_BURN_RATE',
    CreditBurnRatePhoneNumbers: 'CREDIT_BURN_RATE_PHONE_NUMBERS',
    CreditBurnRateCallSeconds: 'CREDIT_BURN_RATE_CALL_SECONDS',
    CreditBurnRateEmails: 'CREDIT_BURN_RATE_EMAILS',
    CreditBurnRateLeadGeneration: 'CREDIT_BURN_RATE_LEAD_GENERATION',
    CreditBurnRateLinkedInScraping: 'CREDIT_BURN_RATE_LINKED_IN_SCRAPING',
    CreditBurnRateCourses: 'CREDIT_BURN_RATE_COURSES',
    TotalRevenue: 'TOTAL_REVENUE',
    Profit: 'PROFIT',
    RevenueBySubscription: 'REVENUE_BY_SUBSCRIPTION',
    RevenueByAddOns: 'REVENUE_BY_ADD_ONS',
    MonthlyRecurringRevenue: 'MONTHLY_RECURRING_REVENUE',
    OneTimeRevenue: 'ONE_TIME_REVENUE',
    ActiveSubscriptions: 'ACTIVE_SUBSCRIPTIONS',
    NumberOfActivePayingCustomers: 'NUMBER_OF_ACTIVE_PAYING_CUSTOMERS',
    AverageRevenuePerActivePayingCustomer: 'AVERAGE_REVENUE_PER_ACTIVE_PAYING_CUSTOMER',
    TotalHoursConsumed: 'TOTAL_HOURS_CONSUMED',
    Prospects: 'PROSPECTS',
    Interested: 'INTERESTED',
    NotInterested: 'NOT_INTERESTED',
    NewCustomers: 'NEW_CUSTOMERS'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.ModuleAttemptStatus = {
    Passed: 'PASSED',
    Failed: 'FAILED',
    NotAttempted: 'NOT_ATTEMPTED'
};
exports.NoAuthAuthTypeEnum = {
    Noauth: 'noauth'
};
exports.NoAuthCredentialsCredentialsTypeEnum = {
    Noauth: 'noauth'
};
exports.OAuthAuthTypeEnum = {
    Oauth: 'oauth'
};
exports.OAuthCredentialsCredentialsTypeEnum = {
    Oauth: 'oauth'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.OrganizationInitializationStatus = {
    Pending: 'PENDING',
    Completed: 'COMPLETED',
    Failed: 'FAILED'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.PriceInterval = {
    OneTime: 'one_time',
    Monthly: 'monthly',
    Quarterly: 'quarterly',
    Yearly: 'yearly'
};
exports.ProductInputCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Bov: 'BOV',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Che: 'CHE',
    Chf: 'CHF',
    Chw: 'CHW',
    Clf: 'CLF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Cou: 'COU',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mru: 'MRU',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Mxv: 'MXV',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sle: 'SLE',
    Sll: 'SLL',
    Sos: 'SOS',
    Srd: 'SRD',
    Ssp: 'SSP',
    Stn: 'STN',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Usn: 'USN',
    Uyi: 'UYI',
    Uyu: 'UYU',
    Uyw: 'UYW',
    Uzs: 'UZS',
    Ved: 'VED',
    Ves: 'VES',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xof: 'XOF',
    Xpf: 'XPF',
    Xsu: 'XSU',
    Xua: 'XUA',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwl: 'ZWL'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.ProspectStatus = {
    New: 'NEW',
    GeneralEnquiry: 'GENERAL_ENQUIRY',
    ScheduledCallbackWithBot: 'SCHEDULED_CALLBACK_WITH_BOT',
    ScheduledAppointmentWithPerson: 'SCHEDULED_APPOINTMENT_WITH_PERSON',
    ScheduledAppointmentForService: 'SCHEDULED_APPOINTMENT_FOR_SERVICE',
    NotInterested: 'NOT_INTERESTED',
    ProductOrderPlaced: 'PRODUCT_ORDER_PLACED',
    ServiceOrderPlaced: 'SERVICE_ORDER_PLACED'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.Role = {
    Admin: 'ADMIN',
    ReadOnly: 'READ_ONLY',
    Owner: 'OWNER',
    ResellerAdmin: 'RESELLER_ADMIN'
};
/**
 * Rubric levels for consistent scoring
 * @export
 * @enum {string}
 */
exports.RubricLevel = {
    NotDemonstrated: 'NOT_DEMONSTRATED',
    Beginning: 'BEGINNING',
    Developing: 'DEVELOPING',
    Competent: 'COMPETENT',
    Advanced: 'ADVANCED',
    Mastery: 'MASTERY',
    InsufficientData: 'INSUFFICIENT_DATA'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SortOrder = {
    Asc: 'asc',
    Desc: 'desc'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SparrAdaptability = {
    OpenToChange: 'open to change',
    Resistant: 'resistant',
    Indifferent: 'indifferent'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SparrCommunicationStyle = {
    Direct: 'direct',
    Indirect: 'indirect',
    Verbose: 'verbose',
    Brief: 'brief'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SparrDecisionMakingStyle = {
    Logical: 'logical',
    Emotional: 'emotional',
    Impulsive: 'impulsive',
    Hesitant: 'hesitant'
};
exports.SparrDialogLineSpeakerEnum = {
    User: 'USER',
    Ai: 'AI',
    Tool: 'TOOL',
    AiToolRequest: 'AI - TOOL REQUEST'
};
exports.SparrDialogLineWithSentimentSentimentEnum = {
    Positive: 'POSITIVE',
    Negative: 'NEGATIVE',
    Neutral: 'NEUTRAL'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SparrEngagementLevel = {
    HighlyEngaged: 'highly engaged',
    Distracted: 'distracted',
    Uninterested: 'uninterested'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SparrExcitementLevel = {
    Neutral: 'neutral',
    Interested: 'interested',
    Excited: 'excited',
    Overjoyed: 'overjoyed',
    Euphoric: 'euphoric'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SparrFrustrationTolerance = {
    Neutral: 'neutral',
    QuickToAnger: 'quick to anger',
    Understanding: 'understanding'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SparrInteractionTone = {
    Casual: 'casual',
    Professional: 'professional',
    Friendly: 'friendly',
    Authoritative: 'authoritative'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SparrModelsAnalyticsAggregationFormula = {
    Count: 'COUNT',
    Sum: 'SUM',
    Avg: 'AVG',
    Min: 'MIN',
    Max: 'MAX',
    Median: 'MEDIAN'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SparrModelsAnalyticsMetricName = {
    Calls: 'CALLS',
    CallCount: 'callCount',
    CallDuration: 'CALL_DURATION',
    TalkRatio: 'TALK_RATIO',
    AverageFillerWordsCount: 'AVERAGE_FILLER_WORDS_COUNT',
    AverageOverallScore: 'AVERAGE_OVERALL_SCORE',
    AverageLongestMonologue: 'AVERAGE_LONGEST_MONOLOGUE',
    AverageModulesCompleted: 'AVERAGE_MODULES_COMPLETED',
    AverageActiveDays: 'AVERAGE_ACTIVE_DAYS',
    AverageScore: 'AVERAGE_SCORE',
    ProcessAdherenceScore: 'processAdherenceScore',
    SkillsScore: 'skillsScore',
    CommunicationScore: 'communicationScore',
    UserTalkingRatio: 'userTalkingRatio',
    FillerWords: 'fillerWords',
    OverallScore: 'overallScore',
    ModulesCompleted: 'modulesCompleted',
    CallDuration2: 'callDuration',
    LongestMonologue: 'longestMonologue',
    Winrate: 'winrate',
    ActiveDays: 'activeDays'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SparrNegotiationStyle = {
    HardBargainer: 'hard bargainer',
    FriendlyNegotiator: 'friendly negotiator',
    NonNegotiator: 'non-negotiator'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SparrPatienceLevel = {
    Neutral: 'neutral',
    VeryPatient: 'very patient',
    Impatient: 'impatient'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SparrRudenessLevel = {
    Courteous: 'courteous',
    Direct: 'direct',
    Irritable: 'irritable',
    Aggressive: 'aggressive',
    Toxic: 'toxic'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SparrVoiceAccent = {
    American: 'American',
    Indian: 'Indian',
    Australian: 'Australian',
    British: 'British',
    Hindi: 'Hindi',
    MiddleEastern: 'Middle Eastern'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SparrVoiceLanguage = {
    English: 'English',
    Spanish: 'Spanish',
    Hindi: 'Hindi'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.Status = {
    Active: 'active',
    Inactive: 'inactive',
    Pending: 'pending',
    Archived: 'archived'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SynthesizerConfig = {
    CustomPropsModelNameAuraModelProviderDeepgram: '{\"CustomProps\":{},\"ModelName\":\"aura\",\"ModelProvider\":\"Deepgram\"}',
    CustomPropsModelNameTts1ModelProviderOpenAi: '{\"CustomProps\":{},\"ModelName\":\"tts-1\",\"ModelProvider\":\"OpenAI\"}',
    CustomPropsModelNameModelProviderOpenVoice: '{\"CustomProps\":{},\"ModelName\":\"\",\"ModelProvider\":\"OpenVoice\"}',
    CustomPropsCanStreamInputTrueModelNameModelProviderElevenlabs: '{\"CustomProps\":{\"can_stream_input\":true},\"ModelName\":\"\",\"ModelProvider\":\"Elevenlabs\"}',
    CustomPropsCanStreamInputTrueModelNameSonicEnglishModelProviderCartesia: '{\"CustomProps\":{\"can_stream_input\":true},\"ModelName\":\"sonic-english\",\"ModelProvider\":\"Cartesia\"}',
    CustomPropsCanStreamInputTrueModelNameMistModelProviderRime: '{\"CustomProps\":{\"can_stream_input\":true},\"ModelName\":\"mist\",\"ModelProvider\":\"Rime\"}'
};
exports.SystemMetricsAverageSentimentEnum = {
    Positive: 'POSITIVE',
    Negative: 'NEGATIVE',
    Neutral: 'NEUTRAL',
    Empty: ''
};
/**
 * Enum class representing transcriber
 * @export
 * @enum {string}
 */
exports.TranscriberConfig = {
    CustomPropsModelNameNova2ModelProviderDeepgram: '{\"CustomProps\":{},\"ModelName\":\"nova-2\",\"ModelProvider\":\"Deepgram\"}',
    CustomPropsModelNameNovaModelProviderDeepgram: '{\"CustomProps\":{},\"ModelName\":\"nova\",\"ModelProvider\":\"Deepgram\"}',
    CustomPropsModelNameBaseModelProviderDeepgram: '{\"CustomProps\":{},\"ModelName\":\"base\",\"ModelProvider\":\"Deepgram\"}',
    CustomPropsModelNameNova2PhonecallModelProviderDeepgram: '{\"CustomProps\":{},\"ModelName\":\"nova-2-phonecall\",\"ModelProvider\":\"Deepgram\"}',
    CustomPropsModelNameSttModelProviderGoogle: '{\"CustomProps\":{},\"ModelName\":\"stt\",\"ModelProvider\":\"google\"}',
    CustomPropsModelNameWhisperModelProviderOpenai: '{\"CustomProps\":{},\"ModelName\":\"whisper\",\"ModelProvider\":\"openai\"}',
    CustomPropsModelNameTinyModelProviderOpenWhisper: '{\"CustomProps\":{},\"ModelName\":\"tiny\",\"ModelProvider\":\"OpenWhisper\"}',
    CustomPropsModelNameMediumModelProviderFastWhisper: '{\"CustomProps\":{},\"ModelName\":\"medium\",\"ModelProvider\":\"FastWhisper\"}',
    CustomPropsModelNameMediumModelProviderFastWhisperStream: '{\"CustomProps\":{},\"ModelName\":\"medium\",\"ModelProvider\":\"FastWhisperStream\"}',
    CustomPropsModelNameMediumModelProviderFastWhisperOnline: '{\"CustomProps\":{},\"ModelName\":\"medium\",\"ModelProvider\":\"FastWhisperOnline\"}'
};
/**
 * Enum for UI node types
 * @export
 * @enum {string}
 */
exports.UiNodeType = {
    Action: 'ACTION',
    Condition: 'CONDITION',
    Loop: 'LOOP',
    Subflow: 'SUBFLOW'
};
exports.UserPerformanceSummaryRequestSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
};
/**
 * Enum which stores the list of types of sparring calls
 * @export
 * @enum {string}
 */
exports.VirtualProspectTypeEnum = {
    Inbound: 'INBOUND',
    Outbound: 'OUTBOUND'
};
exports.VoiceInputGenderEnum = {
    Male: 'Male',
    Female: 'Female',
    Neutral: 'Neutral'
};
exports.VoiceOutputGenderEnum = {
    Male: 'Male',
    Female: 'Female',
    Neutral: 'Neutral'
};
/**
 * ActionAgentLinkApi - axios parameter creator
 * @export
 */
exports.ActionAgentLinkApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionAgentLinkV1: (actionId, agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionId' is not null or undefined
            common_1.assertParamExists('createActionAgentLinkV1', 'actionId', actionId);
            // verify required parameter 'agentId' is not null or undefined
            common_1.assertParamExists('createActionAgentLinkV1', 'agentId', agentId);
            const localVarPath = `/v1/actions/{action_id}/ai-agents/{agent_id}/link`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionAgentLinkV1: (actionId, agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionId' is not null or undefined
            common_1.assertParamExists('deleteActionAgentLinkV1', 'actionId', actionId);
            // verify required parameter 'agentId' is not null or undefined
            common_1.assertParamExists('deleteActionAgentLinkV1', 'agentId', agentId);
            const localVarPath = `/v1/actions/{action_id}/ai-agents/{agent_id}/link`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsOfAgentV1: (agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            common_1.assertParamExists('listActionsOfAgentV1', 'agentId', agentId);
            const localVarPath = `/v1/ai-agents/{agent_id}/actions`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ActionAgentLinkApi - functional programming interface
 * @export
 */
exports.ActionAgentLinkApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ActionAgentLinkApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionAgentLinkV1(actionId, agentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createActionAgentLinkV1(actionId, agentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ActionAgentLinkApi.createActionAgentLinkV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionAgentLinkV1(actionId, agentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteActionAgentLinkV1(actionId, agentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ActionAgentLinkApi.deleteActionAgentLinkV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsOfAgentV1(agentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listActionsOfAgentV1(agentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ActionAgentLinkApi.listActionsOfAgentV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ActionAgentLinkApi - factory interface
 * @export
 */
exports.ActionAgentLinkApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ActionAgentLinkApiFp(configuration);
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionAgentLinkV1(actionId, agentId, options) {
            return localVarFp.createActionAgentLinkV1(actionId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionAgentLinkV1(actionId, agentId, options) {
            return localVarFp.deleteActionAgentLinkV1(actionId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsOfAgentV1(agentId, options) {
            return localVarFp.listActionsOfAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ActionAgentLinkApi - object-oriented interface
 * @export
 * @class ActionAgentLinkApi
 * @extends {BaseAPI}
 */
class ActionAgentLinkApi extends base_1.BaseAPI {
    /**
     * Create a Link Between an Action and an Agent
     * @summary Create a Link Between an Action and an Agent
     * @param {string} actionId ID of the action
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    createActionAgentLinkV1(actionId, agentId, options) {
        return exports.ActionAgentLinkApiFp(this.configuration).createActionAgentLinkV1(actionId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Link Between an Action and an Agent
     * @summary Delete a Link Between an Action and an Agent
     * @param {string} actionId ID of the action
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    deleteActionAgentLinkV1(actionId, agentId, options) {
        return exports.ActionAgentLinkApiFp(this.configuration).deleteActionAgentLinkV1(actionId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Actions Linked to a Specific Agent
     * @summary List All Actions Linked to a Specific Agent
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    listActionsOfAgentV1(agentId, options) {
        return exports.ActionAgentLinkApiFp(this.configuration).listActionsOfAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ActionAgentLinkApi = ActionAgentLinkApi;
/**
 * ActionsApi - axios parameter creator
 * @export
 */
exports.ActionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionV1: (actionInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionInput' is not null or undefined
            common_1.assertParamExists('createActionV1', 'actionInput', actionInput);
            const localVarPath = `/v1/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(actionInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionV1: (actionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionId' is not null or undefined
            common_1.assertParamExists('deleteActionV1', 'actionId', actionId);
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1: (actionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionId' is not null or undefined
            common_1.assertParamExists('getActionV1', 'actionId', actionId);
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Actions
         * @summary List All Actions
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter instanceof Date) ?
                    updatedAfter.toISOString() :
                    updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore instanceof Date) ?
                    updatedBefore.toISOString() :
                    updatedBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActionV1: (actionId, actionInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionId' is not null or undefined
            common_1.assertParamExists('updateActionV1', 'actionId', actionId);
            // verify required parameter 'actionInput' is not null or undefined
            common_1.assertParamExists('updateActionV1', 'actionInput', actionInput);
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(actionInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ActionsApi - functional programming interface
 * @export
 */
exports.ActionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ActionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionV1(actionInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createActionV1(actionInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ActionsApi.createActionV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionV1(actionId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteActionV1(actionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ActionsApi.deleteActionV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1(actionId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getActionV1(actionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ActionsApi.getActionV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List All Actions
         * @summary List All Actions
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ActionsApi.listActionsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActionV1(actionId, actionInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateActionV1(actionId, actionInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ActionsApi.updateActionV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ActionsApi - factory interface
 * @export
 */
exports.ActionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ActionsApiFp(configuration);
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionV1(actionInput, options) {
            return localVarFp.createActionV1(actionInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionV1(actionId, options) {
            return localVarFp.deleteActionV1(actionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1(actionId, options) {
            return localVarFp.getActionV1(actionId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Actions
         * @summary List All Actions
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return localVarFp.listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActionV1(actionId, actionInput, options) {
            return localVarFp.updateActionV1(actionId, actionInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
class ActionsApi extends base_1.BaseAPI {
    /**
     * Create a New Action
     * @summary Create a New Action
     * @param {ActionInput} actionInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    createActionV1(actionInput, options) {
        return exports.ActionsApiFp(this.configuration).createActionV1(actionInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Specific Action by ID
     * @summary Delete a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    deleteActionV1(actionId, options) {
        return exports.ActionsApiFp(this.configuration).deleteActionV1(actionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Specific Action by ID
     * @summary Get a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    getActionV1(actionId, options) {
        return exports.ActionsApiFp(this.configuration).getActionV1(actionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Actions
     * @summary List All Actions
     * @param {string | null} [searchBy]
     * @param {string | null} [searchValue]
     * @param {string | null} [status]
     * @param {string | null} [sortBy]
     * @param {SortOrder | null} [sortOrder]
     * @param {number | null} [skip]
     * @param {number | null} [limit]
     * @param {string | null} [updatedAfter]
     * @param {string | null} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ActionsApiFp(this.configuration).listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Specific Action by ID
     * @summary Update a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {ActionInput} actionInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    updateActionV1(actionId, actionInput, options) {
        return exports.ActionsApiFp(this.configuration).updateActionV1(actionId, actionInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ActionsApi = ActionsApi;
/**
 * AgentsApi - axios parameter creator
 * @export
 */
exports.AgentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAIAgentV1: (aIAgentInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'aIAgentInput' is not null or undefined
            common_1.assertParamExists('createAIAgentV1', 'aIAgentInput', aIAgentInput);
            const localVarPath = `/v1/ai-agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(aIAgentInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAIAgentV1: (agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            common_1.assertParamExists('deleteAIAgentV1', 'agentId', agentId);
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIAgentV1: (agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            common_1.assertParamExists('getAIAgentV1', 'agentId', agentId);
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All AI Agents
         * @summary List All AI Agents
         * @param {AppEnumInput | null} [app]
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIAgentsV1: (app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/ai-agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter instanceof Date) ?
                    updatedAfter.toISOString() :
                    updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore instanceof Date) ?
                    updatedBefore.toISOString() :
                    updatedBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIAgentV1: (agentId, aIAgentInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            common_1.assertParamExists('updateAIAgentV1', 'agentId', agentId);
            // verify required parameter 'aIAgentInput' is not null or undefined
            common_1.assertParamExists('updateAIAgentV1', 'aIAgentInput', aIAgentInput);
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(aIAgentInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * AgentsApi - functional programming interface
 * @export
 */
exports.AgentsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.AgentsApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAIAgentV1(aIAgentInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createAIAgentV1(aIAgentInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AgentsApi.createAIAgentV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAIAgentV1(agentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAIAgentV1(agentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AgentsApi.deleteAIAgentV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIAgentV1(agentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAIAgentV1(agentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AgentsApi.getAIAgentV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List All AI Agents
         * @summary List All AI Agents
         * @param {AppEnumInput | null} [app]
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AgentsApi.listAIAgentsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIAgentV1(agentId, aIAgentInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAIAgentV1(agentId, aIAgentInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AgentsApi.updateAIAgentV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * AgentsApi - factory interface
 * @export
 */
exports.AgentsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.AgentsApiFp(configuration);
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAIAgentV1(aIAgentInput, options) {
            return localVarFp.createAIAgentV1(aIAgentInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAIAgentV1(agentId, options) {
            return localVarFp.deleteAIAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIAgentV1(agentId, options) {
            return localVarFp.getAIAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All AI Agents
         * @summary List All AI Agents
         * @param {AppEnumInput | null} [app]
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return localVarFp.listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIAgentV1(agentId, aIAgentInput, options) {
            return localVarFp.updateAIAgentV1(agentId, aIAgentInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AgentsApi - object-oriented interface
 * @export
 * @class AgentsApi
 * @extends {BaseAPI}
 */
class AgentsApi extends base_1.BaseAPI {
    /**
     * Create a New AI Agent
     * @summary Create a New AI Agent
     * @param {AIAgentInput} aIAgentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    createAIAgentV1(aIAgentInput, options) {
        return exports.AgentsApiFp(this.configuration).createAIAgentV1(aIAgentInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Specific AI Agent by ID
     * @summary Delete a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    deleteAIAgentV1(agentId, options) {
        return exports.AgentsApiFp(this.configuration).deleteAIAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Specific AI Agent by ID
     * @summary Get a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    getAIAgentV1(agentId, options) {
        return exports.AgentsApiFp(this.configuration).getAIAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All AI Agents
     * @summary List All AI Agents
     * @param {AppEnumInput | null} [app]
     * @param {string | null} [searchBy]
     * @param {string | null} [searchValue]
     * @param {string | null} [status]
     * @param {string | null} [sortBy]
     * @param {SortOrder | null} [sortOrder]
     * @param {number | null} [skip]
     * @param {number | null} [limit]
     * @param {string | null} [updatedAfter]
     * @param {string | null} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.AgentsApiFp(this.configuration).listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Specific AI Agent by ID
     * @summary Update a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {AIAgentInput} aIAgentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    updateAIAgentV1(agentId, aIAgentInput, options) {
        return exports.AgentsApiFp(this.configuration).updateAIAgentV1(agentId, aIAgentInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AgentsApi = AgentsApi;
/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
exports.AnalyticsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get fine grained analytics data from Trata AI like call, duration stats, etc.
         * @summary Get Metrics
         * @param {BatchMetricsRequestsInput} batchMetricsRequestsInput
         * @param {string | null} [app]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1MetricsPost: (batchMetricsRequestsInput, app, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'batchMetricsRequestsInput' is not null or undefined
            common_1.assertParamExists('getMetricsV1MetricsPost', 'batchMetricsRequestsInput', batchMetricsRequestsInput);
            const localVarPath = `/v1/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(batchMetricsRequestsInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get aggregated stats from Trata AI like call count, prospect count, etc.
         * @summary Get Aggregated Stats
         * @param {AppEnumInput | null} [app]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallStatsV1StatsGet: (app, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get simplified user analytics with custom metrics and single date range aggregation.  This endpoint aggregates metrics over the entire date range without time-based grouping. Perfect for getting summary statistics or single aggregated values.  Example request: ```json {     \"startDate\": \"2024-01-01\",     \"endDate\": \"2024-03-31\",     \"metrics\": [         {             \"name\": \"overallScore\",             \"aggregation\": \"AVG\",             \"alias\": \"average_performance\"         },         {             \"name\": \"callDuration\",             \"aggregation\": \"SUM\",             \"alias\": \"total_call_time\"         },         {             \"name\": \"modulesCompleted\",             \"aggregation\": \"COUNT\",             \"alias\": \"completion_count\"         }     ],     \"userIds\": [\"user_id_1\", \"user_id_2\"] } ```  Available metric names: - processAdherenceScore: Process adherence score metric - skillsScore: Skills assessment score metric - communicationScore: Communication effectiveness score metric - userTalkingRatio: Ratio of user talking time vs total conversation time - fillerWords: Count of filler words used - overallScore: Overall performance score metric - modulesCompleted: Number of modules completed - callDuration: Duration of the call in seconds - longestMonologue: Duration of the longest monologue in seconds - winrate: Percentage of calls with overallScore > threshold (use with AVG aggregation) - callCount: Count of calls (each analytics record represents one call) - activeDays: Count of unique days with user activity (use with COUNT aggregation) - userId: User ID for counting unique users - feedbackId: Feedback ID for counting records  Note: Both camelCase and snake_case formats are supported for column names (e.g., \"processAdherenceScore\" or \"process_adherence_score\")  Available aggregations: - SUM: Total values - AVG: Average values - COUNT: Count of non-null values - MIN: Minimum value - MAX: Maximum value
         * @summary Get User Analytics
         * @param {AnalyticsRequest} analyticsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAnalyticsV1: (analyticsRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'analyticsRequest' is not null or undefined
            common_1.assertParamExists('getUserAnalyticsV1', 'analyticsRequest', analyticsRequest);
            const localVarPath = `/v1/sparr/analytics/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(analyticsRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get user performance summary with aggregated metrics grouped by user.  This endpoint returns a list of users with their average performance scores: - Average Process Adherence Score - Average Skills Score - Average Communication Score - Average Overall Score - Total number of sessions  Features: - Date range filtering (startDate, endDate) - Optional user ID filtering - Sorting by any column (userName, avgProcessAdherenceScore, avgSkillsScore, avgCommunicationScore, avgOverallScore) - Sort order (asc/desc, default desc) - Pagination support (skip/limit)  Example request: ```json {     \"startDate\": \"2024-01-01\",     \"endDate\": \"2024-03-31\",     \"userIds\": [\"user_id_1\", \"user_id_2\"],     \"sortBy\": \"avgOverallScore\",     \"sortOrder\": \"desc\",     \"skip\": 0,     \"limit\": 50 } ```  Available sort columns: - userName: User name - avgProcessAdherenceScore: Average process adherence score - avgSkillsScore: Average skills assessment score - avgCommunicationScore: Average communication effectiveness score - avgOverallScore: Average overall performance score (default)  Returns: - List of user performance summaries - Total count of matching users - Pagination metadata
         * @summary Get User Performance Summary
         * @param {UserPerformanceSummaryRequest} userPerformanceSummaryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPerformanceSummaryV1: (userPerformanceSummaryRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userPerformanceSummaryRequest' is not null or undefined
            common_1.assertParamExists('getUserPerformanceSummaryV1', 'userPerformanceSummaryRequest', userPerformanceSummaryRequest);
            const localVarPath = `/v1/sparr/analytics/users/performance-summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(userPerformanceSummaryRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * AnalyticsApi - functional programming interface
 * @export
 */
exports.AnalyticsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.AnalyticsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get fine grained analytics data from Trata AI like call, duration stats, etc.
         * @summary Get Metrics
         * @param {BatchMetricsRequestsInput} batchMetricsRequestsInput
         * @param {string | null} [app]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1MetricsPost(batchMetricsRequestsInput, app, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMetricsV1MetricsPost(batchMetricsRequestsInput, app, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AnalyticsApi.getMetricsV1MetricsPost']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get aggregated stats from Trata AI like call count, prospect count, etc.
         * @summary Get Aggregated Stats
         * @param {AppEnumInput | null} [app]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallStatsV1StatsGet(app, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOverallStatsV1StatsGet(app, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AnalyticsApi.getOverallStatsV1StatsGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get simplified user analytics with custom metrics and single date range aggregation.  This endpoint aggregates metrics over the entire date range without time-based grouping. Perfect for getting summary statistics or single aggregated values.  Example request: ```json {     \"startDate\": \"2024-01-01\",     \"endDate\": \"2024-03-31\",     \"metrics\": [         {             \"name\": \"overallScore\",             \"aggregation\": \"AVG\",             \"alias\": \"average_performance\"         },         {             \"name\": \"callDuration\",             \"aggregation\": \"SUM\",             \"alias\": \"total_call_time\"         },         {             \"name\": \"modulesCompleted\",             \"aggregation\": \"COUNT\",             \"alias\": \"completion_count\"         }     ],     \"userIds\": [\"user_id_1\", \"user_id_2\"] } ```  Available metric names: - processAdherenceScore: Process adherence score metric - skillsScore: Skills assessment score metric - communicationScore: Communication effectiveness score metric - userTalkingRatio: Ratio of user talking time vs total conversation time - fillerWords: Count of filler words used - overallScore: Overall performance score metric - modulesCompleted: Number of modules completed - callDuration: Duration of the call in seconds - longestMonologue: Duration of the longest monologue in seconds - winrate: Percentage of calls with overallScore > threshold (use with AVG aggregation) - callCount: Count of calls (each analytics record represents one call) - activeDays: Count of unique days with user activity (use with COUNT aggregation) - userId: User ID for counting unique users - feedbackId: Feedback ID for counting records  Note: Both camelCase and snake_case formats are supported for column names (e.g., \"processAdherenceScore\" or \"process_adherence_score\")  Available aggregations: - SUM: Total values - AVG: Average values - COUNT: Count of non-null values - MIN: Minimum value - MAX: Maximum value
         * @summary Get User Analytics
         * @param {AnalyticsRequest} analyticsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAnalyticsV1(analyticsRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserAnalyticsV1(analyticsRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AnalyticsApi.getUserAnalyticsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get user performance summary with aggregated metrics grouped by user.  This endpoint returns a list of users with their average performance scores: - Average Process Adherence Score - Average Skills Score - Average Communication Score - Average Overall Score - Total number of sessions  Features: - Date range filtering (startDate, endDate) - Optional user ID filtering - Sorting by any column (userName, avgProcessAdherenceScore, avgSkillsScore, avgCommunicationScore, avgOverallScore) - Sort order (asc/desc, default desc) - Pagination support (skip/limit)  Example request: ```json {     \"startDate\": \"2024-01-01\",     \"endDate\": \"2024-03-31\",     \"userIds\": [\"user_id_1\", \"user_id_2\"],     \"sortBy\": \"avgOverallScore\",     \"sortOrder\": \"desc\",     \"skip\": 0,     \"limit\": 50 } ```  Available sort columns: - userName: User name - avgProcessAdherenceScore: Average process adherence score - avgSkillsScore: Average skills assessment score - avgCommunicationScore: Average communication effectiveness score - avgOverallScore: Average overall performance score (default)  Returns: - List of user performance summaries - Total count of matching users - Pagination metadata
         * @summary Get User Performance Summary
         * @param {UserPerformanceSummaryRequest} userPerformanceSummaryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPerformanceSummaryV1(userPerformanceSummaryRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserPerformanceSummaryV1(userPerformanceSummaryRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AnalyticsApi.getUserPerformanceSummaryV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * AnalyticsApi - factory interface
 * @export
 */
exports.AnalyticsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.AnalyticsApiFp(configuration);
    return {
        /**
         * Get fine grained analytics data from Trata AI like call, duration stats, etc.
         * @summary Get Metrics
         * @param {BatchMetricsRequestsInput} batchMetricsRequestsInput
         * @param {string | null} [app]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1MetricsPost(batchMetricsRequestsInput, app, options) {
            return localVarFp.getMetricsV1MetricsPost(batchMetricsRequestsInput, app, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregated stats from Trata AI like call count, prospect count, etc.
         * @summary Get Aggregated Stats
         * @param {AppEnumInput | null} [app]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallStatsV1StatsGet(app, options) {
            return localVarFp.getOverallStatsV1StatsGet(app, options).then((request) => request(axios, basePath));
        },
        /**
         * Get simplified user analytics with custom metrics and single date range aggregation.  This endpoint aggregates metrics over the entire date range without time-based grouping. Perfect for getting summary statistics or single aggregated values.  Example request: ```json {     \"startDate\": \"2024-01-01\",     \"endDate\": \"2024-03-31\",     \"metrics\": [         {             \"name\": \"overallScore\",             \"aggregation\": \"AVG\",             \"alias\": \"average_performance\"         },         {             \"name\": \"callDuration\",             \"aggregation\": \"SUM\",             \"alias\": \"total_call_time\"         },         {             \"name\": \"modulesCompleted\",             \"aggregation\": \"COUNT\",             \"alias\": \"completion_count\"         }     ],     \"userIds\": [\"user_id_1\", \"user_id_2\"] } ```  Available metric names: - processAdherenceScore: Process adherence score metric - skillsScore: Skills assessment score metric - communicationScore: Communication effectiveness score metric - userTalkingRatio: Ratio of user talking time vs total conversation time - fillerWords: Count of filler words used - overallScore: Overall performance score metric - modulesCompleted: Number of modules completed - callDuration: Duration of the call in seconds - longestMonologue: Duration of the longest monologue in seconds - winrate: Percentage of calls with overallScore > threshold (use with AVG aggregation) - callCount: Count of calls (each analytics record represents one call) - activeDays: Count of unique days with user activity (use with COUNT aggregation) - userId: User ID for counting unique users - feedbackId: Feedback ID for counting records  Note: Both camelCase and snake_case formats are supported for column names (e.g., \"processAdherenceScore\" or \"process_adherence_score\")  Available aggregations: - SUM: Total values - AVG: Average values - COUNT: Count of non-null values - MIN: Minimum value - MAX: Maximum value
         * @summary Get User Analytics
         * @param {AnalyticsRequest} analyticsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAnalyticsV1(analyticsRequest, options) {
            return localVarFp.getUserAnalyticsV1(analyticsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user performance summary with aggregated metrics grouped by user.  This endpoint returns a list of users with their average performance scores: - Average Process Adherence Score - Average Skills Score - Average Communication Score - Average Overall Score - Total number of sessions  Features: - Date range filtering (startDate, endDate) - Optional user ID filtering - Sorting by any column (userName, avgProcessAdherenceScore, avgSkillsScore, avgCommunicationScore, avgOverallScore) - Sort order (asc/desc, default desc) - Pagination support (skip/limit)  Example request: ```json {     \"startDate\": \"2024-01-01\",     \"endDate\": \"2024-03-31\",     \"userIds\": [\"user_id_1\", \"user_id_2\"],     \"sortBy\": \"avgOverallScore\",     \"sortOrder\": \"desc\",     \"skip\": 0,     \"limit\": 50 } ```  Available sort columns: - userName: User name - avgProcessAdherenceScore: Average process adherence score - avgSkillsScore: Average skills assessment score - avgCommunicationScore: Average communication effectiveness score - avgOverallScore: Average overall performance score (default)  Returns: - List of user performance summaries - Total count of matching users - Pagination metadata
         * @summary Get User Performance Summary
         * @param {UserPerformanceSummaryRequest} userPerformanceSummaryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPerformanceSummaryV1(userPerformanceSummaryRequest, options) {
            return localVarFp.getUserPerformanceSummaryV1(userPerformanceSummaryRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
class AnalyticsApi extends base_1.BaseAPI {
    /**
     * Get fine grained analytics data from Trata AI like call, duration stats, etc.
     * @summary Get Metrics
     * @param {BatchMetricsRequestsInput} batchMetricsRequestsInput
     * @param {string | null} [app]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    getMetricsV1MetricsPost(batchMetricsRequestsInput, app, options) {
        return exports.AnalyticsApiFp(this.configuration).getMetricsV1MetricsPost(batchMetricsRequestsInput, app, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get aggregated stats from Trata AI like call count, prospect count, etc.
     * @summary Get Aggregated Stats
     * @param {AppEnumInput | null} [app]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    getOverallStatsV1StatsGet(app, options) {
        return exports.AnalyticsApiFp(this.configuration).getOverallStatsV1StatsGet(app, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get simplified user analytics with custom metrics and single date range aggregation.  This endpoint aggregates metrics over the entire date range without time-based grouping. Perfect for getting summary statistics or single aggregated values.  Example request: ```json {     \"startDate\": \"2024-01-01\",     \"endDate\": \"2024-03-31\",     \"metrics\": [         {             \"name\": \"overallScore\",             \"aggregation\": \"AVG\",             \"alias\": \"average_performance\"         },         {             \"name\": \"callDuration\",             \"aggregation\": \"SUM\",             \"alias\": \"total_call_time\"         },         {             \"name\": \"modulesCompleted\",             \"aggregation\": \"COUNT\",             \"alias\": \"completion_count\"         }     ],     \"userIds\": [\"user_id_1\", \"user_id_2\"] } ```  Available metric names: - processAdherenceScore: Process adherence score metric - skillsScore: Skills assessment score metric - communicationScore: Communication effectiveness score metric - userTalkingRatio: Ratio of user talking time vs total conversation time - fillerWords: Count of filler words used - overallScore: Overall performance score metric - modulesCompleted: Number of modules completed - callDuration: Duration of the call in seconds - longestMonologue: Duration of the longest monologue in seconds - winrate: Percentage of calls with overallScore > threshold (use with AVG aggregation) - callCount: Count of calls (each analytics record represents one call) - activeDays: Count of unique days with user activity (use with COUNT aggregation) - userId: User ID for counting unique users - feedbackId: Feedback ID for counting records  Note: Both camelCase and snake_case formats are supported for column names (e.g., \"processAdherenceScore\" or \"process_adherence_score\")  Available aggregations: - SUM: Total values - AVG: Average values - COUNT: Count of non-null values - MIN: Minimum value - MAX: Maximum value
     * @summary Get User Analytics
     * @param {AnalyticsRequest} analyticsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    getUserAnalyticsV1(analyticsRequest, options) {
        return exports.AnalyticsApiFp(this.configuration).getUserAnalyticsV1(analyticsRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get user performance summary with aggregated metrics grouped by user.  This endpoint returns a list of users with their average performance scores: - Average Process Adherence Score - Average Skills Score - Average Communication Score - Average Overall Score - Total number of sessions  Features: - Date range filtering (startDate, endDate) - Optional user ID filtering - Sorting by any column (userName, avgProcessAdherenceScore, avgSkillsScore, avgCommunicationScore, avgOverallScore) - Sort order (asc/desc, default desc) - Pagination support (skip/limit)  Example request: ```json {     \"startDate\": \"2024-01-01\",     \"endDate\": \"2024-03-31\",     \"userIds\": [\"user_id_1\", \"user_id_2\"],     \"sortBy\": \"avgOverallScore\",     \"sortOrder\": \"desc\",     \"skip\": 0,     \"limit\": 50 } ```  Available sort columns: - userName: User name - avgProcessAdherenceScore: Average process adherence score - avgSkillsScore: Average skills assessment score - avgCommunicationScore: Average communication effectiveness score - avgOverallScore: Average overall performance score (default)  Returns: - List of user performance summaries - Total count of matching users - Pagination metadata
     * @summary Get User Performance Summary
     * @param {UserPerformanceSummaryRequest} userPerformanceSummaryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    getUserPerformanceSummaryV1(userPerformanceSummaryRequest, options) {
        return exports.AnalyticsApiFp(this.configuration).getUserPerformanceSummaryV1(userPerformanceSummaryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AnalyticsApi = AnalyticsApi;
/**
 * ApiKeyApi - axios parameter creator
 * @export
 */
exports.ApiKeyApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyV1: (apiKeyRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'apiKeyRequest' is not null or undefined
            common_1.assertParamExists('createApiKeyV1', 'apiKeyRequest', apiKeyRequest);
            const localVarPath = `/v1/api-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(apiKeyRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete Api Key
         * @param {string} keyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyV1: (keyId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'keyId' is not null or undefined
            common_1.assertParamExists('deleteApiKeyV1', 'keyId', keyId);
            const localVarPath = `/v1/api-keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallKeyV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/api-keys/call-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/api-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ApiKeyApi - functional programming interface
 * @export
 */
exports.ApiKeyApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ApiKeyApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyV1(apiKeyRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createApiKeyV1(apiKeyRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ApiKeyApi.createApiKeyV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete Api Key
         * @param {string} keyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyV1(keyId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteApiKeyV1(keyId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ApiKeyApi.deleteApiKeyV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallKeyV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCallKeyV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ApiKeyApi.getCallKeyV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listApiKeysV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ApiKeyApi.listApiKeysV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ApiKeyApi - factory interface
 * @export
 */
exports.ApiKeyApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ApiKeyApiFp(configuration);
    return {
        /**
         *
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyV1(apiKeyRequest, options) {
            return localVarFp.createApiKeyV1(apiKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete Api Key
         * @param {string} keyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyV1(keyId, options) {
            return localVarFp.deleteApiKeyV1(keyId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallKeyV1(options) {
            return localVarFp.getCallKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysV1(options) {
            return localVarFp.listApiKeysV1(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ApiKeyApi - object-oriented interface
 * @export
 * @class ApiKeyApi
 * @extends {BaseAPI}
 */
class ApiKeyApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create Api Key
     * @param {ApiKeyRequest} apiKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    createApiKeyV1(apiKeyRequest, options) {
        return exports.ApiKeyApiFp(this.configuration).createApiKeyV1(apiKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete Api Key
     * @param {string} keyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    deleteApiKeyV1(keyId, options) {
        return exports.ApiKeyApiFp(this.configuration).deleteApiKeyV1(keyId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Call Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    getCallKeyV1(options) {
        return exports.ApiKeyApiFp(this.configuration).getCallKeyV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Api Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    listApiKeysV1(options) {
        return exports.ApiKeyApiFp(this.configuration).listApiKeysV1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ApiKeyApi = ApiKeyApi;
/**
 * BillingApi - axios parameter creator
 * @export
 */
exports.BillingApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForBillableProductV1: (billableProductId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'billableProductId' is not null or undefined
            common_1.assertParamExists('createCheckoutSessionForBillableProductV1', 'billableProductId', billableProductId);
            const localVarPath = `/v1/subscription/billable-products/{billable_product_id}/checkout`
                .replace(`{${"billable_product_id"}}`, encodeURIComponent(String(billableProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerSessionSecretV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/subscription/customer-session-secret`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionBillableProductsV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/subscription/billable-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPortalV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/subscription/portal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * BillingApi - functional programming interface
 * @export
 */
exports.BillingApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.BillingApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForBillableProductV1(billableProductId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createCheckoutSessionForBillableProductV1(billableProductId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.createCheckoutSessionForBillableProductV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerSessionSecretV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCustomerSessionSecretV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getCustomerSessionSecretV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionBillableProductsV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSubscriptionBillableProductsV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getSubscriptionBillableProductsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPortalV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSubscriptionPortalV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getSubscriptionPortalV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSubscriptionV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getSubscriptionV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * BillingApi - factory interface
 * @export
 */
exports.BillingApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.BillingApiFp(configuration);
    return {
        /**
         *
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForBillableProductV1(billableProductId, options) {
            return localVarFp.createCheckoutSessionForBillableProductV1(billableProductId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerSessionSecretV1(options) {
            return localVarFp.getCustomerSessionSecretV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionBillableProductsV1(options) {
            return localVarFp.getSubscriptionBillableProductsV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPortalV1(options) {
            return localVarFp.getSubscriptionPortalV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionV1(options) {
            return localVarFp.getSubscriptionV1(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
class BillingApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create Checkout Session For Billable Product
     * @param {string} billableProductId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    createCheckoutSessionForBillableProductV1(billableProductId, options) {
        return exports.BillingApiFp(this.configuration).createCheckoutSessionForBillableProductV1(billableProductId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Customer Session Secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getCustomerSessionSecretV1(options) {
        return exports.BillingApiFp(this.configuration).getCustomerSessionSecretV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Subscription Billable Products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getSubscriptionBillableProductsV1(options) {
        return exports.BillingApiFp(this.configuration).getSubscriptionBillableProductsV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Subscription Portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getSubscriptionPortalV1(options) {
        return exports.BillingApiFp(this.configuration).getSubscriptionPortalV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getSubscriptionV1(options) {
        return exports.BillingApiFp(this.configuration).getSubscriptionV1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BillingApi = BillingApi;
/**
 * ConversationProspectLinkApi - axios parameter creator
 * @export
 */
exports.ConversationProspectLinkApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationProspectLinkV1: (conversationId, prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationId' is not null or undefined
            common_1.assertParamExists('createConversationProspectLinkV1', 'conversationId', conversationId);
            // verify required parameter 'prospectId' is not null or undefined
            common_1.assertParamExists('createConversationProspectLinkV1', 'prospectId', prospectId);
            const localVarPath = `/v1/conversations/{conversation_id}/prospects/{prospect_id}/links`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationProspectLinkV1: (conversationId, prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationId' is not null or undefined
            common_1.assertParamExists('deleteConversationProspectLinkV1', 'conversationId', conversationId);
            // verify required parameter 'prospectId' is not null or undefined
            common_1.assertParamExists('deleteConversationProspectLinkV1', 'prospectId', prospectId);
            const localVarPath = `/v1/conversations/{conversation_id}/prospects/{prospect_id}/links`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsOfProspectsV1: (prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectId' is not null or undefined
            common_1.assertParamExists('listConversationsOfProspectsV1', 'prospectId', prospectId);
            const localVarPath = `/v1/prospects/{prospect_id}/conversations`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ConversationProspectLinkApi - functional programming interface
 * @export
 */
exports.ConversationProspectLinkApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ConversationProspectLinkApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationProspectLinkV1(conversationId, prospectId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createConversationProspectLinkV1(conversationId, prospectId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ConversationProspectLinkApi.createConversationProspectLinkV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationProspectLinkV1(conversationId, prospectId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteConversationProspectLinkV1(conversationId, prospectId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ConversationProspectLinkApi.deleteConversationProspectLinkV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsOfProspectsV1(prospectId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listConversationsOfProspectsV1(prospectId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ConversationProspectLinkApi.listConversationsOfProspectsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ConversationProspectLinkApi - factory interface
 * @export
 */
exports.ConversationProspectLinkApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ConversationProspectLinkApiFp(configuration);
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationProspectLinkV1(conversationId, prospectId, options) {
            return localVarFp.createConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationProspectLinkV1(conversationId, prospectId, options) {
            return localVarFp.deleteConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsOfProspectsV1(prospectId, options) {
            return localVarFp.listConversationsOfProspectsV1(prospectId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ConversationProspectLinkApi - object-oriented interface
 * @export
 * @class ConversationProspectLinkApi
 * @extends {BaseAPI}
 */
class ConversationProspectLinkApi extends base_1.BaseAPI {
    /**
     * Create a link between a conversation and a prospect
     * @summary Create a link between a conversation and a prospect
     * @param {string} conversationId ID of the conversation
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    createConversationProspectLinkV1(conversationId, prospectId, options) {
        return exports.ConversationProspectLinkApiFp(this.configuration).createConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a link between a conversation and a prospect
     * @summary Delete a link between a conversation and a prospect
     * @param {string} conversationId ID of the conversation
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    deleteConversationProspectLinkV1(conversationId, prospectId, options) {
        return exports.ConversationProspectLinkApiFp(this.configuration).deleteConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all conversations linked to a specific prospect
     * @summary List all conversations linked to a specific prospect
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    listConversationsOfProspectsV1(prospectId, options) {
        return exports.ConversationProspectLinkApiFp(this.configuration).listConversationsOfProspectsV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ConversationProspectLinkApi = ConversationProspectLinkApi;
/**
 * ConversationsApi - axios parameter creator
 * @export
 */
exports.ConversationsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedbackV1: (conversationId, comment, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationId' is not null or undefined
            common_1.assertParamExists('addFeedbackV1', 'conversationId', conversationId);
            // verify required parameter 'comment' is not null or undefined
            common_1.assertParamExists('addFeedbackV1', 'comment', comment);
            const localVarPath = `/v1/conversations/{conversation_id}/feedback`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(comment, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationV1: (conversationInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationInput' is not null or undefined
            common_1.assertParamExists('createConversationV1', 'conversationInput', conversationInput);
            const localVarPath = `/v1/conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(conversationInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationV1: (conversationId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationId' is not null or undefined
            common_1.assertParamExists('deleteConversationV1', 'conversationId', conversationId);
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationV1: (conversationId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationId' is not null or undefined
            common_1.assertParamExists('getConversationV1', 'conversationId', conversationId);
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Conversations
         * @summary List All Conversations
         * @param {AppEnumInput | null} [app]
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsV1: (app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter instanceof Date) ?
                    updatedAfter.toISOString() :
                    updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore instanceof Date) ?
                    updatedBefore.toISOString() :
                    updatedBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationV1: (conversationId, conversationInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationId' is not null or undefined
            common_1.assertParamExists('updateConversationV1', 'conversationId', conversationId);
            // verify required parameter 'conversationInput' is not null or undefined
            common_1.assertParamExists('updateConversationV1', 'conversationInput', conversationInput);
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(conversationInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ConversationsApi - functional programming interface
 * @export
 */
exports.ConversationsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ConversationsApiAxiosParamCreator(configuration);
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedbackV1(conversationId, comment, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addFeedbackV1(conversationId, comment, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ConversationsApi.addFeedbackV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationV1(conversationInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createConversationV1(conversationInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ConversationsApi.createConversationV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationV1(conversationId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteConversationV1(conversationId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ConversationsApi.deleteConversationV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationV1(conversationId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getConversationV1(conversationId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ConversationsApi.getConversationV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List All Conversations
         * @summary List All Conversations
         * @param {AppEnumInput | null} [app]
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ConversationsApi.listConversationsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationV1(conversationId, conversationInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateConversationV1(conversationId, conversationInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ConversationsApi.updateConversationV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ConversationsApi - factory interface
 * @export
 */
exports.ConversationsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ConversationsApiFp(configuration);
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedbackV1(conversationId, comment, options) {
            return localVarFp.addFeedbackV1(conversationId, comment, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationV1(conversationInput, options) {
            return localVarFp.createConversationV1(conversationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationV1(conversationId, options) {
            return localVarFp.deleteConversationV1(conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationV1(conversationId, options) {
            return localVarFp.getConversationV1(conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Conversations
         * @summary List All Conversations
         * @param {AppEnumInput | null} [app]
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return localVarFp.listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationV1(conversationId, conversationInput, options) {
            return localVarFp.updateConversationV1(conversationId, conversationInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ConversationsApi - object-oriented interface
 * @export
 * @class ConversationsApi
 * @extends {BaseAPI}
 */
class ConversationsApi extends base_1.BaseAPI {
    /**
     * Add Feedback to a Specific Conversation
     * @summary Add Feedback to a Specific Conversation
     * @param {string} conversationId ID of the conversation
     * @param {Comment} comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    addFeedbackV1(conversationId, comment, options) {
        return exports.ConversationsApiFp(this.configuration).addFeedbackV1(conversationId, comment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a New Conversation
     * @summary Create a New Conversation
     * @param {ConversationInput} conversationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    createConversationV1(conversationInput, options) {
        return exports.ConversationsApiFp(this.configuration).createConversationV1(conversationInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Specific Conversation by ID
     * @summary Delete a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    deleteConversationV1(conversationId, options) {
        return exports.ConversationsApiFp(this.configuration).deleteConversationV1(conversationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Specific Conversation by ID
     * @summary Get a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    getConversationV1(conversationId, options) {
        return exports.ConversationsApiFp(this.configuration).getConversationV1(conversationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Conversations
     * @summary List All Conversations
     * @param {AppEnumInput | null} [app]
     * @param {string | null} [searchBy]
     * @param {string | null} [searchValue]
     * @param {string | null} [status]
     * @param {string | null} [sortBy]
     * @param {SortOrder | null} [sortOrder]
     * @param {number | null} [skip]
     * @param {number | null} [limit]
     * @param {string | null} [updatedAfter]
     * @param {string | null} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ConversationsApiFp(this.configuration).listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Specific Conversation by ID
     * @summary Update a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {ConversationInput} conversationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    updateConversationV1(conversationId, conversationInput, options) {
        return exports.ConversationsApiFp(this.configuration).updateConversationV1(conversationId, conversationInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ConversationsApi = ConversationsApi;
/**
 * DataPlaneApi - axios parameter creator
 * @export
 */
exports.DataPlaneApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new connection for an AI Agent to start a voice conversation
         * @summary Create Connection
         * @param {string} agentId
         * @param {ConnectionSource} connectionSource
         * @param {string | null} [prospectId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection: (agentId, connectionSource, prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            common_1.assertParamExists('createConnection', 'agentId', agentId);
            // verify required parameter 'connectionSource' is not null or undefined
            common_1.assertParamExists('createConnection', 'connectionSource', connectionSource);
            const localVarPath = `/v1/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (agentId !== undefined) {
                localVarQueryParameter['agentId'] = agentId;
            }
            if (prospectId !== undefined) {
                localVarQueryParameter['prospect_id'] = prospectId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(connectionSource, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get the audio stream xml for Plivo to start a voice conversation
         * @summary Get Audio Stream XML For Plivo
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlivoAudioStreamXml: (connectionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'connectionId' is not null or undefined
            common_1.assertParamExists('getPlivoAudioStreamXml', 'connectionId', connectionId);
            const localVarPath = `/v1/connections/{connection_id}/plivo-audio-stream-xml`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List connections
         * @summary Listconnections
         * @param {string | null} [sourceName]
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections: (sourceName, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (sourceName !== undefined) {
                localVarQueryParameter['sourceName'] = sourceName;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter instanceof Date) ?
                    updatedAfter.toISOString() :
                    updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore instanceof Date) ?
                    updatedBefore.toISOString() :
                    updatedBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DataPlaneApi - functional programming interface
 * @export
 */
exports.DataPlaneApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.DataPlaneApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a new connection for an AI Agent to start a voice conversation
         * @summary Create Connection
         * @param {string} agentId
         * @param {ConnectionSource} connectionSource
         * @param {string | null} [prospectId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(agentId, connectionSource, prospectId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createConnection(agentId, connectionSource, prospectId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DataPlaneApi.createConnection']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get the audio stream xml for Plivo to start a voice conversation
         * @summary Get Audio Stream XML For Plivo
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlivoAudioStreamXml(connectionId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPlivoAudioStreamXml(connectionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DataPlaneApi.getPlivoAudioStreamXml']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List connections
         * @summary Listconnections
         * @param {string | null} [sourceName]
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections(sourceName, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listConnections(sourceName, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DataPlaneApi.listConnections']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * DataPlaneApi - factory interface
 * @export
 */
exports.DataPlaneApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.DataPlaneApiFp(configuration);
    return {
        /**
         * Create a new connection for an AI Agent to start a voice conversation
         * @summary Create Connection
         * @param {string} agentId
         * @param {ConnectionSource} connectionSource
         * @param {string | null} [prospectId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(agentId, connectionSource, prospectId, options) {
            return localVarFp.createConnection(agentId, connectionSource, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the audio stream xml for Plivo to start a voice conversation
         * @summary Get Audio Stream XML For Plivo
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlivoAudioStreamXml(connectionId, options) {
            return localVarFp.getPlivoAudioStreamXml(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * List connections
         * @summary Listconnections
         * @param {string | null} [sourceName]
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections(sourceName, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return localVarFp.listConnections(sourceName, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DataPlaneApi - object-oriented interface
 * @export
 * @class DataPlaneApi
 * @extends {BaseAPI}
 */
class DataPlaneApi extends base_1.BaseAPI {
    /**
     * Create a new connection for an AI Agent to start a voice conversation
     * @summary Create Connection
     * @param {string} agentId
     * @param {ConnectionSource} connectionSource
     * @param {string | null} [prospectId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPlaneApi
     */
    createConnection(agentId, connectionSource, prospectId, options) {
        return exports.DataPlaneApiFp(this.configuration).createConnection(agentId, connectionSource, prospectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the audio stream xml for Plivo to start a voice conversation
     * @summary Get Audio Stream XML For Plivo
     * @param {string} connectionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPlaneApi
     */
    getPlivoAudioStreamXml(connectionId, options) {
        return exports.DataPlaneApiFp(this.configuration).getPlivoAudioStreamXml(connectionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List connections
     * @summary Listconnections
     * @param {string | null} [sourceName]
     * @param {string | null} [searchBy]
     * @param {string | null} [searchValue]
     * @param {string | null} [status]
     * @param {string | null} [sortBy]
     * @param {SortOrder | null} [sortOrder]
     * @param {number | null} [skip]
     * @param {number | null} [limit]
     * @param {string | null} [updatedAfter]
     * @param {string | null} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPlaneApi
     */
    listConnections(sourceName, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.DataPlaneApiFp(this.configuration).listConnections(sourceName, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DataPlaneApi = DataPlaneApi;
/**
 * FilesApi - axios parameter creator
 * @export
 */
exports.FilesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete files from Trata account
         * @summary Delete Files
         * @param {string} fileIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1: (fileIds, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'fileIds' is not null or undefined
            common_1.assertParamExists('deleteFileV1', 'fileIds', fileIds);
            const localVarPath = `/v1/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (fileIds !== undefined) {
                localVarQueryParameter['file_ids'] = fileIds;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<File>} files
         * @param {UploadFileV1ValidatorEnum} [validator] Validator type to use for file validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1: (files, validator, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'files' is not null or undefined
            common_1.assertParamExists('uploadFileV1', 'files', files);
            const localVarPath = `/v1/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (validator !== undefined) {
                localVarQueryParameter['validator'] = validator;
            }
            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element);
                });
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * FilesApi - functional programming interface
 * @export
 */
exports.FilesApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.FilesApiAxiosParamCreator(configuration);
    return {
        /**
         * Delete files from Trata account
         * @summary Delete Files
         * @param {string} fileIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1(fileIds, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteFileV1(fileIds, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FilesApi.deleteFileV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<File>} files
         * @param {UploadFileV1ValidatorEnum} [validator] Validator type to use for file validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1(files, validator, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadFileV1(files, validator, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FilesApi.uploadFileV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * FilesApi - factory interface
 * @export
 */
exports.FilesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.FilesApiFp(configuration);
    return {
        /**
         * Delete files from Trata account
         * @summary Delete Files
         * @param {string} fileIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1(fileIds, options) {
            return localVarFp.deleteFileV1(fileIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<File>} files
         * @param {UploadFileV1ValidatorEnum} [validator] Validator type to use for file validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1(files, validator, options) {
            return localVarFp.uploadFileV1(files, validator, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
class FilesApi extends base_1.BaseAPI {
    /**
     * Delete files from Trata account
     * @summary Delete Files
     * @param {string} fileIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    deleteFileV1(fileIds, options) {
        return exports.FilesApiFp(this.configuration).deleteFileV1(fileIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload file to Trata account to use in AI Agents
     * @summary Upload Files
     * @param {Array<File>} files
     * @param {UploadFileV1ValidatorEnum} [validator] Validator type to use for file validation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    uploadFileV1(files, validator, options) {
        return exports.FilesApiFp(this.configuration).uploadFileV1(files, validator, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FilesApi = FilesApi;
/**
 * @export
 */
exports.UploadFileV1ValidatorEnum = {
    CampaignProspectSchemaCsv: 'campaign-prospect-schema-csv'
};
/**
 * HealthApi - axios parameter creator
 * @export
 */
exports.HealthApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Heart Beat check to check the health of Trata Backend
         * @summary Heart Beat Status Of Trata Backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatusGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Heart Beat check to check the health of Workflow Service
         * @summary Heart Beat Status Of Workflow Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusWorkflowsStatusGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/workflows/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * HealthApi - functional programming interface
 * @export
 */
exports.HealthApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.HealthApiAxiosParamCreator(configuration);
    return {
        /**
         * Heart Beat check to check the health of Trata Backend
         * @summary Heart Beat Status Of Trata Backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatusGet(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.statusStatusGet(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HealthApi.statusStatusGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Heart Beat check to check the health of Workflow Service
         * @summary Heart Beat Status Of Workflow Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusWorkflowsStatusGet(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.statusWorkflowsStatusGet(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HealthApi.statusWorkflowsStatusGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * HealthApi - factory interface
 * @export
 */
exports.HealthApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.HealthApiFp(configuration);
    return {
        /**
         * Heart Beat check to check the health of Trata Backend
         * @summary Heart Beat Status Of Trata Backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatusGet(options) {
            return localVarFp.statusStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Heart Beat check to check the health of Workflow Service
         * @summary Heart Beat Status Of Workflow Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusWorkflowsStatusGet(options) {
            return localVarFp.statusWorkflowsStatusGet(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
class HealthApi extends base_1.BaseAPI {
    /**
     * Heart Beat check to check the health of Trata Backend
     * @summary Heart Beat Status Of Trata Backend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    statusStatusGet(options) {
        return exports.HealthApiFp(this.configuration).statusStatusGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Heart Beat check to check the health of Workflow Service
     * @summary Heart Beat Status Of Workflow Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    statusWorkflowsStatusGet(options) {
        return exports.HealthApiFp(this.configuration).statusWorkflowsStatusGet(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.HealthApi = HealthApi;
/**
 * HiveApi - axios parameter creator
 * @export
 */
exports.HiveApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1: (hiveContentInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveContentInput' is not null or undefined
            common_1.assertParamExists('createHiveV1', 'hiveContentInput', hiveContentInput);
            const localVarPath = `/v1/hives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(hiveContentInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1: (hiveId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveId' is not null or undefined
            common_1.assertParamExists('deleteHiveV1', 'hiveId', hiveId);
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1: (hiveId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveId' is not null or undefined
            common_1.assertParamExists('getHiveV1', 'hiveId', hiveId);
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Hives
         * @summary List All Hives
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/hives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter instanceof Date) ?
                    updatedAfter.toISOString() :
                    updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore instanceof Date) ?
                    updatedBefore.toISOString() :
                    updatedBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1: (hiveId, hiveContentOutput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveId' is not null or undefined
            common_1.assertParamExists('updateHiveV1', 'hiveId', hiveId);
            // verify required parameter 'hiveContentOutput' is not null or undefined
            common_1.assertParamExists('updateHiveV1', 'hiveContentOutput', hiveContentOutput);
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(hiveContentOutput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * HiveApi - functional programming interface
 * @export
 */
exports.HiveApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.HiveApiAxiosParamCreator(configuration);
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1(hiveContentInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createHiveV1(hiveContentInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HiveApi.createHiveV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1(hiveId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteHiveV1(hiveId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HiveApi.deleteHiveV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1(hiveId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getHiveV1(hiveId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HiveApi.getHiveV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List All Hives
         * @summary List All Hives
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HiveApi.listHivesV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1(hiveId, hiveContentOutput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateHiveV1(hiveId, hiveContentOutput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HiveApi.updateHiveV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * HiveApi - factory interface
 * @export
 */
exports.HiveApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.HiveApiFp(configuration);
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1(hiveContentInput, options) {
            return localVarFp.createHiveV1(hiveContentInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1(hiveId, options) {
            return localVarFp.deleteHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1(hiveId, options) {
            return localVarFp.getHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Hives
         * @summary List All Hives
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return localVarFp.listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1(hiveId, hiveContentOutput, options) {
            return localVarFp.updateHiveV1(hiveId, hiveContentOutput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * HiveApi - object-oriented interface
 * @export
 * @class HiveApi
 * @extends {BaseAPI}
 */
class HiveApi extends base_1.BaseAPI {
    /**
     * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
     * @summary Create a New Hive
     * @param {HiveContentInput} hiveContentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    createHiveV1(hiveContentInput, options) {
        return exports.HiveApiFp(this.configuration).createHiveV1(hiveContentInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Specific Hive by ID
     * @summary Delete a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    deleteHiveV1(hiveId, options) {
        return exports.HiveApiFp(this.configuration).deleteHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Specific Hive by ID
     * @summary Get a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    getHiveV1(hiveId, options) {
        return exports.HiveApiFp(this.configuration).getHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Hives
     * @summary List All Hives
     * @param {string | null} [searchBy]
     * @param {string | null} [searchValue]
     * @param {string | null} [status]
     * @param {string | null} [sortBy]
     * @param {SortOrder | null} [sortOrder]
     * @param {number | null} [skip]
     * @param {number | null} [limit]
     * @param {string | null} [updatedAfter]
     * @param {string | null} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.HiveApiFp(this.configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Specific Hive by ID
     * @summary Update a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {HiveContentOutput} hiveContentOutput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    updateHiveV1(hiveId, hiveContentOutput, options) {
        return exports.HiveApiFp(this.configuration).updateHiveV1(hiveId, hiveContentOutput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.HiveApi = HiveApi;
/**
 * HiveAgentLinkApi - axios parameter creator
 * @export
 */
exports.HiveAgentLinkApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveAgentLinkV1: (hiveId, agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveId' is not null or undefined
            common_1.assertParamExists('createHiveAgentLinkV1', 'hiveId', hiveId);
            // verify required parameter 'agentId' is not null or undefined
            common_1.assertParamExists('createHiveAgentLinkV1', 'agentId', agentId);
            const localVarPath = `/v1/hives/{hive_id}/ai-agents/{agent_id}/link`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveAgentLinkV1: (hiveId, agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveId' is not null or undefined
            common_1.assertParamExists('deleteHiveAgentLinkV1', 'hiveId', hiveId);
            // verify required parameter 'agentId' is not null or undefined
            common_1.assertParamExists('deleteHiveAgentLinkV1', 'agentId', agentId);
            const localVarPath = `/v1/hives/{hive_id}/ai-agents/{agent_id}/link`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfHiveV1: (hiveId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveId' is not null or undefined
            common_1.assertParamExists('listAgentsOfHiveV1', 'hiveId', hiveId);
            const localVarPath = `/v1/hives/{hive_id}/ai-agents`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesOfAgentV1: (agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            common_1.assertParamExists('listHivesOfAgentV1', 'agentId', agentId);
            const localVarPath = `/v1/ai-agents/{agent_id}/hives`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * HiveAgentLinkApi - functional programming interface
 * @export
 */
exports.HiveAgentLinkApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.HiveAgentLinkApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveAgentLinkV1(hiveId, agentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createHiveAgentLinkV1(hiveId, agentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HiveAgentLinkApi.createHiveAgentLinkV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveAgentLinkV1(hiveId, agentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteHiveAgentLinkV1(hiveId, agentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HiveAgentLinkApi.deleteHiveAgentLinkV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfHiveV1(hiveId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAgentsOfHiveV1(hiveId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HiveAgentLinkApi.listAgentsOfHiveV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesOfAgentV1(agentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listHivesOfAgentV1(agentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HiveAgentLinkApi.listHivesOfAgentV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * HiveAgentLinkApi - factory interface
 * @export
 */
exports.HiveAgentLinkApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.HiveAgentLinkApiFp(configuration);
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveAgentLinkV1(hiveId, agentId, options) {
            return localVarFp.createHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveAgentLinkV1(hiveId, agentId, options) {
            return localVarFp.deleteHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfHiveV1(hiveId, options) {
            return localVarFp.listAgentsOfHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesOfAgentV1(agentId, options) {
            return localVarFp.listHivesOfAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * HiveAgentLinkApi - object-oriented interface
 * @export
 * @class HiveAgentLinkApi
 * @extends {BaseAPI}
 */
class HiveAgentLinkApi extends base_1.BaseAPI {
    /**
     * Create a Link Between a Hive and an Agent
     * @summary Create a Link Between a Hive and an Agent
     * @param {string} hiveId ID of the hive
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    createHiveAgentLinkV1(hiveId, agentId, options) {
        return exports.HiveAgentLinkApiFp(this.configuration).createHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Link Between a Hive and an Agent
     * @summary Delete a Link Between a Hive and an Agent
     * @param {string} hiveId ID of the hive
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    deleteHiveAgentLinkV1(hiveId, agentId, options) {
        return exports.HiveAgentLinkApiFp(this.configuration).deleteHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Agents Linked to a Specific Hive
     * @summary List All Agents Linked to a Specific Hive
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    listAgentsOfHiveV1(hiveId, options) {
        return exports.HiveAgentLinkApiFp(this.configuration).listAgentsOfHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Hives Linked to a Specific Agent
     * @summary List All Hives Linked to a Specific Agent
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    listHivesOfAgentV1(agentId, options) {
        return exports.HiveAgentLinkApiFp(this.configuration).listHivesOfAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.HiveAgentLinkApi = HiveAgentLinkApi;
/**
 * InternalApi - axios parameter creator
 * @export
 */
exports.InternalApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteV1: (acceptInviteRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'acceptInviteRequest' is not null or undefined
            common_1.assertParamExists('acceptInviteV1', 'acceptInviteRequest', acceptInviteRequest);
            const localVarPath = `/v1/invites/accept`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(acceptInviteRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationV1: (bodyCreateOrganizationV1, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'bodyCreateOrganizationV1' is not null or undefined
            common_1.assertParamExists('createOrganizationV1', 'bodyCreateOrganizationV1', bodyCreateOrganizationV1);
            const localVarPath = `/v1/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(bodyCreateOrganizationV1, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new user
         * @summary Createuser
         * @param {UserPayload} userPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserV1: (userPayload, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userPayload' is not null or undefined
            common_1.assertParamExists('createUserV1', 'userPayload', userPayload);
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(userPayload, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1: (userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('deleteUserV1', 'userId', userId);
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get customer credits
         * @summary Get Customer Credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCreditsV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/customers/credits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get customer pricing
         * @summary Get Customer Pricing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerPricingV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/customers/pricing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Getorganizationbranding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBrandingV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/organizations/branding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Getuserbyid
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIdV1: (userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('getUserByIdV1', 'userId', userId);
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter instanceof Date) ?
                    updatedAfter.toISOString() :
                    updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore instanceof Date) ?
                    updatedBefore.toISOString() :
                    updatedBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {boolean} [showResellerOwner] Show owner users
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersV1: (showResellerOwner, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (showResellerOwner !== undefined) {
                localVarQueryParameter['showResellerOwner'] = showResellerOwner;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter instanceof Date) ?
                    updatedAfter.toISOString() :
                    updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore instanceof Date) ?
                    updatedBefore.toISOString() :
                    updatedBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput
         * @param {SendInviteV1AppEnum} [app] The app to use for the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInviteV1: (guestInput, app, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'guestInput' is not null or undefined
            common_1.assertParamExists('sendInviteV1', 'guestInput', guestInput);
            const localVarPath = `/v1/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(guestInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationV1: (orgId, organizationInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'orgId' is not null or undefined
            common_1.assertParamExists('updateOrganizationV1', 'orgId', orgId);
            // verify required parameter 'organizationInput' is not null or undefined
            common_1.assertParamExists('updateOrganizationV1', 'organizationInput', organizationInput);
            const localVarPath = `/v1/organizations/{org_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(organizationInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId
         * @param {UserPayload} userPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1: (userId, userPayload, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('updateUserV1', 'userId', userId);
            // verify required parameter 'userPayload' is not null or undefined
            common_1.assertParamExists('updateUserV1', 'userPayload', userPayload);
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(userPayload, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * InternalApi - functional programming interface
 * @export
 */
exports.InternalApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.InternalApiAxiosParamCreator(configuration);
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteV1(acceptInviteRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.acceptInviteV1(acceptInviteRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InternalApi.acceptInviteV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationV1(bodyCreateOrganizationV1, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createOrganizationV1(bodyCreateOrganizationV1, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InternalApi.createOrganizationV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a new user
         * @summary Createuser
         * @param {UserPayload} userPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserV1(userPayload, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createUserV1(userPayload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InternalApi.createUserV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteOrganizationV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InternalApi.deleteOrganizationV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1(userId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUserV1(userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InternalApi.deleteUserV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get customer credits
         * @summary Get Customer Credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCreditsV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCustomerCreditsV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InternalApi.getCustomerCreditsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get customer pricing
         * @summary Get Customer Pricing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerPricingV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCustomerPricingV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InternalApi.getCustomerPricingV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Getorganizationbranding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBrandingV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganizationBrandingV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InternalApi.getOrganizationBrandingV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganizationV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InternalApi.getOrganizationV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Getuserbyid
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIdV1(userId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserByIdV1(userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InternalApi.getUserByIdV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InternalApi.listInvitesV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {boolean} [showResellerOwner] Show owner users
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersV1(showResellerOwner, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listUsersV1(showResellerOwner, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InternalApi.listUsersV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput
         * @param {SendInviteV1AppEnum} [app] The app to use for the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInviteV1(guestInput, app, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.sendInviteV1(guestInput, app, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InternalApi.sendInviteV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationV1(orgId, organizationInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateOrganizationV1(orgId, organizationInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InternalApi.updateOrganizationV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId
         * @param {UserPayload} userPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1(userId, userPayload, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserV1(userId, userPayload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InternalApi.updateUserV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * InternalApi - factory interface
 * @export
 */
exports.InternalApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.InternalApiFp(configuration);
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteV1(acceptInviteRequest, options) {
            return localVarFp.acceptInviteV1(acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationV1(bodyCreateOrganizationV1, options) {
            return localVarFp.createOrganizationV1(bodyCreateOrganizationV1, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user
         * @summary Createuser
         * @param {UserPayload} userPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserV1(userPayload, options) {
            return localVarFp.createUserV1(userPayload, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationV1(options) {
            return localVarFp.deleteOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1(userId, options) {
            return localVarFp.deleteUserV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get customer credits
         * @summary Get Customer Credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCreditsV1(options) {
            return localVarFp.getCustomerCreditsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get customer pricing
         * @summary Get Customer Pricing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerPricingV1(options) {
            return localVarFp.getCustomerPricingV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Getorganizationbranding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBrandingV1(options) {
            return localVarFp.getOrganizationBrandingV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationV1(options) {
            return localVarFp.getOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Getuserbyid
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIdV1(userId, options) {
            return localVarFp.getUserByIdV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return localVarFp.listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {boolean} [showResellerOwner] Show owner users
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersV1(showResellerOwner, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return localVarFp.listUsersV1(showResellerOwner, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput
         * @param {SendInviteV1AppEnum} [app] The app to use for the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInviteV1(guestInput, app, options) {
            return localVarFp.sendInviteV1(guestInput, app, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationV1(orgId, organizationInput, options) {
            return localVarFp.updateOrganizationV1(orgId, organizationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId
         * @param {UserPayload} userPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1(userId, userPayload, options) {
            return localVarFp.updateUserV1(userId, userPayload, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
class InternalApi extends base_1.BaseAPI {
    /**
     * Accept invite and add new user to organization
     * @summary Acceptinvite
     * @param {AcceptInviteRequest} acceptInviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    acceptInviteV1(acceptInviteRequest, options) {
        return exports.InternalApiFp(this.configuration).acceptInviteV1(acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new organization and adds the user as the \"ADMIN\" user for the org
     * @summary Createorganization
     * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    createOrganizationV1(bodyCreateOrganizationV1, options) {
        return exports.InternalApiFp(this.configuration).createOrganizationV1(bodyCreateOrganizationV1, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new user
     * @summary Createuser
     * @param {UserPayload} userPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    createUserV1(userPayload, options) {
        return exports.InternalApiFp(this.configuration).createUserV1(userPayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deleteorganization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    deleteOrganizationV1(options) {
        return exports.InternalApiFp(this.configuration).deleteOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a user
     * @summary Deleteuser
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    deleteUserV1(userId, options) {
        return exports.InternalApiFp(this.configuration).deleteUserV1(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get customer credits
     * @summary Get Customer Credits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    getCustomerCreditsV1(options) {
        return exports.InternalApiFp(this.configuration).getCustomerCreditsV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get customer pricing
     * @summary Get Customer Pricing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    getCustomerPricingV1(options) {
        return exports.InternalApiFp(this.configuration).getCustomerPricingV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Getorganizationbranding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    getOrganizationBrandingV1(options) {
        return exports.InternalApiFp(this.configuration).getOrganizationBrandingV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Getorganization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    getOrganizationV1(options) {
        return exports.InternalApiFp(this.configuration).getOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Getuserbyid
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    getUserByIdV1(userId, options) {
        return exports.InternalApiFp(this.configuration).getUserByIdV1(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List of all open invites from the organization
     * @summary Listinvites
     * @param {string | null} [searchBy]
     * @param {string | null} [searchValue]
     * @param {string | null} [status]
     * @param {string | null} [sortBy]
     * @param {SortOrder | null} [sortOrder]
     * @param {number | null} [skip]
     * @param {number | null} [limit]
     * @param {string | null} [updatedAfter]
     * @param {string | null} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.InternalApiFp(this.configuration).listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all users under the user\'s organization
     * @summary Listusers
     * @param {boolean} [showResellerOwner] Show owner users
     * @param {string | null} [searchBy]
     * @param {string | null} [searchValue]
     * @param {string | null} [status]
     * @param {string | null} [sortBy]
     * @param {SortOrder | null} [sortOrder]
     * @param {number | null} [skip]
     * @param {number | null} [limit]
     * @param {string | null} [updatedAfter]
     * @param {string | null} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    listUsersV1(showResellerOwner, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.InternalApiFp(this.configuration).listUsersV1(showResellerOwner, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Invite a new user to an organization or resend invite to the user if the user is already invited
     * @summary Inviteusers
     * @param {GuestInput} guestInput
     * @param {SendInviteV1AppEnum} [app] The app to use for the invite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    sendInviteV1(guestInput, app, options) {
        return exports.InternalApiFp(this.configuration).sendInviteV1(guestInput, app, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updateorganization
     * @param {string} orgId ID of the organization
     * @param {OrganizationInput} organizationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    updateOrganizationV1(orgId, organizationInput, options) {
        return exports.InternalApiFp(this.configuration).updateOrganizationV1(orgId, organizationInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update user details
     * @summary Updateuser
     * @param {string} userId
     * @param {UserPayload} userPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    updateUserV1(userId, userPayload, options) {
        return exports.InternalApiFp(this.configuration).updateUserV1(userId, userPayload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.InternalApi = InternalApi;
/**
 * @export
 */
exports.SendInviteV1AppEnum = {
    Trata: 'trata',
    Sparr: 'sparr'
};
/**
 * ProductsApi - axios parameter creator
 * @export
 */
exports.ProductsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductV1: (productInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productInput' is not null or undefined
            common_1.assertParamExists('createProductV1', 'productInput', productInput);
            const localVarPath = `/v1/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(productInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductV1: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            common_1.assertParamExists('deleteProductV1', 'productId', productId);
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductV1: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            common_1.assertParamExists('getProductV1', 'productId', productId);
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfProductV1: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            common_1.assertParamExists('listAgentsOfProductV1', 'productId', productId);
            const localVarPath = `/v1/products/{product_id}/agents`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Products
         * @summary List All Products
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {string | null} [tags]
         * @param {string | null} [productIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter instanceof Date) ?
                    updatedAfter.toISOString() :
                    updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore instanceof Date) ?
                    updatedBefore.toISOString() :
                    updatedBefore;
            }
            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }
            if (productIds !== undefined) {
                localVarQueryParameter['product_ids'] = productIds;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductV1: (productId, productInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            common_1.assertParamExists('updateProductV1', 'productId', productId);
            // verify required parameter 'productInput' is not null or undefined
            common_1.assertParamExists('updateProductV1', 'productInput', productInput);
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(productInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ProductsApi - functional programming interface
 * @export
 */
exports.ProductsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ProductsApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductV1(productInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createProductV1(productInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProductsApi.createProductV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductV1(productId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteProductV1(productId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProductsApi.deleteProductV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductV1(productId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getProductV1(productId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProductsApi.getProductV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfProductV1(productId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAgentsOfProductV1(productId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProductsApi.listAgentsOfProductV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List All Products
         * @summary List All Products
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {string | null} [tags]
         * @param {string | null} [productIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProductsApi.listProductsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductV1(productId, productInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateProductV1(productId, productInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProductsApi.updateProductV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ProductsApi - factory interface
 * @export
 */
exports.ProductsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ProductsApiFp(configuration);
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductV1(productInput, options) {
            return localVarFp.createProductV1(productInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductV1(productId, options) {
            return localVarFp.deleteProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductV1(productId, options) {
            return localVarFp.getProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfProductV1(productId, options) {
            return localVarFp.listAgentsOfProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Products
         * @summary List All Products
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {string | null} [tags]
         * @param {string | null} [productIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options) {
            return localVarFp.listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductV1(productId, productInput, options) {
            return localVarFp.updateProductV1(productId, productInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
class ProductsApi extends base_1.BaseAPI {
    /**
     * Create a New Product
     * @summary Create a New Product
     * @param {ProductInput} productInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    createProductV1(productInput, options) {
        return exports.ProductsApiFp(this.configuration).createProductV1(productInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Specific Product by ID
     * @summary Delete a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    deleteProductV1(productId, options) {
        return exports.ProductsApiFp(this.configuration).deleteProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Specific Product by ID
     * @summary Get a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getProductV1(productId, options) {
        return exports.ProductsApiFp(this.configuration).getProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Agents Linked to a Specific Product
     * @summary List All Agents Linked to a Specific Product
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    listAgentsOfProductV1(productId, options) {
        return exports.ProductsApiFp(this.configuration).listAgentsOfProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Products
     * @summary List All Products
     * @param {string | null} [searchBy]
     * @param {string | null} [searchValue]
     * @param {string | null} [status]
     * @param {string | null} [sortBy]
     * @param {SortOrder | null} [sortOrder]
     * @param {number | null} [skip]
     * @param {number | null} [limit]
     * @param {string | null} [updatedAfter]
     * @param {string | null} [updatedBefore]
     * @param {string | null} [tags]
     * @param {string | null} [productIds]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options) {
        return exports.ProductsApiFp(this.configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Specific Product by ID
     * @summary Update a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {ProductInput} productInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    updateProductV1(productId, productInput, options) {
        return exports.ProductsApiFp(this.configuration).updateProductV1(productId, productInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProductsApi = ProductsApi;
/**
 * ProspectsApi - axios parameter creator
 * @export
 */
exports.ProspectsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProspectV1: (prospectInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectInput' is not null or undefined
            common_1.assertParamExists('createProspectV1', 'prospectInput', prospectInput);
            const localVarPath = `/v1/prospects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(prospectInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProspectV1: (prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectId' is not null or undefined
            common_1.assertParamExists('deleteProspectV1', 'prospectId', prospectId);
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProspectV1: (prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectId' is not null or undefined
            common_1.assertParamExists('getProspectV1', 'prospectId', prospectId);
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Prospects
         * @summary List All Prospects
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProspectsV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/prospects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter instanceof Date) ?
                    updatedAfter.toISOString() :
                    updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore instanceof Date) ?
                    updatedBefore.toISOString() :
                    updatedBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProspectV1: (prospectId, prospectInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectId' is not null or undefined
            common_1.assertParamExists('updateProspectV1', 'prospectId', prospectId);
            // verify required parameter 'prospectInput' is not null or undefined
            common_1.assertParamExists('updateProspectV1', 'prospectInput', prospectInput);
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(prospectInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ProspectsApi - functional programming interface
 * @export
 */
exports.ProspectsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ProspectsApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProspectV1(prospectInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createProspectV1(prospectInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProspectsApi.createProspectV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProspectV1(prospectId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteProspectV1(prospectId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProspectsApi.deleteProspectV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProspectV1(prospectId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getProspectV1(prospectId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProspectsApi.getProspectV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List All Prospects
         * @summary List All Prospects
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProspectsApi.listProspectsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProspectV1(prospectId, prospectInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateProspectV1(prospectId, prospectInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProspectsApi.updateProspectV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ProspectsApi - factory interface
 * @export
 */
exports.ProspectsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ProspectsApiFp(configuration);
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProspectV1(prospectInput, options) {
            return localVarFp.createProspectV1(prospectInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProspectV1(prospectId, options) {
            return localVarFp.deleteProspectV1(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProspectV1(prospectId, options) {
            return localVarFp.getProspectV1(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Prospects
         * @summary List All Prospects
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return localVarFp.listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProspectV1(prospectId, prospectInput, options) {
            return localVarFp.updateProspectV1(prospectId, prospectInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProspectsApi - object-oriented interface
 * @export
 * @class ProspectsApi
 * @extends {BaseAPI}
 */
class ProspectsApi extends base_1.BaseAPI {
    /**
     * Create a New Prospect
     * @summary Create a New Prospect
     * @param {ProspectInput} prospectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    createProspectV1(prospectInput, options) {
        return exports.ProspectsApiFp(this.configuration).createProspectV1(prospectInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Specific Prospect by ID
     * @summary Delete a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    deleteProspectV1(prospectId, options) {
        return exports.ProspectsApiFp(this.configuration).deleteProspectV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Specific Prospect by ID
     * @summary Get a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    getProspectV1(prospectId, options) {
        return exports.ProspectsApiFp(this.configuration).getProspectV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Prospects
     * @summary List All Prospects
     * @param {string | null} [searchBy]
     * @param {string | null} [searchValue]
     * @param {string | null} [status]
     * @param {string | null} [sortBy]
     * @param {SortOrder | null} [sortOrder]
     * @param {number | null} [skip]
     * @param {number | null} [limit]
     * @param {string | null} [updatedAfter]
     * @param {string | null} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ProspectsApiFp(this.configuration).listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Specific Prospect by ID
     * @summary Update a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {ProspectInput} prospectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    updateProspectV1(prospectId, prospectInput, options) {
        return exports.ProspectsApiFp(this.configuration).updateProspectV1(prospectId, prospectInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProspectsApi = ProspectsApi;
/**
 * ResellerCourseAssignmentsApi - axios parameter creator
 * @export
 */
exports.ResellerCourseAssignmentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Assign or remove courses for reseller customers
         * @summary Change Reseller Course Assignments
         * @param {ChangeAssignmentRequest} changeAssignmentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeResellerCourseAssignmentsV1: (changeAssignmentRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'changeAssignmentRequest' is not null or undefined
            common_1.assertParamExists('changeResellerCourseAssignmentsV1', 'changeAssignmentRequest', changeAssignmentRequest);
            const localVarPath = `/v1/resellers/course-assignments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(changeAssignmentRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all courses that have been assigned to a specific customer
         * @summary Get Assigned Courses By Customer V1
         * @param {string} customerOrgId
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedCoursesByCustomerV1: (customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('getAssignedCoursesByCustomerV1', 'customerOrgId', customerOrgId);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/courses`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter instanceof Date) ?
                    updatedAfter.toISOString() :
                    updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore instanceof Date) ?
                    updatedBefore.toISOString() :
                    updatedBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all customers with their course assignment status
         * @summary Get Customers By Assigned Course V1
         * @param {string} courseId
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersByAssignedCourseV1: (courseId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            common_1.assertParamExists('getCustomersByAssignedCourseV1', 'courseId', courseId);
            const localVarPath = `/v1/resellers/courses/{course_id}/customers`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter instanceof Date) ?
                    updatedAfter.toISOString() :
                    updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore instanceof Date) ?
                    updatedBefore.toISOString() :
                    updatedBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerCourseAssignmentsApi - functional programming interface
 * @export
 */
exports.ResellerCourseAssignmentsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ResellerCourseAssignmentsApiAxiosParamCreator(configuration);
    return {
        /**
         * Assign or remove courses for reseller customers
         * @summary Change Reseller Course Assignments
         * @param {ChangeAssignmentRequest} changeAssignmentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeResellerCourseAssignmentsV1(changeAssignmentRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.changeResellerCourseAssignmentsV1(changeAssignmentRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCourseAssignmentsApi.changeResellerCourseAssignmentsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all courses that have been assigned to a specific customer
         * @summary Get Assigned Courses By Customer V1
         * @param {string} customerOrgId
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedCoursesByCustomerV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAssignedCoursesByCustomerV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCourseAssignmentsApi.getAssignedCoursesByCustomerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all customers with their course assignment status
         * @summary Get Customers By Assigned Course V1
         * @param {string} courseId
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersByAssignedCourseV1(courseId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCustomersByAssignedCourseV1(courseId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCourseAssignmentsApi.getCustomersByAssignedCourseV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ResellerCourseAssignmentsApi - factory interface
 * @export
 */
exports.ResellerCourseAssignmentsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ResellerCourseAssignmentsApiFp(configuration);
    return {
        /**
         * Assign or remove courses for reseller customers
         * @summary Change Reseller Course Assignments
         * @param {ChangeAssignmentRequest} changeAssignmentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeResellerCourseAssignmentsV1(changeAssignmentRequest, options) {
            return localVarFp.changeResellerCourseAssignmentsV1(changeAssignmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all courses that have been assigned to a specific customer
         * @summary Get Assigned Courses By Customer V1
         * @param {string} customerOrgId
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedCoursesByCustomerV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return localVarFp.getAssignedCoursesByCustomerV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all customers with their course assignment status
         * @summary Get Customers By Assigned Course V1
         * @param {string} courseId
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersByAssignedCourseV1(courseId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return localVarFp.getCustomersByAssignedCourseV1(courseId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerCourseAssignmentsApi - object-oriented interface
 * @export
 * @class ResellerCourseAssignmentsApi
 * @extends {BaseAPI}
 */
class ResellerCourseAssignmentsApi extends base_1.BaseAPI {
    /**
     * Assign or remove courses for reseller customers
     * @summary Change Reseller Course Assignments
     * @param {ChangeAssignmentRequest} changeAssignmentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCourseAssignmentsApi
     */
    changeResellerCourseAssignmentsV1(changeAssignmentRequest, options) {
        return exports.ResellerCourseAssignmentsApiFp(this.configuration).changeResellerCourseAssignmentsV1(changeAssignmentRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all courses that have been assigned to a specific customer
     * @summary Get Assigned Courses By Customer V1
     * @param {string} customerOrgId
     * @param {string | null} [searchBy]
     * @param {string | null} [searchValue]
     * @param {string | null} [status]
     * @param {string | null} [sortBy]
     * @param {SortOrder | null} [sortOrder]
     * @param {number | null} [skip]
     * @param {number | null} [limit]
     * @param {string | null} [updatedAfter]
     * @param {string | null} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCourseAssignmentsApi
     */
    getAssignedCoursesByCustomerV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ResellerCourseAssignmentsApiFp(this.configuration).getAssignedCoursesByCustomerV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all customers with their course assignment status
     * @summary Get Customers By Assigned Course V1
     * @param {string} courseId
     * @param {string | null} [searchBy]
     * @param {string | null} [searchValue]
     * @param {string | null} [status]
     * @param {string | null} [sortBy]
     * @param {SortOrder | null} [sortOrder]
     * @param {number | null} [skip]
     * @param {number | null} [limit]
     * @param {string | null} [updatedAfter]
     * @param {string | null} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCourseAssignmentsApi
     */
    getCustomersByAssignedCourseV1(courseId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ResellerCourseAssignmentsApiFp(this.configuration).getCustomersByAssignedCourseV1(courseId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerCourseAssignmentsApi = ResellerCourseAssignmentsApi;
/**
 * ResellerCustomerApi - axios parameter creator
 * @export
 */
exports.ResellerCustomerApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new customer organization under a reseller organization
         * @summary Create Customer V1
         * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerOrganizationV1: (bodyCreateCustomerOrganizationV1, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'bodyCreateCustomerOrganizationV1' is not null or undefined
            common_1.assertParamExists('createCustomerOrganizationV1', 'bodyCreateCustomerOrganizationV1', bodyCreateCustomerOrganizationV1);
            const localVarPath = `/v1/resellers/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(bodyCreateCustomerOrganizationV1, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a reseller\'s customer and all associated data
         * @summary Delete Customer V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerCustomerV1: (customerOrgId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('deleteResellerCustomerV1', 'customerOrgId', customerOrgId);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get the basic credentials of a customer organization under a reseller organization.
         * @summary Get Customer Basic Credentials V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerBasicCredentialsV1: (customerOrgId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('getCustomerBasicCredentialsV1', 'customerOrgId', customerOrgId);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/basic_credentials`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
         * @summary Get Customer Credentials V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCredentialsV1: (customerOrgId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('getCustomerCredentialsV1', 'customerOrgId', customerOrgId);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/credentials`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get reseller customer by id
         * @summary Get Reseller Customer By Id V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerByIdV1: (customerOrgId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('getResellerCustomerByIdV1', 'customerOrgId', customerOrgId);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List reseller customers with prices, users and credits
         * @summary List Reseller Customers V1
         * @param {string | null} [searchQuery] Search query
         * @param {boolean | null} [expandPrices] Whether to expand the prices
         * @param {boolean | null} [expandUsers] Whether to expand the users
         * @param {boolean | null} [expandCredits] Whether to expand the credits
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerCustomersV1: (searchQuery, expandPrices, expandUsers, expandCredits, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (searchQuery !== undefined) {
                localVarQueryParameter['search_query'] = searchQuery;
            }
            if (expandPrices !== undefined) {
                localVarQueryParameter['expand_prices'] = expandPrices;
            }
            if (expandUsers !== undefined) {
                localVarQueryParameter['expand_users'] = expandUsers;
            }
            if (expandCredits !== undefined) {
                localVarQueryParameter['expand_credits'] = expandCredits;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter instanceof Date) ?
                    updatedAfter.toISOString() :
                    updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore instanceof Date) ?
                    updatedBefore.toISOString() :
                    updatedBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a customer organization under a reseller organization
         * @summary Update Customer V1
         * @param {string} customerOrgId
         * @param {OrganizationInput} organizationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerOrganizationV1: (customerOrgId, organizationInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('updateCustomerOrganizationV1', 'customerOrgId', customerOrgId);
            // verify required parameter 'organizationInput' is not null or undefined
            common_1.assertParamExists('updateCustomerOrganizationV1', 'organizationInput', organizationInput);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(organizationInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerCustomerApi - functional programming interface
 * @export
 */
exports.ResellerCustomerApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ResellerCustomerApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates a new customer organization under a reseller organization
         * @summary Create Customer V1
         * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerApi.createCustomerOrganizationV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a reseller\'s customer and all associated data
         * @summary Delete Customer V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerCustomerV1(customerOrgId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteResellerCustomerV1(customerOrgId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerApi.deleteResellerCustomerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get the basic credentials of a customer organization under a reseller organization.
         * @summary Get Customer Basic Credentials V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerBasicCredentialsV1(customerOrgId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCustomerBasicCredentialsV1(customerOrgId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerApi.getCustomerBasicCredentialsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
         * @summary Get Customer Credentials V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCredentialsV1(customerOrgId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCustomerCredentialsV1(customerOrgId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerApi.getCustomerCredentialsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get reseller customer by id
         * @summary Get Reseller Customer By Id V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerByIdV1(customerOrgId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getResellerCustomerByIdV1(customerOrgId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerApi.getResellerCustomerByIdV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List reseller customers with prices, users and credits
         * @summary List Reseller Customers V1
         * @param {string | null} [searchQuery] Search query
         * @param {boolean | null} [expandPrices] Whether to expand the prices
         * @param {boolean | null} [expandUsers] Whether to expand the users
         * @param {boolean | null} [expandCredits] Whether to expand the credits
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerCustomersV1(searchQuery, expandPrices, expandUsers, expandCredits, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listResellerCustomersV1(searchQuery, expandPrices, expandUsers, expandCredits, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerApi.listResellerCustomersV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a customer organization under a reseller organization
         * @summary Update Customer V1
         * @param {string} customerOrgId
         * @param {OrganizationInput} organizationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerOrganizationV1(customerOrgId, organizationInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateCustomerOrganizationV1(customerOrgId, organizationInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerApi.updateCustomerOrganizationV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ResellerCustomerApi - factory interface
 * @export
 */
exports.ResellerCustomerApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ResellerCustomerApiFp(configuration);
    return {
        /**
         * Creates a new customer organization under a reseller organization
         * @summary Create Customer V1
         * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options) {
            return localVarFp.createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a reseller\'s customer and all associated data
         * @summary Delete Customer V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerCustomerV1(customerOrgId, options) {
            return localVarFp.deleteResellerCustomerV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the basic credentials of a customer organization under a reseller organization.
         * @summary Get Customer Basic Credentials V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerBasicCredentialsV1(customerOrgId, options) {
            return localVarFp.getCustomerBasicCredentialsV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
         * @summary Get Customer Credentials V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCredentialsV1(customerOrgId, options) {
            return localVarFp.getCustomerCredentialsV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get reseller customer by id
         * @summary Get Reseller Customer By Id V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerByIdV1(customerOrgId, options) {
            return localVarFp.getResellerCustomerByIdV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * List reseller customers with prices, users and credits
         * @summary List Reseller Customers V1
         * @param {string | null} [searchQuery] Search query
         * @param {boolean | null} [expandPrices] Whether to expand the prices
         * @param {boolean | null} [expandUsers] Whether to expand the users
         * @param {boolean | null} [expandCredits] Whether to expand the credits
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerCustomersV1(searchQuery, expandPrices, expandUsers, expandCredits, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return localVarFp.listResellerCustomersV1(searchQuery, expandPrices, expandUsers, expandCredits, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a customer organization under a reseller organization
         * @summary Update Customer V1
         * @param {string} customerOrgId
         * @param {OrganizationInput} organizationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerOrganizationV1(customerOrgId, organizationInput, options) {
            return localVarFp.updateCustomerOrganizationV1(customerOrgId, organizationInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerCustomerApi - object-oriented interface
 * @export
 * @class ResellerCustomerApi
 * @extends {BaseAPI}
 */
class ResellerCustomerApi extends base_1.BaseAPI {
    /**
     * Creates a new customer organization under a reseller organization
     * @summary Create Customer V1
     * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options) {
        return exports.ResellerCustomerApiFp(this.configuration).createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a reseller\'s customer and all associated data
     * @summary Delete Customer V1
     * @param {string} customerOrgId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    deleteResellerCustomerV1(customerOrgId, options) {
        return exports.ResellerCustomerApiFp(this.configuration).deleteResellerCustomerV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the basic credentials of a customer organization under a reseller organization.
     * @summary Get Customer Basic Credentials V1
     * @param {string} customerOrgId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    getCustomerBasicCredentialsV1(customerOrgId, options) {
        return exports.ResellerCustomerApiFp(this.configuration).getCustomerBasicCredentialsV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
     * @summary Get Customer Credentials V1
     * @param {string} customerOrgId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    getCustomerCredentialsV1(customerOrgId, options) {
        return exports.ResellerCustomerApiFp(this.configuration).getCustomerCredentialsV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get reseller customer by id
     * @summary Get Reseller Customer By Id V1
     * @param {string} customerOrgId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    getResellerCustomerByIdV1(customerOrgId, options) {
        return exports.ResellerCustomerApiFp(this.configuration).getResellerCustomerByIdV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List reseller customers with prices, users and credits
     * @summary List Reseller Customers V1
     * @param {string | null} [searchQuery] Search query
     * @param {boolean | null} [expandPrices] Whether to expand the prices
     * @param {boolean | null} [expandUsers] Whether to expand the users
     * @param {boolean | null} [expandCredits] Whether to expand the credits
     * @param {string | null} [searchBy]
     * @param {string | null} [searchValue]
     * @param {string | null} [status]
     * @param {string | null} [sortBy]
     * @param {SortOrder | null} [sortOrder]
     * @param {number | null} [skip]
     * @param {number | null} [limit]
     * @param {string | null} [updatedAfter]
     * @param {string | null} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    listResellerCustomersV1(searchQuery, expandPrices, expandUsers, expandCredits, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ResellerCustomerApiFp(this.configuration).listResellerCustomersV1(searchQuery, expandPrices, expandUsers, expandCredits, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a customer organization under a reseller organization
     * @summary Update Customer V1
     * @param {string} customerOrgId
     * @param {OrganizationInput} organizationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    updateCustomerOrganizationV1(customerOrgId, organizationInput, options) {
        return exports.ResellerCustomerApiFp(this.configuration).updateCustomerOrganizationV1(customerOrgId, organizationInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerCustomerApi = ResellerCustomerApi;
/**
 * ResellerCustomerAuditLogsApi - axios parameter creator
 * @export
 */
exports.ResellerCustomerAuditLogsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get Reseller Customer Audit Logs
         * @param {string} customerOrgId
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet: (customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet', 'customerOrgId', customerOrgId);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/audit-logs`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter instanceof Date) ?
                    updatedAfter.toISOString() :
                    updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore instanceof Date) ?
                    updatedBefore.toISOString() :
                    updatedBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerCustomerAuditLogsApi - functional programming interface
 * @export
 */
exports.ResellerCustomerAuditLogsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ResellerCustomerAuditLogsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get Reseller Customer Audit Logs
         * @param {string} customerOrgId
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerAuditLogsApi.getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ResellerCustomerAuditLogsApi - factory interface
 * @export
 */
exports.ResellerCustomerAuditLogsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ResellerCustomerAuditLogsApiFp(configuration);
    return {
        /**
         *
         * @summary Get Reseller Customer Audit Logs
         * @param {string} customerOrgId
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return localVarFp.getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerCustomerAuditLogsApi - object-oriented interface
 * @export
 * @class ResellerCustomerAuditLogsApi
 * @extends {BaseAPI}
 */
class ResellerCustomerAuditLogsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get Reseller Customer Audit Logs
     * @param {string} customerOrgId
     * @param {string | null} [searchBy]
     * @param {string | null} [searchValue]
     * @param {string | null} [status]
     * @param {string | null} [sortBy]
     * @param {SortOrder | null} [sortOrder]
     * @param {number | null} [skip]
     * @param {number | null} [limit]
     * @param {string | null} [updatedAfter]
     * @param {string | null} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerAuditLogsApi
     */
    getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ResellerCustomerAuditLogsApiFp(this.configuration).getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerCustomerAuditLogsApi = ResellerCustomerAuditLogsApi;
/**
 * ResellerCustomerCheckoutApi - axios parameter creator
 * @export
 */
exports.ResellerCustomerCheckoutApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a checkout session for a reseller customer
         * @summary Create Checkout Session For Reseller Customer
         * @param {string} customerOrgId
         * @param {string} priceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForResellerCustomerV1: (customerOrgId, priceId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('createCheckoutSessionForResellerCustomerV1', 'customerOrgId', customerOrgId);
            // verify required parameter 'priceId' is not null or undefined
            common_1.assertParamExists('createCheckoutSessionForResellerCustomerV1', 'priceId', priceId);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/pricing/{price_id}/checkout`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"price_id"}}`, encodeURIComponent(String(priceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerCustomerCheckoutApi - functional programming interface
 * @export
 */
exports.ResellerCustomerCheckoutApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ResellerCustomerCheckoutApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a checkout session for a reseller customer
         * @summary Create Checkout Session For Reseller Customer
         * @param {string} customerOrgId
         * @param {string} priceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForResellerCustomerV1(customerOrgId, priceId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createCheckoutSessionForResellerCustomerV1(customerOrgId, priceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerCheckoutApi.createCheckoutSessionForResellerCustomerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ResellerCustomerCheckoutApi - factory interface
 * @export
 */
exports.ResellerCustomerCheckoutApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ResellerCustomerCheckoutApiFp(configuration);
    return {
        /**
         * Create a checkout session for a reseller customer
         * @summary Create Checkout Session For Reseller Customer
         * @param {string} customerOrgId
         * @param {string} priceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForResellerCustomerV1(customerOrgId, priceId, options) {
            return localVarFp.createCheckoutSessionForResellerCustomerV1(customerOrgId, priceId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerCustomerCheckoutApi - object-oriented interface
 * @export
 * @class ResellerCustomerCheckoutApi
 * @extends {BaseAPI}
 */
class ResellerCustomerCheckoutApi extends base_1.BaseAPI {
    /**
     * Create a checkout session for a reseller customer
     * @summary Create Checkout Session For Reseller Customer
     * @param {string} customerOrgId
     * @param {string} priceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerCheckoutApi
     */
    createCheckoutSessionForResellerCustomerV1(customerOrgId, priceId, options) {
        return exports.ResellerCustomerCheckoutApiFp(this.configuration).createCheckoutSessionForResellerCustomerV1(customerOrgId, priceId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerCustomerCheckoutApi = ResellerCustomerCheckoutApi;
/**
 * ResellerCustomerDefaultPricingApi - axios parameter creator
 * @export
 */
exports.ResellerCustomerDefaultPricingApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get the default pricing for all customers under the reseller organization
         * @summary Get Customer Default Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerDefaultPricingV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/customers/pricing/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update customer default pricing
         * @summary Update Customer Default Pricing V1
         * @param {string} priceId
         * @param {PricingRequest} pricingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerDefaultPricingV1: (priceId, pricingRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'priceId' is not null or undefined
            common_1.assertParamExists('updateCustomerDefaultPricingV1', 'priceId', priceId);
            // verify required parameter 'pricingRequest' is not null or undefined
            common_1.assertParamExists('updateCustomerDefaultPricingV1', 'pricingRequest', pricingRequest);
            const localVarPath = `/v1/resellers/customers/pricing/default/{price_id}`
                .replace(`{${"price_id"}}`, encodeURIComponent(String(priceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(pricingRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerCustomerDefaultPricingApi - functional programming interface
 * @export
 */
exports.ResellerCustomerDefaultPricingApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ResellerCustomerDefaultPricingApiAxiosParamCreator(configuration);
    return {
        /**
         * Get the default pricing for all customers under the reseller organization
         * @summary Get Customer Default Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerDefaultPricingV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCustomerDefaultPricingV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerDefaultPricingApi.getCustomerDefaultPricingV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update customer default pricing
         * @summary Update Customer Default Pricing V1
         * @param {string} priceId
         * @param {PricingRequest} pricingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerDefaultPricingV1(priceId, pricingRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateCustomerDefaultPricingV1(priceId, pricingRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerDefaultPricingApi.updateCustomerDefaultPricingV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ResellerCustomerDefaultPricingApi - factory interface
 * @export
 */
exports.ResellerCustomerDefaultPricingApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ResellerCustomerDefaultPricingApiFp(configuration);
    return {
        /**
         * Get the default pricing for all customers under the reseller organization
         * @summary Get Customer Default Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerDefaultPricingV1(options) {
            return localVarFp.getCustomerDefaultPricingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Update customer default pricing
         * @summary Update Customer Default Pricing V1
         * @param {string} priceId
         * @param {PricingRequest} pricingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerDefaultPricingV1(priceId, pricingRequest, options) {
            return localVarFp.updateCustomerDefaultPricingV1(priceId, pricingRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerCustomerDefaultPricingApi - object-oriented interface
 * @export
 * @class ResellerCustomerDefaultPricingApi
 * @extends {BaseAPI}
 */
class ResellerCustomerDefaultPricingApi extends base_1.BaseAPI {
    /**
     * Get the default pricing for all customers under the reseller organization
     * @summary Get Customer Default Pricing V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerDefaultPricingApi
     */
    getCustomerDefaultPricingV1(options) {
        return exports.ResellerCustomerDefaultPricingApiFp(this.configuration).getCustomerDefaultPricingV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update customer default pricing
     * @summary Update Customer Default Pricing V1
     * @param {string} priceId
     * @param {PricingRequest} pricingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerDefaultPricingApi
     */
    updateCustomerDefaultPricingV1(priceId, pricingRequest, options) {
        return exports.ResellerCustomerDefaultPricingApiFp(this.configuration).updateCustomerDefaultPricingV1(priceId, pricingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerCustomerDefaultPricingApi = ResellerCustomerDefaultPricingApi;
/**
 * ResellerCustomerPortalApi - axios parameter creator
 * @export
 */
exports.ResellerCustomerPortalApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a customer portal for a reseller customer
         * @summary Create Customer Portal For Reseller Customer
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPortalForResellerCustomerV1: (customerOrgId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('createCustomerPortalForResellerCustomerV1', 'customerOrgId', customerOrgId);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/portal`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerCustomerPortalApi - functional programming interface
 * @export
 */
exports.ResellerCustomerPortalApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ResellerCustomerPortalApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a customer portal for a reseller customer
         * @summary Create Customer Portal For Reseller Customer
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPortalForResellerCustomerV1(customerOrgId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createCustomerPortalForResellerCustomerV1(customerOrgId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerPortalApi.createCustomerPortalForResellerCustomerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ResellerCustomerPortalApi - factory interface
 * @export
 */
exports.ResellerCustomerPortalApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ResellerCustomerPortalApiFp(configuration);
    return {
        /**
         * Create a customer portal for a reseller customer
         * @summary Create Customer Portal For Reseller Customer
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPortalForResellerCustomerV1(customerOrgId, options) {
            return localVarFp.createCustomerPortalForResellerCustomerV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerCustomerPortalApi - object-oriented interface
 * @export
 * @class ResellerCustomerPortalApi
 * @extends {BaseAPI}
 */
class ResellerCustomerPortalApi extends base_1.BaseAPI {
    /**
     * Create a customer portal for a reseller customer
     * @summary Create Customer Portal For Reseller Customer
     * @param {string} customerOrgId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerPortalApi
     */
    createCustomerPortalForResellerCustomerV1(customerOrgId, options) {
        return exports.ResellerCustomerPortalApiFp(this.configuration).createCustomerPortalForResellerCustomerV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerCustomerPortalApi = ResellerCustomerPortalApi;
/**
 * ResellerCustomerPricingApi - axios parameter creator
 * @export
 */
exports.ResellerCustomerPricingApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Override pricing for customer
         * @summary Create Customer Pricing V1
         * @param {string} customerOrgId
         * @param {PricingRequest} pricingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPricingV1: (customerOrgId, pricingRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('createCustomerPricingV1', 'customerOrgId', customerOrgId);
            // verify required parameter 'pricingRequest' is not null or undefined
            common_1.assertParamExists('createCustomerPricingV1', 'pricingRequest', pricingRequest);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/pricing`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(pricingRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get resellers customer credits
         * @summary Get Reseller Customer Credits V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerCreditsV1: (customerOrgId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('getResellerCustomerCreditsV1', 'customerOrgId', customerOrgId);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/credits`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get resellers customer pricing
         * @summary Get Reseller Customer Pricing V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerPricingV1: (customerOrgId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('getResellerCustomerPricingV1', 'customerOrgId', customerOrgId);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/pricing`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update customer pricing
         * @summary Update Customer Pricing V1
         * @param {string} customerOrgId
         * @param {string} priceId
         * @param {PricingRequest} pricingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerPricingV1: (customerOrgId, priceId, pricingRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('updateCustomerPricingV1', 'customerOrgId', customerOrgId);
            // verify required parameter 'priceId' is not null or undefined
            common_1.assertParamExists('updateCustomerPricingV1', 'priceId', priceId);
            // verify required parameter 'pricingRequest' is not null or undefined
            common_1.assertParamExists('updateCustomerPricingV1', 'pricingRequest', pricingRequest);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/pricing/{price_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"price_id"}}`, encodeURIComponent(String(priceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(pricingRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerCustomerPricingApi - functional programming interface
 * @export
 */
exports.ResellerCustomerPricingApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ResellerCustomerPricingApiAxiosParamCreator(configuration);
    return {
        /**
         * Override pricing for customer
         * @summary Create Customer Pricing V1
         * @param {string} customerOrgId
         * @param {PricingRequest} pricingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPricingV1(customerOrgId, pricingRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createCustomerPricingV1(customerOrgId, pricingRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerPricingApi.createCustomerPricingV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get resellers customer credits
         * @summary Get Reseller Customer Credits V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerCreditsV1(customerOrgId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getResellerCustomerCreditsV1(customerOrgId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerPricingApi.getResellerCustomerCreditsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get resellers customer pricing
         * @summary Get Reseller Customer Pricing V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerPricingV1(customerOrgId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getResellerCustomerPricingV1(customerOrgId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerPricingApi.getResellerCustomerPricingV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update customer pricing
         * @summary Update Customer Pricing V1
         * @param {string} customerOrgId
         * @param {string} priceId
         * @param {PricingRequest} pricingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerPricingV1(customerOrgId, priceId, pricingRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateCustomerPricingV1(customerOrgId, priceId, pricingRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerPricingApi.updateCustomerPricingV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ResellerCustomerPricingApi - factory interface
 * @export
 */
exports.ResellerCustomerPricingApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ResellerCustomerPricingApiFp(configuration);
    return {
        /**
         * Override pricing for customer
         * @summary Create Customer Pricing V1
         * @param {string} customerOrgId
         * @param {PricingRequest} pricingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPricingV1(customerOrgId, pricingRequest, options) {
            return localVarFp.createCustomerPricingV1(customerOrgId, pricingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get resellers customer credits
         * @summary Get Reseller Customer Credits V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerCreditsV1(customerOrgId, options) {
            return localVarFp.getResellerCustomerCreditsV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get resellers customer pricing
         * @summary Get Reseller Customer Pricing V1
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerPricingV1(customerOrgId, options) {
            return localVarFp.getResellerCustomerPricingV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update customer pricing
         * @summary Update Customer Pricing V1
         * @param {string} customerOrgId
         * @param {string} priceId
         * @param {PricingRequest} pricingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerPricingV1(customerOrgId, priceId, pricingRequest, options) {
            return localVarFp.updateCustomerPricingV1(customerOrgId, priceId, pricingRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerCustomerPricingApi - object-oriented interface
 * @export
 * @class ResellerCustomerPricingApi
 * @extends {BaseAPI}
 */
class ResellerCustomerPricingApi extends base_1.BaseAPI {
    /**
     * Override pricing for customer
     * @summary Create Customer Pricing V1
     * @param {string} customerOrgId
     * @param {PricingRequest} pricingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerPricingApi
     */
    createCustomerPricingV1(customerOrgId, pricingRequest, options) {
        return exports.ResellerCustomerPricingApiFp(this.configuration).createCustomerPricingV1(customerOrgId, pricingRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get resellers customer credits
     * @summary Get Reseller Customer Credits V1
     * @param {string} customerOrgId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerPricingApi
     */
    getResellerCustomerCreditsV1(customerOrgId, options) {
        return exports.ResellerCustomerPricingApiFp(this.configuration).getResellerCustomerCreditsV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get resellers customer pricing
     * @summary Get Reseller Customer Pricing V1
     * @param {string} customerOrgId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerPricingApi
     */
    getResellerCustomerPricingV1(customerOrgId, options) {
        return exports.ResellerCustomerPricingApiFp(this.configuration).getResellerCustomerPricingV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update customer pricing
     * @summary Update Customer Pricing V1
     * @param {string} customerOrgId
     * @param {string} priceId
     * @param {PricingRequest} pricingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerPricingApi
     */
    updateCustomerPricingV1(customerOrgId, priceId, pricingRequest, options) {
        return exports.ResellerCustomerPricingApiFp(this.configuration).updateCustomerPricingV1(customerOrgId, priceId, pricingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerCustomerPricingApi = ResellerCustomerPricingApi;
/**
 * ResellerCustomerUserApi - axios parameter creator
 * @export
 */
exports.ResellerCustomerUserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete reseller customer user
         * @summary Delete Reseller Customer User V1
         * @param {string} customerOrgId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerCustomerUserV1: (customerOrgId, userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('deleteResellerCustomerUserV1', 'customerOrgId', customerOrgId);
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('deleteResellerCustomerUserV1', 'userId', userId);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/users/{user_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get resellers customer users and invites by id
         * @summary Get Reseller Customer User And Invites V1
         * @param {string} customerOrgId
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerUserAndInvitesV1: (customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('getResellerCustomerUserAndInvitesV1', 'customerOrgId', customerOrgId);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/users_and_invites`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter instanceof Date) ?
                    updatedAfter.toISOString() :
                    updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore instanceof Date) ?
                    updatedBefore.toISOString() :
                    updatedBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get resellers customer user by id
         * @summary Get Reseller Customer User By Id V1
         * @param {string} customerOrgId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerUserByIdV1: (customerOrgId, userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('getResellerCustomerUserByIdV1', 'customerOrgId', customerOrgId);
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('getResellerCustomerUserByIdV1', 'userId', userId);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/users/{user_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all invites for a customer organization
         * @summary List Customer Invites V1
         * @param {string} customerOrgId
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomerInvitesV1: (customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('listCustomerInvitesV1', 'customerOrgId', customerOrgId);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/invites`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter instanceof Date) ?
                    updatedAfter.toISOString() :
                    updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore instanceof Date) ?
                    updatedBefore.toISOString() :
                    updatedBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List resellers customer users
         * @summary List Reseller Customer Users V1
         * @param {string} customerOrgId
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerCustomerUsersV1: (customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('listResellerCustomerUsersV1', 'customerOrgId', customerOrgId);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/users`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter instanceof Date) ?
                    updatedAfter.toISOString() :
                    updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore instanceof Date) ?
                    updatedBefore.toISOString() :
                    updatedBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Revoke an invite for a customer organization
         * @summary Revoke Customer Invite V1
         * @param {string} customerOrgId
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCustomerInviteV1: (customerOrgId, email, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('revokeCustomerInviteV1', 'customerOrgId', customerOrgId);
            // verify required parameter 'email' is not null or undefined
            common_1.assertParamExists('revokeCustomerInviteV1', 'email', email);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/invites/{email}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Send invite to a user on behalf of a customer organization
         * @summary Invite Customer Users V1
         * @param {string} customerOrgId
         * @param {GuestInput} guestInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCustomerUserInviteV1: (customerOrgId, guestInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('sendCustomerUserInviteV1', 'customerOrgId', customerOrgId);
            // verify required parameter 'guestInput' is not null or undefined
            common_1.assertParamExists('sendCustomerUserInviteV1', 'guestInput', guestInput);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/invites`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(guestInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update reseller customer user
         * @summary Update Reseller Customer User V1
         * @param {string} customerOrgId
         * @param {string} userId
         * @param {UpdateUserRequest} updateUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerCustomerUserV1: (customerOrgId, userId, updateUserRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            common_1.assertParamExists('updateResellerCustomerUserV1', 'customerOrgId', customerOrgId);
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('updateResellerCustomerUserV1', 'userId', userId);
            // verify required parameter 'updateUserRequest' is not null or undefined
            common_1.assertParamExists('updateResellerCustomerUserV1', 'updateUserRequest', updateUserRequest);
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/users/{user_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerCustomerUserApi - functional programming interface
 * @export
 */
exports.ResellerCustomerUserApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ResellerCustomerUserApiAxiosParamCreator(configuration);
    return {
        /**
         * Delete reseller customer user
         * @summary Delete Reseller Customer User V1
         * @param {string} customerOrgId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerCustomerUserV1(customerOrgId, userId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteResellerCustomerUserV1(customerOrgId, userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerUserApi.deleteResellerCustomerUserV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get resellers customer users and invites by id
         * @summary Get Reseller Customer User And Invites V1
         * @param {string} customerOrgId
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerUserAndInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getResellerCustomerUserAndInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerUserApi.getResellerCustomerUserAndInvitesV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get resellers customer user by id
         * @summary Get Reseller Customer User By Id V1
         * @param {string} customerOrgId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerUserByIdV1(customerOrgId, userId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getResellerCustomerUserByIdV1(customerOrgId, userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerUserApi.getResellerCustomerUserByIdV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all invites for a customer organization
         * @summary List Customer Invites V1
         * @param {string} customerOrgId
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomerInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listCustomerInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerUserApi.listCustomerInvitesV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List resellers customer users
         * @summary List Reseller Customer Users V1
         * @param {string} customerOrgId
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerCustomerUsersV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listResellerCustomerUsersV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerUserApi.listResellerCustomerUsersV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Revoke an invite for a customer organization
         * @summary Revoke Customer Invite V1
         * @param {string} customerOrgId
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCustomerInviteV1(customerOrgId, email, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.revokeCustomerInviteV1(customerOrgId, email, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerUserApi.revokeCustomerInviteV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Send invite to a user on behalf of a customer organization
         * @summary Invite Customer Users V1
         * @param {string} customerOrgId
         * @param {GuestInput} guestInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCustomerUserInviteV1(customerOrgId, guestInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.sendCustomerUserInviteV1(customerOrgId, guestInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerUserApi.sendCustomerUserInviteV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update reseller customer user
         * @summary Update Reseller Customer User V1
         * @param {string} customerOrgId
         * @param {string} userId
         * @param {UpdateUserRequest} updateUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerCustomerUserV1(customerOrgId, userId, updateUserRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateResellerCustomerUserV1(customerOrgId, userId, updateUserRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerCustomerUserApi.updateResellerCustomerUserV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ResellerCustomerUserApi - factory interface
 * @export
 */
exports.ResellerCustomerUserApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ResellerCustomerUserApiFp(configuration);
    return {
        /**
         * Delete reseller customer user
         * @summary Delete Reseller Customer User V1
         * @param {string} customerOrgId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerCustomerUserV1(customerOrgId, userId, options) {
            return localVarFp.deleteResellerCustomerUserV1(customerOrgId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get resellers customer users and invites by id
         * @summary Get Reseller Customer User And Invites V1
         * @param {string} customerOrgId
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerUserAndInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return localVarFp.getResellerCustomerUserAndInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Get resellers customer user by id
         * @summary Get Reseller Customer User By Id V1
         * @param {string} customerOrgId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerUserByIdV1(customerOrgId, userId, options) {
            return localVarFp.getResellerCustomerUserByIdV1(customerOrgId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all invites for a customer organization
         * @summary List Customer Invites V1
         * @param {string} customerOrgId
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomerInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return localVarFp.listCustomerInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * List resellers customer users
         * @summary List Reseller Customer Users V1
         * @param {string} customerOrgId
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerCustomerUsersV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return localVarFp.listResellerCustomerUsersV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke an invite for a customer organization
         * @summary Revoke Customer Invite V1
         * @param {string} customerOrgId
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCustomerInviteV1(customerOrgId, email, options) {
            return localVarFp.revokeCustomerInviteV1(customerOrgId, email, options).then((request) => request(axios, basePath));
        },
        /**
         * Send invite to a user on behalf of a customer organization
         * @summary Invite Customer Users V1
         * @param {string} customerOrgId
         * @param {GuestInput} guestInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCustomerUserInviteV1(customerOrgId, guestInput, options) {
            return localVarFp.sendCustomerUserInviteV1(customerOrgId, guestInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update reseller customer user
         * @summary Update Reseller Customer User V1
         * @param {string} customerOrgId
         * @param {string} userId
         * @param {UpdateUserRequest} updateUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerCustomerUserV1(customerOrgId, userId, updateUserRequest, options) {
            return localVarFp.updateResellerCustomerUserV1(customerOrgId, userId, updateUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerCustomerUserApi - object-oriented interface
 * @export
 * @class ResellerCustomerUserApi
 * @extends {BaseAPI}
 */
class ResellerCustomerUserApi extends base_1.BaseAPI {
    /**
     * Delete reseller customer user
     * @summary Delete Reseller Customer User V1
     * @param {string} customerOrgId
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    deleteResellerCustomerUserV1(customerOrgId, userId, options) {
        return exports.ResellerCustomerUserApiFp(this.configuration).deleteResellerCustomerUserV1(customerOrgId, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get resellers customer users and invites by id
     * @summary Get Reseller Customer User And Invites V1
     * @param {string} customerOrgId
     * @param {string | null} [searchBy]
     * @param {string | null} [searchValue]
     * @param {string | null} [status]
     * @param {string | null} [sortBy]
     * @param {SortOrder | null} [sortOrder]
     * @param {number | null} [skip]
     * @param {number | null} [limit]
     * @param {string | null} [updatedAfter]
     * @param {string | null} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    getResellerCustomerUserAndInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ResellerCustomerUserApiFp(this.configuration).getResellerCustomerUserAndInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get resellers customer user by id
     * @summary Get Reseller Customer User By Id V1
     * @param {string} customerOrgId
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    getResellerCustomerUserByIdV1(customerOrgId, userId, options) {
        return exports.ResellerCustomerUserApiFp(this.configuration).getResellerCustomerUserByIdV1(customerOrgId, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all invites for a customer organization
     * @summary List Customer Invites V1
     * @param {string} customerOrgId
     * @param {string | null} [searchBy]
     * @param {string | null} [searchValue]
     * @param {string | null} [status]
     * @param {string | null} [sortBy]
     * @param {SortOrder | null} [sortOrder]
     * @param {number | null} [skip]
     * @param {number | null} [limit]
     * @param {string | null} [updatedAfter]
     * @param {string | null} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    listCustomerInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ResellerCustomerUserApiFp(this.configuration).listCustomerInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List resellers customer users
     * @summary List Reseller Customer Users V1
     * @param {string} customerOrgId
     * @param {string | null} [searchBy]
     * @param {string | null} [searchValue]
     * @param {string | null} [status]
     * @param {string | null} [sortBy]
     * @param {SortOrder | null} [sortOrder]
     * @param {number | null} [skip]
     * @param {number | null} [limit]
     * @param {string | null} [updatedAfter]
     * @param {string | null} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    listResellerCustomerUsersV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ResellerCustomerUserApiFp(this.configuration).listResellerCustomerUsersV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Revoke an invite for a customer organization
     * @summary Revoke Customer Invite V1
     * @param {string} customerOrgId
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    revokeCustomerInviteV1(customerOrgId, email, options) {
        return exports.ResellerCustomerUserApiFp(this.configuration).revokeCustomerInviteV1(customerOrgId, email, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Send invite to a user on behalf of a customer organization
     * @summary Invite Customer Users V1
     * @param {string} customerOrgId
     * @param {GuestInput} guestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    sendCustomerUserInviteV1(customerOrgId, guestInput, options) {
        return exports.ResellerCustomerUserApiFp(this.configuration).sendCustomerUserInviteV1(customerOrgId, guestInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update reseller customer user
     * @summary Update Reseller Customer User V1
     * @param {string} customerOrgId
     * @param {string} userId
     * @param {UpdateUserRequest} updateUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    updateResellerCustomerUserV1(customerOrgId, userId, updateUserRequest, options) {
        return exports.ResellerCustomerUserApiFp(this.configuration).updateResellerCustomerUserV1(customerOrgId, userId, updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerCustomerUserApi = ResellerCustomerUserApi;
/**
 * ResellerFilesApi - axios parameter creator
 * @export
 */
exports.ResellerFilesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete files from Trata reseller account
         * @summary Delete Files
         * @param {string} fileIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerFilesV1: (fileIds, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'fileIds' is not null or undefined
            common_1.assertParamExists('deleteResellerFilesV1', 'fileIds', fileIds);
            const localVarPath = `/v1/resellers/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (fileIds !== undefined) {
                localVarQueryParameter['file_ids'] = fileIds;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<File>} files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadResellerFilesV1: (files, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'files' is not null or undefined
            common_1.assertParamExists('uploadResellerFilesV1', 'files', files);
            const localVarPath = `/v1/resellers/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element);
                });
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerFilesApi - functional programming interface
 * @export
 */
exports.ResellerFilesApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ResellerFilesApiAxiosParamCreator(configuration);
    return {
        /**
         * Delete files from Trata reseller account
         * @summary Delete Files
         * @param {string} fileIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerFilesV1(fileIds, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteResellerFilesV1(fileIds, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerFilesApi.deleteResellerFilesV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<File>} files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadResellerFilesV1(files, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadResellerFilesV1(files, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerFilesApi.uploadResellerFilesV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ResellerFilesApi - factory interface
 * @export
 */
exports.ResellerFilesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ResellerFilesApiFp(configuration);
    return {
        /**
         * Delete files from Trata reseller account
         * @summary Delete Files
         * @param {string} fileIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerFilesV1(fileIds, options) {
            return localVarFp.deleteResellerFilesV1(fileIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<File>} files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadResellerFilesV1(files, options) {
            return localVarFp.uploadResellerFilesV1(files, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerFilesApi - object-oriented interface
 * @export
 * @class ResellerFilesApi
 * @extends {BaseAPI}
 */
class ResellerFilesApi extends base_1.BaseAPI {
    /**
     * Delete files from Trata reseller account
     * @summary Delete Files
     * @param {string} fileIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerFilesApi
     */
    deleteResellerFilesV1(fileIds, options) {
        return exports.ResellerFilesApiFp(this.configuration).deleteResellerFilesV1(fileIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload file to Trata account to use in AI Agents
     * @summary Upload Files
     * @param {Array<File>} files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerFilesApi
     */
    uploadResellerFilesV1(files, options) {
        return exports.ResellerFilesApiFp(this.configuration).uploadResellerFilesV1(files, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerFilesApi = ResellerFilesApi;
/**
 * ResellerMetricsApi - axios parameter creator
 * @export
 */
exports.ResellerMetricsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get analytics data for Reseller
         * @summary Get Reseller Metrics
         * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerMetricsV1: (resellerBatchMetricsRequests, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'resellerBatchMetricsRequests' is not null or undefined
            common_1.assertParamExists('getResellerMetricsV1', 'resellerBatchMetricsRequests', resellerBatchMetricsRequests);
            const localVarPath = `/v1/resellers/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(resellerBatchMetricsRequests, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerMetricsApi - functional programming interface
 * @export
 */
exports.ResellerMetricsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ResellerMetricsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get analytics data for Reseller
         * @summary Get Reseller Metrics
         * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerMetricsV1(resellerBatchMetricsRequests, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getResellerMetricsV1(resellerBatchMetricsRequests, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerMetricsApi.getResellerMetricsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ResellerMetricsApi - factory interface
 * @export
 */
exports.ResellerMetricsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ResellerMetricsApiFp(configuration);
    return {
        /**
         * Get analytics data for Reseller
         * @summary Get Reseller Metrics
         * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerMetricsV1(resellerBatchMetricsRequests, options) {
            return localVarFp.getResellerMetricsV1(resellerBatchMetricsRequests, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerMetricsApi - object-oriented interface
 * @export
 * @class ResellerMetricsApi
 * @extends {BaseAPI}
 */
class ResellerMetricsApi extends base_1.BaseAPI {
    /**
     * Get analytics data for Reseller
     * @summary Get Reseller Metrics
     * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerMetricsApi
     */
    getResellerMetricsV1(resellerBatchMetricsRequests, options) {
        return exports.ResellerMetricsApiFp(this.configuration).getResellerMetricsV1(resellerBatchMetricsRequests, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerMetricsApi = ResellerMetricsApi;
/**
 * ResellerOrganizationApi - axios parameter creator
 * @export
 */
exports.ResellerOrganizationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
         * @summary Create Reseller Organization V1
         * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResellerOrganizationV1: (bodyCreateResellerOrganizationV1, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'bodyCreateResellerOrganizationV1' is not null or undefined
            common_1.assertParamExists('createResellerOrganizationV1', 'bodyCreateResellerOrganizationV1', bodyCreateResellerOrganizationV1);
            const localVarPath = `/v1/resellers/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(bodyCreateResellerOrganizationV1, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a reseller organization
         * @summary Delete Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerOrganizationV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a reseller organization by id
         * @summary Get Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerOrganizationV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a reseller organization
         * @summary Update Reseller Organization V1
         * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerOrganizationV1: (updateResellerOrganizationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'updateResellerOrganizationRequest' is not null or undefined
            common_1.assertParamExists('updateResellerOrganizationV1', 'updateResellerOrganizationRequest', updateResellerOrganizationRequest);
            const localVarPath = `/v1/resellers/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(updateResellerOrganizationRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerOrganizationApi - functional programming interface
 * @export
 */
exports.ResellerOrganizationApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ResellerOrganizationApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
         * @summary Create Reseller Organization V1
         * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerOrganizationApi.createResellerOrganizationV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a reseller organization
         * @summary Delete Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerOrganizationV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteResellerOrganizationV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerOrganizationApi.deleteResellerOrganizationV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a reseller organization by id
         * @summary Get Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerOrganizationV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getResellerOrganizationV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerOrganizationApi.getResellerOrganizationV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a reseller organization
         * @summary Update Reseller Organization V1
         * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerOrganizationV1(updateResellerOrganizationRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateResellerOrganizationV1(updateResellerOrganizationRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerOrganizationApi.updateResellerOrganizationV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ResellerOrganizationApi - factory interface
 * @export
 */
exports.ResellerOrganizationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ResellerOrganizationApiFp(configuration);
    return {
        /**
         * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
         * @summary Create Reseller Organization V1
         * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options) {
            return localVarFp.createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a reseller organization
         * @summary Delete Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerOrganizationV1(options) {
            return localVarFp.deleteResellerOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a reseller organization by id
         * @summary Get Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerOrganizationV1(options) {
            return localVarFp.getResellerOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a reseller organization
         * @summary Update Reseller Organization V1
         * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerOrganizationV1(updateResellerOrganizationRequest, options) {
            return localVarFp.updateResellerOrganizationV1(updateResellerOrganizationRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerOrganizationApi - object-oriented interface
 * @export
 * @class ResellerOrganizationApi
 * @extends {BaseAPI}
 */
class ResellerOrganizationApi extends base_1.BaseAPI {
    /**
     * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
     * @summary Create Reseller Organization V1
     * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerOrganizationApi
     */
    createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options) {
        return exports.ResellerOrganizationApiFp(this.configuration).createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a reseller organization
     * @summary Delete Reseller Organization V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerOrganizationApi
     */
    deleteResellerOrganizationV1(options) {
        return exports.ResellerOrganizationApiFp(this.configuration).deleteResellerOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a reseller organization by id
     * @summary Get Reseller Organization V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerOrganizationApi
     */
    getResellerOrganizationV1(options) {
        return exports.ResellerOrganizationApiFp(this.configuration).getResellerOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a reseller organization
     * @summary Update Reseller Organization V1
     * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerOrganizationApi
     */
    updateResellerOrganizationV1(updateResellerOrganizationRequest, options) {
        return exports.ResellerOrganizationApiFp(this.configuration).updateResellerOrganizationV1(updateResellerOrganizationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerOrganizationApi = ResellerOrganizationApi;
/**
 * ResellerPricingApi - axios parameter creator
 * @export
 */
exports.ResellerPricingApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Adds a new account link to the reseller organization
         * @summary Add Stripe Account Link To Reseller Org
         * @param {string} code
         * @param {string} state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addStripeAccountLinkToResellerOrgV1: (code, state, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'code' is not null or undefined
            common_1.assertParamExists('addStripeAccountLinkToResellerOrgV1', 'code', code);
            // verify required parameter 'state' is not null or undefined
            common_1.assertParamExists('addStripeAccountLinkToResellerOrgV1', 'state', state);
            const localVarPath = `/v1/resellers/stripe-account/link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }
            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new account link URL for the reseller
         * @summary Create Stripe Account Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStripeAccountLinkV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/stripe-account/connect-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get stripe account details
         * @summary Get Stripe Account Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripeAccountDetailsV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/stripe-account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Disconnect reseller stripe account connection
         * @summary Revoke Stripe Connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeDisconnectV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/stripe-account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerPricingApi - functional programming interface
 * @export
 */
exports.ResellerPricingApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ResellerPricingApiAxiosParamCreator(configuration);
    return {
        /**
         * Adds a new account link to the reseller organization
         * @summary Add Stripe Account Link To Reseller Org
         * @param {string} code
         * @param {string} state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addStripeAccountLinkToResellerOrgV1(code, state, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addStripeAccountLinkToResellerOrgV1(code, state, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerPricingApi.addStripeAccountLinkToResellerOrgV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new account link URL for the reseller
         * @summary Create Stripe Account Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStripeAccountLinkV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createStripeAccountLinkV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerPricingApi.createStripeAccountLinkV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get stripe account details
         * @summary Get Stripe Account Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripeAccountDetailsV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getStripeAccountDetailsV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerPricingApi.getStripeAccountDetailsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Disconnect reseller stripe account connection
         * @summary Revoke Stripe Connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeDisconnectV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.stripeDisconnectV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerPricingApi.stripeDisconnectV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ResellerPricingApi - factory interface
 * @export
 */
exports.ResellerPricingApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ResellerPricingApiFp(configuration);
    return {
        /**
         * Adds a new account link to the reseller organization
         * @summary Add Stripe Account Link To Reseller Org
         * @param {string} code
         * @param {string} state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addStripeAccountLinkToResellerOrgV1(code, state, options) {
            return localVarFp.addStripeAccountLinkToResellerOrgV1(code, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new account link URL for the reseller
         * @summary Create Stripe Account Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStripeAccountLinkV1(options) {
            return localVarFp.createStripeAccountLinkV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get stripe account details
         * @summary Get Stripe Account Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripeAccountDetailsV1(options) {
            return localVarFp.getStripeAccountDetailsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Disconnect reseller stripe account connection
         * @summary Revoke Stripe Connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeDisconnectV1(options) {
            return localVarFp.stripeDisconnectV1(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerPricingApi - object-oriented interface
 * @export
 * @class ResellerPricingApi
 * @extends {BaseAPI}
 */
class ResellerPricingApi extends base_1.BaseAPI {
    /**
     * Adds a new account link to the reseller organization
     * @summary Add Stripe Account Link To Reseller Org
     * @param {string} code
     * @param {string} state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerPricingApi
     */
    addStripeAccountLinkToResellerOrgV1(code, state, options) {
        return exports.ResellerPricingApiFp(this.configuration).addStripeAccountLinkToResellerOrgV1(code, state, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new account link URL for the reseller
     * @summary Create Stripe Account Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerPricingApi
     */
    createStripeAccountLinkV1(options) {
        return exports.ResellerPricingApiFp(this.configuration).createStripeAccountLinkV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get stripe account details
     * @summary Get Stripe Account Details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerPricingApi
     */
    getStripeAccountDetailsV1(options) {
        return exports.ResellerPricingApiFp(this.configuration).getStripeAccountDetailsV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Disconnect reseller stripe account connection
     * @summary Revoke Stripe Connection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerPricingApi
     */
    stripeDisconnectV1(options) {
        return exports.ResellerPricingApiFp(this.configuration).stripeDisconnectV1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerPricingApi = ResellerPricingApi;
/**
 * ResellerSettingsApi - axios parameter creator
 * @export
 */
exports.ResellerSettingsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add Reseller settings
         * @summary Organization Settings V1
         * @param {OrganizationSettings} organizationSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResellerSettingsV1: (organizationSettings, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organizationSettings' is not null or undefined
            common_1.assertParamExists('addResellerSettingsV1', 'organizationSettings', organizationSettings);
            const localVarPath = `/v1/resellers/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(organizationSettings, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get organization settings
         * @summary Get Organization Settings V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSettingsV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update organization settings
         * @summary Organization Settings Update V1
         * @param {OrganizationSettings} organizationSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerSettingsV1: (organizationSettings, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organizationSettings' is not null or undefined
            common_1.assertParamExists('updateResellerSettingsV1', 'organizationSettings', organizationSettings);
            const localVarPath = `/v1/resellers/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(organizationSettings, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerSettingsApi - functional programming interface
 * @export
 */
exports.ResellerSettingsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ResellerSettingsApiAxiosParamCreator(configuration);
    return {
        /**
         * Add Reseller settings
         * @summary Organization Settings V1
         * @param {OrganizationSettings} organizationSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResellerSettingsV1(organizationSettings, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addResellerSettingsV1(organizationSettings, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerSettingsApi.addResellerSettingsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get organization settings
         * @summary Get Organization Settings V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSettingsV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganizationSettingsV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerSettingsApi.getOrganizationSettingsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update organization settings
         * @summary Organization Settings Update V1
         * @param {OrganizationSettings} organizationSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerSettingsV1(organizationSettings, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateResellerSettingsV1(organizationSettings, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerSettingsApi.updateResellerSettingsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ResellerSettingsApi - factory interface
 * @export
 */
exports.ResellerSettingsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ResellerSettingsApiFp(configuration);
    return {
        /**
         * Add Reseller settings
         * @summary Organization Settings V1
         * @param {OrganizationSettings} organizationSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResellerSettingsV1(organizationSettings, options) {
            return localVarFp.addResellerSettingsV1(organizationSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization settings
         * @summary Get Organization Settings V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSettingsV1(options) {
            return localVarFp.getOrganizationSettingsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Update organization settings
         * @summary Organization Settings Update V1
         * @param {OrganizationSettings} organizationSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerSettingsV1(organizationSettings, options) {
            return localVarFp.updateResellerSettingsV1(organizationSettings, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerSettingsApi - object-oriented interface
 * @export
 * @class ResellerSettingsApi
 * @extends {BaseAPI}
 */
class ResellerSettingsApi extends base_1.BaseAPI {
    /**
     * Add Reseller settings
     * @summary Organization Settings V1
     * @param {OrganizationSettings} organizationSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerSettingsApi
     */
    addResellerSettingsV1(organizationSettings, options) {
        return exports.ResellerSettingsApiFp(this.configuration).addResellerSettingsV1(organizationSettings, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get organization settings
     * @summary Get Organization Settings V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerSettingsApi
     */
    getOrganizationSettingsV1(options) {
        return exports.ResellerSettingsApiFp(this.configuration).getOrganizationSettingsV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update organization settings
     * @summary Organization Settings Update V1
     * @param {OrganizationSettings} organizationSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerSettingsApi
     */
    updateResellerSettingsV1(organizationSettings, options) {
        return exports.ResellerSettingsApiFp(this.configuration).updateResellerSettingsV1(organizationSettings, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerSettingsApi = ResellerSettingsApi;
/**
 * ResellerUserApi - axios parameter creator
 * @export
 */
exports.ResellerUserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Accept Invite V1
         * @param {AcceptInviteRequest} acceptInviteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptResellerUserInviteV1: (acceptInviteRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'acceptInviteRequest' is not null or undefined
            common_1.assertParamExists('acceptResellerUserInviteV1', 'acceptInviteRequest', acceptInviteRequest);
            const localVarPath = `/v1/resellers/invites/accept`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(acceptInviteRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a user
         * @summary Delete Reseller User V1
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerUserV1: (userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('deleteResellerUserV1', 'userId', userId);
            const localVarPath = `/v1/resellers/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Reseller User By Id V1
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerUserByIdV1: (userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('getResellerUserByIdV1', 'userId', userId);
            const localVarPath = `/v1/resellers/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List of all open invites from the organization
         * @summary List Reseller User Invites V1
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUserInvitesV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter instanceof Date) ?
                    updatedAfter.toISOString() :
                    updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore instanceof Date) ?
                    updatedBefore.toISOString() :
                    updatedBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all users under the user\'s organization
         * @summary List Reseller Users V1
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUsersV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter instanceof Date) ?
                    updatedAfter.toISOString() :
                    updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore instanceof Date) ?
                    updatedBefore.toISOString() :
                    updatedBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Invite Users V1
         * @param {GuestInput} guestInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendResellerUserInviteV1: (guestInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'guestInput' is not null or undefined
            common_1.assertParamExists('sendResellerUserInviteV1', 'guestInput', guestInput);
            const localVarPath = `/v1/resellers/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(guestInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update user details
         * @summary Update Reseller User V1
         * @param {string} userId
         * @param {UserPayload} userPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerUserV1: (userId, userPayload, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('updateResellerUserV1', 'userId', userId);
            // verify required parameter 'userPayload' is not null or undefined
            common_1.assertParamExists('updateResellerUserV1', 'userPayload', userPayload);
            const localVarPath = `/v1/resellers/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(userPayload, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerUserApi - functional programming interface
 * @export
 */
exports.ResellerUserApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ResellerUserApiAxiosParamCreator(configuration);
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Accept Invite V1
         * @param {AcceptInviteRequest} acceptInviteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptResellerUserInviteV1(acceptInviteRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.acceptResellerUserInviteV1(acceptInviteRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerUserApi.acceptResellerUserInviteV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a user
         * @summary Delete Reseller User V1
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerUserV1(userId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteResellerUserV1(userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerUserApi.deleteResellerUserV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get Reseller User By Id V1
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerUserByIdV1(userId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getResellerUserByIdV1(userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerUserApi.getResellerUserByIdV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List of all open invites from the organization
         * @summary List Reseller User Invites V1
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerUserApi.listResellerUserInvitesV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all users under the user\'s organization
         * @summary List Reseller Users V1
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerUserApi.listResellerUsersV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Invite Users V1
         * @param {GuestInput} guestInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendResellerUserInviteV1(guestInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.sendResellerUserInviteV1(guestInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerUserApi.sendResellerUserInviteV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update user details
         * @summary Update Reseller User V1
         * @param {string} userId
         * @param {UserPayload} userPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerUserV1(userId, userPayload, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateResellerUserV1(userId, userPayload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ResellerUserApi.updateResellerUserV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ResellerUserApi - factory interface
 * @export
 */
exports.ResellerUserApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ResellerUserApiFp(configuration);
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Accept Invite V1
         * @param {AcceptInviteRequest} acceptInviteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptResellerUserInviteV1(acceptInviteRequest, options) {
            return localVarFp.acceptResellerUserInviteV1(acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user
         * @summary Delete Reseller User V1
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerUserV1(userId, options) {
            return localVarFp.deleteResellerUserV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Reseller User By Id V1
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerUserByIdV1(userId, options) {
            return localVarFp.getResellerUserByIdV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List of all open invites from the organization
         * @summary List Reseller User Invites V1
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return localVarFp.listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all users under the user\'s organization
         * @summary List Reseller Users V1
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return localVarFp.listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Invite Users V1
         * @param {GuestInput} guestInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendResellerUserInviteV1(guestInput, options) {
            return localVarFp.sendResellerUserInviteV1(guestInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user details
         * @summary Update Reseller User V1
         * @param {string} userId
         * @param {UserPayload} userPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerUserV1(userId, userPayload, options) {
            return localVarFp.updateResellerUserV1(userId, userPayload, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerUserApi - object-oriented interface
 * @export
 * @class ResellerUserApi
 * @extends {BaseAPI}
 */
class ResellerUserApi extends base_1.BaseAPI {
    /**
     * Accept invite and add new user to organization
     * @summary Accept Invite V1
     * @param {AcceptInviteRequest} acceptInviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    acceptResellerUserInviteV1(acceptInviteRequest, options) {
        return exports.ResellerUserApiFp(this.configuration).acceptResellerUserInviteV1(acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a user
     * @summary Delete Reseller User V1
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    deleteResellerUserV1(userId, options) {
        return exports.ResellerUserApiFp(this.configuration).deleteResellerUserV1(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Reseller User By Id V1
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    getResellerUserByIdV1(userId, options) {
        return exports.ResellerUserApiFp(this.configuration).getResellerUserByIdV1(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List of all open invites from the organization
     * @summary List Reseller User Invites V1
     * @param {string | null} [searchBy]
     * @param {string | null} [searchValue]
     * @param {string | null} [status]
     * @param {string | null} [sortBy]
     * @param {SortOrder | null} [sortOrder]
     * @param {number | null} [skip]
     * @param {number | null} [limit]
     * @param {string | null} [updatedAfter]
     * @param {string | null} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ResellerUserApiFp(this.configuration).listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all users under the user\'s organization
     * @summary List Reseller Users V1
     * @param {string | null} [searchBy]
     * @param {string | null} [searchValue]
     * @param {string | null} [status]
     * @param {string | null} [sortBy]
     * @param {SortOrder | null} [sortOrder]
     * @param {number | null} [skip]
     * @param {number | null} [limit]
     * @param {string | null} [updatedAfter]
     * @param {string | null} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.ResellerUserApiFp(this.configuration).listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Invite a new user to an organization or resend invite to the user if the user is already invited
     * @summary Invite Users V1
     * @param {GuestInput} guestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    sendResellerUserInviteV1(guestInput, options) {
        return exports.ResellerUserApiFp(this.configuration).sendResellerUserInviteV1(guestInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update user details
     * @summary Update Reseller User V1
     * @param {string} userId
     * @param {UserPayload} userPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    updateResellerUserV1(userId, userPayload, options) {
        return exports.ResellerUserApiFp(this.configuration).updateResellerUserV1(userId, userPayload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerUserApi = ResellerUserApi;
/**
 * SparrApi - axios parameter creator
 * @export
 */
exports.SparrApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add a module attempt for a user
         * @summary Add Module Attempt
         * @param {string} moduleId
         * @param {UserModuleAttemptCore} userModuleAttemptCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addModuleAttemptV1: (moduleId, userModuleAttemptCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'moduleId' is not null or undefined
            common_1.assertParamExists('addModuleAttemptV1', 'moduleId', moduleId);
            // verify required parameter 'userModuleAttemptCore' is not null or undefined
            common_1.assertParamExists('addModuleAttemptV1', 'userModuleAttemptCore', userModuleAttemptCore);
            const localVarPath = `/v1/sparr/courses/modules/{module_id}/attempts`
                .replace(`{${"module_id"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(userModuleAttemptCore, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Assign a course to a user
         * @summary Assign Course
         * @param {string} courseId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignCourseV1: (courseId, userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            common_1.assertParamExists('assignCourseV1', 'courseId', courseId);
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('assignCourseV1', 'userId', userId);
            const localVarPath = `/v1/sparr/courses/{course_id}/assign/{user_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Attach a tag to an entity
         * @summary Attach Tag
         * @param {string} entityType
         * @param {string} entityId
         * @param {TagCreate} tagCreate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost: (entityType, entityId, tagCreate, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'entityType' is not null or undefined
            common_1.assertParamExists('attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost', 'entityType', entityType);
            // verify required parameter 'entityId' is not null or undefined
            common_1.assertParamExists('attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost', 'entityId', entityId);
            // verify required parameter 'tagCreate' is not null or undefined
            common_1.assertParamExists('attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost', 'tagCreate', tagCreate);
            const localVarPath = `/v1/sparr/entity-tags/{entity_type}/{entity_id}/tags`
                .replace(`{${"entity_type"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(tagCreate, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a checkout session for a price
         * @summary Create Checkout Session For Price
         * @param {string} priceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForPriceV1: (priceId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'priceId' is not null or undefined
            common_1.assertParamExists('createCheckoutSessionForPriceV1', 'priceId', priceId);
            const localVarPath = `/v1/sparr/pricing/{price_id}/checkout`
                .replace(`{${"price_id"}}`, encodeURIComponent(String(priceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseV1: (courseRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseRequest' is not null or undefined
            common_1.assertParamExists('createCourseV1', 'courseRequest', courseRequest);
            const localVarPath = `/v1/sparr/courses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(courseRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a customer portal for customer
         * @summary Create Customer Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPortalV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/customers/portal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new feedback
         * @summary Create Feedback
         * @param {FeedbackCore} feedbackCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedbackV1: (feedbackCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'feedbackCore' is not null or undefined
            common_1.assertParamExists('createFeedbackV1', 'feedbackCore', feedbackCore);
            const localVarPath = `/v1/sparr/feedbacks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(feedbackCore, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new goals collection
         * @summary Create Goals
         * @param {GoalCoreInput} goalCoreInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoalsV1: (goalCoreInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'goalCoreInput' is not null or undefined
            common_1.assertParamExists('createGoalsV1', 'goalCoreInput', goalCoreInput);
            const localVarPath = `/v1/sparr/goals/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(goalCoreInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonaV1: (personaCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'personaCore' is not null or undefined
            common_1.assertParamExists('createPersonaV1', 'personaCore', personaCore);
            const localVarPath = `/v1/sparr/personas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(personaCore, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new evaluator
         * @summary Create Evaluator
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPostCallEvaluationParamsV1: (evaluatorCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'evaluatorCore' is not null or undefined
            common_1.assertParamExists('createPostCallEvaluationParamsV1', 'evaluatorCore', evaluatorCore);
            const localVarPath = `/v1/sparr/evaluators/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(evaluatorCore, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {CreateScenarioRequest} createScenarioRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenarioV1: (createScenarioRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'createScenarioRequest' is not null or undefined
            common_1.assertParamExists('createScenarioV1', 'createScenarioRequest', createScenarioRequest);
            const localVarPath = `/v1/sparr/scenarios/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createScenarioRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new tracker
         * @summary Create Tracker
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackerV1: (trackerCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'trackerCore' is not null or undefined
            common_1.assertParamExists('createTrackerV1', 'trackerCore', trackerCore);
            const localVarPath = `/v1/sparr/trackers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(trackerCore, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseV1: (courseId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            common_1.assertParamExists('deleteCourseV1', 'courseId', courseId);
            const localVarPath = `/v1/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete evaluator
         * @summary Delete Evaluator
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvaluatorV1: (paramsId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'paramsId' is not null or undefined
            common_1.assertParamExists('deleteEvaluatorV1', 'paramsId', paramsId);
            const localVarPath = `/v1/sparr/evaluators/{params_id}`
                .replace(`{${"params_id"}}`, encodeURIComponent(String(paramsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a feedback
         * @summary Delete Feedback
         * @param {string} feedbackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedbackV1: (feedbackId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'feedbackId' is not null or undefined
            common_1.assertParamExists('deleteFeedbackV1', 'feedbackId', feedbackId);
            const localVarPath = `/v1/sparr/feedbacks/{feedback_id}`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a file
         * @summary Delete File
         * @param {string} fileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1: (fileId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'fileId' is not null or undefined
            common_1.assertParamExists('deleteFileV1', 'fileId', fileId);
            const localVarPath = `/v1/sparr/files/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a goals collection
         * @summary Delete Goals
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoalsV1: (goalsId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'goalsId' is not null or undefined
            common_1.assertParamExists('deleteGoalsV1', 'goalsId', goalsId);
            const localVarPath = `/v1/sparr/goals/{goals_id}`
                .replace(`{${"goals_id"}}`, encodeURIComponent(String(goalsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonaV1: (personaId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'personaId' is not null or undefined
            common_1.assertParamExists('deletePersonaV1', 'personaId', personaId);
            const localVarPath = `/v1/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioV1: (scenarioId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'scenarioId' is not null or undefined
            common_1.assertParamExists('deleteScenarioV1', 'scenarioId', scenarioId);
            const localVarPath = `/v1/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a tracker
         * @summary Delete Tracker
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackerV1: (trackerId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'trackerId' is not null or undefined
            common_1.assertParamExists('deleteTrackerV1', 'trackerId', trackerId);
            const localVarPath = `/v1/sparr/trackers/{tracker_id}`
                .replace(`{${"tracker_id"}}`, encodeURIComponent(String(trackerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Detach a tag from an entity
         * @summary Detach Tag
         * @param {string} entityType
         * @param {string} entityId
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete: (entityType, entityId, tagName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'entityType' is not null or undefined
            common_1.assertParamExists('detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete', 'entityType', entityType);
            // verify required parameter 'entityId' is not null or undefined
            common_1.assertParamExists('detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete', 'entityId', entityId);
            // verify required parameter 'tagName' is not null or undefined
            common_1.assertParamExists('detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete', 'tagName', tagName);
            const localVarPath = `/v1/sparr/entity-tags/{entity_type}/{entity_id}/tags/{tag_name}`
                .replace(`{${"entity_type"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Generate evaluator data from files and/or existing core components
         * @summary Generate Evaluator
         * @param {FlexibleGenerationRequest} flexibleGenerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEvaluatorV1: (flexibleGenerationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'flexibleGenerationRequest' is not null or undefined
            common_1.assertParamExists('generateEvaluatorV1', 'flexibleGenerationRequest', flexibleGenerationRequest);
            const localVarPath = `/v1/sparr/evaluators/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(flexibleGenerationRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseV1: (courseId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            common_1.assertParamExists('getCourseV1', 'courseId', courseId);
            const localVarPath = `/v1/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get credits
         * @summary Get Credits V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditsV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/credits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all entities of a type that have a specific tag
         * @summary Get Entities By Tag
         * @param {string} entityType
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet: (entityType, tagName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'entityType' is not null or undefined
            common_1.assertParamExists('getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet', 'entityType', entityType);
            // verify required parameter 'tagName' is not null or undefined
            common_1.assertParamExists('getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet', 'tagName', tagName);
            const localVarPath = `/v1/sparr/entity-tags/{entity_type}/by-tag/{tag_name}`
                .replace(`{${"entity_type"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all tags for an entity
         * @summary Get Entity Tags
         * @param {string} entityType
         * @param {string} entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet: (entityType, entityId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'entityType' is not null or undefined
            common_1.assertParamExists('getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet', 'entityType', entityType);
            // verify required parameter 'entityId' is not null or undefined
            common_1.assertParamExists('getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet', 'entityId', entityId);
            const localVarPath = `/v1/sparr/entity-tags/{entity_type}/{entity_id}/tags`
                .replace(`{${"entity_type"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
         * @summary Get Evaluator By Id
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluatorV1: (paramsId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'paramsId' is not null or undefined
            common_1.assertParamExists('getEvaluatorV1', 'paramsId', paramsId);
            const localVarPath = `/v1/sparr/evaluators/{params_id}`
                .replace(`{${"params_id"}}`, encodeURIComponent(String(paramsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific feedback by ID
         * @summary Get Feedback
         * @param {string} feedbackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedbackV1: (feedbackId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'feedbackId' is not null or undefined
            common_1.assertParamExists('getFeedbackV1', 'feedbackId', feedbackId);
            const localVarPath = `/v1/sparr/feedbacks/{feedback_id}`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific file by ID
         * @summary Get File
         * @param {string} fileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileV1: (fileId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'fileId' is not null or undefined
            common_1.assertParamExists('getFileV1', 'fileId', fileId);
            const localVarPath = `/v1/sparr/files/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
         * @summary Get Goals By Id
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalsV1: (goalsId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'goalsId' is not null or undefined
            common_1.assertParamExists('getGoalsV1', 'goalsId', goalsId);
            const localVarPath = `/v1/sparr/goals/{goals_id}`
                .replace(`{${"goals_id"}}`, encodeURIComponent(String(goalsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get metrics for a given batch of metrics requests
         * @summary Get Metrics
         * @param {SparrModelsAnalyticsBatchMetricsRequests} sparrModelsAnalyticsBatchMetricsRequests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1: (sparrModelsAnalyticsBatchMetricsRequests, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'sparrModelsAnalyticsBatchMetricsRequests' is not null or undefined
            common_1.assertParamExists('getMetricsV1', 'sparrModelsAnalyticsBatchMetricsRequests', sparrModelsAnalyticsBatchMetricsRequests);
            const localVarPath = `/v1/sparr/feedbacks/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(sparrModelsAnalyticsBatchMetricsRequests, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific persona by ID that is either directly owned or available through reseller course assignments
         * @summary Get Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaV1: (personaId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'personaId' is not null or undefined
            common_1.assertParamExists('getPersonaV1', 'personaId', personaId);
            const localVarPath = `/v1/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get pricing
         * @summary Get Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/pricing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
         * @summary Get Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioV1: (scenarioId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'scenarioId' is not null or undefined
            common_1.assertParamExists('getScenarioV1', 'scenarioId', scenarioId);
            const localVarPath = `/v1/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
         * @summary Get Tracker By Id
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackerV1: (trackerId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'trackerId' is not null or undefined
            common_1.assertParamExists('getTrackerV1', 'trackerId', trackerId);
            const localVarPath = `/v1/sparr/trackers/{tracker_id}`
                .replace(`{${"tracker_id"}}`, encodeURIComponent(String(trackerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search personas by name, title and company
         * @summary Get User Stats
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStatsV1: (userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('getUserStatsV1', 'userId', userId);
            const localVarPath = `/v1/sparr/user_stats/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLinkedinPersonaV1: (linkedinUrl, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'linkedinUrl' is not null or undefined
            common_1.assertParamExists('importLinkedinPersonaV1', 'linkedinUrl', linkedinUrl);
            const localVarPath = `/v1/sparr/personas/import-linkedin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (linkedinUrl !== undefined) {
                localVarQueryParameter['linkedin_url'] = linkedinUrl;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string | null} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoursesV1: (skip, limit, status, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/courses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all evaluator that are either directly owned or available through reseller course assignments
         * @summary Get Evaluator
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvaluatorV1: (skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/evaluators/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all feedbacks
         * @summary Get Feedbacks
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string | null} [fromDate] Start date for filtering feedbacks
         * @param {string | null} [toDate] End date for filtering feedbacks
         * @param {string | null} [userFilter] User filter for filtering feedbacks. Comma separated list of user ids.
         * @param {string | null} [statusFilter] Status filter for filtering feedbacks. Comma separated list of statuses.
         * @param {string | null} [scenarioFilter] Scenario filter for filtering feedbacks. Comma separated list of scenario ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeedbacksV1: (skip, limit, fromDate, toDate, userFilter, statusFilter, scenarioFilter, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/feedbacks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = (fromDate instanceof Date) ?
                    fromDate.toISOString() :
                    fromDate;
            }
            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = (toDate instanceof Date) ?
                    toDate.toISOString() :
                    toDate;
            }
            if (userFilter !== undefined) {
                localVarQueryParameter['user_filter'] = userFilter;
            }
            if (statusFilter !== undefined) {
                localVarQueryParameter['status_filter'] = statusFilter;
            }
            if (scenarioFilter !== undefined) {
                localVarQueryParameter['scenario_filter'] = scenarioFilter;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all goals that are either directly owned or available through reseller course assignments
         * @summary Get Goals
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGoalsV1: (skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/goals/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all personas that are either directly owned or available through reseller course assignments
         * @summary Get Personas
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter personas by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonasV1: (skip, limit, tags, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/personas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all scenarios that are either directly owned or available through reseller course assignments
         * @summary Get Scenarios
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter scenarios by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenariosV1: (skip, limit, tags, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/scenarios/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all trackers that are either directly owned or available through reseller course assignments
         * @summary Get Trackers
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrackerV1: (skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/trackers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all course assignments for a user with analytics
         * @summary Get User Assignments
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAssignmentsV1: (userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('listUserAssignmentsV1', 'userId', userId);
            const localVarPath = `/v1/sparr/courses/users/{user_id}/assignments`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all module attempts with module information for a user in a specific course
         * @summary Get User Course Attempts
         * @param {string} courseId
         * @param {string} userId
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCourseAttemptsV1: (courseId, userId, skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            common_1.assertParamExists('listUserCourseAttemptsV1', 'courseId', courseId);
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('listUserCourseAttemptsV1', 'userId', userId);
            const localVarPath = `/v1/sparr/courses/{course_id}/attempts/users/{user_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all module attempts for a user
         * @summary Get User Module Attempts
         * @param {string} moduleId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserModuleAttemptsV1: (moduleId, userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'moduleId' is not null or undefined
            common_1.assertParamExists('listUserModuleAttemptsV1', 'moduleId', moduleId);
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('listUserModuleAttemptsV1', 'userId', userId);
            const localVarPath = `/v1/sparr/courses/modules/{module_id}/attempts/{user_id}`
                .replace(`{${"module_id"}}`, encodeURIComponent(String(moduleId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Revoke a course from a user
         * @summary Revoke Course
         * @param {string} courseId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCourseV1: (courseId, userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            common_1.assertParamExists('revokeCourseV1', 'courseId', courseId);
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('revokeCourseV1', 'userId', userId);
            const localVarPath = `/v1/sparr/courses/{course_id}/assign/{user_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search goals by name and description
         * @summary Search Goals
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGoalsV1: (query, page, size, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'query' is not null or undefined
            common_1.assertParamExists('searchGoalsV1', 'query', query);
            const localVarPath = `/v1/sparr/goals/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonasV1: (query, page, size, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'query' is not null or undefined
            common_1.assertParamExists('searchPersonasV1', 'query', query);
            const localVarPath = `/v1/sparr/personas/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenariosV1: (query, page, size, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'query' is not null or undefined
            common_1.assertParamExists('searchScenariosV1', 'query', query);
            const localVarPath = `/v1/sparr/scenarios/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search trackers by name and description
         * @summary Search Tracker
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTrackerV1: (query, page, size, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'query' is not null or undefined
            common_1.assertParamExists('searchTrackerV1', 'query', query);
            const localVarPath = `/v1/sparr/trackers/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Heart Beat check to check the health of Sparr Service
         * @summary Heart Beat Status Of Sparr Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusSparrStatusGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/sparr/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update course completion status
         * @summary Update Course Completion Status
         * @param {string} courseId
         * @param {string} userId
         * @param {CourseCompletionStatus} completionStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseCompletionStatusV1: (courseId, userId, completionStatus, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            common_1.assertParamExists('updateCourseCompletionStatusV1', 'courseId', courseId);
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('updateCourseCompletionStatusV1', 'userId', userId);
            // verify required parameter 'completionStatus' is not null or undefined
            common_1.assertParamExists('updateCourseCompletionStatusV1', 'completionStatus', completionStatus);
            const localVarPath = `/v1/sparr/courses/{course_id}/assign/{user_id}/status`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (completionStatus !== undefined) {
                localVarQueryParameter['completionStatus'] = completionStatus;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId
         * @param {CourseUpdateRequest} courseUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseV1: (courseId, courseUpdateRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            common_1.assertParamExists('updateCourseV1', 'courseId', courseId);
            // verify required parameter 'courseUpdateRequest' is not null or undefined
            common_1.assertParamExists('updateCourseV1', 'courseUpdateRequest', courseUpdateRequest);
            const localVarPath = `/v1/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(courseUpdateRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update evaluator
         * @summary Update Evaluator
         * @param {string} paramsId
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvaluatorV1: (paramsId, evaluatorCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'paramsId' is not null or undefined
            common_1.assertParamExists('updateEvaluatorV1', 'paramsId', paramsId);
            // verify required parameter 'evaluatorCore' is not null or undefined
            common_1.assertParamExists('updateEvaluatorV1', 'evaluatorCore', evaluatorCore);
            const localVarPath = `/v1/sparr/evaluators/{params_id}`
                .replace(`{${"params_id"}}`, encodeURIComponent(String(paramsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(evaluatorCore, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a feedback
         * @summary Update Feedback
         * @param {string} feedbackId
         * @param {FeedbackCore} feedbackCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedbackV1: (feedbackId, feedbackCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'feedbackId' is not null or undefined
            common_1.assertParamExists('updateFeedbackV1', 'feedbackId', feedbackId);
            // verify required parameter 'feedbackCore' is not null or undefined
            common_1.assertParamExists('updateFeedbackV1', 'feedbackCore', feedbackCore);
            const localVarPath = `/v1/sparr/feedbacks/{feedback_id}`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(feedbackCore, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a goals collection
         * @summary Update Goals
         * @param {string} goalsId
         * @param {GoalCoreInput} goalCoreInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalsV1: (goalsId, goalCoreInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'goalsId' is not null or undefined
            common_1.assertParamExists('updateGoalsV1', 'goalsId', goalsId);
            // verify required parameter 'goalCoreInput' is not null or undefined
            common_1.assertParamExists('updateGoalsV1', 'goalCoreInput', goalCoreInput);
            const localVarPath = `/v1/sparr/goals/{goals_id}`
                .replace(`{${"goals_id"}}`, encodeURIComponent(String(goalsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(goalCoreInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonaV1: (personaId, personaCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'personaId' is not null or undefined
            common_1.assertParamExists('updatePersonaV1', 'personaId', personaId);
            // verify required parameter 'personaCore' is not null or undefined
            common_1.assertParamExists('updatePersonaV1', 'personaCore', personaCore);
            const localVarPath = `/v1/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(personaCore, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId
         * @param {CreateScenarioRequest} createScenarioRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenarioV1: (scenarioId, createScenarioRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'scenarioId' is not null or undefined
            common_1.assertParamExists('updateScenarioV1', 'scenarioId', scenarioId);
            // verify required parameter 'createScenarioRequest' is not null or undefined
            common_1.assertParamExists('updateScenarioV1', 'createScenarioRequest', createScenarioRequest);
            const localVarPath = `/v1/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createScenarioRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a tracker
         * @summary Update Tracker
         * @param {string} trackerId
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackerV1: (trackerId, trackerCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'trackerId' is not null or undefined
            common_1.assertParamExists('updateTrackerV1', 'trackerId', trackerId);
            // verify required parameter 'trackerCore' is not null or undefined
            common_1.assertParamExists('updateTrackerV1', 'trackerCore', trackerCore);
            const localVarPath = `/v1/sparr/trackers/{tracker_id}`
                .replace(`{${"tracker_id"}}`, encodeURIComponent(String(trackerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(trackerCore, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Upload multiple files and create file records. Maximum 5 files per request, each file max 10MB.
         * @summary Upload Files
         * @param {Array<File>} files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilesV1: (files, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'files' is not null or undefined
            common_1.assertParamExists('uploadFilesV1', 'files', files);
            const localVarPath = `/v1/sparr/files/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element);
                });
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * SparrApi - functional programming interface
 * @export
 */
exports.SparrApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.SparrApiAxiosParamCreator(configuration);
    return {
        /**
         * Add a module attempt for a user
         * @summary Add Module Attempt
         * @param {string} moduleId
         * @param {UserModuleAttemptCore} userModuleAttemptCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addModuleAttemptV1(moduleId, userModuleAttemptCore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addModuleAttemptV1(moduleId, userModuleAttemptCore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.addModuleAttemptV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Assign a course to a user
         * @summary Assign Course
         * @param {string} courseId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignCourseV1(courseId, userId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.assignCourseV1(courseId, userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.assignCourseV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Attach a tag to an entity
         * @summary Attach Tag
         * @param {string} entityType
         * @param {string} entityId
         * @param {TagCreate} tagCreate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost(entityType, entityId, tagCreate, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost(entityType, entityId, tagCreate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a checkout session for a price
         * @summary Create Checkout Session For Price
         * @param {string} priceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForPriceV1(priceId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createCheckoutSessionForPriceV1(priceId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.createCheckoutSessionForPriceV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseV1(courseRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createCourseV1(courseRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.createCourseV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a customer portal for customer
         * @summary Create Customer Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPortalV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createCustomerPortalV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.createCustomerPortalV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a new feedback
         * @summary Create Feedback
         * @param {FeedbackCore} feedbackCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedbackV1(feedbackCore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createFeedbackV1(feedbackCore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.createFeedbackV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a new goals collection
         * @summary Create Goals
         * @param {GoalCoreInput} goalCoreInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoalsV1(goalCoreInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createGoalsV1(goalCoreInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.createGoalsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonaV1(personaCore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPersonaV1(personaCore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.createPersonaV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a new evaluator
         * @summary Create Evaluator
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPostCallEvaluationParamsV1(evaluatorCore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPostCallEvaluationParamsV1(evaluatorCore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.createPostCallEvaluationParamsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {CreateScenarioRequest} createScenarioRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenarioV1(createScenarioRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createScenarioV1(createScenarioRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.createScenarioV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a new tracker
         * @summary Create Tracker
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackerV1(trackerCore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createTrackerV1(trackerCore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.createTrackerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseV1(courseId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteCourseV1(courseId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.deleteCourseV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete evaluator
         * @summary Delete Evaluator
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvaluatorV1(paramsId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteEvaluatorV1(paramsId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.deleteEvaluatorV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a feedback
         * @summary Delete Feedback
         * @param {string} feedbackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedbackV1(feedbackId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteFeedbackV1(feedbackId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.deleteFeedbackV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a file
         * @summary Delete File
         * @param {string} fileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1(fileId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteFileV1(fileId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.deleteFileV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a goals collection
         * @summary Delete Goals
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoalsV1(goalsId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteGoalsV1(goalsId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.deleteGoalsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonaV1(personaId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deletePersonaV1(personaId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.deletePersonaV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioV1(scenarioId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteScenarioV1(scenarioId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.deleteScenarioV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a tracker
         * @summary Delete Tracker
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackerV1(trackerId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteTrackerV1(trackerId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.deleteTrackerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Detach a tag from an entity
         * @summary Detach Tag
         * @param {string} entityType
         * @param {string} entityId
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete(entityType, entityId, tagName, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete(entityType, entityId, tagName, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Generate evaluator data from files and/or existing core components
         * @summary Generate Evaluator
         * @param {FlexibleGenerationRequest} flexibleGenerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEvaluatorV1(flexibleGenerationRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.generateEvaluatorV1(flexibleGenerationRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.generateEvaluatorV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseV1(courseId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCourseV1(courseId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.getCourseV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get credits
         * @summary Get Credits V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditsV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCreditsV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.getCreditsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all entities of a type that have a specific tag
         * @summary Get Entities By Tag
         * @param {string} entityType
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet(entityType, tagName, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet(entityType, tagName, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all tags for an entity
         * @summary Get Entity Tags
         * @param {string} entityType
         * @param {string} entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet(entityType, entityId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet(entityType, entityId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
         * @summary Get Evaluator By Id
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluatorV1(paramsId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEvaluatorV1(paramsId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.getEvaluatorV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a specific feedback by ID
         * @summary Get Feedback
         * @param {string} feedbackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedbackV1(feedbackId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFeedbackV1(feedbackId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.getFeedbackV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a specific file by ID
         * @summary Get File
         * @param {string} fileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileV1(fileId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFileV1(fileId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.getFileV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
         * @summary Get Goals By Id
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalsV1(goalsId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getGoalsV1(goalsId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.getGoalsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get metrics for a given batch of metrics requests
         * @summary Get Metrics
         * @param {SparrModelsAnalyticsBatchMetricsRequests} sparrModelsAnalyticsBatchMetricsRequests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.getMetricsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a specific persona by ID that is either directly owned or available through reseller course assignments
         * @summary Get Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaV1(personaId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPersonaV1(personaId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.getPersonaV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get pricing
         * @summary Get Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPricingV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.getPricingV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
         * @summary Get Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioV1(scenarioId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getScenarioV1(scenarioId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.getScenarioV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
         * @summary Get Tracker By Id
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackerV1(trackerId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTrackerV1(trackerId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.getTrackerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Search personas by name, title and company
         * @summary Get User Stats
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStatsV1(userId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserStatsV1(userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.getUserStatsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLinkedinPersonaV1(linkedinUrl, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.importLinkedinPersonaV1(linkedinUrl, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.importLinkedinPersonaV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string | null} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoursesV1(skip, limit, status, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listCoursesV1(skip, limit, status, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.listCoursesV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all evaluator that are either directly owned or available through reseller course assignments
         * @summary Get Evaluator
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvaluatorV1(skip, limit, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listEvaluatorV1(skip, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.listEvaluatorV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all feedbacks
         * @summary Get Feedbacks
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string | null} [fromDate] Start date for filtering feedbacks
         * @param {string | null} [toDate] End date for filtering feedbacks
         * @param {string | null} [userFilter] User filter for filtering feedbacks. Comma separated list of user ids.
         * @param {string | null} [statusFilter] Status filter for filtering feedbacks. Comma separated list of statuses.
         * @param {string | null} [scenarioFilter] Scenario filter for filtering feedbacks. Comma separated list of scenario ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeedbacksV1(skip, limit, fromDate, toDate, userFilter, statusFilter, scenarioFilter, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listFeedbacksV1(skip, limit, fromDate, toDate, userFilter, statusFilter, scenarioFilter, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.listFeedbacksV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all goals that are either directly owned or available through reseller course assignments
         * @summary Get Goals
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGoalsV1(skip, limit, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listGoalsV1(skip, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.listGoalsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all personas that are either directly owned or available through reseller course assignments
         * @summary Get Personas
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter personas by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonasV1(skip, limit, tags, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPersonasV1(skip, limit, tags, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.listPersonasV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all scenarios that are either directly owned or available through reseller course assignments
         * @summary Get Scenarios
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter scenarios by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenariosV1(skip, limit, tags, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listScenariosV1(skip, limit, tags, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.listScenariosV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all trackers that are either directly owned or available through reseller course assignments
         * @summary Get Trackers
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrackerV1(skip, limit, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTrackerV1(skip, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.listTrackerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all course assignments for a user with analytics
         * @summary Get User Assignments
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAssignmentsV1(userId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listUserAssignmentsV1(userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.listUserAssignmentsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all module attempts with module information for a user in a specific course
         * @summary Get User Course Attempts
         * @param {string} courseId
         * @param {string} userId
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCourseAttemptsV1(courseId, userId, skip, limit, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listUserCourseAttemptsV1(courseId, userId, skip, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.listUserCourseAttemptsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all module attempts for a user
         * @summary Get User Module Attempts
         * @param {string} moduleId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserModuleAttemptsV1(moduleId, userId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listUserModuleAttemptsV1(moduleId, userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.listUserModuleAttemptsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Revoke a course from a user
         * @summary Revoke Course
         * @param {string} courseId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCourseV1(courseId, userId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.revokeCourseV1(courseId, userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.revokeCourseV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Search goals by name and description
         * @summary Search Goals
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGoalsV1(query, page, size, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchGoalsV1(query, page, size, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.searchGoalsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonasV1(query, page, size, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchPersonasV1(query, page, size, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.searchPersonasV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenariosV1(query, page, size, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchScenariosV1(query, page, size, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.searchScenariosV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Search trackers by name and description
         * @summary Search Tracker
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTrackerV1(query, page, size, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchTrackerV1(query, page, size, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.searchTrackerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Heart Beat check to check the health of Sparr Service
         * @summary Heart Beat Status Of Sparr Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusSparrStatusGet(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.statusSparrStatusGet(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.statusSparrStatusGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update course completion status
         * @summary Update Course Completion Status
         * @param {string} courseId
         * @param {string} userId
         * @param {CourseCompletionStatus} completionStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseCompletionStatusV1(courseId, userId, completionStatus, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateCourseCompletionStatusV1(courseId, userId, completionStatus, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.updateCourseCompletionStatusV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId
         * @param {CourseUpdateRequest} courseUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseV1(courseId, courseUpdateRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateCourseV1(courseId, courseUpdateRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.updateCourseV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update evaluator
         * @summary Update Evaluator
         * @param {string} paramsId
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvaluatorV1(paramsId, evaluatorCore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateEvaluatorV1(paramsId, evaluatorCore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.updateEvaluatorV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a feedback
         * @summary Update Feedback
         * @param {string} feedbackId
         * @param {FeedbackCore} feedbackCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedbackV1(feedbackId, feedbackCore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateFeedbackV1(feedbackId, feedbackCore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.updateFeedbackV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a goals collection
         * @summary Update Goals
         * @param {string} goalsId
         * @param {GoalCoreInput} goalCoreInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalsV1(goalsId, goalCoreInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateGoalsV1(goalsId, goalCoreInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.updateGoalsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonaV1(personaId, personaCore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updatePersonaV1(personaId, personaCore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.updatePersonaV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId
         * @param {CreateScenarioRequest} createScenarioRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenarioV1(scenarioId, createScenarioRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateScenarioV1(scenarioId, createScenarioRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.updateScenarioV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a tracker
         * @summary Update Tracker
         * @param {string} trackerId
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackerV1(trackerId, trackerCore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateTrackerV1(trackerId, trackerCore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.updateTrackerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Upload multiple files and create file records. Maximum 5 files per request, each file max 10MB.
         * @summary Upload Files
         * @param {Array<File>} files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilesV1(files, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadFilesV1(files, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrApi.uploadFilesV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * SparrApi - factory interface
 * @export
 */
exports.SparrApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.SparrApiFp(configuration);
    return {
        /**
         * Add a module attempt for a user
         * @summary Add Module Attempt
         * @param {string} moduleId
         * @param {UserModuleAttemptCore} userModuleAttemptCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addModuleAttemptV1(moduleId, userModuleAttemptCore, options) {
            return localVarFp.addModuleAttemptV1(moduleId, userModuleAttemptCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign a course to a user
         * @summary Assign Course
         * @param {string} courseId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignCourseV1(courseId, userId, options) {
            return localVarFp.assignCourseV1(courseId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Attach a tag to an entity
         * @summary Attach Tag
         * @param {string} entityType
         * @param {string} entityId
         * @param {TagCreate} tagCreate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost(entityType, entityId, tagCreate, options) {
            return localVarFp.attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost(entityType, entityId, tagCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a checkout session for a price
         * @summary Create Checkout Session For Price
         * @param {string} priceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForPriceV1(priceId, options) {
            return localVarFp.createCheckoutSessionForPriceV1(priceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseV1(courseRequest, options) {
            return localVarFp.createCourseV1(courseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a customer portal for customer
         * @summary Create Customer Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPortalV1(options) {
            return localVarFp.createCustomerPortalV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new feedback
         * @summary Create Feedback
         * @param {FeedbackCore} feedbackCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedbackV1(feedbackCore, options) {
            return localVarFp.createFeedbackV1(feedbackCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new goals collection
         * @summary Create Goals
         * @param {GoalCoreInput} goalCoreInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoalsV1(goalCoreInput, options) {
            return localVarFp.createGoalsV1(goalCoreInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonaV1(personaCore, options) {
            return localVarFp.createPersonaV1(personaCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new evaluator
         * @summary Create Evaluator
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPostCallEvaluationParamsV1(evaluatorCore, options) {
            return localVarFp.createPostCallEvaluationParamsV1(evaluatorCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {CreateScenarioRequest} createScenarioRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenarioV1(createScenarioRequest, options) {
            return localVarFp.createScenarioV1(createScenarioRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new tracker
         * @summary Create Tracker
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackerV1(trackerCore, options) {
            return localVarFp.createTrackerV1(trackerCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseV1(courseId, options) {
            return localVarFp.deleteCourseV1(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete evaluator
         * @summary Delete Evaluator
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvaluatorV1(paramsId, options) {
            return localVarFp.deleteEvaluatorV1(paramsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a feedback
         * @summary Delete Feedback
         * @param {string} feedbackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedbackV1(feedbackId, options) {
            return localVarFp.deleteFeedbackV1(feedbackId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a file
         * @summary Delete File
         * @param {string} fileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1(fileId, options) {
            return localVarFp.deleteFileV1(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a goals collection
         * @summary Delete Goals
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoalsV1(goalsId, options) {
            return localVarFp.deleteGoalsV1(goalsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonaV1(personaId, options) {
            return localVarFp.deletePersonaV1(personaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioV1(scenarioId, options) {
            return localVarFp.deleteScenarioV1(scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a tracker
         * @summary Delete Tracker
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackerV1(trackerId, options) {
            return localVarFp.deleteTrackerV1(trackerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detach a tag from an entity
         * @summary Detach Tag
         * @param {string} entityType
         * @param {string} entityId
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete(entityType, entityId, tagName, options) {
            return localVarFp.detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete(entityType, entityId, tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate evaluator data from files and/or existing core components
         * @summary Generate Evaluator
         * @param {FlexibleGenerationRequest} flexibleGenerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEvaluatorV1(flexibleGenerationRequest, options) {
            return localVarFp.generateEvaluatorV1(flexibleGenerationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseV1(courseId, options) {
            return localVarFp.getCourseV1(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get credits
         * @summary Get Credits V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditsV1(options) {
            return localVarFp.getCreditsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all entities of a type that have a specific tag
         * @summary Get Entities By Tag
         * @param {string} entityType
         * @param {string} tagName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet(entityType, tagName, options) {
            return localVarFp.getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet(entityType, tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all tags for an entity
         * @summary Get Entity Tags
         * @param {string} entityType
         * @param {string} entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet(entityType, entityId, options) {
            return localVarFp.getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet(entityType, entityId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
         * @summary Get Evaluator By Id
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluatorV1(paramsId, options) {
            return localVarFp.getEvaluatorV1(paramsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific feedback by ID
         * @summary Get Feedback
         * @param {string} feedbackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedbackV1(feedbackId, options) {
            return localVarFp.getFeedbackV1(feedbackId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific file by ID
         * @summary Get File
         * @param {string} fileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileV1(fileId, options) {
            return localVarFp.getFileV1(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
         * @summary Get Goals By Id
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalsV1(goalsId, options) {
            return localVarFp.getGoalsV1(goalsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get metrics for a given batch of metrics requests
         * @summary Get Metrics
         * @param {SparrModelsAnalyticsBatchMetricsRequests} sparrModelsAnalyticsBatchMetricsRequests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests, options) {
            return localVarFp.getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific persona by ID that is either directly owned or available through reseller course assignments
         * @summary Get Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaV1(personaId, options) {
            return localVarFp.getPersonaV1(personaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pricing
         * @summary Get Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingV1(options) {
            return localVarFp.getPricingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
         * @summary Get Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioV1(scenarioId, options) {
            return localVarFp.getScenarioV1(scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
         * @summary Get Tracker By Id
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackerV1(trackerId, options) {
            return localVarFp.getTrackerV1(trackerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search personas by name, title and company
         * @summary Get User Stats
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStatsV1(userId, options) {
            return localVarFp.getUserStatsV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLinkedinPersonaV1(linkedinUrl, options) {
            return localVarFp.importLinkedinPersonaV1(linkedinUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string | null} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoursesV1(skip, limit, status, options) {
            return localVarFp.listCoursesV1(skip, limit, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all evaluator that are either directly owned or available through reseller course assignments
         * @summary Get Evaluator
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvaluatorV1(skip, limit, options) {
            return localVarFp.listEvaluatorV1(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all feedbacks
         * @summary Get Feedbacks
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string | null} [fromDate] Start date for filtering feedbacks
         * @param {string | null} [toDate] End date for filtering feedbacks
         * @param {string | null} [userFilter] User filter for filtering feedbacks. Comma separated list of user ids.
         * @param {string | null} [statusFilter] Status filter for filtering feedbacks. Comma separated list of statuses.
         * @param {string | null} [scenarioFilter] Scenario filter for filtering feedbacks. Comma separated list of scenario ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeedbacksV1(skip, limit, fromDate, toDate, userFilter, statusFilter, scenarioFilter, options) {
            return localVarFp.listFeedbacksV1(skip, limit, fromDate, toDate, userFilter, statusFilter, scenarioFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all goals that are either directly owned or available through reseller course assignments
         * @summary Get Goals
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGoalsV1(skip, limit, options) {
            return localVarFp.listGoalsV1(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all personas that are either directly owned or available through reseller course assignments
         * @summary Get Personas
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter personas by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonasV1(skip, limit, tags, options) {
            return localVarFp.listPersonasV1(skip, limit, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all scenarios that are either directly owned or available through reseller course assignments
         * @summary Get Scenarios
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter scenarios by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenariosV1(skip, limit, tags, options) {
            return localVarFp.listScenariosV1(skip, limit, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all trackers that are either directly owned or available through reseller course assignments
         * @summary Get Trackers
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrackerV1(skip, limit, options) {
            return localVarFp.listTrackerV1(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all course assignments for a user with analytics
         * @summary Get User Assignments
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAssignmentsV1(userId, options) {
            return localVarFp.listUserAssignmentsV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all module attempts with module information for a user in a specific course
         * @summary Get User Course Attempts
         * @param {string} courseId
         * @param {string} userId
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCourseAttemptsV1(courseId, userId, skip, limit, options) {
            return localVarFp.listUserCourseAttemptsV1(courseId, userId, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all module attempts for a user
         * @summary Get User Module Attempts
         * @param {string} moduleId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserModuleAttemptsV1(moduleId, userId, options) {
            return localVarFp.listUserModuleAttemptsV1(moduleId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke a course from a user
         * @summary Revoke Course
         * @param {string} courseId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCourseV1(courseId, userId, options) {
            return localVarFp.revokeCourseV1(courseId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search goals by name and description
         * @summary Search Goals
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGoalsV1(query, page, size, options) {
            return localVarFp.searchGoalsV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonasV1(query, page, size, options) {
            return localVarFp.searchPersonasV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenariosV1(query, page, size, options) {
            return localVarFp.searchScenariosV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Search trackers by name and description
         * @summary Search Tracker
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTrackerV1(query, page, size, options) {
            return localVarFp.searchTrackerV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Heart Beat check to check the health of Sparr Service
         * @summary Heart Beat Status Of Sparr Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusSparrStatusGet(options) {
            return localVarFp.statusSparrStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update course completion status
         * @summary Update Course Completion Status
         * @param {string} courseId
         * @param {string} userId
         * @param {CourseCompletionStatus} completionStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseCompletionStatusV1(courseId, userId, completionStatus, options) {
            return localVarFp.updateCourseCompletionStatusV1(courseId, userId, completionStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId
         * @param {CourseUpdateRequest} courseUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseV1(courseId, courseUpdateRequest, options) {
            return localVarFp.updateCourseV1(courseId, courseUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update evaluator
         * @summary Update Evaluator
         * @param {string} paramsId
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvaluatorV1(paramsId, evaluatorCore, options) {
            return localVarFp.updateEvaluatorV1(paramsId, evaluatorCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a feedback
         * @summary Update Feedback
         * @param {string} feedbackId
         * @param {FeedbackCore} feedbackCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedbackV1(feedbackId, feedbackCore, options) {
            return localVarFp.updateFeedbackV1(feedbackId, feedbackCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a goals collection
         * @summary Update Goals
         * @param {string} goalsId
         * @param {GoalCoreInput} goalCoreInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalsV1(goalsId, goalCoreInput, options) {
            return localVarFp.updateGoalsV1(goalsId, goalCoreInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonaV1(personaId, personaCore, options) {
            return localVarFp.updatePersonaV1(personaId, personaCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId
         * @param {CreateScenarioRequest} createScenarioRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenarioV1(scenarioId, createScenarioRequest, options) {
            return localVarFp.updateScenarioV1(scenarioId, createScenarioRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a tracker
         * @summary Update Tracker
         * @param {string} trackerId
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackerV1(trackerId, trackerCore, options) {
            return localVarFp.updateTrackerV1(trackerId, trackerCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload multiple files and create file records. Maximum 5 files per request, each file max 10MB.
         * @summary Upload Files
         * @param {Array<File>} files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilesV1(files, options) {
            return localVarFp.uploadFilesV1(files, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SparrApi - object-oriented interface
 * @export
 * @class SparrApi
 * @extends {BaseAPI}
 */
class SparrApi extends base_1.BaseAPI {
    /**
     * Add a module attempt for a user
     * @summary Add Module Attempt
     * @param {string} moduleId
     * @param {UserModuleAttemptCore} userModuleAttemptCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    addModuleAttemptV1(moduleId, userModuleAttemptCore, options) {
        return exports.SparrApiFp(this.configuration).addModuleAttemptV1(moduleId, userModuleAttemptCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Assign a course to a user
     * @summary Assign Course
     * @param {string} courseId
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    assignCourseV1(courseId, userId, options) {
        return exports.SparrApiFp(this.configuration).assignCourseV1(courseId, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Attach a tag to an entity
     * @summary Attach Tag
     * @param {string} entityType
     * @param {string} entityId
     * @param {TagCreate} tagCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost(entityType, entityId, tagCreate, options) {
        return exports.SparrApiFp(this.configuration).attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost(entityType, entityId, tagCreate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a checkout session for a price
     * @summary Create Checkout Session For Price
     * @param {string} priceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    createCheckoutSessionForPriceV1(priceId, options) {
        return exports.SparrApiFp(this.configuration).createCheckoutSessionForPriceV1(priceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new course
     * @summary Create Course
     * @param {CourseRequest} courseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    createCourseV1(courseRequest, options) {
        return exports.SparrApiFp(this.configuration).createCourseV1(courseRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a customer portal for customer
     * @summary Create Customer Portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    createCustomerPortalV1(options) {
        return exports.SparrApiFp(this.configuration).createCustomerPortalV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new feedback
     * @summary Create Feedback
     * @param {FeedbackCore} feedbackCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    createFeedbackV1(feedbackCore, options) {
        return exports.SparrApiFp(this.configuration).createFeedbackV1(feedbackCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new goals collection
     * @summary Create Goals
     * @param {GoalCoreInput} goalCoreInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    createGoalsV1(goalCoreInput, options) {
        return exports.SparrApiFp(this.configuration).createGoalsV1(goalCoreInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new persona
     * @summary Create Persona
     * @param {PersonaCore} personaCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    createPersonaV1(personaCore, options) {
        return exports.SparrApiFp(this.configuration).createPersonaV1(personaCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new evaluator
     * @summary Create Evaluator
     * @param {EvaluatorCore} evaluatorCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    createPostCallEvaluationParamsV1(evaluatorCore, options) {
        return exports.SparrApiFp(this.configuration).createPostCallEvaluationParamsV1(evaluatorCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new scenario
     * @summary Create Scenario
     * @param {CreateScenarioRequest} createScenarioRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    createScenarioV1(createScenarioRequest, options) {
        return exports.SparrApiFp(this.configuration).createScenarioV1(createScenarioRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new tracker
     * @summary Create Tracker
     * @param {TrackerCore} trackerCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    createTrackerV1(trackerCore, options) {
        return exports.SparrApiFp(this.configuration).createTrackerV1(trackerCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a course
     * @summary Delete Course
     * @param {string} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    deleteCourseV1(courseId, options) {
        return exports.SparrApiFp(this.configuration).deleteCourseV1(courseId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete evaluator
     * @summary Delete Evaluator
     * @param {string} paramsId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    deleteEvaluatorV1(paramsId, options) {
        return exports.SparrApiFp(this.configuration).deleteEvaluatorV1(paramsId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a feedback
     * @summary Delete Feedback
     * @param {string} feedbackId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    deleteFeedbackV1(feedbackId, options) {
        return exports.SparrApiFp(this.configuration).deleteFeedbackV1(feedbackId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a file
     * @summary Delete File
     * @param {string} fileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    deleteFileV1(fileId, options) {
        return exports.SparrApiFp(this.configuration).deleteFileV1(fileId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a goals collection
     * @summary Delete Goals
     * @param {string} goalsId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    deleteGoalsV1(goalsId, options) {
        return exports.SparrApiFp(this.configuration).deleteGoalsV1(goalsId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a persona
     * @summary Delete Persona
     * @param {string} personaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    deletePersonaV1(personaId, options) {
        return exports.SparrApiFp(this.configuration).deletePersonaV1(personaId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a scenario
     * @summary Delete Scenario
     * @param {string} scenarioId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    deleteScenarioV1(scenarioId, options) {
        return exports.SparrApiFp(this.configuration).deleteScenarioV1(scenarioId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a tracker
     * @summary Delete Tracker
     * @param {string} trackerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    deleteTrackerV1(trackerId, options) {
        return exports.SparrApiFp(this.configuration).deleteTrackerV1(trackerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Detach a tag from an entity
     * @summary Detach Tag
     * @param {string} entityType
     * @param {string} entityId
     * @param {string} tagName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete(entityType, entityId, tagName, options) {
        return exports.SparrApiFp(this.configuration).detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete(entityType, entityId, tagName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generate evaluator data from files and/or existing core components
     * @summary Generate Evaluator
     * @param {FlexibleGenerationRequest} flexibleGenerationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    generateEvaluatorV1(flexibleGenerationRequest, options) {
        return exports.SparrApiFp(this.configuration).generateEvaluatorV1(flexibleGenerationRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific course by ID
     * @summary Get Course
     * @param {string} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getCourseV1(courseId, options) {
        return exports.SparrApiFp(this.configuration).getCourseV1(courseId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get credits
     * @summary Get Credits V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getCreditsV1(options) {
        return exports.SparrApiFp(this.configuration).getCreditsV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all entities of a type that have a specific tag
     * @summary Get Entities By Tag
     * @param {string} entityType
     * @param {string} tagName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet(entityType, tagName, options) {
        return exports.SparrApiFp(this.configuration).getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet(entityType, tagName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all tags for an entity
     * @summary Get Entity Tags
     * @param {string} entityType
     * @param {string} entityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet(entityType, entityId, options) {
        return exports.SparrApiFp(this.configuration).getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet(entityType, entityId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
     * @summary Get Evaluator By Id
     * @param {string} paramsId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getEvaluatorV1(paramsId, options) {
        return exports.SparrApiFp(this.configuration).getEvaluatorV1(paramsId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific feedback by ID
     * @summary Get Feedback
     * @param {string} feedbackId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getFeedbackV1(feedbackId, options) {
        return exports.SparrApiFp(this.configuration).getFeedbackV1(feedbackId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific file by ID
     * @summary Get File
     * @param {string} fileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getFileV1(fileId, options) {
        return exports.SparrApiFp(this.configuration).getFileV1(fileId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
     * @summary Get Goals By Id
     * @param {string} goalsId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getGoalsV1(goalsId, options) {
        return exports.SparrApiFp(this.configuration).getGoalsV1(goalsId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get metrics for a given batch of metrics requests
     * @summary Get Metrics
     * @param {SparrModelsAnalyticsBatchMetricsRequests} sparrModelsAnalyticsBatchMetricsRequests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests, options) {
        return exports.SparrApiFp(this.configuration).getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific persona by ID that is either directly owned or available through reseller course assignments
     * @summary Get Persona
     * @param {string} personaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getPersonaV1(personaId, options) {
        return exports.SparrApiFp(this.configuration).getPersonaV1(personaId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get pricing
     * @summary Get Pricing V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getPricingV1(options) {
        return exports.SparrApiFp(this.configuration).getPricingV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
     * @summary Get Scenario
     * @param {string} scenarioId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getScenarioV1(scenarioId, options) {
        return exports.SparrApiFp(this.configuration).getScenarioV1(scenarioId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
     * @summary Get Tracker By Id
     * @param {string} trackerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getTrackerV1(trackerId, options) {
        return exports.SparrApiFp(this.configuration).getTrackerV1(trackerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search personas by name, title and company
     * @summary Get User Stats
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    getUserStatsV1(userId, options) {
        return exports.SparrApiFp(this.configuration).getUserStatsV1(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Import a persona from LinkedIn URL
     * @summary Import Linkedin Persona
     * @param {string} linkedinUrl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    importLinkedinPersonaV1(linkedinUrl, options) {
        return exports.SparrApiFp(this.configuration).importLinkedinPersonaV1(linkedinUrl, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all courses including reseller assignments
     * @summary Get Courses
     * @param {number} [skip] Skip for pagination
     * @param {number} [limit] Limit for pagination
     * @param {string | null} [status] Filter by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    listCoursesV1(skip, limit, status, options) {
        return exports.SparrApiFp(this.configuration).listCoursesV1(skip, limit, status, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all evaluator that are either directly owned or available through reseller course assignments
     * @summary Get Evaluator
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    listEvaluatorV1(skip, limit, options) {
        return exports.SparrApiFp(this.configuration).listEvaluatorV1(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all feedbacks
     * @summary Get Feedbacks
     * @param {number} [skip] Skip for pagination
     * @param {number} [limit] Limit for pagination
     * @param {string | null} [fromDate] Start date for filtering feedbacks
     * @param {string | null} [toDate] End date for filtering feedbacks
     * @param {string | null} [userFilter] User filter for filtering feedbacks. Comma separated list of user ids.
     * @param {string | null} [statusFilter] Status filter for filtering feedbacks. Comma separated list of statuses.
     * @param {string | null} [scenarioFilter] Scenario filter for filtering feedbacks. Comma separated list of scenario ids.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    listFeedbacksV1(skip, limit, fromDate, toDate, userFilter, statusFilter, scenarioFilter, options) {
        return exports.SparrApiFp(this.configuration).listFeedbacksV1(skip, limit, fromDate, toDate, userFilter, statusFilter, scenarioFilter, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all goals that are either directly owned or available through reseller course assignments
     * @summary Get Goals
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    listGoalsV1(skip, limit, options) {
        return exports.SparrApiFp(this.configuration).listGoalsV1(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all personas that are either directly owned or available through reseller course assignments
     * @summary Get Personas
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [tags] Filter personas by tag, comma separated names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    listPersonasV1(skip, limit, tags, options) {
        return exports.SparrApiFp(this.configuration).listPersonasV1(skip, limit, tags, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all scenarios that are either directly owned or available through reseller course assignments
     * @summary Get Scenarios
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [tags] Filter scenarios by tag, comma separated names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    listScenariosV1(skip, limit, tags, options) {
        return exports.SparrApiFp(this.configuration).listScenariosV1(skip, limit, tags, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all trackers that are either directly owned or available through reseller course assignments
     * @summary Get Trackers
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    listTrackerV1(skip, limit, options) {
        return exports.SparrApiFp(this.configuration).listTrackerV1(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all course assignments for a user with analytics
     * @summary Get User Assignments
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    listUserAssignmentsV1(userId, options) {
        return exports.SparrApiFp(this.configuration).listUserAssignmentsV1(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all module attempts with module information for a user in a specific course
     * @summary Get User Course Attempts
     * @param {string} courseId
     * @param {string} userId
     * @param {number} [skip] Skip for pagination
     * @param {number} [limit] Limit for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    listUserCourseAttemptsV1(courseId, userId, skip, limit, options) {
        return exports.SparrApiFp(this.configuration).listUserCourseAttemptsV1(courseId, userId, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all module attempts for a user
     * @summary Get User Module Attempts
     * @param {string} moduleId
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    listUserModuleAttemptsV1(moduleId, userId, options) {
        return exports.SparrApiFp(this.configuration).listUserModuleAttemptsV1(moduleId, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Revoke a course from a user
     * @summary Revoke Course
     * @param {string} courseId
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    revokeCourseV1(courseId, userId, options) {
        return exports.SparrApiFp(this.configuration).revokeCourseV1(courseId, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search goals by name and description
     * @summary Search Goals
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    searchGoalsV1(query, page, size, options) {
        return exports.SparrApiFp(this.configuration).searchGoalsV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search personas by name, title and company
     * @summary Search Personas
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    searchPersonasV1(query, page, size, options) {
        return exports.SparrApiFp(this.configuration).searchPersonasV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search scenarios by name and description
     * @summary Search Scenarios
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    searchScenariosV1(query, page, size, options) {
        return exports.SparrApiFp(this.configuration).searchScenariosV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search trackers by name and description
     * @summary Search Tracker
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    searchTrackerV1(query, page, size, options) {
        return exports.SparrApiFp(this.configuration).searchTrackerV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Heart Beat check to check the health of Sparr Service
     * @summary Heart Beat Status Of Sparr Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    statusSparrStatusGet(options) {
        return exports.SparrApiFp(this.configuration).statusSparrStatusGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update course completion status
     * @summary Update Course Completion Status
     * @param {string} courseId
     * @param {string} userId
     * @param {CourseCompletionStatus} completionStatus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    updateCourseCompletionStatusV1(courseId, userId, completionStatus, options) {
        return exports.SparrApiFp(this.configuration).updateCourseCompletionStatusV1(courseId, userId, completionStatus, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a course
     * @summary Update Course
     * @param {string} courseId
     * @param {CourseUpdateRequest} courseUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    updateCourseV1(courseId, courseUpdateRequest, options) {
        return exports.SparrApiFp(this.configuration).updateCourseV1(courseId, courseUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update evaluator
     * @summary Update Evaluator
     * @param {string} paramsId
     * @param {EvaluatorCore} evaluatorCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    updateEvaluatorV1(paramsId, evaluatorCore, options) {
        return exports.SparrApiFp(this.configuration).updateEvaluatorV1(paramsId, evaluatorCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a feedback
     * @summary Update Feedback
     * @param {string} feedbackId
     * @param {FeedbackCore} feedbackCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    updateFeedbackV1(feedbackId, feedbackCore, options) {
        return exports.SparrApiFp(this.configuration).updateFeedbackV1(feedbackId, feedbackCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a goals collection
     * @summary Update Goals
     * @param {string} goalsId
     * @param {GoalCoreInput} goalCoreInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    updateGoalsV1(goalsId, goalCoreInput, options) {
        return exports.SparrApiFp(this.configuration).updateGoalsV1(goalsId, goalCoreInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a persona
     * @summary Update Persona
     * @param {string} personaId
     * @param {PersonaCore} personaCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    updatePersonaV1(personaId, personaCore, options) {
        return exports.SparrApiFp(this.configuration).updatePersonaV1(personaId, personaCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a scenario
     * @summary Update Scenario
     * @param {string} scenarioId
     * @param {CreateScenarioRequest} createScenarioRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    updateScenarioV1(scenarioId, createScenarioRequest, options) {
        return exports.SparrApiFp(this.configuration).updateScenarioV1(scenarioId, createScenarioRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a tracker
     * @summary Update Tracker
     * @param {string} trackerId
     * @param {TrackerCore} trackerCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    updateTrackerV1(trackerId, trackerCore, options) {
        return exports.SparrApiFp(this.configuration).updateTrackerV1(trackerId, trackerCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload multiple files and create file records. Maximum 5 files per request, each file max 10MB.
     * @summary Upload Files
     * @param {Array<File>} files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    uploadFilesV1(files, options) {
        return exports.SparrApiFp(this.configuration).uploadFilesV1(files, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SparrApi = SparrApi;
/**
 * SparrResellerApi - axios parameter creator
 * @export
 */
exports.SparrResellerApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseResellerV1: (courseRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseRequest' is not null or undefined
            common_1.assertParamExists('createCourseResellerV1', 'courseRequest', courseRequest);
            const localVarPath = `/v1/resellers/sparr/courses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(courseRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new evaluator
         * @summary Create Evaluator
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvaluatorResellerV1: (evaluatorCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'evaluatorCore' is not null or undefined
            common_1.assertParamExists('createEvaluatorResellerV1', 'evaluatorCore', evaluatorCore);
            const localVarPath = `/v1/resellers/sparr/evaluators/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(evaluatorCore, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new goals collection
         * @summary Create Goals
         * @param {GoalCoreInput} goalCoreInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoalsResellerV1: (goalCoreInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'goalCoreInput' is not null or undefined
            common_1.assertParamExists('createGoalsResellerV1', 'goalCoreInput', goalCoreInput);
            const localVarPath = `/v1/resellers/sparr/goals/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(goalCoreInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonaResellerV1: (personaCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'personaCore' is not null or undefined
            common_1.assertParamExists('createPersonaResellerV1', 'personaCore', personaCore);
            const localVarPath = `/v1/resellers/sparr/personas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(personaCore, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {CreateScenarioRequest} createScenarioRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenarioResellerV1: (createScenarioRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'createScenarioRequest' is not null or undefined
            common_1.assertParamExists('createScenarioResellerV1', 'createScenarioRequest', createScenarioRequest);
            const localVarPath = `/v1/resellers/sparr/scenarios/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createScenarioRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new tracker
         * @summary Create Tracker
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackerResellerV1: (trackerCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'trackerCore' is not null or undefined
            common_1.assertParamExists('createTrackerResellerV1', 'trackerCore', trackerCore);
            const localVarPath = `/v1/resellers/sparr/trackers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(trackerCore, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseResellerV1: (courseId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            common_1.assertParamExists('deleteCourseResellerV1', 'courseId', courseId);
            const localVarPath = `/v1/resellers/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete evaluator
         * @summary Delete Evaluator
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvaluatorResellerV1: (paramsId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'paramsId' is not null or undefined
            common_1.assertParamExists('deleteEvaluatorResellerV1', 'paramsId', paramsId);
            const localVarPath = `/v1/resellers/sparr/evaluators/{params_id}`
                .replace(`{${"params_id"}}`, encodeURIComponent(String(paramsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a goals collection
         * @summary Delete Goals
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoalsResellerV1: (goalsId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'goalsId' is not null or undefined
            common_1.assertParamExists('deleteGoalsResellerV1', 'goalsId', goalsId);
            const localVarPath = `/v1/resellers/sparr/goals/{goals_id}`
                .replace(`{${"goals_id"}}`, encodeURIComponent(String(goalsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonaResellerV1: (personaId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'personaId' is not null or undefined
            common_1.assertParamExists('deletePersonaResellerV1', 'personaId', personaId);
            const localVarPath = `/v1/resellers/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioResellerV1: (scenarioId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'scenarioId' is not null or undefined
            common_1.assertParamExists('deleteScenarioResellerV1', 'scenarioId', scenarioId);
            const localVarPath = `/v1/resellers/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a tracker
         * @summary Delete Tracker
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackerResellerV1: (trackerId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'trackerId' is not null or undefined
            common_1.assertParamExists('deleteTrackerResellerV1', 'trackerId', trackerId);
            const localVarPath = `/v1/resellers/sparr/trackers/{tracker_id}`
                .replace(`{${"tracker_id"}}`, encodeURIComponent(String(trackerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Generate evaluator data from files and/or existing core components
         * @summary Generate Evaluator
         * @param {FlexibleGenerationRequest} flexibleGenerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEvaluatorResellerV1: (flexibleGenerationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'flexibleGenerationRequest' is not null or undefined
            common_1.assertParamExists('generateEvaluatorResellerV1', 'flexibleGenerationRequest', flexibleGenerationRequest);
            const localVarPath = `/v1/resellers/sparr/evaluators/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(flexibleGenerationRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseResellerV1: (courseId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            common_1.assertParamExists('getCourseResellerV1', 'courseId', courseId);
            const localVarPath = `/v1/resellers/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
         * @summary Get Evaluator By Id
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluatorResellerV1: (paramsId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'paramsId' is not null or undefined
            common_1.assertParamExists('getEvaluatorResellerV1', 'paramsId', paramsId);
            const localVarPath = `/v1/resellers/sparr/evaluators/{params_id}`
                .replace(`{${"params_id"}}`, encodeURIComponent(String(paramsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
         * @summary Get Goals By Id
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalsResellerV1: (goalsId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'goalsId' is not null or undefined
            common_1.assertParamExists('getGoalsResellerV1', 'goalsId', goalsId);
            const localVarPath = `/v1/resellers/sparr/goals/{goals_id}`
                .replace(`{${"goals_id"}}`, encodeURIComponent(String(goalsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific persona by ID that is either directly owned or available through reseller course assignments
         * @summary Get Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaResellerV1: (personaId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'personaId' is not null or undefined
            common_1.assertParamExists('getPersonaResellerV1', 'personaId', personaId);
            const localVarPath = `/v1/resellers/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
         * @summary Get Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioResellerV1: (scenarioId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'scenarioId' is not null or undefined
            common_1.assertParamExists('getScenarioResellerV1', 'scenarioId', scenarioId);
            const localVarPath = `/v1/resellers/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
         * @summary Get Tracker By Id
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackerResellerV1: (trackerId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'trackerId' is not null or undefined
            common_1.assertParamExists('getTrackerResellerV1', 'trackerId', trackerId);
            const localVarPath = `/v1/resellers/sparr/trackers/{tracker_id}`
                .replace(`{${"tracker_id"}}`, encodeURIComponent(String(trackerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLinkedinPersonaResellerV1: (linkedinUrl, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'linkedinUrl' is not null or undefined
            common_1.assertParamExists('importLinkedinPersonaResellerV1', 'linkedinUrl', linkedinUrl);
            const localVarPath = `/v1/resellers/sparr/personas/import-linkedin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (linkedinUrl !== undefined) {
                localVarQueryParameter['linkedin_url'] = linkedinUrl;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string | null} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoursesResellerV1: (skip, limit, status, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/sparr/courses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all evaluator that are either directly owned or available through reseller course assignments
         * @summary Get Evaluator
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvaluatorResellerV1: (skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/sparr/evaluators/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all goals that are either directly owned or available through reseller course assignments
         * @summary Get Goals
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGoalsResellerV1: (skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/sparr/goals/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all personas that are either directly owned or available through reseller course assignments
         * @summary Get Personas
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter personas by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonasResellerV1: (skip, limit, tags, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/sparr/personas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all scenarios that are either directly owned or available through reseller course assignments
         * @summary Get Scenarios
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter scenarios by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenariosResellerV1: (skip, limit, tags, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/sparr/scenarios/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all trackers that are either directly owned or available through reseller course assignments
         * @summary Get Trackers
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrackerResellerV1: (skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/sparr/trackers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search goals by name and description
         * @summary Search Goals
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGoalsResellerV1: (query, page, size, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'query' is not null or undefined
            common_1.assertParamExists('searchGoalsResellerV1', 'query', query);
            const localVarPath = `/v1/resellers/sparr/goals/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonasResellerV1: (query, page, size, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'query' is not null or undefined
            common_1.assertParamExists('searchPersonasResellerV1', 'query', query);
            const localVarPath = `/v1/resellers/sparr/personas/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenariosResellerV1: (query, page, size, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'query' is not null or undefined
            common_1.assertParamExists('searchScenariosResellerV1', 'query', query);
            const localVarPath = `/v1/resellers/sparr/scenarios/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search trackers by name and description
         * @summary Search Tracker
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTrackerResellerV1: (query, page, size, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'query' is not null or undefined
            common_1.assertParamExists('searchTrackerResellerV1', 'query', query);
            const localVarPath = `/v1/resellers/sparr/trackers/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId
         * @param {CourseUpdateRequest} courseUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseResellerV1: (courseId, courseUpdateRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'courseId' is not null or undefined
            common_1.assertParamExists('updateCourseResellerV1', 'courseId', courseId);
            // verify required parameter 'courseUpdateRequest' is not null or undefined
            common_1.assertParamExists('updateCourseResellerV1', 'courseUpdateRequest', courseUpdateRequest);
            const localVarPath = `/v1/resellers/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(courseUpdateRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update evaluator
         * @summary Update Evaluator
         * @param {string} paramsId
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvaluatorResellerV1: (paramsId, evaluatorCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'paramsId' is not null or undefined
            common_1.assertParamExists('updateEvaluatorResellerV1', 'paramsId', paramsId);
            // verify required parameter 'evaluatorCore' is not null or undefined
            common_1.assertParamExists('updateEvaluatorResellerV1', 'evaluatorCore', evaluatorCore);
            const localVarPath = `/v1/resellers/sparr/evaluators/{params_id}`
                .replace(`{${"params_id"}}`, encodeURIComponent(String(paramsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(evaluatorCore, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a goals collection
         * @summary Update Goals
         * @param {string} goalsId
         * @param {GoalCoreInput} goalCoreInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalsResellerV1: (goalsId, goalCoreInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'goalsId' is not null or undefined
            common_1.assertParamExists('updateGoalsResellerV1', 'goalsId', goalsId);
            // verify required parameter 'goalCoreInput' is not null or undefined
            common_1.assertParamExists('updateGoalsResellerV1', 'goalCoreInput', goalCoreInput);
            const localVarPath = `/v1/resellers/sparr/goals/{goals_id}`
                .replace(`{${"goals_id"}}`, encodeURIComponent(String(goalsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(goalCoreInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonaResellerV1: (personaId, personaCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'personaId' is not null or undefined
            common_1.assertParamExists('updatePersonaResellerV1', 'personaId', personaId);
            // verify required parameter 'personaCore' is not null or undefined
            common_1.assertParamExists('updatePersonaResellerV1', 'personaCore', personaCore);
            const localVarPath = `/v1/resellers/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(personaCore, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId
         * @param {CreateScenarioRequest} createScenarioRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenarioResellerV1: (scenarioId, createScenarioRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'scenarioId' is not null or undefined
            common_1.assertParamExists('updateScenarioResellerV1', 'scenarioId', scenarioId);
            // verify required parameter 'createScenarioRequest' is not null or undefined
            common_1.assertParamExists('updateScenarioResellerV1', 'createScenarioRequest', createScenarioRequest);
            const localVarPath = `/v1/resellers/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createScenarioRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a tracker
         * @summary Update Tracker
         * @param {string} trackerId
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackerResellerV1: (trackerId, trackerCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'trackerId' is not null or undefined
            common_1.assertParamExists('updateTrackerResellerV1', 'trackerId', trackerId);
            // verify required parameter 'trackerCore' is not null or undefined
            common_1.assertParamExists('updateTrackerResellerV1', 'trackerCore', trackerCore);
            const localVarPath = `/v1/resellers/sparr/trackers/{tracker_id}`
                .replace(`{${"tracker_id"}}`, encodeURIComponent(String(trackerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(trackerCore, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * SparrResellerApi - functional programming interface
 * @export
 */
exports.SparrResellerApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.SparrResellerApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseResellerV1(courseRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createCourseResellerV1(courseRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.createCourseResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a new evaluator
         * @summary Create Evaluator
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvaluatorResellerV1(evaluatorCore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createEvaluatorResellerV1(evaluatorCore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.createEvaluatorResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a new goals collection
         * @summary Create Goals
         * @param {GoalCoreInput} goalCoreInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoalsResellerV1(goalCoreInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createGoalsResellerV1(goalCoreInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.createGoalsResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonaResellerV1(personaCore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPersonaResellerV1(personaCore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.createPersonaResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {CreateScenarioRequest} createScenarioRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenarioResellerV1(createScenarioRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createScenarioResellerV1(createScenarioRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.createScenarioResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a new tracker
         * @summary Create Tracker
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackerResellerV1(trackerCore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createTrackerResellerV1(trackerCore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.createTrackerResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseResellerV1(courseId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteCourseResellerV1(courseId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.deleteCourseResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete evaluator
         * @summary Delete Evaluator
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvaluatorResellerV1(paramsId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteEvaluatorResellerV1(paramsId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.deleteEvaluatorResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a goals collection
         * @summary Delete Goals
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoalsResellerV1(goalsId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteGoalsResellerV1(goalsId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.deleteGoalsResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonaResellerV1(personaId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deletePersonaResellerV1(personaId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.deletePersonaResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioResellerV1(scenarioId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteScenarioResellerV1(scenarioId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.deleteScenarioResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a tracker
         * @summary Delete Tracker
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackerResellerV1(trackerId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteTrackerResellerV1(trackerId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.deleteTrackerResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Generate evaluator data from files and/or existing core components
         * @summary Generate Evaluator
         * @param {FlexibleGenerationRequest} flexibleGenerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEvaluatorResellerV1(flexibleGenerationRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.generateEvaluatorResellerV1(flexibleGenerationRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.generateEvaluatorResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseResellerV1(courseId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCourseResellerV1(courseId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.getCourseResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
         * @summary Get Evaluator By Id
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluatorResellerV1(paramsId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEvaluatorResellerV1(paramsId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.getEvaluatorResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
         * @summary Get Goals By Id
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalsResellerV1(goalsId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getGoalsResellerV1(goalsId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.getGoalsResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a specific persona by ID that is either directly owned or available through reseller course assignments
         * @summary Get Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaResellerV1(personaId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPersonaResellerV1(personaId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.getPersonaResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
         * @summary Get Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioResellerV1(scenarioId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getScenarioResellerV1(scenarioId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.getScenarioResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
         * @summary Get Tracker By Id
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackerResellerV1(trackerId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTrackerResellerV1(trackerId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.getTrackerResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLinkedinPersonaResellerV1(linkedinUrl, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.importLinkedinPersonaResellerV1(linkedinUrl, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.importLinkedinPersonaResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string | null} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoursesResellerV1(skip, limit, status, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listCoursesResellerV1(skip, limit, status, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.listCoursesResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all evaluator that are either directly owned or available through reseller course assignments
         * @summary Get Evaluator
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvaluatorResellerV1(skip, limit, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listEvaluatorResellerV1(skip, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.listEvaluatorResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all goals that are either directly owned or available through reseller course assignments
         * @summary Get Goals
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGoalsResellerV1(skip, limit, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listGoalsResellerV1(skip, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.listGoalsResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all personas that are either directly owned or available through reseller course assignments
         * @summary Get Personas
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter personas by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonasResellerV1(skip, limit, tags, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPersonasResellerV1(skip, limit, tags, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.listPersonasResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all scenarios that are either directly owned or available through reseller course assignments
         * @summary Get Scenarios
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter scenarios by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenariosResellerV1(skip, limit, tags, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listScenariosResellerV1(skip, limit, tags, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.listScenariosResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all trackers that are either directly owned or available through reseller course assignments
         * @summary Get Trackers
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrackerResellerV1(skip, limit, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTrackerResellerV1(skip, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.listTrackerResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Search goals by name and description
         * @summary Search Goals
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGoalsResellerV1(query, page, size, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchGoalsResellerV1(query, page, size, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.searchGoalsResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonasResellerV1(query, page, size, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchPersonasResellerV1(query, page, size, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.searchPersonasResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenariosResellerV1(query, page, size, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchScenariosResellerV1(query, page, size, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.searchScenariosResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Search trackers by name and description
         * @summary Search Tracker
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTrackerResellerV1(query, page, size, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchTrackerResellerV1(query, page, size, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.searchTrackerResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId
         * @param {CourseUpdateRequest} courseUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseResellerV1(courseId, courseUpdateRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateCourseResellerV1(courseId, courseUpdateRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.updateCourseResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update evaluator
         * @summary Update Evaluator
         * @param {string} paramsId
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvaluatorResellerV1(paramsId, evaluatorCore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateEvaluatorResellerV1(paramsId, evaluatorCore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.updateEvaluatorResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a goals collection
         * @summary Update Goals
         * @param {string} goalsId
         * @param {GoalCoreInput} goalCoreInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalsResellerV1(goalsId, goalCoreInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateGoalsResellerV1(goalsId, goalCoreInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.updateGoalsResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonaResellerV1(personaId, personaCore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updatePersonaResellerV1(personaId, personaCore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.updatePersonaResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId
         * @param {CreateScenarioRequest} createScenarioRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenarioResellerV1(scenarioId, createScenarioRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateScenarioResellerV1(scenarioId, createScenarioRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.updateScenarioResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a tracker
         * @summary Update Tracker
         * @param {string} trackerId
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackerResellerV1(trackerId, trackerCore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateTrackerResellerV1(trackerId, trackerCore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparrResellerApi.updateTrackerResellerV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * SparrResellerApi - factory interface
 * @export
 */
exports.SparrResellerApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.SparrResellerApiFp(configuration);
    return {
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseResellerV1(courseRequest, options) {
            return localVarFp.createCourseResellerV1(courseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new evaluator
         * @summary Create Evaluator
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvaluatorResellerV1(evaluatorCore, options) {
            return localVarFp.createEvaluatorResellerV1(evaluatorCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new goals collection
         * @summary Create Goals
         * @param {GoalCoreInput} goalCoreInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoalsResellerV1(goalCoreInput, options) {
            return localVarFp.createGoalsResellerV1(goalCoreInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonaResellerV1(personaCore, options) {
            return localVarFp.createPersonaResellerV1(personaCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {CreateScenarioRequest} createScenarioRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenarioResellerV1(createScenarioRequest, options) {
            return localVarFp.createScenarioResellerV1(createScenarioRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new tracker
         * @summary Create Tracker
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackerResellerV1(trackerCore, options) {
            return localVarFp.createTrackerResellerV1(trackerCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseResellerV1(courseId, options) {
            return localVarFp.deleteCourseResellerV1(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete evaluator
         * @summary Delete Evaluator
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvaluatorResellerV1(paramsId, options) {
            return localVarFp.deleteEvaluatorResellerV1(paramsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a goals collection
         * @summary Delete Goals
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoalsResellerV1(goalsId, options) {
            return localVarFp.deleteGoalsResellerV1(goalsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonaResellerV1(personaId, options) {
            return localVarFp.deletePersonaResellerV1(personaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioResellerV1(scenarioId, options) {
            return localVarFp.deleteScenarioResellerV1(scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a tracker
         * @summary Delete Tracker
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackerResellerV1(trackerId, options) {
            return localVarFp.deleteTrackerResellerV1(trackerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate evaluator data from files and/or existing core components
         * @summary Generate Evaluator
         * @param {FlexibleGenerationRequest} flexibleGenerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEvaluatorResellerV1(flexibleGenerationRequest, options) {
            return localVarFp.generateEvaluatorResellerV1(flexibleGenerationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseResellerV1(courseId, options) {
            return localVarFp.getCourseResellerV1(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
         * @summary Get Evaluator By Id
         * @param {string} paramsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluatorResellerV1(paramsId, options) {
            return localVarFp.getEvaluatorResellerV1(paramsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
         * @summary Get Goals By Id
         * @param {string} goalsId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalsResellerV1(goalsId, options) {
            return localVarFp.getGoalsResellerV1(goalsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific persona by ID that is either directly owned or available through reseller course assignments
         * @summary Get Persona
         * @param {string} personaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaResellerV1(personaId, options) {
            return localVarFp.getPersonaResellerV1(personaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
         * @summary Get Scenario
         * @param {string} scenarioId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioResellerV1(scenarioId, options) {
            return localVarFp.getScenarioResellerV1(scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
         * @summary Get Tracker By Id
         * @param {string} trackerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackerResellerV1(trackerId, options) {
            return localVarFp.getTrackerResellerV1(trackerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLinkedinPersonaResellerV1(linkedinUrl, options) {
            return localVarFp.importLinkedinPersonaResellerV1(linkedinUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string | null} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoursesResellerV1(skip, limit, status, options) {
            return localVarFp.listCoursesResellerV1(skip, limit, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all evaluator that are either directly owned or available through reseller course assignments
         * @summary Get Evaluator
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvaluatorResellerV1(skip, limit, options) {
            return localVarFp.listEvaluatorResellerV1(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all goals that are either directly owned or available through reseller course assignments
         * @summary Get Goals
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGoalsResellerV1(skip, limit, options) {
            return localVarFp.listGoalsResellerV1(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all personas that are either directly owned or available through reseller course assignments
         * @summary Get Personas
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter personas by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonasResellerV1(skip, limit, tags, options) {
            return localVarFp.listPersonasResellerV1(skip, limit, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all scenarios that are either directly owned or available through reseller course assignments
         * @summary Get Scenarios
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {string} [tags] Filter scenarios by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenariosResellerV1(skip, limit, tags, options) {
            return localVarFp.listScenariosResellerV1(skip, limit, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all trackers that are either directly owned or available through reseller course assignments
         * @summary Get Trackers
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrackerResellerV1(skip, limit, options) {
            return localVarFp.listTrackerResellerV1(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Search goals by name and description
         * @summary Search Goals
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGoalsResellerV1(query, page, size, options) {
            return localVarFp.searchGoalsResellerV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonasResellerV1(query, page, size, options) {
            return localVarFp.searchPersonasResellerV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenariosResellerV1(query, page, size, options) {
            return localVarFp.searchScenariosResellerV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Search trackers by name and description
         * @summary Search Tracker
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTrackerResellerV1(query, page, size, options) {
            return localVarFp.searchTrackerResellerV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId
         * @param {CourseUpdateRequest} courseUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseResellerV1(courseId, courseUpdateRequest, options) {
            return localVarFp.updateCourseResellerV1(courseId, courseUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update evaluator
         * @summary Update Evaluator
         * @param {string} paramsId
         * @param {EvaluatorCore} evaluatorCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvaluatorResellerV1(paramsId, evaluatorCore, options) {
            return localVarFp.updateEvaluatorResellerV1(paramsId, evaluatorCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a goals collection
         * @summary Update Goals
         * @param {string} goalsId
         * @param {GoalCoreInput} goalCoreInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalsResellerV1(goalsId, goalCoreInput, options) {
            return localVarFp.updateGoalsResellerV1(goalsId, goalCoreInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId
         * @param {PersonaCore} personaCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonaResellerV1(personaId, personaCore, options) {
            return localVarFp.updatePersonaResellerV1(personaId, personaCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId
         * @param {CreateScenarioRequest} createScenarioRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenarioResellerV1(scenarioId, createScenarioRequest, options) {
            return localVarFp.updateScenarioResellerV1(scenarioId, createScenarioRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a tracker
         * @summary Update Tracker
         * @param {string} trackerId
         * @param {TrackerCore} trackerCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackerResellerV1(trackerId, trackerCore, options) {
            return localVarFp.updateTrackerResellerV1(trackerId, trackerCore, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SparrResellerApi - object-oriented interface
 * @export
 * @class SparrResellerApi
 * @extends {BaseAPI}
 */
class SparrResellerApi extends base_1.BaseAPI {
    /**
     * Create a new course
     * @summary Create Course
     * @param {CourseRequest} courseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    createCourseResellerV1(courseRequest, options) {
        return exports.SparrResellerApiFp(this.configuration).createCourseResellerV1(courseRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new evaluator
     * @summary Create Evaluator
     * @param {EvaluatorCore} evaluatorCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    createEvaluatorResellerV1(evaluatorCore, options) {
        return exports.SparrResellerApiFp(this.configuration).createEvaluatorResellerV1(evaluatorCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new goals collection
     * @summary Create Goals
     * @param {GoalCoreInput} goalCoreInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    createGoalsResellerV1(goalCoreInput, options) {
        return exports.SparrResellerApiFp(this.configuration).createGoalsResellerV1(goalCoreInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new persona
     * @summary Create Persona
     * @param {PersonaCore} personaCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    createPersonaResellerV1(personaCore, options) {
        return exports.SparrResellerApiFp(this.configuration).createPersonaResellerV1(personaCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new scenario
     * @summary Create Scenario
     * @param {CreateScenarioRequest} createScenarioRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    createScenarioResellerV1(createScenarioRequest, options) {
        return exports.SparrResellerApiFp(this.configuration).createScenarioResellerV1(createScenarioRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new tracker
     * @summary Create Tracker
     * @param {TrackerCore} trackerCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    createTrackerResellerV1(trackerCore, options) {
        return exports.SparrResellerApiFp(this.configuration).createTrackerResellerV1(trackerCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a course
     * @summary Delete Course
     * @param {string} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    deleteCourseResellerV1(courseId, options) {
        return exports.SparrResellerApiFp(this.configuration).deleteCourseResellerV1(courseId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete evaluator
     * @summary Delete Evaluator
     * @param {string} paramsId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    deleteEvaluatorResellerV1(paramsId, options) {
        return exports.SparrResellerApiFp(this.configuration).deleteEvaluatorResellerV1(paramsId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a goals collection
     * @summary Delete Goals
     * @param {string} goalsId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    deleteGoalsResellerV1(goalsId, options) {
        return exports.SparrResellerApiFp(this.configuration).deleteGoalsResellerV1(goalsId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a persona
     * @summary Delete Persona
     * @param {string} personaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    deletePersonaResellerV1(personaId, options) {
        return exports.SparrResellerApiFp(this.configuration).deletePersonaResellerV1(personaId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a scenario
     * @summary Delete Scenario
     * @param {string} scenarioId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    deleteScenarioResellerV1(scenarioId, options) {
        return exports.SparrResellerApiFp(this.configuration).deleteScenarioResellerV1(scenarioId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a tracker
     * @summary Delete Tracker
     * @param {string} trackerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    deleteTrackerResellerV1(trackerId, options) {
        return exports.SparrResellerApiFp(this.configuration).deleteTrackerResellerV1(trackerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generate evaluator data from files and/or existing core components
     * @summary Generate Evaluator
     * @param {FlexibleGenerationRequest} flexibleGenerationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    generateEvaluatorResellerV1(flexibleGenerationRequest, options) {
        return exports.SparrResellerApiFp(this.configuration).generateEvaluatorResellerV1(flexibleGenerationRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific course by ID
     * @summary Get Course
     * @param {string} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    getCourseResellerV1(courseId, options) {
        return exports.SparrResellerApiFp(this.configuration).getCourseResellerV1(courseId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
     * @summary Get Evaluator By Id
     * @param {string} paramsId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    getEvaluatorResellerV1(paramsId, options) {
        return exports.SparrResellerApiFp(this.configuration).getEvaluatorResellerV1(paramsId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
     * @summary Get Goals By Id
     * @param {string} goalsId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    getGoalsResellerV1(goalsId, options) {
        return exports.SparrResellerApiFp(this.configuration).getGoalsResellerV1(goalsId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific persona by ID that is either directly owned or available through reseller course assignments
     * @summary Get Persona
     * @param {string} personaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    getPersonaResellerV1(personaId, options) {
        return exports.SparrResellerApiFp(this.configuration).getPersonaResellerV1(personaId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
     * @summary Get Scenario
     * @param {string} scenarioId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    getScenarioResellerV1(scenarioId, options) {
        return exports.SparrResellerApiFp(this.configuration).getScenarioResellerV1(scenarioId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
     * @summary Get Tracker By Id
     * @param {string} trackerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    getTrackerResellerV1(trackerId, options) {
        return exports.SparrResellerApiFp(this.configuration).getTrackerResellerV1(trackerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Import a persona from LinkedIn URL
     * @summary Import Linkedin Persona
     * @param {string} linkedinUrl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    importLinkedinPersonaResellerV1(linkedinUrl, options) {
        return exports.SparrResellerApiFp(this.configuration).importLinkedinPersonaResellerV1(linkedinUrl, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all courses including reseller assignments
     * @summary Get Courses
     * @param {number} [skip] Skip for pagination
     * @param {number} [limit] Limit for pagination
     * @param {string | null} [status] Filter by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    listCoursesResellerV1(skip, limit, status, options) {
        return exports.SparrResellerApiFp(this.configuration).listCoursesResellerV1(skip, limit, status, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all evaluator that are either directly owned or available through reseller course assignments
     * @summary Get Evaluator
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    listEvaluatorResellerV1(skip, limit, options) {
        return exports.SparrResellerApiFp(this.configuration).listEvaluatorResellerV1(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all goals that are either directly owned or available through reseller course assignments
     * @summary Get Goals
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    listGoalsResellerV1(skip, limit, options) {
        return exports.SparrResellerApiFp(this.configuration).listGoalsResellerV1(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all personas that are either directly owned or available through reseller course assignments
     * @summary Get Personas
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [tags] Filter personas by tag, comma separated names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    listPersonasResellerV1(skip, limit, tags, options) {
        return exports.SparrResellerApiFp(this.configuration).listPersonasResellerV1(skip, limit, tags, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all scenarios that are either directly owned or available through reseller course assignments
     * @summary Get Scenarios
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {string} [tags] Filter scenarios by tag, comma separated names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    listScenariosResellerV1(skip, limit, tags, options) {
        return exports.SparrResellerApiFp(this.configuration).listScenariosResellerV1(skip, limit, tags, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all trackers that are either directly owned or available through reseller course assignments
     * @summary Get Trackers
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    listTrackerResellerV1(skip, limit, options) {
        return exports.SparrResellerApiFp(this.configuration).listTrackerResellerV1(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search goals by name and description
     * @summary Search Goals
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    searchGoalsResellerV1(query, page, size, options) {
        return exports.SparrResellerApiFp(this.configuration).searchGoalsResellerV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search personas by name, title and company
     * @summary Search Personas
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    searchPersonasResellerV1(query, page, size, options) {
        return exports.SparrResellerApiFp(this.configuration).searchPersonasResellerV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search scenarios by name and description
     * @summary Search Scenarios
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    searchScenariosResellerV1(query, page, size, options) {
        return exports.SparrResellerApiFp(this.configuration).searchScenariosResellerV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search trackers by name and description
     * @summary Search Tracker
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    searchTrackerResellerV1(query, page, size, options) {
        return exports.SparrResellerApiFp(this.configuration).searchTrackerResellerV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a course
     * @summary Update Course
     * @param {string} courseId
     * @param {CourseUpdateRequest} courseUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    updateCourseResellerV1(courseId, courseUpdateRequest, options) {
        return exports.SparrResellerApiFp(this.configuration).updateCourseResellerV1(courseId, courseUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update evaluator
     * @summary Update Evaluator
     * @param {string} paramsId
     * @param {EvaluatorCore} evaluatorCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    updateEvaluatorResellerV1(paramsId, evaluatorCore, options) {
        return exports.SparrResellerApiFp(this.configuration).updateEvaluatorResellerV1(paramsId, evaluatorCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a goals collection
     * @summary Update Goals
     * @param {string} goalsId
     * @param {GoalCoreInput} goalCoreInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    updateGoalsResellerV1(goalsId, goalCoreInput, options) {
        return exports.SparrResellerApiFp(this.configuration).updateGoalsResellerV1(goalsId, goalCoreInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a persona
     * @summary Update Persona
     * @param {string} personaId
     * @param {PersonaCore} personaCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    updatePersonaResellerV1(personaId, personaCore, options) {
        return exports.SparrResellerApiFp(this.configuration).updatePersonaResellerV1(personaId, personaCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a scenario
     * @summary Update Scenario
     * @param {string} scenarioId
     * @param {CreateScenarioRequest} createScenarioRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    updateScenarioResellerV1(scenarioId, createScenarioRequest, options) {
        return exports.SparrResellerApiFp(this.configuration).updateScenarioResellerV1(scenarioId, createScenarioRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a tracker
     * @summary Update Tracker
     * @param {string} trackerId
     * @param {TrackerCore} trackerCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    updateTrackerResellerV1(trackerId, trackerCore, options) {
        return exports.SparrResellerApiFp(this.configuration).updateTrackerResellerV1(trackerId, trackerCore, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SparrResellerApi = SparrResellerApi;
/**
 * SparringApi - axios parameter creator
 * @export
 */
exports.SparringApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a virtual prospect
         * @summary Create Virtual Prospect
         * @param {VirtualProspectInput} virtualProspectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualProspectV1SparrVirtualProspectsPost: (virtualProspectInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'virtualProspectInput' is not null or undefined
            common_1.assertParamExists('createVirtualProspectV1SparrVirtualProspectsPost', 'virtualProspectInput', virtualProspectInput);
            const localVarPath = `/v1/sparr/virtual-prospects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(virtualProspectInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a virtual prospect
         * @summary Delete Virtual Prospect
         * @param {string} prospectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete: (prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectId' is not null or undefined
            common_1.assertParamExists('deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete', 'prospectId', prospectId);
            const localVarPath = `/v1/sparr/virtual-prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get sparring stats from Trata AI like call count, prospect count, etc.
         * @summary Get Sparring Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSparringStatsV1SparrSparringStatsGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/sparring-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get virtual prospect associated with an agent
         * @summary Get Virtual Prospect by Agent ID
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet: (agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            common_1.assertParamExists('getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet', 'agentId', agentId);
            const localVarPath = `/v1/sparr/agent/{agent_id}/virtual-prospect`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a virtual prospect
         * @summary Get Virtual Prospect
         * @param {string} prospectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectV1SparrVirtualProspectsProspectIdGet: (prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectId' is not null or undefined
            common_1.assertParamExists('getVirtualProspectV1SparrVirtualProspectsProspectIdGet', 'prospectId', prospectId);
            const localVarPath = `/v1/sparr/virtual-prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Link a virtual prospect to an agent
         * @summary Link Virtual Prospect to Agent
         * @param {string} prospectId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost: (prospectId, agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectId' is not null or undefined
            common_1.assertParamExists('linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost', 'prospectId', prospectId);
            // verify required parameter 'agentId' is not null or undefined
            common_1.assertParamExists('linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost', 'agentId', agentId);
            const localVarPath = `/v1/sparr/virtual-prospects/{prospect_id}/agent/{agent_id}/link`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all virtual prospects
         * @summary List Virtual Prospects
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualProspectsV1SparrVirtualProspectsGet: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr/virtual-prospects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter instanceof Date) ?
                    updatedAfter.toISOString() :
                    updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore instanceof Date) ?
                    updatedBefore.toISOString() :
                    updatedBefore;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a virtual prospect
         * @summary Update Virtual Prospect
         * @param {string} prospectId
         * @param {VirtualProspectInput} virtualProspectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVirtualProspectV1SparrVirtualProspectsProspectIdPut: (prospectId, virtualProspectInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectId' is not null or undefined
            common_1.assertParamExists('updateVirtualProspectV1SparrVirtualProspectsProspectIdPut', 'prospectId', prospectId);
            // verify required parameter 'virtualProspectInput' is not null or undefined
            common_1.assertParamExists('updateVirtualProspectV1SparrVirtualProspectsProspectIdPut', 'virtualProspectInput', virtualProspectInput);
            const localVarPath = `/v1/sparr/virtual-prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(virtualProspectInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * SparringApi - functional programming interface
 * @export
 */
exports.SparringApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.SparringApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a virtual prospect
         * @summary Create Virtual Prospect
         * @param {VirtualProspectInput} virtualProspectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparringApi.createVirtualProspectV1SparrVirtualProspectsPost']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a virtual prospect
         * @summary Delete Virtual Prospect
         * @param {string} prospectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparringApi.deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get sparring stats from Trata AI like call count, prospect count, etc.
         * @summary Get Sparring Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSparringStatsV1SparrSparringStatsGet(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSparringStatsV1SparrSparringStatsGet(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparringApi.getSparringStatsV1SparrSparringStatsGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get virtual prospect associated with an agent
         * @summary Get Virtual Prospect by Agent ID
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparringApi.getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a virtual prospect
         * @summary Get Virtual Prospect
         * @param {string} prospectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparringApi.getVirtualProspectV1SparrVirtualProspectsProspectIdGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Link a virtual prospect to an agent
         * @summary Link Virtual Prospect to Agent
         * @param {string} prospectId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparringApi.linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all virtual prospects
         * @summary List Virtual Prospects
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparringApi.listVirtualProspectsV1SparrVirtualProspectsGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a virtual prospect
         * @summary Update Virtual Prospect
         * @param {string} prospectId
         * @param {VirtualProspectInput} virtualProspectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SparringApi.updateVirtualProspectV1SparrVirtualProspectsProspectIdPut']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * SparringApi - factory interface
 * @export
 */
exports.SparringApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.SparringApiFp(configuration);
    return {
        /**
         * Create a virtual prospect
         * @summary Create Virtual Prospect
         * @param {VirtualProspectInput} virtualProspectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options) {
            return localVarFp.createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a virtual prospect
         * @summary Delete Virtual Prospect
         * @param {string} prospectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options) {
            return localVarFp.deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get sparring stats from Trata AI like call count, prospect count, etc.
         * @summary Get Sparring Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSparringStatsV1SparrSparringStatsGet(options) {
            return localVarFp.getSparringStatsV1SparrSparringStatsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get virtual prospect associated with an agent
         * @summary Get Virtual Prospect by Agent ID
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options) {
            return localVarFp.getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a virtual prospect
         * @summary Get Virtual Prospect
         * @param {string} prospectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options) {
            return localVarFp.getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Link a virtual prospect to an agent
         * @summary Link Virtual Prospect to Agent
         * @param {string} prospectId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options) {
            return localVarFp.linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all virtual prospects
         * @summary List Virtual Prospects
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
            return localVarFp.listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a virtual prospect
         * @summary Update Virtual Prospect
         * @param {string} prospectId
         * @param {VirtualProspectInput} virtualProspectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options) {
            return localVarFp.updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SparringApi - object-oriented interface
 * @export
 * @class SparringApi
 * @extends {BaseAPI}
 */
class SparringApi extends base_1.BaseAPI {
    /**
     * Create a virtual prospect
     * @summary Create Virtual Prospect
     * @param {VirtualProspectInput} virtualProspectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options) {
        return exports.SparringApiFp(this.configuration).createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a virtual prospect
     * @summary Delete Virtual Prospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options) {
        return exports.SparringApiFp(this.configuration).deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get sparring stats from Trata AI like call count, prospect count, etc.
     * @summary Get Sparring Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    getSparringStatsV1SparrSparringStatsGet(options) {
        return exports.SparringApiFp(this.configuration).getSparringStatsV1SparrSparringStatsGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get virtual prospect associated with an agent
     * @summary Get Virtual Prospect by Agent ID
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options) {
        return exports.SparringApiFp(this.configuration).getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a virtual prospect
     * @summary Get Virtual Prospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options) {
        return exports.SparringApiFp(this.configuration).getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Link a virtual prospect to an agent
     * @summary Link Virtual Prospect to Agent
     * @param {string} prospectId
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options) {
        return exports.SparringApiFp(this.configuration).linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all virtual prospects
     * @summary List Virtual Prospects
     * @param {string | null} [searchBy]
     * @param {string | null} [searchValue]
     * @param {string | null} [status]
     * @param {string | null} [sortBy]
     * @param {SortOrder | null} [sortOrder]
     * @param {number | null} [skip]
     * @param {number | null} [limit]
     * @param {string | null} [updatedAfter]
     * @param {string | null} [updatedBefore]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options) {
        return exports.SparringApiFp(this.configuration).listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a virtual prospect
     * @summary Update Virtual Prospect
     * @param {string} prospectId
     * @param {VirtualProspectInput} virtualProspectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options) {
        return exports.SparringApiFp(this.configuration).updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SparringApi = SparringApi;
/**
 * TelephonyApi - axios parameter creator
 * @export
 */
exports.TelephonyApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get Agent Phones
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentPhonesV1: (agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            common_1.assertParamExists('getAgentPhonesV1', 'agentId', agentId);
            const localVarPath = `/v1/ai-agents/{agent_id}/phones`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Link Phone To Agent
         * @param {string} phoneId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPhoneToAgentV1: (phoneId, agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'phoneId' is not null or undefined
            common_1.assertParamExists('linkPhoneToAgentV1', 'phoneId', phoneId);
            // verify required parameter 'agentId' is not null or undefined
            common_1.assertParamExists('linkPhoneToAgentV1', 'agentId', agentId);
            const localVarPath = `/v1/telephony/phones/{phone_id}/ai-agents/{agent_id}/link`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Available Phones
         * @param {string} countryCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailablePhonesV1: (countryCode, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'countryCode' is not null or undefined
            common_1.assertParamExists('listAvailablePhonesV1', 'countryCode', countryCode);
            const localVarPath = `/v1/telephony/countries/{country_code}/available-phones`
                .replace(`{${"country_code"}}`, encodeURIComponent(String(countryCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Purchased Phones
         * @param {string | null} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPurchasedPhonesV1: (countryCode, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/telephony/phones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedCountriesV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/telephony/countries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePhoneV1: (numberPurchaseRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'numberPurchaseRequest' is not null or undefined
            common_1.assertParamExists('purchasePhoneV1', 'numberPurchaseRequest', numberPurchaseRequest);
            const localVarPath = `/v1/telephony/phones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(numberPurchaseRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Release Phone
         * @param {string} phoneId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePhoneV1: (phoneId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'phoneId' is not null or undefined
            common_1.assertParamExists('releasePhoneV1', 'phoneId', phoneId);
            const localVarPath = `/v1/telephony/phones/{phone_id}`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Unlink Phone From Agent
         * @param {string} phoneId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPhoneFromAgentV1: (phoneId, agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'phoneId' is not null or undefined
            common_1.assertParamExists('unlinkPhoneFromAgentV1', 'phoneId', phoneId);
            // verify required parameter 'agentId' is not null or undefined
            common_1.assertParamExists('unlinkPhoneFromAgentV1', 'agentId', agentId);
            const localVarPath = `/v1/telephony/phones/{phone_id}/ai-agents/{agent_id}/link`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TelephonyApi - functional programming interface
 * @export
 */
exports.TelephonyApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.TelephonyApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get Agent Phones
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentPhonesV1(agentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAgentPhonesV1(agentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TelephonyApi.getAgentPhonesV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Link Phone To Agent
         * @param {string} phoneId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPhoneToAgentV1(phoneId, agentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.linkPhoneToAgentV1(phoneId, agentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TelephonyApi.linkPhoneToAgentV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary List Available Phones
         * @param {string} countryCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailablePhonesV1(countryCode, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAvailablePhonesV1(countryCode, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TelephonyApi.listAvailablePhonesV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary List Purchased Phones
         * @param {string | null} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPurchasedPhonesV1(countryCode, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPurchasedPhonesV1(countryCode, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TelephonyApi.listPurchasedPhonesV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedCountriesV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listSupportedCountriesV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TelephonyApi.listSupportedCountriesV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePhoneV1(numberPurchaseRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.purchasePhoneV1(numberPurchaseRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TelephonyApi.purchasePhoneV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Release Phone
         * @param {string} phoneId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePhoneV1(phoneId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.releasePhoneV1(phoneId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TelephonyApi.releasePhoneV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Unlink Phone From Agent
         * @param {string} phoneId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPhoneFromAgentV1(phoneId, agentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.unlinkPhoneFromAgentV1(phoneId, agentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TelephonyApi.unlinkPhoneFromAgentV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * TelephonyApi - factory interface
 * @export
 */
exports.TelephonyApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.TelephonyApiFp(configuration);
    return {
        /**
         *
         * @summary Get Agent Phones
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentPhonesV1(agentId, options) {
            return localVarFp.getAgentPhonesV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Link Phone To Agent
         * @param {string} phoneId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPhoneToAgentV1(phoneId, agentId, options) {
            return localVarFp.linkPhoneToAgentV1(phoneId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Available Phones
         * @param {string} countryCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailablePhonesV1(countryCode, options) {
            return localVarFp.listAvailablePhonesV1(countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Purchased Phones
         * @param {string | null} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPurchasedPhonesV1(countryCode, options) {
            return localVarFp.listPurchasedPhonesV1(countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedCountriesV1(options) {
            return localVarFp.listSupportedCountriesV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePhoneV1(numberPurchaseRequest, options) {
            return localVarFp.purchasePhoneV1(numberPurchaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Release Phone
         * @param {string} phoneId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePhoneV1(phoneId, options) {
            return localVarFp.releasePhoneV1(phoneId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Unlink Phone From Agent
         * @param {string} phoneId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPhoneFromAgentV1(phoneId, agentId, options) {
            return localVarFp.unlinkPhoneFromAgentV1(phoneId, agentId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TelephonyApi - object-oriented interface
 * @export
 * @class TelephonyApi
 * @extends {BaseAPI}
 */
class TelephonyApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get Agent Phones
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    getAgentPhonesV1(agentId, options) {
        return exports.TelephonyApiFp(this.configuration).getAgentPhonesV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Link Phone To Agent
     * @param {string} phoneId
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    linkPhoneToAgentV1(phoneId, agentId, options) {
        return exports.TelephonyApiFp(this.configuration).linkPhoneToAgentV1(phoneId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Available Phones
     * @param {string} countryCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    listAvailablePhonesV1(countryCode, options) {
        return exports.TelephonyApiFp(this.configuration).listAvailablePhonesV1(countryCode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Purchased Phones
     * @param {string | null} [countryCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    listPurchasedPhonesV1(countryCode, options) {
        return exports.TelephonyApiFp(this.configuration).listPurchasedPhonesV1(countryCode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Supported Countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    listSupportedCountriesV1(options) {
        return exports.TelephonyApiFp(this.configuration).listSupportedCountriesV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Purchase Phone
     * @param {NumberPurchaseRequest} numberPurchaseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    purchasePhoneV1(numberPurchaseRequest, options) {
        return exports.TelephonyApiFp(this.configuration).purchasePhoneV1(numberPurchaseRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Release Phone
     * @param {string} phoneId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    releasePhoneV1(phoneId, options) {
        return exports.TelephonyApiFp(this.configuration).releasePhoneV1(phoneId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Unlink Phone From Agent
     * @param {string} phoneId
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    unlinkPhoneFromAgentV1(phoneId, agentId, options) {
        return exports.TelephonyApiFp(this.configuration).unlinkPhoneFromAgentV1(phoneId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TelephonyApi = TelephonyApi;
/**
 * UIApi - axios parameter creator
 * @export
 */
exports.UIApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary List Action Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionTemplatesV1: (language, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/ui/action-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Products
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {string | null} [tags]
         * @param {string | null} [productIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsDetailedV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/ui/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter instanceof Date) ?
                    updatedAfter.toISOString() :
                    updatedAfter;
            }
            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore instanceof Date) ?
                    updatedBefore.toISOString() :
                    updatedBefore;
            }
            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }
            if (productIds !== undefined) {
                localVarQueryParameter['product_ids'] = productIds;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Prompt Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptTemplatesV1: (language, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/ui/prompt-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Role Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleTemplatesV1: (language, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/ui/role-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * UIApi - functional programming interface
 * @export
 */
exports.UIApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.UIApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary List Action Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionTemplatesV1(language, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listActionTemplatesV1(language, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UIApi.listActionTemplatesV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary List Products
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {string | null} [tags]
         * @param {string | null} [productIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UIApi.listProductsDetailedV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary List Prompt Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptTemplatesV1(language, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPromptTemplatesV1(language, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UIApi.listPromptTemplatesV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary List Role Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleTemplatesV1(language, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listRoleTemplatesV1(language, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UIApi.listRoleTemplatesV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * UIApi - factory interface
 * @export
 */
exports.UIApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.UIApiFp(configuration);
    return {
        /**
         *
         * @summary List Action Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionTemplatesV1(language, options) {
            return localVarFp.listActionTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Products
         * @param {string | null} [searchBy]
         * @param {string | null} [searchValue]
         * @param {string | null} [status]
         * @param {string | null} [sortBy]
         * @param {SortOrder | null} [sortOrder]
         * @param {number | null} [skip]
         * @param {number | null} [limit]
         * @param {string | null} [updatedAfter]
         * @param {string | null} [updatedBefore]
         * @param {string | null} [tags]
         * @param {string | null} [productIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options) {
            return localVarFp.listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Prompt Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptTemplatesV1(language, options) {
            return localVarFp.listPromptTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Role Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleTemplatesV1(language, options) {
            return localVarFp.listRoleTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UIApi - object-oriented interface
 * @export
 * @class UIApi
 * @extends {BaseAPI}
 */
class UIApi extends base_1.BaseAPI {
    /**
     *
     * @summary List Action Templates
     * @param {string} [language]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    listActionTemplatesV1(language, options) {
        return exports.UIApiFp(this.configuration).listActionTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Products
     * @param {string | null} [searchBy]
     * @param {string | null} [searchValue]
     * @param {string | null} [status]
     * @param {string | null} [sortBy]
     * @param {SortOrder | null} [sortOrder]
     * @param {number | null} [skip]
     * @param {number | null} [limit]
     * @param {string | null} [updatedAfter]
     * @param {string | null} [updatedBefore]
     * @param {string | null} [tags]
     * @param {string | null} [productIds]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options) {
        return exports.UIApiFp(this.configuration).listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Prompt Templates
     * @param {string} [language]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    listPromptTemplatesV1(language, options) {
        return exports.UIApiFp(this.configuration).listPromptTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Role Templates
     * @param {string} [language]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    listRoleTemplatesV1(language, options) {
        return exports.UIApiFp(this.configuration).listRoleTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UIApi = UIApi;
/**
 * VoiceModelsApi - axios parameter creator
 * @export
 */
exports.VoiceModelsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get List Of Voices Available For Sparr
         * @summary Get List Of Voices Available For Sparr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSparrVoiceModelsV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/sparr-voice-models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get List Of Voices Available For Conversations
         * @summary Get List Of Voices Available For Conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceModelsV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/voice-models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * VoiceModelsApi - functional programming interface
 * @export
 */
exports.VoiceModelsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.VoiceModelsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get List Of Voices Available For Sparr
         * @summary Get List Of Voices Available For Sparr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSparrVoiceModelsV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listSparrVoiceModelsV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VoiceModelsApi.listSparrVoiceModelsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get List Of Voices Available For Conversations
         * @summary Get List Of Voices Available For Conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceModelsV1(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listVoiceModelsV1(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VoiceModelsApi.listVoiceModelsV1']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * VoiceModelsApi - factory interface
 * @export
 */
exports.VoiceModelsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.VoiceModelsApiFp(configuration);
    return {
        /**
         * Get List Of Voices Available For Sparr
         * @summary Get List Of Voices Available For Sparr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSparrVoiceModelsV1(options) {
            return localVarFp.listSparrVoiceModelsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get List Of Voices Available For Conversations
         * @summary Get List Of Voices Available For Conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceModelsV1(options) {
            return localVarFp.listVoiceModelsV1(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * VoiceModelsApi - object-oriented interface
 * @export
 * @class VoiceModelsApi
 * @extends {BaseAPI}
 */
class VoiceModelsApi extends base_1.BaseAPI {
    /**
     * Get List Of Voices Available For Sparr
     * @summary Get List Of Voices Available For Sparr
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceModelsApi
     */
    listSparrVoiceModelsV1(options) {
        return exports.VoiceModelsApiFp(this.configuration).listSparrVoiceModelsV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get List Of Voices Available For Conversations
     * @summary Get List Of Voices Available For Conversations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceModelsApi
     */
    listVoiceModelsV1(options) {
        return exports.VoiceModelsApiFp(this.configuration).listVoiceModelsV1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.VoiceModelsApi = VoiceModelsApi;
/**
 * WorkflowsApi - axios parameter creator
 * @export
 */
exports.WorkflowsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create Workflow
         * @param {WorkflowCore} workflowCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowV1WorkflowsPost: (workflowCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowCore' is not null or undefined
            common_1.assertParamExists('createWorkflowV1WorkflowsPost', 'workflowCore', workflowCore);
            const localVarPath = `/v1/workflows/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(workflowCore, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete Workflow
         * @param {string} workflowId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowV1WorkflowsWorkflowIdDelete: (workflowId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowId' is not null or undefined
            common_1.assertParamExists('deleteWorkflowV1WorkflowsWorkflowIdDelete', 'workflowId', workflowId);
            const localVarPath = `/v1/workflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Read Workflow
         * @param {string} workflowId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowV1WorkflowsWorkflowIdGet: (workflowId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowId' is not null or undefined
            common_1.assertParamExists('readWorkflowV1WorkflowsWorkflowIdGet', 'workflowId', workflowId);
            const localVarPath = `/v1/workflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Read Workflows
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {AgenticWorkflowAdkModelsWorkflowAppEnum | null} [app]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowsV1WorkflowsGet: (skip, limit, app, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/workflows/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Trigger Workflow Step
         * @param {string} workflowId
         * @param {string} stepId
         * @param {WorkflowStepTriggerRequest} workflowStepTriggerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost: (workflowId, stepId, workflowStepTriggerRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowId' is not null or undefined
            common_1.assertParamExists('triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost', 'workflowId', workflowId);
            // verify required parameter 'stepId' is not null or undefined
            common_1.assertParamExists('triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost', 'stepId', stepId);
            // verify required parameter 'workflowStepTriggerRequest' is not null or undefined
            common_1.assertParamExists('triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost', 'workflowStepTriggerRequest', workflowStepTriggerRequest);
            const localVarPath = `/v1/workflows/{workflow_id}/step/{step_id}/trigger`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)))
                .replace(`{${"step_id"}}`, encodeURIComponent(String(stepId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(workflowStepTriggerRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update Workflow
         * @param {string} workflowId
         * @param {WorkflowCore} workflowCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowV1WorkflowsWorkflowIdPut: (workflowId, workflowCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowId' is not null or undefined
            common_1.assertParamExists('updateWorkflowV1WorkflowsWorkflowIdPut', 'workflowId', workflowId);
            // verify required parameter 'workflowCore' is not null or undefined
            common_1.assertParamExists('updateWorkflowV1WorkflowsWorkflowIdPut', 'workflowCore', workflowCore);
            const localVarPath = `/v1/workflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(workflowCore, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Upload File
         * @param {string} workflowId
         * @param {File} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1WorkflowsWorkflowIdFilePost: (workflowId, file, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowId' is not null or undefined
            common_1.assertParamExists('uploadFileV1WorkflowsWorkflowIdFilePost', 'workflowId', workflowId);
            // verify required parameter 'file' is not null or undefined
            common_1.assertParamExists('uploadFileV1WorkflowsWorkflowIdFilePost', 'file', file);
            const localVarPath = `/v1/workflows/{workflow_id}/file`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * WorkflowsApi - functional programming interface
 * @export
 */
exports.WorkflowsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.WorkflowsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create Workflow
         * @param {WorkflowCore} workflowCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowV1WorkflowsPost(workflowCore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createWorkflowV1WorkflowsPost(workflowCore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsApi.createWorkflowV1WorkflowsPost']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete Workflow
         * @param {string} workflowId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsApi.deleteWorkflowV1WorkflowsWorkflowIdDelete']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Read Workflow
         * @param {string} workflowId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsApi.readWorkflowV1WorkflowsWorkflowIdGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Read Workflows
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {AgenticWorkflowAdkModelsWorkflowAppEnum | null} [app]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowsV1WorkflowsGet(skip, limit, app, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.readWorkflowsV1WorkflowsGet(skip, limit, app, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsApi.readWorkflowsV1WorkflowsGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Trigger Workflow Step
         * @param {string} workflowId
         * @param {string} stepId
         * @param {WorkflowStepTriggerRequest} workflowStepTriggerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsApi.triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Update Workflow
         * @param {string} workflowId
         * @param {WorkflowCore} workflowCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsApi.updateWorkflowV1WorkflowsWorkflowIdPut']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Upload File
         * @param {string} workflowId
         * @param {File} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1WorkflowsWorkflowIdFilePost(workflowId, file, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadFileV1WorkflowsWorkflowIdFilePost(workflowId, file, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsApi.uploadFileV1WorkflowsWorkflowIdFilePost']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * WorkflowsApi - factory interface
 * @export
 */
exports.WorkflowsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.WorkflowsApiFp(configuration);
    return {
        /**
         *
         * @summary Create Workflow
         * @param {WorkflowCore} workflowCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowV1WorkflowsPost(workflowCore, options) {
            return localVarFp.createWorkflowV1WorkflowsPost(workflowCore, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete Workflow
         * @param {string} workflowId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, options) {
            return localVarFp.deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Read Workflow
         * @param {string} workflowId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options) {
            return localVarFp.readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Read Workflows
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {AgenticWorkflowAdkModelsWorkflowAppEnum | null} [app]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowsV1WorkflowsGet(skip, limit, app, options) {
            return localVarFp.readWorkflowsV1WorkflowsGet(skip, limit, app, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Trigger Workflow Step
         * @param {string} workflowId
         * @param {string} stepId
         * @param {WorkflowStepTriggerRequest} workflowStepTriggerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options) {
            return localVarFp.triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update Workflow
         * @param {string} workflowId
         * @param {WorkflowCore} workflowCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options) {
            return localVarFp.updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Upload File
         * @param {string} workflowId
         * @param {File} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1WorkflowsWorkflowIdFilePost(workflowId, file, options) {
            return localVarFp.uploadFileV1WorkflowsWorkflowIdFilePost(workflowId, file, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * WorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsApi
 * @extends {BaseAPI}
 */
class WorkflowsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create Workflow
     * @param {WorkflowCore} workflowCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    createWorkflowV1WorkflowsPost(workflowCore, options) {
        return exports.WorkflowsApiFp(this.configuration).createWorkflowV1WorkflowsPost(workflowCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete Workflow
     * @param {string} workflowId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, options) {
        return exports.WorkflowsApiFp(this.configuration).deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Read Workflow
     * @param {string} workflowId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options) {
        return exports.WorkflowsApiFp(this.configuration).readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Read Workflows
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {AgenticWorkflowAdkModelsWorkflowAppEnum | null} [app]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    readWorkflowsV1WorkflowsGet(skip, limit, app, options) {
        return exports.WorkflowsApiFp(this.configuration).readWorkflowsV1WorkflowsGet(skip, limit, app, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Trigger Workflow Step
     * @param {string} workflowId
     * @param {string} stepId
     * @param {WorkflowStepTriggerRequest} workflowStepTriggerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options) {
        return exports.WorkflowsApiFp(this.configuration).triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update Workflow
     * @param {string} workflowId
     * @param {WorkflowCore} workflowCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options) {
        return exports.WorkflowsApiFp(this.configuration).updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Upload File
     * @param {string} workflowId
     * @param {File} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    uploadFileV1WorkflowsWorkflowIdFilePost(workflowId, file, options) {
        return exports.WorkflowsApiFp(this.configuration).uploadFileV1WorkflowsWorkflowIdFilePost(workflowId, file, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WorkflowsApi = WorkflowsApi;
/**
 * WorkflowsApiHubspotApi - axios parameter creator
 * @export
 */
exports.WorkflowsApiHubspotApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Handle Hubspot Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/workflows/api/hubspot/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * WorkflowsApiHubspotApi - functional programming interface
 * @export
 */
exports.WorkflowsApiHubspotApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.WorkflowsApiHubspotApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Handle Hubspot Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsApiHubspotApi.handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * WorkflowsApiHubspotApi - factory interface
 * @export
 */
exports.WorkflowsApiHubspotApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.WorkflowsApiHubspotApiFp(configuration);
    return {
        /**
         *
         * @summary Handle Hubspot Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options) {
            return localVarFp.handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * WorkflowsApiHubspotApi - object-oriented interface
 * @export
 * @class WorkflowsApiHubspotApi
 * @extends {BaseAPI}
 */
class WorkflowsApiHubspotApi extends base_1.BaseAPI {
    /**
     *
     * @summary Handle Hubspot Webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApiHubspotApi
     */
    handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options) {
        return exports.WorkflowsApiHubspotApiFp(this.configuration).handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WorkflowsApiHubspotApi = WorkflowsApiHubspotApi;
/**
 * WorkflowsAppsApi - axios parameter creator
 * @export
 */
exports.WorkflowsAppsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create App
         * @param {AppEntity} appEntity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAppV1WorkflowsAppsPost: (appEntity, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'appEntity' is not null or undefined
            common_1.assertParamExists('createAppV1WorkflowsAppsPost', 'appEntity', appEntity);
            const localVarPath = `/v1/workflows/apps/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(appEntity, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete App
         * @param {string} appId
         * @param {string | null} [version]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppV1WorkflowsAppsAppIdDelete: (appId, version, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'appId' is not null or undefined
            common_1.assertParamExists('deleteAppV1WorkflowsAppsAppIdDelete', 'appId', appId);
            const localVarPath = `/v1/workflows/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Connections By App Id
         * @param {string} appId
         * @param {string} version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet: (appId, version, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'appId' is not null or undefined
            common_1.assertParamExists('getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet', 'appId', appId);
            // verify required parameter 'version' is not null or undefined
            common_1.assertParamExists('getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet', 'version', version);
            const localVarPath = `/v1/workflows/apps/{app_id}/versions/{version}/connections`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Read App
         * @param {string} appId
         * @param {string | null} [version]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppV1WorkflowsAppsAppIdGet: (appId, version, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'appId' is not null or undefined
            common_1.assertParamExists('readAppV1WorkflowsAppsAppIdGet', 'appId', appId);
            const localVarPath = `/v1/workflows/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Read Apps
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppsV1WorkflowsAppsGet: (skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/workflows/apps/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update App
         * @param {string} appId
         * @param {AppEntity} appEntity
         * @param {string | null} [version]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppV1WorkflowsAppsAppIdPut: (appId, appEntity, version, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'appId' is not null or undefined
            common_1.assertParamExists('updateAppV1WorkflowsAppsAppIdPut', 'appId', appId);
            // verify required parameter 'appEntity' is not null or undefined
            common_1.assertParamExists('updateAppV1WorkflowsAppsAppIdPut', 'appEntity', appEntity);
            const localVarPath = `/v1/workflows/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(appEntity, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * WorkflowsAppsApi - functional programming interface
 * @export
 */
exports.WorkflowsAppsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.WorkflowsAppsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create App
         * @param {AppEntity} appEntity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAppV1WorkflowsAppsPost(appEntity, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createAppV1WorkflowsAppsPost(appEntity, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsAppsApi.createAppV1WorkflowsAppsPost']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete App
         * @param {string} appId
         * @param {string | null} [version]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsAppsApi.deleteAppV1WorkflowsAppsAppIdDelete']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get Connections By App Id
         * @param {string} appId
         * @param {string} version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsAppsApi.getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Read App
         * @param {string} appId
         * @param {string | null} [version]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppV1WorkflowsAppsAppIdGet(appId, version, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.readAppV1WorkflowsAppsAppIdGet(appId, version, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsAppsApi.readAppV1WorkflowsAppsAppIdGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Read Apps
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppsV1WorkflowsAppsGet(skip, limit, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.readAppsV1WorkflowsAppsGet(skip, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsAppsApi.readAppsV1WorkflowsAppsGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Update App
         * @param {string} appId
         * @param {AppEntity} appEntity
         * @param {string | null} [version]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsAppsApi.updateAppV1WorkflowsAppsAppIdPut']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * WorkflowsAppsApi - factory interface
 * @export
 */
exports.WorkflowsAppsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.WorkflowsAppsApiFp(configuration);
    return {
        /**
         *
         * @summary Create App
         * @param {AppEntity} appEntity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAppV1WorkflowsAppsPost(appEntity, options) {
            return localVarFp.createAppV1WorkflowsAppsPost(appEntity, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete App
         * @param {string} appId
         * @param {string | null} [version]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options) {
            return localVarFp.deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Connections By App Id
         * @param {string} appId
         * @param {string} version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options) {
            return localVarFp.getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Read App
         * @param {string} appId
         * @param {string | null} [version]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppV1WorkflowsAppsAppIdGet(appId, version, options) {
            return localVarFp.readAppV1WorkflowsAppsAppIdGet(appId, version, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Read Apps
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppsV1WorkflowsAppsGet(skip, limit, options) {
            return localVarFp.readAppsV1WorkflowsAppsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update App
         * @param {string} appId
         * @param {AppEntity} appEntity
         * @param {string | null} [version]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options) {
            return localVarFp.updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * WorkflowsAppsApi - object-oriented interface
 * @export
 * @class WorkflowsAppsApi
 * @extends {BaseAPI}
 */
class WorkflowsAppsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create App
     * @param {AppEntity} appEntity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    createAppV1WorkflowsAppsPost(appEntity, options) {
        return exports.WorkflowsAppsApiFp(this.configuration).createAppV1WorkflowsAppsPost(appEntity, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete App
     * @param {string} appId
     * @param {string | null} [version]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options) {
        return exports.WorkflowsAppsApiFp(this.configuration).deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Connections By App Id
     * @param {string} appId
     * @param {string} version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options) {
        return exports.WorkflowsAppsApiFp(this.configuration).getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Read App
     * @param {string} appId
     * @param {string | null} [version]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    readAppV1WorkflowsAppsAppIdGet(appId, version, options) {
        return exports.WorkflowsAppsApiFp(this.configuration).readAppV1WorkflowsAppsAppIdGet(appId, version, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Read Apps
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    readAppsV1WorkflowsAppsGet(skip, limit, options) {
        return exports.WorkflowsAppsApiFp(this.configuration).readAppsV1WorkflowsAppsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update App
     * @param {string} appId
     * @param {AppEntity} appEntity
     * @param {string | null} [version]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options) {
        return exports.WorkflowsAppsApiFp(this.configuration).updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WorkflowsAppsApi = WorkflowsAppsApi;
/**
 * WorkflowsConnectionsApi - axios parameter creator
 * @export
 */
exports.WorkflowsConnectionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create Connection
         * @param {ConnectionCore} connectionCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectionV1WorkflowsConnectionsPost: (connectionCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'connectionCore' is not null or undefined
            common_1.assertParamExists('createConnectionV1WorkflowsConnectionsPost', 'connectionCore', connectionCore);
            const localVarPath = `/v1/workflows/connections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(connectionCore, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete Connection
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectionV1WorkflowsConnectionsConnectionIdDelete: (connectionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'connectionId' is not null or undefined
            common_1.assertParamExists('deleteConnectionV1WorkflowsConnectionsConnectionIdDelete', 'connectionId', connectionId);
            const localVarPath = `/v1/workflows/connections/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Read Connection
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionV1WorkflowsConnectionsConnectionIdGet: (connectionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'connectionId' is not null or undefined
            common_1.assertParamExists('readConnectionV1WorkflowsConnectionsConnectionIdGet', 'connectionId', connectionId);
            const localVarPath = `/v1/workflows/connections/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Read Connections
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionsV1WorkflowsConnectionsGet: (skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/workflows/connections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update Connection
         * @param {string} connectionId
         * @param {ConnectionCore} connectionCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnectionV1WorkflowsConnectionsConnectionIdPut: (connectionId, connectionCore, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'connectionId' is not null or undefined
            common_1.assertParamExists('updateConnectionV1WorkflowsConnectionsConnectionIdPut', 'connectionId', connectionId);
            // verify required parameter 'connectionCore' is not null or undefined
            common_1.assertParamExists('updateConnectionV1WorkflowsConnectionsConnectionIdPut', 'connectionCore', connectionCore);
            const localVarPath = `/v1/workflows/connections/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(connectionCore, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * WorkflowsConnectionsApi - functional programming interface
 * @export
 */
exports.WorkflowsConnectionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.WorkflowsConnectionsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create Connection
         * @param {ConnectionCore} connectionCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectionV1WorkflowsConnectionsPost(connectionCore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createConnectionV1WorkflowsConnectionsPost(connectionCore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsConnectionsApi.createConnectionV1WorkflowsConnectionsPost']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete Connection
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsConnectionsApi.deleteConnectionV1WorkflowsConnectionsConnectionIdDelete']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Read Connection
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsConnectionsApi.readConnectionV1WorkflowsConnectionsConnectionIdGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Read Connections
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionsV1WorkflowsConnectionsGet(skip, limit, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.readConnectionsV1WorkflowsConnectionsGet(skip, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsConnectionsApi.readConnectionsV1WorkflowsConnectionsGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Update Connection
         * @param {string} connectionId
         * @param {ConnectionCore} connectionCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsConnectionsApi.updateConnectionV1WorkflowsConnectionsConnectionIdPut']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * WorkflowsConnectionsApi - factory interface
 * @export
 */
exports.WorkflowsConnectionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.WorkflowsConnectionsApiFp(configuration);
    return {
        /**
         *
         * @summary Create Connection
         * @param {ConnectionCore} connectionCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectionV1WorkflowsConnectionsPost(connectionCore, options) {
            return localVarFp.createConnectionV1WorkflowsConnectionsPost(connectionCore, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete Connection
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options) {
            return localVarFp.deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Read Connection
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options) {
            return localVarFp.readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Read Connections
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionsV1WorkflowsConnectionsGet(skip, limit, options) {
            return localVarFp.readConnectionsV1WorkflowsConnectionsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update Connection
         * @param {string} connectionId
         * @param {ConnectionCore} connectionCore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options) {
            return localVarFp.updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * WorkflowsConnectionsApi - object-oriented interface
 * @export
 * @class WorkflowsConnectionsApi
 * @extends {BaseAPI}
 */
class WorkflowsConnectionsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create Connection
     * @param {ConnectionCore} connectionCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    createConnectionV1WorkflowsConnectionsPost(connectionCore, options) {
        return exports.WorkflowsConnectionsApiFp(this.configuration).createConnectionV1WorkflowsConnectionsPost(connectionCore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete Connection
     * @param {string} connectionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options) {
        return exports.WorkflowsConnectionsApiFp(this.configuration).deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Read Connection
     * @param {string} connectionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options) {
        return exports.WorkflowsConnectionsApiFp(this.configuration).readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Read Connections
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    readConnectionsV1WorkflowsConnectionsGet(skip, limit, options) {
        return exports.WorkflowsConnectionsApiFp(this.configuration).readConnectionsV1WorkflowsConnectionsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update Connection
     * @param {string} connectionId
     * @param {ConnectionCore} connectionCore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options) {
        return exports.WorkflowsConnectionsApiFp(this.configuration).updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WorkflowsConnectionsApi = WorkflowsConnectionsApi;
/**
 * WorkflowsExecutionsApi - axios parameter creator
 * @export
 */
exports.WorkflowsExecutionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Execute a workflow. This is an Sync call. This returns the status of the workflow
         * @summary Execute Workflow
         * @param {string} workflowId
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost: (workflowId, body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowId' is not null or undefined
            common_1.assertParamExists('executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost', 'workflowId', workflowId);
            // verify required parameter 'body' is not null or undefined
            common_1.assertParamExists('executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost', 'body', body);
            const localVarPath = `/v1/workflows/executions/{workflow_id}/execute`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(body, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get the status of a workflow given the run id
         * @summary Get Workflow Status
         * @param {string} runId
         * @param {string} workflowId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet: (runId, workflowId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'runId' is not null or undefined
            common_1.assertParamExists('getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet', 'runId', runId);
            // verify required parameter 'workflowId' is not null or undefined
            common_1.assertParamExists('getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet', 'workflowId', workflowId);
            const localVarPath = `/v1/workflows/executions/{workflow_id}/runs/{run_id}`
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)))
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Workflow Runs
         * @param {string} workflowId
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet: (workflowId, skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowId' is not null or undefined
            common_1.assertParamExists('listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet', 'workflowId', workflowId);
            const localVarPath = `/v1/workflows/executions/{workflow_id}/runs`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Trigger a workflow execution. This is an Async call. This returns a workflow id which can be queried to get the status of the workflow
         * @summary Trigger Workflow
         * @param {string} workflowId
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost: (workflowId, body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowId' is not null or undefined
            common_1.assertParamExists('triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost', 'workflowId', workflowId);
            // verify required parameter 'body' is not null or undefined
            common_1.assertParamExists('triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost', 'body', body);
            const localVarPath = `/v1/workflows/executions/{workflow_id}/trigger`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(body, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * WorkflowsExecutionsApi - functional programming interface
 * @export
 */
exports.WorkflowsExecutionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.WorkflowsExecutionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Execute a workflow. This is an Sync call. This returns the status of the workflow
         * @summary Execute Workflow
         * @param {string} workflowId
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, body, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsExecutionsApi.executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get the status of a workflow given the run id
         * @summary Get Workflow Status
         * @param {string} runId
         * @param {string} workflowId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsExecutionsApi.getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary List Workflow Runs
         * @param {string} workflowId
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsExecutionsApi.listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Trigger a workflow execution. This is an Async call. This returns a workflow id which can be queried to get the status of the workflow
         * @summary Trigger Workflow
         * @param {string} workflowId
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, body, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsExecutionsApi.triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * WorkflowsExecutionsApi - factory interface
 * @export
 */
exports.WorkflowsExecutionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.WorkflowsExecutionsApiFp(configuration);
    return {
        /**
         * Execute a workflow. This is an Sync call. This returns the status of the workflow
         * @summary Execute Workflow
         * @param {string} workflowId
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, body, options) {
            return localVarFp.executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status of a workflow given the run id
         * @summary Get Workflow Status
         * @param {string} runId
         * @param {string} workflowId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options) {
            return localVarFp.getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Workflow Runs
         * @param {string} workflowId
         * @param {number} [skip]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options) {
            return localVarFp.listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger a workflow execution. This is an Async call. This returns a workflow id which can be queried to get the status of the workflow
         * @summary Trigger Workflow
         * @param {string} workflowId
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, body, options) {
            return localVarFp.triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, body, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * WorkflowsExecutionsApi - object-oriented interface
 * @export
 * @class WorkflowsExecutionsApi
 * @extends {BaseAPI}
 */
class WorkflowsExecutionsApi extends base_1.BaseAPI {
    /**
     * Execute a workflow. This is an Sync call. This returns the status of the workflow
     * @summary Execute Workflow
     * @param {string} workflowId
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsExecutionsApi
     */
    executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, body, options) {
        return exports.WorkflowsExecutionsApiFp(this.configuration).executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the status of a workflow given the run id
     * @summary Get Workflow Status
     * @param {string} runId
     * @param {string} workflowId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsExecutionsApi
     */
    getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options) {
        return exports.WorkflowsExecutionsApiFp(this.configuration).getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Workflow Runs
     * @param {string} workflowId
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsExecutionsApi
     */
    listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options) {
        return exports.WorkflowsExecutionsApiFp(this.configuration).listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Trigger a workflow execution. This is an Async call. This returns a workflow id which can be queried to get the status of the workflow
     * @summary Trigger Workflow
     * @param {string} workflowId
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsExecutionsApi
     */
    triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, body, options) {
        return exports.WorkflowsExecutionsApiFp(this.configuration).triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, body, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WorkflowsExecutionsApi = WorkflowsExecutionsApi;
/**
 * WorkflowsSubWorkflowsApi - axios parameter creator
 * @export
 */
exports.WorkflowsSubWorkflowsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns all sub workflows which can be invoked for a given workflow step
         * @summary Get Sub Workflows
         * @param {WorkflowStepInput} workflowStepInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost: (workflowStepInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowStepInput' is not null or undefined
            common_1.assertParamExists('getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost', 'workflowStepInput', workflowStepInput);
            const localVarPath = `/v1/workflows/steps/sub_workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(workflowStepInput, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * WorkflowsSubWorkflowsApi - functional programming interface
 * @export
 */
exports.WorkflowsSubWorkflowsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.WorkflowsSubWorkflowsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns all sub workflows which can be invoked for a given workflow step
         * @summary Get Sub Workflows
         * @param {WorkflowStepInput} workflowStepInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WorkflowsSubWorkflowsApi.getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * WorkflowsSubWorkflowsApi - factory interface
 * @export
 */
exports.WorkflowsSubWorkflowsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.WorkflowsSubWorkflowsApiFp(configuration);
    return {
        /**
         * Returns all sub workflows which can be invoked for a given workflow step
         * @summary Get Sub Workflows
         * @param {WorkflowStepInput} workflowStepInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options) {
            return localVarFp.getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * WorkflowsSubWorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsSubWorkflowsApi
 * @extends {BaseAPI}
 */
class WorkflowsSubWorkflowsApi extends base_1.BaseAPI {
    /**
     * Returns all sub workflows which can be invoked for a given workflow step
     * @summary Get Sub Workflows
     * @param {WorkflowStepInput} workflowStepInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsSubWorkflowsApi
     */
    getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options) {
        return exports.WorkflowsSubWorkflowsApiFp(this.configuration).getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WorkflowsSubWorkflowsApi = WorkflowsSubWorkflowsApi;
