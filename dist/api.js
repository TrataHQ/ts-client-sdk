"use strict";
// tslint:disable
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter =
  (this && this.__awaiter) ||
  function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P
        ? value
        : new P(function (resolve) {
            resolve(value);
          });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done
          ? resolve(result.value)
          : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
Object.defineProperty(exports, "__esModule", { value: true });
exports.VoiceModelsApi =
  exports.VoiceModelsApiFactory =
  exports.VoiceModelsApiFp =
  exports.VoiceModelsApiAxiosParamCreator =
  exports.ProspectsApi =
  exports.ProspectsApiFactory =
  exports.ProspectsApiFp =
  exports.ProspectsApiAxiosParamCreator =
  exports.ProductsApi =
  exports.ProductsApiFactory =
  exports.ProductsApiFp =
  exports.ProductsApiAxiosParamCreator =
  exports.MetricsApi =
  exports.MetricsApiFactory =
  exports.MetricsApiFp =
  exports.MetricsApiAxiosParamCreator =
  exports.InternalApi =
  exports.InternalApiFactory =
  exports.InternalApiFp =
  exports.InternalApiAxiosParamCreator =
  exports.HiveAgentLinkApi =
  exports.HiveAgentLinkApiFactory =
  exports.HiveAgentLinkApiFp =
  exports.HiveAgentLinkApiAxiosParamCreator =
  exports.HiveApi =
  exports.HiveApiFactory =
  exports.HiveApiFp =
  exports.HiveApiAxiosParamCreator =
  exports.HealthApi =
  exports.HealthApiFactory =
  exports.HealthApiFp =
  exports.HealthApiAxiosParamCreator =
  exports.DataPlaneApi =
  exports.DataPlaneApiFactory =
  exports.DataPlaneApiFp =
  exports.DataPlaneApiAxiosParamCreator =
  exports.ConversationsApi =
  exports.ConversationsApiFactory =
  exports.ConversationsApiFp =
  exports.ConversationsApiAxiosParamCreator =
  exports.ConversationProspectLinkApi =
  exports.ConversationProspectLinkApiFactory =
  exports.ConversationProspectLinkApiFp =
  exports.ConversationProspectLinkApiAxiosParamCreator =
  exports.AgentsApi =
  exports.AgentsApiFactory =
  exports.AgentsApiFp =
  exports.AgentsApiAxiosParamCreator =
  exports.VoiceOutputModelProviderEnum =
  exports.VoiceOutputGenderEnum =
  exports.VoiceInputModelProviderEnum =
  exports.VoiceInputGenderEnum =
  exports.Status =
  exports.SortOrder =
  exports.Sentiment =
  exports.Role =
  exports.ProspectStatus =
  exports.ProductInputCurrencyEnum =
  exports.MetricName =
  exports.Language =
  exports.HiveType =
  exports.ConversationSourceType =
  exports.ConnectionType =
  exports.AggregationPeriod =
  exports.AggregationFormula =
  exports.Accent =
    void 0;
const globalImportUrl = require("url");
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const base_1 = require("./base");
/**
 *
 * @export
 * @enum {string}
 */
var Accent;
(function (Accent) {
  Accent["American"] = "American";
  Accent["Indian"] = "Indian";
})((Accent = exports.Accent || (exports.Accent = {})));
/**
 *
 * @export
 * @enum {string}
 */
var AggregationFormula;
(function (AggregationFormula) {
  AggregationFormula["COUNT"] = "COUNT";
  AggregationFormula["SUM"] = "SUM";
  AggregationFormula["MEDIAN"] = "MEDIAN";
})(
  (AggregationFormula =
    exports.AggregationFormula || (exports.AggregationFormula = {}))
);
/**
 *
 * @export
 * @enum {string}
 */
var AggregationPeriod;
(function (AggregationPeriod) {
  AggregationPeriod["MONTHLY"] = "MONTHLY";
  AggregationPeriod["WEEKLY"] = "WEEKLY";
  AggregationPeriod["DAILY"] = "DAILY";
})(
  (AggregationPeriod =
    exports.AggregationPeriod || (exports.AggregationPeriod = {}))
);
/**
 *
 * @export
 * @enum {string}
 */
var ConnectionType;
(function (ConnectionType) {
  ConnectionType["Socket"] = "socket";
})((ConnectionType = exports.ConnectionType || (exports.ConnectionType = {})));
/**
 *
 * @export
 * @enum {string}
 */
var ConversationSourceType;
(function (ConversationSourceType) {
  ConversationSourceType["VOIP"] = "VOIP";
  ConversationSourceType["PHONE"] = "PHONE";
})(
  (ConversationSourceType =
    exports.ConversationSourceType || (exports.ConversationSourceType = {}))
);
/**
 *
 * @export
 * @enum {string}
 */
var HiveType;
(function (HiveType) {
  HiveType["WEBSITE"] = "WEBSITE";
  HiveType["GOOGLEDOCS"] = "GOOGLE_DOCS";
  HiveType["DOCS"] = "DOCS";
  HiveType["TRANSCRIPTS"] = "TRANSCRIPTS";
})((HiveType = exports.HiveType || (exports.HiveType = {})));
/**
 *
 * @export
 * @enum {string}
 */
var Language;
(function (Language) {
  Language["English"] = "English";
  Language["Spanish"] = "Spanish";
})((Language = exports.Language || (exports.Language = {})));
/**
 *
 * @export
 * @enum {string}
 */
var MetricName;
(function (MetricName) {
  MetricName["CALLS"] = "CALLS";
  MetricName["CALLDURATION"] = "CALL_DURATION";
  MetricName["APPOINTMENTSCHEDULED"] = "APPOINTMENT_SCHEDULED";
  MetricName["PROSPECTS"] = "PROSPECTS";
  MetricName["INTERESTED"] = "INTERESTED";
  MetricName["NOTINTERESTED"] = "NOT_INTERESTED";
})((MetricName = exports.MetricName || (exports.MetricName = {})));
/**
 * @export
 * @enum {string}
 */
var ProductInputCurrencyEnum;
(function (ProductInputCurrencyEnum) {
  ProductInputCurrencyEnum["AED"] = "AED";
  ProductInputCurrencyEnum["AFN"] = "AFN";
  ProductInputCurrencyEnum["ALL"] = "ALL";
  ProductInputCurrencyEnum["AMD"] = "AMD";
  ProductInputCurrencyEnum["ANG"] = "ANG";
  ProductInputCurrencyEnum["AOA"] = "AOA";
  ProductInputCurrencyEnum["ARS"] = "ARS";
  ProductInputCurrencyEnum["AUD"] = "AUD";
  ProductInputCurrencyEnum["AWG"] = "AWG";
  ProductInputCurrencyEnum["AZN"] = "AZN";
  ProductInputCurrencyEnum["BAM"] = "BAM";
  ProductInputCurrencyEnum["BBD"] = "BBD";
  ProductInputCurrencyEnum["BDT"] = "BDT";
  ProductInputCurrencyEnum["BGN"] = "BGN";
  ProductInputCurrencyEnum["BHD"] = "BHD";
  ProductInputCurrencyEnum["BIF"] = "BIF";
  ProductInputCurrencyEnum["BMD"] = "BMD";
  ProductInputCurrencyEnum["BND"] = "BND";
  ProductInputCurrencyEnum["BOB"] = "BOB";
  ProductInputCurrencyEnum["BOV"] = "BOV";
  ProductInputCurrencyEnum["BRL"] = "BRL";
  ProductInputCurrencyEnum["BSD"] = "BSD";
  ProductInputCurrencyEnum["BTN"] = "BTN";
  ProductInputCurrencyEnum["BWP"] = "BWP";
  ProductInputCurrencyEnum["BYN"] = "BYN";
  ProductInputCurrencyEnum["BZD"] = "BZD";
  ProductInputCurrencyEnum["CAD"] = "CAD";
  ProductInputCurrencyEnum["CDF"] = "CDF";
  ProductInputCurrencyEnum["CHE"] = "CHE";
  ProductInputCurrencyEnum["CHF"] = "CHF";
  ProductInputCurrencyEnum["CHW"] = "CHW";
  ProductInputCurrencyEnum["CLF"] = "CLF";
  ProductInputCurrencyEnum["CLP"] = "CLP";
  ProductInputCurrencyEnum["CNY"] = "CNY";
  ProductInputCurrencyEnum["COP"] = "COP";
  ProductInputCurrencyEnum["COU"] = "COU";
  ProductInputCurrencyEnum["CRC"] = "CRC";
  ProductInputCurrencyEnum["CUC"] = "CUC";
  ProductInputCurrencyEnum["CUP"] = "CUP";
  ProductInputCurrencyEnum["CVE"] = "CVE";
  ProductInputCurrencyEnum["CZK"] = "CZK";
  ProductInputCurrencyEnum["DJF"] = "DJF";
  ProductInputCurrencyEnum["DKK"] = "DKK";
  ProductInputCurrencyEnum["DOP"] = "DOP";
  ProductInputCurrencyEnum["DZD"] = "DZD";
  ProductInputCurrencyEnum["EGP"] = "EGP";
  ProductInputCurrencyEnum["ERN"] = "ERN";
  ProductInputCurrencyEnum["ETB"] = "ETB";
  ProductInputCurrencyEnum["EUR"] = "EUR";
  ProductInputCurrencyEnum["FJD"] = "FJD";
  ProductInputCurrencyEnum["FKP"] = "FKP";
  ProductInputCurrencyEnum["GBP"] = "GBP";
  ProductInputCurrencyEnum["GEL"] = "GEL";
  ProductInputCurrencyEnum["GHS"] = "GHS";
  ProductInputCurrencyEnum["GIP"] = "GIP";
  ProductInputCurrencyEnum["GMD"] = "GMD";
  ProductInputCurrencyEnum["GNF"] = "GNF";
  ProductInputCurrencyEnum["GTQ"] = "GTQ";
  ProductInputCurrencyEnum["GYD"] = "GYD";
  ProductInputCurrencyEnum["HKD"] = "HKD";
  ProductInputCurrencyEnum["HNL"] = "HNL";
  ProductInputCurrencyEnum["HRK"] = "HRK";
  ProductInputCurrencyEnum["HTG"] = "HTG";
  ProductInputCurrencyEnum["HUF"] = "HUF";
  ProductInputCurrencyEnum["IDR"] = "IDR";
  ProductInputCurrencyEnum["ILS"] = "ILS";
  ProductInputCurrencyEnum["INR"] = "INR";
  ProductInputCurrencyEnum["IQD"] = "IQD";
  ProductInputCurrencyEnum["IRR"] = "IRR";
  ProductInputCurrencyEnum["ISK"] = "ISK";
  ProductInputCurrencyEnum["JMD"] = "JMD";
  ProductInputCurrencyEnum["JOD"] = "JOD";
  ProductInputCurrencyEnum["JPY"] = "JPY";
  ProductInputCurrencyEnum["KES"] = "KES";
  ProductInputCurrencyEnum["KGS"] = "KGS";
  ProductInputCurrencyEnum["KHR"] = "KHR";
  ProductInputCurrencyEnum["KMF"] = "KMF";
  ProductInputCurrencyEnum["KPW"] = "KPW";
  ProductInputCurrencyEnum["KRW"] = "KRW";
  ProductInputCurrencyEnum["KWD"] = "KWD";
  ProductInputCurrencyEnum["KYD"] = "KYD";
  ProductInputCurrencyEnum["KZT"] = "KZT";
  ProductInputCurrencyEnum["LAK"] = "LAK";
  ProductInputCurrencyEnum["LBP"] = "LBP";
  ProductInputCurrencyEnum["LKR"] = "LKR";
  ProductInputCurrencyEnum["LRD"] = "LRD";
  ProductInputCurrencyEnum["LSL"] = "LSL";
  ProductInputCurrencyEnum["LYD"] = "LYD";
  ProductInputCurrencyEnum["MAD"] = "MAD";
  ProductInputCurrencyEnum["MDL"] = "MDL";
  ProductInputCurrencyEnum["MGA"] = "MGA";
  ProductInputCurrencyEnum["MKD"] = "MKD";
  ProductInputCurrencyEnum["MMK"] = "MMK";
  ProductInputCurrencyEnum["MNT"] = "MNT";
  ProductInputCurrencyEnum["MOP"] = "MOP";
  ProductInputCurrencyEnum["MRU"] = "MRU";
  ProductInputCurrencyEnum["MUR"] = "MUR";
  ProductInputCurrencyEnum["MVR"] = "MVR";
  ProductInputCurrencyEnum["MWK"] = "MWK";
  ProductInputCurrencyEnum["MXN"] = "MXN";
  ProductInputCurrencyEnum["MXV"] = "MXV";
  ProductInputCurrencyEnum["MYR"] = "MYR";
  ProductInputCurrencyEnum["MZN"] = "MZN";
  ProductInputCurrencyEnum["NAD"] = "NAD";
  ProductInputCurrencyEnum["NGN"] = "NGN";
  ProductInputCurrencyEnum["NIO"] = "NIO";
  ProductInputCurrencyEnum["NOK"] = "NOK";
  ProductInputCurrencyEnum["NPR"] = "NPR";
  ProductInputCurrencyEnum["NZD"] = "NZD";
  ProductInputCurrencyEnum["OMR"] = "OMR";
  ProductInputCurrencyEnum["PAB"] = "PAB";
  ProductInputCurrencyEnum["PEN"] = "PEN";
  ProductInputCurrencyEnum["PGK"] = "PGK";
  ProductInputCurrencyEnum["PHP"] = "PHP";
  ProductInputCurrencyEnum["PKR"] = "PKR";
  ProductInputCurrencyEnum["PLN"] = "PLN";
  ProductInputCurrencyEnum["PYG"] = "PYG";
  ProductInputCurrencyEnum["QAR"] = "QAR";
  ProductInputCurrencyEnum["RON"] = "RON";
  ProductInputCurrencyEnum["RSD"] = "RSD";
  ProductInputCurrencyEnum["RUB"] = "RUB";
  ProductInputCurrencyEnum["RWF"] = "RWF";
  ProductInputCurrencyEnum["SAR"] = "SAR";
  ProductInputCurrencyEnum["SBD"] = "SBD";
  ProductInputCurrencyEnum["SCR"] = "SCR";
  ProductInputCurrencyEnum["SDG"] = "SDG";
  ProductInputCurrencyEnum["SEK"] = "SEK";
  ProductInputCurrencyEnum["SGD"] = "SGD";
  ProductInputCurrencyEnum["SHP"] = "SHP";
  ProductInputCurrencyEnum["SLE"] = "SLE";
  ProductInputCurrencyEnum["SLL"] = "SLL";
  ProductInputCurrencyEnum["SOS"] = "SOS";
  ProductInputCurrencyEnum["SRD"] = "SRD";
  ProductInputCurrencyEnum["SSP"] = "SSP";
  ProductInputCurrencyEnum["STN"] = "STN";
  ProductInputCurrencyEnum["SVC"] = "SVC";
  ProductInputCurrencyEnum["SYP"] = "SYP";
  ProductInputCurrencyEnum["SZL"] = "SZL";
  ProductInputCurrencyEnum["THB"] = "THB";
  ProductInputCurrencyEnum["TJS"] = "TJS";
  ProductInputCurrencyEnum["TMT"] = "TMT";
  ProductInputCurrencyEnum["TND"] = "TND";
  ProductInputCurrencyEnum["TOP"] = "TOP";
  ProductInputCurrencyEnum["TRY"] = "TRY";
  ProductInputCurrencyEnum["TTD"] = "TTD";
  ProductInputCurrencyEnum["TWD"] = "TWD";
  ProductInputCurrencyEnum["TZS"] = "TZS";
  ProductInputCurrencyEnum["UAH"] = "UAH";
  ProductInputCurrencyEnum["UGX"] = "UGX";
  ProductInputCurrencyEnum["USD"] = "USD";
  ProductInputCurrencyEnum["USN"] = "USN";
  ProductInputCurrencyEnum["UYI"] = "UYI";
  ProductInputCurrencyEnum["UYU"] = "UYU";
  ProductInputCurrencyEnum["UYW"] = "UYW";
  ProductInputCurrencyEnum["UZS"] = "UZS";
  ProductInputCurrencyEnum["VED"] = "VED";
  ProductInputCurrencyEnum["VES"] = "VES";
  ProductInputCurrencyEnum["VND"] = "VND";
  ProductInputCurrencyEnum["VUV"] = "VUV";
  ProductInputCurrencyEnum["WST"] = "WST";
  ProductInputCurrencyEnum["XAF"] = "XAF";
  ProductInputCurrencyEnum["XCD"] = "XCD";
  ProductInputCurrencyEnum["XOF"] = "XOF";
  ProductInputCurrencyEnum["XPF"] = "XPF";
  ProductInputCurrencyEnum["XSU"] = "XSU";
  ProductInputCurrencyEnum["XUA"] = "XUA";
  ProductInputCurrencyEnum["YER"] = "YER";
  ProductInputCurrencyEnum["ZAR"] = "ZAR";
  ProductInputCurrencyEnum["ZMW"] = "ZMW";
  ProductInputCurrencyEnum["ZWL"] = "ZWL";
})(
  (ProductInputCurrencyEnum =
    exports.ProductInputCurrencyEnum || (exports.ProductInputCurrencyEnum = {}))
);
/**
 *
 * @export
 * @enum {string}
 */
var ProspectStatus;
(function (ProspectStatus) {
  ProspectStatus["GENERALENQUIRY"] = "GENERAL_ENQUIRY";
  ProspectStatus["SCHEDULEDCALLBACKWITHBOT"] = "SCHEDULED_CALLBACK_WITH_BOT";
  ProspectStatus["SCHEDULEDAPPOINTMENTWITHPERSON"] =
    "SCHEDULED_APPOINTMENT_WITH_PERSON";
  ProspectStatus["SCHEDULEDAPPOINTMENTFORSERVICE"] =
    "SCHEDULED_APPOINTMENT_FOR_SERVICE";
  ProspectStatus["NOTINTERESTED"] = "NOT_INTERESTED";
  ProspectStatus["PRODUCTORDERPLACED"] = "PRODUCT_ORDER_PLACED";
  ProspectStatus["SERVICEORDERPLACED"] = "SERVICE_ORDER_PLACED";
})((ProspectStatus = exports.ProspectStatus || (exports.ProspectStatus = {})));
/**
 *
 * @export
 * @enum {string}
 */
var Role;
(function (Role) {
  Role["ADMIN"] = "ADMIN";
  Role["READONLY"] = "READ_ONLY";
})((Role = exports.Role || (exports.Role = {})));
/**
 *
 * @export
 * @enum {string}
 */
var Sentiment;
(function (Sentiment) {
  Sentiment["POSITIVE"] = "POSITIVE";
  Sentiment["EXCITED"] = "EXCITED";
  Sentiment["NEGATIVE"] = "NEGATIVE";
  Sentiment["BAD"] = "BAD";
})((Sentiment = exports.Sentiment || (exports.Sentiment = {})));
/**
 *
 * @export
 * @enum {string}
 */
var SortOrder;
(function (SortOrder) {
  SortOrder["Asc"] = "asc";
  SortOrder["Desc"] = "desc";
})((SortOrder = exports.SortOrder || (exports.SortOrder = {})));
/**
 *
 * @export
 * @enum {string}
 */
var Status;
(function (Status) {
  Status["Active"] = "active";
  Status["Inactive"] = "inactive";
})((Status = exports.Status || (exports.Status = {})));
/**
 * @export
 * @enum {string}
 */
var VoiceInputGenderEnum;
(function (VoiceInputGenderEnum) {
  VoiceInputGenderEnum["Male"] = "Male";
  VoiceInputGenderEnum["Female"] = "Female";
  VoiceInputGenderEnum["Neutral"] = "Neutral";
})(
  (VoiceInputGenderEnum =
    exports.VoiceInputGenderEnum || (exports.VoiceInputGenderEnum = {}))
);
/**
 * @export
 * @enum {string}
 */
var VoiceInputModelProviderEnum;
(function (VoiceInputModelProviderEnum) {
  VoiceInputModelProviderEnum["Google"] = "Google";
  VoiceInputModelProviderEnum["AWS"] = "AWS";
  VoiceInputModelProviderEnum["Elevenlabs"] = "Elevenlabs";
  VoiceInputModelProviderEnum["PlayHT"] = "PlayHT";
  VoiceInputModelProviderEnum["Deepgram"] = "Deepgram";
})(
  (VoiceInputModelProviderEnum =
    exports.VoiceInputModelProviderEnum ||
    (exports.VoiceInputModelProviderEnum = {}))
);
/**
 * @export
 * @enum {string}
 */
var VoiceOutputGenderEnum;
(function (VoiceOutputGenderEnum) {
  VoiceOutputGenderEnum["Male"] = "Male";
  VoiceOutputGenderEnum["Female"] = "Female";
  VoiceOutputGenderEnum["Neutral"] = "Neutral";
})(
  (VoiceOutputGenderEnum =
    exports.VoiceOutputGenderEnum || (exports.VoiceOutputGenderEnum = {}))
);
/**
 * @export
 * @enum {string}
 */
var VoiceOutputModelProviderEnum;
(function (VoiceOutputModelProviderEnum) {
  VoiceOutputModelProviderEnum["Google"] = "Google";
  VoiceOutputModelProviderEnum["AWS"] = "AWS";
  VoiceOutputModelProviderEnum["Elevenlabs"] = "Elevenlabs";
  VoiceOutputModelProviderEnum["PlayHT"] = "PlayHT";
  VoiceOutputModelProviderEnum["Deepgram"] = "Deepgram";
})(
  (VoiceOutputModelProviderEnum =
    exports.VoiceOutputModelProviderEnum ||
    (exports.VoiceOutputModelProviderEnum = {}))
);
/**
 * AgentsApi - axios parameter creator
 * @export
 */
exports.AgentsApiAxiosParamCreator = function (configuration) {
  return {
    /**
     * Creates a new AI agent.
     * @summary Createaiagent
     * @param {AIAgentInput} aIAgentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAIAgentV1: (aIAgentInput, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'aIAgentInput' is not null or undefined
        if (aIAgentInput === null || aIAgentInput === undefined) {
          throw new base_1.RequiredError(
            "aIAgentInput",
            "Required parameter aIAgentInput was null or undefined when calling createAIAgentV1."
          );
        }
        const localVarPath = `/v1/ai-agents`;
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "POST" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        const needsSerialization =
          typeof aIAgentInput !== "string" ||
          localVarRequestOptions.headers["Content-Type"] === "application/json";
        localVarRequestOptions.data = needsSerialization
          ? JSON.stringify(aIAgentInput !== undefined ? aIAgentInput : {})
          : aIAgentInput || "";
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     * Deletes an AI agent.
     * @summary Deleteaiagent
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAIAgentV1: (agentId, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'agentId' is not null or undefined
        if (agentId === null || agentId === undefined) {
          throw new base_1.RequiredError(
            "agentId",
            "Required parameter agentId was null or undefined when calling deleteAIAgentV1."
          );
        }
        const localVarPath = `/v1/ai-agents/{agent_id}`.replace(
          `{${"agent_id"}}`,
          encodeURIComponent(String(agentId))
        );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "DELETE" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     * Gets a specific AI agent by ID.
     * @summary Getaiagent
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAIAgentV1: (agentId, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'agentId' is not null or undefined
        if (agentId === null || agentId === undefined) {
          throw new base_1.RequiredError(
            "agentId",
            "Required parameter agentId was null or undefined when calling getAIAgentV1."
          );
        }
        const localVarPath = `/v1/ai-agents/{agent_id}`.replace(
          `{${"agent_id"}}`,
          encodeURIComponent(String(agentId))
        );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "GET" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     * Lists all AI agents under the user\'s organization.
     * @summary Listaiagents
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAIAgentsV1: (
      searchBy,
      searchValue,
      status,
      sortBy,
      sortOrder,
      skip,
      limit,
      options = {}
    ) =>
      __awaiter(this, void 0, void 0, function* () {
        const localVarPath = `/v1/ai-agents`;
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "GET" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        if (searchBy !== undefined) {
          localVarQueryParameter["search_by"] = searchBy;
        }
        if (searchValue !== undefined) {
          localVarQueryParameter["search_value"] = searchValue;
        }
        if (status !== undefined) {
          localVarQueryParameter["status"] = status;
        }
        if (sortBy !== undefined) {
          localVarQueryParameter["sort_by"] = sortBy;
        }
        if (sortOrder !== undefined) {
          localVarQueryParameter["sort_order"] = sortOrder;
        }
        if (skip !== undefined) {
          localVarQueryParameter["skip"] = skip;
        }
        if (limit !== undefined) {
          localVarQueryParameter["limit"] = limit;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     * Updates an existing AI agent.
     * @summary Updateaiagent
     * @param {string} agentId
     * @param {AIAgentInput} aIAgentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAIAgentV1: (agentId, aIAgentInput, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'agentId' is not null or undefined
        if (agentId === null || agentId === undefined) {
          throw new base_1.RequiredError(
            "agentId",
            "Required parameter agentId was null or undefined when calling updateAIAgentV1."
          );
        }
        // verify required parameter 'aIAgentInput' is not null or undefined
        if (aIAgentInput === null || aIAgentInput === undefined) {
          throw new base_1.RequiredError(
            "aIAgentInput",
            "Required parameter aIAgentInput was null or undefined when calling updateAIAgentV1."
          );
        }
        const localVarPath = `/v1/ai-agents/{agent_id}`.replace(
          `{${"agent_id"}}`,
          encodeURIComponent(String(agentId))
        );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "PUT" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        const needsSerialization =
          typeof aIAgentInput !== "string" ||
          localVarRequestOptions.headers["Content-Type"] === "application/json";
        localVarRequestOptions.data = needsSerialization
          ? JSON.stringify(aIAgentInput !== undefined ? aIAgentInput : {})
          : aIAgentInput || "";
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
  };
};
/**
 * AgentsApi - functional programming interface
 * @export
 */
exports.AgentsApiFp = function (configuration) {
  return {
    /**
     * Creates a new AI agent.
     * @summary Createaiagent
     * @param {AIAgentInput} aIAgentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAIAgentV1(aIAgentInput, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .AgentsApiAxiosParamCreator(configuration)
          .createAIAgentV1(aIAgentInput, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     * Deletes an AI agent.
     * @summary Deleteaiagent
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAIAgentV1(agentId, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .AgentsApiAxiosParamCreator(configuration)
          .deleteAIAgentV1(agentId, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     * Gets a specific AI agent by ID.
     * @summary Getaiagent
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAIAgentV1(agentId, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .AgentsApiAxiosParamCreator(configuration)
          .getAIAgentV1(agentId, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     * Lists all AI agents under the user\'s organization.
     * @summary Listaiagents
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAIAgentsV1(
      searchBy,
      searchValue,
      status,
      sortBy,
      sortOrder,
      skip,
      limit,
      options
    ) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .AgentsApiAxiosParamCreator(configuration)
          .listAIAgentsV1(
            searchBy,
            searchValue,
            status,
            sortBy,
            sortOrder,
            skip,
            limit,
            options
          );
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     * Updates an existing AI agent.
     * @summary Updateaiagent
     * @param {string} agentId
     * @param {AIAgentInput} aIAgentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAIAgentV1(agentId, aIAgentInput, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .AgentsApiAxiosParamCreator(configuration)
          .updateAIAgentV1(agentId, aIAgentInput, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
  };
};
/**
 * AgentsApi - factory interface
 * @export
 */
exports.AgentsApiFactory = function (configuration, basePath, axios) {
  return {
    /**
     * Creates a new AI agent.
     * @summary Createaiagent
     * @param {AIAgentInput} aIAgentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAIAgentV1(aIAgentInput, options) {
      return exports
        .AgentsApiFp(configuration)
        .createAIAgentV1(aIAgentInput, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes an AI agent.
     * @summary Deleteaiagent
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAIAgentV1(agentId, options) {
      return exports
        .AgentsApiFp(configuration)
        .deleteAIAgentV1(agentId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets a specific AI agent by ID.
     * @summary Getaiagent
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAIAgentV1(agentId, options) {
      return exports
        .AgentsApiFp(configuration)
        .getAIAgentV1(agentId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists all AI agents under the user\'s organization.
     * @summary Listaiagents
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAIAgentsV1(
      searchBy,
      searchValue,
      status,
      sortBy,
      sortOrder,
      skip,
      limit,
      options
    ) {
      return exports
        .AgentsApiFp(configuration)
        .listAIAgentsV1(
          searchBy,
          searchValue,
          status,
          sortBy,
          sortOrder,
          skip,
          limit,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates an existing AI agent.
     * @summary Updateaiagent
     * @param {string} agentId
     * @param {AIAgentInput} aIAgentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAIAgentV1(agentId, aIAgentInput, options) {
      return exports
        .AgentsApiFp(configuration)
        .updateAIAgentV1(agentId, aIAgentInput, options)
        .then((request) => request(axios, basePath));
    },
  };
};
/**
 * AgentsApi - object-oriented interface
 * @export
 * @class AgentsApi
 * @extends {BaseAPI}
 */
class AgentsApi extends base_1.BaseAPI {
  /**
   * Creates a new AI agent.
   * @summary Createaiagent
   * @param {AIAgentInput} aIAgentInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentsApi
   */
  createAIAgentV1(aIAgentInput, options) {
    return exports
      .AgentsApiFp(this.configuration)
      .createAIAgentV1(aIAgentInput, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes an AI agent.
   * @summary Deleteaiagent
   * @param {string} agentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentsApi
   */
  deleteAIAgentV1(agentId, options) {
    return exports
      .AgentsApiFp(this.configuration)
      .deleteAIAgentV1(agentId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a specific AI agent by ID.
   * @summary Getaiagent
   * @param {string} agentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentsApi
   */
  getAIAgentV1(agentId, options) {
    return exports
      .AgentsApiFp(this.configuration)
      .getAIAgentV1(agentId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all AI agents under the user\'s organization.
   * @summary Listaiagents
   * @param {string} [searchBy]
   * @param {string} [searchValue]
   * @param {string} [status]
   * @param {string} [sortBy]
   * @param {SortOrder} [sortOrder]
   * @param {number} [skip]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentsApi
   */
  listAIAgentsV1(
    searchBy,
    searchValue,
    status,
    sortBy,
    sortOrder,
    skip,
    limit,
    options
  ) {
    return exports
      .AgentsApiFp(this.configuration)
      .listAIAgentsV1(
        searchBy,
        searchValue,
        status,
        sortBy,
        sortOrder,
        skip,
        limit,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Updates an existing AI agent.
   * @summary Updateaiagent
   * @param {string} agentId
   * @param {AIAgentInput} aIAgentInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentsApi
   */
  updateAIAgentV1(agentId, aIAgentInput, options) {
    return exports
      .AgentsApiFp(this.configuration)
      .updateAIAgentV1(agentId, aIAgentInput, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
exports.AgentsApi = AgentsApi;
/**
 * ConversationProspectLinkApi - axios parameter creator
 * @export
 */
exports.ConversationProspectLinkApiAxiosParamCreator = function (
  configuration
) {
  return {
    /**
     *
     * @summary Createconversationprospectlink
     * @param {string} conversationId
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConversationProspectLinkV1: (
      conversationId,
      prospectId,
      options = {}
    ) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'conversationId' is not null or undefined
        if (conversationId === null || conversationId === undefined) {
          throw new base_1.RequiredError(
            "conversationId",
            "Required parameter conversationId was null or undefined when calling createConversationProspectLinkV1."
          );
        }
        // verify required parameter 'prospectId' is not null or undefined
        if (prospectId === null || prospectId === undefined) {
          throw new base_1.RequiredError(
            "prospectId",
            "Required parameter prospectId was null or undefined when calling createConversationProspectLinkV1."
          );
        }
        const localVarPath =
          `/v1/conversations/{conversation_id}/prospects/{prospect_id}/links`
            .replace(
              `{${"conversation_id"}}`,
              encodeURIComponent(String(conversationId))
            )
            .replace(
              `{${"prospect_id"}}`,
              encodeURIComponent(String(prospectId))
            );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "POST" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     *
     * @summary Deleteconversationbyprospect
     * @param {string} conversationId
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConversationProspectLinkV1: (
      conversationId,
      prospectId,
      options = {}
    ) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'conversationId' is not null or undefined
        if (conversationId === null || conversationId === undefined) {
          throw new base_1.RequiredError(
            "conversationId",
            "Required parameter conversationId was null or undefined when calling deleteConversationProspectLinkV1."
          );
        }
        // verify required parameter 'prospectId' is not null or undefined
        if (prospectId === null || prospectId === undefined) {
          throw new base_1.RequiredError(
            "prospectId",
            "Required parameter prospectId was null or undefined when calling deleteConversationProspectLinkV1."
          );
        }
        const localVarPath =
          `/v1/conversations/{conversation_id}/prospects/{prospect_id}/links`
            .replace(
              `{${"conversation_id"}}`,
              encodeURIComponent(String(conversationId))
            )
            .replace(
              `{${"prospect_id"}}`,
              encodeURIComponent(String(prospectId))
            );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "DELETE" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     *
     * @summary Getconversationsbyprospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listConversationsOfProspectsV1: (prospectId, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'prospectId' is not null or undefined
        if (prospectId === null || prospectId === undefined) {
          throw new base_1.RequiredError(
            "prospectId",
            "Required parameter prospectId was null or undefined when calling listConversationsOfProspectsV1."
          );
        }
        const localVarPath =
          `/v1/prospects/{prospect_id}/conversations`.replace(
            `{${"prospect_id"}}`,
            encodeURIComponent(String(prospectId))
          );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "GET" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
  };
};
/**
 * ConversationProspectLinkApi - functional programming interface
 * @export
 */
exports.ConversationProspectLinkApiFp = function (configuration) {
  return {
    /**
     *
     * @summary Createconversationprospectlink
     * @param {string} conversationId
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConversationProspectLinkV1(conversationId, prospectId, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .ConversationProspectLinkApiAxiosParamCreator(configuration)
          .createConversationProspectLinkV1(
            conversationId,
            prospectId,
            options
          );
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     *
     * @summary Deleteconversationbyprospect
     * @param {string} conversationId
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConversationProspectLinkV1(conversationId, prospectId, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .ConversationProspectLinkApiAxiosParamCreator(configuration)
          .deleteConversationProspectLinkV1(
            conversationId,
            prospectId,
            options
          );
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     *
     * @summary Getconversationsbyprospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listConversationsOfProspectsV1(prospectId, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .ConversationProspectLinkApiAxiosParamCreator(configuration)
          .listConversationsOfProspectsV1(prospectId, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
  };
};
/**
 * ConversationProspectLinkApi - factory interface
 * @export
 */
exports.ConversationProspectLinkApiFactory = function (
  configuration,
  basePath,
  axios
) {
  return {
    /**
     *
     * @summary Createconversationprospectlink
     * @param {string} conversationId
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConversationProspectLinkV1(conversationId, prospectId, options) {
      return exports
        .ConversationProspectLinkApiFp(configuration)
        .createConversationProspectLinkV1(conversationId, prospectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deleteconversationbyprospect
     * @param {string} conversationId
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConversationProspectLinkV1(conversationId, prospectId, options) {
      return exports
        .ConversationProspectLinkApiFp(configuration)
        .deleteConversationProspectLinkV1(conversationId, prospectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Getconversationsbyprospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listConversationsOfProspectsV1(prospectId, options) {
      return exports
        .ConversationProspectLinkApiFp(configuration)
        .listConversationsOfProspectsV1(prospectId, options)
        .then((request) => request(axios, basePath));
    },
  };
};
/**
 * ConversationProspectLinkApi - object-oriented interface
 * @export
 * @class ConversationProspectLinkApi
 * @extends {BaseAPI}
 */
class ConversationProspectLinkApi extends base_1.BaseAPI {
  /**
   *
   * @summary Createconversationprospectlink
   * @param {string} conversationId
   * @param {string} prospectId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConversationProspectLinkApi
   */
  createConversationProspectLinkV1(conversationId, prospectId, options) {
    return exports
      .ConversationProspectLinkApiFp(this.configuration)
      .createConversationProspectLinkV1(conversationId, prospectId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Deleteconversationbyprospect
   * @param {string} conversationId
   * @param {string} prospectId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConversationProspectLinkApi
   */
  deleteConversationProspectLinkV1(conversationId, prospectId, options) {
    return exports
      .ConversationProspectLinkApiFp(this.configuration)
      .deleteConversationProspectLinkV1(conversationId, prospectId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Getconversationsbyprospect
   * @param {string} prospectId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConversationProspectLinkApi
   */
  listConversationsOfProspectsV1(prospectId, options) {
    return exports
      .ConversationProspectLinkApiFp(this.configuration)
      .listConversationsOfProspectsV1(prospectId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
exports.ConversationProspectLinkApi = ConversationProspectLinkApi;
/**
 * ConversationsApi - axios parameter creator
 * @export
 */
exports.ConversationsApiAxiosParamCreator = function (configuration) {
  return {
    /**
     *
     * @summary Addfeedback
     * @param {string} conversationId
     * @param {Comment} comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFeedbackV1: (conversationId, comment, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'conversationId' is not null or undefined
        if (conversationId === null || conversationId === undefined) {
          throw new base_1.RequiredError(
            "conversationId",
            "Required parameter conversationId was null or undefined when calling addFeedbackV1."
          );
        }
        // verify required parameter 'comment' is not null or undefined
        if (comment === null || comment === undefined) {
          throw new base_1.RequiredError(
            "comment",
            "Required parameter comment was null or undefined when calling addFeedbackV1."
          );
        }
        const localVarPath =
          `/v1/conversations/{conversation_id}/feedback`.replace(
            `{${"conversation_id"}}`,
            encodeURIComponent(String(conversationId))
          );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "POST" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        const needsSerialization =
          typeof comment !== "string" ||
          localVarRequestOptions.headers["Content-Type"] === "application/json";
        localVarRequestOptions.data = needsSerialization
          ? JSON.stringify(comment !== undefined ? comment : {})
          : comment || "";
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     *
     * @summary Createconversation
     * @param {ConversationInput} conversationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConversationV1: (conversationInput, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'conversationInput' is not null or undefined
        if (conversationInput === null || conversationInput === undefined) {
          throw new base_1.RequiredError(
            "conversationInput",
            "Required parameter conversationInput was null or undefined when calling createConversationV1."
          );
        }
        const localVarPath = `/v1/conversations`;
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "POST" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        const needsSerialization =
          typeof conversationInput !== "string" ||
          localVarRequestOptions.headers["Content-Type"] === "application/json";
        localVarRequestOptions.data = needsSerialization
          ? JSON.stringify(
              conversationInput !== undefined ? conversationInput : {}
            )
          : conversationInput || "";
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     *
     * @summary Deleteconversation
     * @param {string} conversationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConversationV1: (conversationId, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'conversationId' is not null or undefined
        if (conversationId === null || conversationId === undefined) {
          throw new base_1.RequiredError(
            "conversationId",
            "Required parameter conversationId was null or undefined when calling deleteConversationV1."
          );
        }
        const localVarPath = `/v1/conversations/{conversation_id}`.replace(
          `{${"conversation_id"}}`,
          encodeURIComponent(String(conversationId))
        );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "DELETE" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     *
     * @summary Getconversation
     * @param {string} conversationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConversationV1: (conversationId, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'conversationId' is not null or undefined
        if (conversationId === null || conversationId === undefined) {
          throw new base_1.RequiredError(
            "conversationId",
            "Required parameter conversationId was null or undefined when calling getConversationV1."
          );
        }
        const localVarPath = `/v1/conversations/{conversation_id}`.replace(
          `{${"conversation_id"}}`,
          encodeURIComponent(String(conversationId))
        );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "GET" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     *
     * @summary Listconversations
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listConversationsV1: (
      searchBy,
      searchValue,
      status,
      sortBy,
      sortOrder,
      skip,
      limit,
      options = {}
    ) =>
      __awaiter(this, void 0, void 0, function* () {
        const localVarPath = `/v1/conversations`;
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "GET" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        if (searchBy !== undefined) {
          localVarQueryParameter["search_by"] = searchBy;
        }
        if (searchValue !== undefined) {
          localVarQueryParameter["search_value"] = searchValue;
        }
        if (status !== undefined) {
          localVarQueryParameter["status"] = status;
        }
        if (sortBy !== undefined) {
          localVarQueryParameter["sort_by"] = sortBy;
        }
        if (sortOrder !== undefined) {
          localVarQueryParameter["sort_order"] = sortOrder;
        }
        if (skip !== undefined) {
          localVarQueryParameter["skip"] = skip;
        }
        if (limit !== undefined) {
          localVarQueryParameter["limit"] = limit;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     *
     * @summary Updateconversation
     * @param {string} conversationId
     * @param {ConversationInput} conversationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConversationV1: (conversationId, conversationInput, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'conversationId' is not null or undefined
        if (conversationId === null || conversationId === undefined) {
          throw new base_1.RequiredError(
            "conversationId",
            "Required parameter conversationId was null or undefined when calling updateConversationV1."
          );
        }
        // verify required parameter 'conversationInput' is not null or undefined
        if (conversationInput === null || conversationInput === undefined) {
          throw new base_1.RequiredError(
            "conversationInput",
            "Required parameter conversationInput was null or undefined when calling updateConversationV1."
          );
        }
        const localVarPath = `/v1/conversations/{conversation_id}`.replace(
          `{${"conversation_id"}}`,
          encodeURIComponent(String(conversationId))
        );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "PUT" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        const needsSerialization =
          typeof conversationInput !== "string" ||
          localVarRequestOptions.headers["Content-Type"] === "application/json";
        localVarRequestOptions.data = needsSerialization
          ? JSON.stringify(
              conversationInput !== undefined ? conversationInput : {}
            )
          : conversationInput || "";
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
  };
};
/**
 * ConversationsApi - functional programming interface
 * @export
 */
exports.ConversationsApiFp = function (configuration) {
  return {
    /**
     *
     * @summary Addfeedback
     * @param {string} conversationId
     * @param {Comment} comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFeedbackV1(conversationId, comment, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .ConversationsApiAxiosParamCreator(configuration)
          .addFeedbackV1(conversationId, comment, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     *
     * @summary Createconversation
     * @param {ConversationInput} conversationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConversationV1(conversationInput, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .ConversationsApiAxiosParamCreator(configuration)
          .createConversationV1(conversationInput, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     *
     * @summary Deleteconversation
     * @param {string} conversationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConversationV1(conversationId, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .ConversationsApiAxiosParamCreator(configuration)
          .deleteConversationV1(conversationId, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     *
     * @summary Getconversation
     * @param {string} conversationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConversationV1(conversationId, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .ConversationsApiAxiosParamCreator(configuration)
          .getConversationV1(conversationId, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     *
     * @summary Listconversations
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listConversationsV1(
      searchBy,
      searchValue,
      status,
      sortBy,
      sortOrder,
      skip,
      limit,
      options
    ) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .ConversationsApiAxiosParamCreator(configuration)
          .listConversationsV1(
            searchBy,
            searchValue,
            status,
            sortBy,
            sortOrder,
            skip,
            limit,
            options
          );
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     *
     * @summary Updateconversation
     * @param {string} conversationId
     * @param {ConversationInput} conversationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConversationV1(conversationId, conversationInput, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .ConversationsApiAxiosParamCreator(configuration)
          .updateConversationV1(conversationId, conversationInput, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
  };
};
/**
 * ConversationsApi - factory interface
 * @export
 */
exports.ConversationsApiFactory = function (configuration, basePath, axios) {
  return {
    /**
     *
     * @summary Addfeedback
     * @param {string} conversationId
     * @param {Comment} comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFeedbackV1(conversationId, comment, options) {
      return exports
        .ConversationsApiFp(configuration)
        .addFeedbackV1(conversationId, comment, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Createconversation
     * @param {ConversationInput} conversationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConversationV1(conversationInput, options) {
      return exports
        .ConversationsApiFp(configuration)
        .createConversationV1(conversationInput, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deleteconversation
     * @param {string} conversationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConversationV1(conversationId, options) {
      return exports
        .ConversationsApiFp(configuration)
        .deleteConversationV1(conversationId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Getconversation
     * @param {string} conversationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConversationV1(conversationId, options) {
      return exports
        .ConversationsApiFp(configuration)
        .getConversationV1(conversationId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Listconversations
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listConversationsV1(
      searchBy,
      searchValue,
      status,
      sortBy,
      sortOrder,
      skip,
      limit,
      options
    ) {
      return exports
        .ConversationsApiFp(configuration)
        .listConversationsV1(
          searchBy,
          searchValue,
          status,
          sortBy,
          sortOrder,
          skip,
          limit,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updateconversation
     * @param {string} conversationId
     * @param {ConversationInput} conversationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConversationV1(conversationId, conversationInput, options) {
      return exports
        .ConversationsApiFp(configuration)
        .updateConversationV1(conversationId, conversationInput, options)
        .then((request) => request(axios, basePath));
    },
  };
};
/**
 * ConversationsApi - object-oriented interface
 * @export
 * @class ConversationsApi
 * @extends {BaseAPI}
 */
class ConversationsApi extends base_1.BaseAPI {
  /**
   *
   * @summary Addfeedback
   * @param {string} conversationId
   * @param {Comment} comment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConversationsApi
   */
  addFeedbackV1(conversationId, comment, options) {
    return exports
      .ConversationsApiFp(this.configuration)
      .addFeedbackV1(conversationId, comment, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Createconversation
   * @param {ConversationInput} conversationInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConversationsApi
   */
  createConversationV1(conversationInput, options) {
    return exports
      .ConversationsApiFp(this.configuration)
      .createConversationV1(conversationInput, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Deleteconversation
   * @param {string} conversationId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConversationsApi
   */
  deleteConversationV1(conversationId, options) {
    return exports
      .ConversationsApiFp(this.configuration)
      .deleteConversationV1(conversationId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Getconversation
   * @param {string} conversationId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConversationsApi
   */
  getConversationV1(conversationId, options) {
    return exports
      .ConversationsApiFp(this.configuration)
      .getConversationV1(conversationId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Listconversations
   * @param {string} [searchBy]
   * @param {string} [searchValue]
   * @param {string} [status]
   * @param {string} [sortBy]
   * @param {SortOrder} [sortOrder]
   * @param {number} [skip]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConversationsApi
   */
  listConversationsV1(
    searchBy,
    searchValue,
    status,
    sortBy,
    sortOrder,
    skip,
    limit,
    options
  ) {
    return exports
      .ConversationsApiFp(this.configuration)
      .listConversationsV1(
        searchBy,
        searchValue,
        status,
        sortBy,
        sortOrder,
        skip,
        limit,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Updateconversation
   * @param {string} conversationId
   * @param {ConversationInput} conversationInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConversationsApi
   */
  updateConversationV1(conversationId, conversationInput, options) {
    return exports
      .ConversationsApiFp(this.configuration)
      .updateConversationV1(conversationId, conversationInput, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
exports.ConversationsApi = ConversationsApi;
/**
 * DataPlaneApi - axios parameter creator
 * @export
 */
exports.DataPlaneApiAxiosParamCreator = function (configuration) {
  return {
    /**
     *
     * @summary Createconnection
     * @param {string} agentId
     * @param {string} prospectId
     * @param {ConnectionSource} connectionSource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConnection: (agentId, prospectId, connectionSource, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'agentId' is not null or undefined
        if (agentId === null || agentId === undefined) {
          throw new base_1.RequiredError(
            "agentId",
            "Required parameter agentId was null or undefined when calling createConnection."
          );
        }
        // verify required parameter 'prospectId' is not null or undefined
        if (prospectId === null || prospectId === undefined) {
          throw new base_1.RequiredError(
            "prospectId",
            "Required parameter prospectId was null or undefined when calling createConnection."
          );
        }
        // verify required parameter 'connectionSource' is not null or undefined
        if (connectionSource === null || connectionSource === undefined) {
          throw new base_1.RequiredError(
            "connectionSource",
            "Required parameter connectionSource was null or undefined when calling createConnection."
          );
        }
        const localVarPath = `/connections`;
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "POST" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        if (agentId !== undefined) {
          localVarQueryParameter["agentId"] = agentId;
        }
        if (prospectId !== undefined) {
          localVarQueryParameter["prospect_id"] = prospectId;
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        const needsSerialization =
          typeof connectionSource !== "string" ||
          localVarRequestOptions.headers["Content-Type"] === "application/json";
        localVarRequestOptions.data = needsSerialization
          ? JSON.stringify(
              connectionSource !== undefined ? connectionSource : {}
            )
          : connectionSource || "";
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
  };
};
/**
 * DataPlaneApi - functional programming interface
 * @export
 */
exports.DataPlaneApiFp = function (configuration) {
  return {
    /**
     *
     * @summary Createconnection
     * @param {string} agentId
     * @param {string} prospectId
     * @param {ConnectionSource} connectionSource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConnection(agentId, prospectId, connectionSource, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .DataPlaneApiAxiosParamCreator(configuration)
          .createConnection(agentId, prospectId, connectionSource, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
  };
};
/**
 * DataPlaneApi - factory interface
 * @export
 */
exports.DataPlaneApiFactory = function (configuration, basePath, axios) {
  return {
    /**
     *
     * @summary Createconnection
     * @param {string} agentId
     * @param {string} prospectId
     * @param {ConnectionSource} connectionSource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConnection(agentId, prospectId, connectionSource, options) {
      return exports
        .DataPlaneApiFp(configuration)
        .createConnection(agentId, prospectId, connectionSource, options)
        .then((request) => request(axios, basePath));
    },
  };
};
/**
 * DataPlaneApi - object-oriented interface
 * @export
 * @class DataPlaneApi
 * @extends {BaseAPI}
 */
class DataPlaneApi extends base_1.BaseAPI {
  /**
   *
   * @summary Createconnection
   * @param {string} agentId
   * @param {string} prospectId
   * @param {ConnectionSource} connectionSource
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataPlaneApi
   */
  createConnection(agentId, prospectId, connectionSource, options) {
    return exports
      .DataPlaneApiFp(this.configuration)
      .createConnection(agentId, prospectId, connectionSource, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
exports.DataPlaneApi = DataPlaneApi;
/**
 * HealthApi - axios parameter creator
 * @export
 */
exports.HealthApiAxiosParamCreator = function (configuration) {
  return {
    /**
     *
     * @summary Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusStatusGet: (options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        const localVarPath = `/status`;
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "GET" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
  };
};
/**
 * HealthApi - functional programming interface
 * @export
 */
exports.HealthApiFp = function (configuration) {
  return {
    /**
     *
     * @summary Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusStatusGet(options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .HealthApiAxiosParamCreator(configuration)
          .statusStatusGet(options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
  };
};
/**
 * HealthApi - factory interface
 * @export
 */
exports.HealthApiFactory = function (configuration, basePath, axios) {
  return {
    /**
     *
     * @summary Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusStatusGet(options) {
      return exports
        .HealthApiFp(configuration)
        .statusStatusGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};
/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
class HealthApi extends base_1.BaseAPI {
  /**
   *
   * @summary Status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  statusStatusGet(options) {
    return exports
      .HealthApiFp(this.configuration)
      .statusStatusGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}
exports.HealthApi = HealthApi;
/**
 * HiveApi - axios parameter creator
 * @export
 */
exports.HiveApiAxiosParamCreator = function (configuration) {
  return {
    /**
     *
     * @summary Createhive
     * @param {HiveContent} hiveContent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createHiveV1: (hiveContent, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'hiveContent' is not null or undefined
        if (hiveContent === null || hiveContent === undefined) {
          throw new base_1.RequiredError(
            "hiveContent",
            "Required parameter hiveContent was null or undefined when calling createHiveV1."
          );
        }
        const localVarPath = `/v1/hives`;
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "POST" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        const needsSerialization =
          typeof hiveContent !== "string" ||
          localVarRequestOptions.headers["Content-Type"] === "application/json";
        localVarRequestOptions.data = needsSerialization
          ? JSON.stringify(hiveContent !== undefined ? hiveContent : {})
          : hiveContent || "";
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     *
     * @summary Deletehive
     * @param {string} hiveId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteHiveV1: (hiveId, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'hiveId' is not null or undefined
        if (hiveId === null || hiveId === undefined) {
          throw new base_1.RequiredError(
            "hiveId",
            "Required parameter hiveId was null or undefined when calling deleteHiveV1."
          );
        }
        const localVarPath = `/v1/hives/{hive_id}`.replace(
          `{${"hive_id"}}`,
          encodeURIComponent(String(hiveId))
        );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "DELETE" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     *
     * @summary Gethive
     * @param {string} hiveId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHiveV1: (hiveId, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'hiveId' is not null or undefined
        if (hiveId === null || hiveId === undefined) {
          throw new base_1.RequiredError(
            "hiveId",
            "Required parameter hiveId was null or undefined when calling getHiveV1."
          );
        }
        const localVarPath = `/v1/hives/{hive_id}`.replace(
          `{${"hive_id"}}`,
          encodeURIComponent(String(hiveId))
        );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "GET" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     *
     * @summary Listhives
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHivesV1: (
      searchBy,
      searchValue,
      status,
      sortBy,
      sortOrder,
      skip,
      limit,
      options = {}
    ) =>
      __awaiter(this, void 0, void 0, function* () {
        const localVarPath = `/v1/hives`;
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "GET" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        if (searchBy !== undefined) {
          localVarQueryParameter["search_by"] = searchBy;
        }
        if (searchValue !== undefined) {
          localVarQueryParameter["search_value"] = searchValue;
        }
        if (status !== undefined) {
          localVarQueryParameter["status"] = status;
        }
        if (sortBy !== undefined) {
          localVarQueryParameter["sort_by"] = sortBy;
        }
        if (sortOrder !== undefined) {
          localVarQueryParameter["sort_order"] = sortOrder;
        }
        if (skip !== undefined) {
          localVarQueryParameter["skip"] = skip;
        }
        if (limit !== undefined) {
          localVarQueryParameter["limit"] = limit;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     *
     * @summary Updatehive
     * @param {string} hiveId
     * @param {HiveContent} hiveContent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateHiveV1: (hiveId, hiveContent, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'hiveId' is not null or undefined
        if (hiveId === null || hiveId === undefined) {
          throw new base_1.RequiredError(
            "hiveId",
            "Required parameter hiveId was null or undefined when calling updateHiveV1."
          );
        }
        // verify required parameter 'hiveContent' is not null or undefined
        if (hiveContent === null || hiveContent === undefined) {
          throw new base_1.RequiredError(
            "hiveContent",
            "Required parameter hiveContent was null or undefined when calling updateHiveV1."
          );
        }
        const localVarPath = `/v1/hives/{hive_id}`.replace(
          `{${"hive_id"}}`,
          encodeURIComponent(String(hiveId))
        );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "PUT" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        const needsSerialization =
          typeof hiveContent !== "string" ||
          localVarRequestOptions.headers["Content-Type"] === "application/json";
        localVarRequestOptions.data = needsSerialization
          ? JSON.stringify(hiveContent !== undefined ? hiveContent : {})
          : hiveContent || "";
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
  };
};
/**
 * HiveApi - functional programming interface
 * @export
 */
exports.HiveApiFp = function (configuration) {
  return {
    /**
     *
     * @summary Createhive
     * @param {HiveContent} hiveContent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createHiveV1(hiveContent, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .HiveApiAxiosParamCreator(configuration)
          .createHiveV1(hiveContent, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     *
     * @summary Deletehive
     * @param {string} hiveId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteHiveV1(hiveId, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .HiveApiAxiosParamCreator(configuration)
          .deleteHiveV1(hiveId, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     *
     * @summary Gethive
     * @param {string} hiveId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHiveV1(hiveId, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .HiveApiAxiosParamCreator(configuration)
          .getHiveV1(hiveId, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     *
     * @summary Listhives
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHivesV1(
      searchBy,
      searchValue,
      status,
      sortBy,
      sortOrder,
      skip,
      limit,
      options
    ) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .HiveApiAxiosParamCreator(configuration)
          .listHivesV1(
            searchBy,
            searchValue,
            status,
            sortBy,
            sortOrder,
            skip,
            limit,
            options
          );
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     *
     * @summary Updatehive
     * @param {string} hiveId
     * @param {HiveContent} hiveContent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateHiveV1(hiveId, hiveContent, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .HiveApiAxiosParamCreator(configuration)
          .updateHiveV1(hiveId, hiveContent, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
  };
};
/**
 * HiveApi - factory interface
 * @export
 */
exports.HiveApiFactory = function (configuration, basePath, axios) {
  return {
    /**
     *
     * @summary Createhive
     * @param {HiveContent} hiveContent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createHiveV1(hiveContent, options) {
      return exports
        .HiveApiFp(configuration)
        .createHiveV1(hiveContent, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletehive
     * @param {string} hiveId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteHiveV1(hiveId, options) {
      return exports
        .HiveApiFp(configuration)
        .deleteHiveV1(hiveId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gethive
     * @param {string} hiveId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHiveV1(hiveId, options) {
      return exports
        .HiveApiFp(configuration)
        .getHiveV1(hiveId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Listhives
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHivesV1(
      searchBy,
      searchValue,
      status,
      sortBy,
      sortOrder,
      skip,
      limit,
      options
    ) {
      return exports
        .HiveApiFp(configuration)
        .listHivesV1(
          searchBy,
          searchValue,
          status,
          sortBy,
          sortOrder,
          skip,
          limit,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updatehive
     * @param {string} hiveId
     * @param {HiveContent} hiveContent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateHiveV1(hiveId, hiveContent, options) {
      return exports
        .HiveApiFp(configuration)
        .updateHiveV1(hiveId, hiveContent, options)
        .then((request) => request(axios, basePath));
    },
  };
};
/**
 * HiveApi - object-oriented interface
 * @export
 * @class HiveApi
 * @extends {BaseAPI}
 */
class HiveApi extends base_1.BaseAPI {
  /**
   *
   * @summary Createhive
   * @param {HiveContent} hiveContent
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HiveApi
   */
  createHiveV1(hiveContent, options) {
    return exports
      .HiveApiFp(this.configuration)
      .createHiveV1(hiveContent, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Deletehive
   * @param {string} hiveId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HiveApi
   */
  deleteHiveV1(hiveId, options) {
    return exports
      .HiveApiFp(this.configuration)
      .deleteHiveV1(hiveId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Gethive
   * @param {string} hiveId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HiveApi
   */
  getHiveV1(hiveId, options) {
    return exports
      .HiveApiFp(this.configuration)
      .getHiveV1(hiveId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Listhives
   * @param {string} [searchBy]
   * @param {string} [searchValue]
   * @param {string} [status]
   * @param {string} [sortBy]
   * @param {SortOrder} [sortOrder]
   * @param {number} [skip]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HiveApi
   */
  listHivesV1(
    searchBy,
    searchValue,
    status,
    sortBy,
    sortOrder,
    skip,
    limit,
    options
  ) {
    return exports
      .HiveApiFp(this.configuration)
      .listHivesV1(
        searchBy,
        searchValue,
        status,
        sortBy,
        sortOrder,
        skip,
        limit,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Updatehive
   * @param {string} hiveId
   * @param {HiveContent} hiveContent
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HiveApi
   */
  updateHiveV1(hiveId, hiveContent, options) {
    return exports
      .HiveApiFp(this.configuration)
      .updateHiveV1(hiveId, hiveContent, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
exports.HiveApi = HiveApi;
/**
 * HiveAgentLinkApi - axios parameter creator
 * @export
 */
exports.HiveAgentLinkApiAxiosParamCreator = function (configuration) {
  return {
    /**
     *
     * @summary Createhiveagentlink
     * @param {string} hiveId
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createHiveAgentLinkV1: (hiveId, agentId, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'hiveId' is not null or undefined
        if (hiveId === null || hiveId === undefined) {
          throw new base_1.RequiredError(
            "hiveId",
            "Required parameter hiveId was null or undefined when calling createHiveAgentLinkV1."
          );
        }
        // verify required parameter 'agentId' is not null or undefined
        if (agentId === null || agentId === undefined) {
          throw new base_1.RequiredError(
            "agentId",
            "Required parameter agentId was null or undefined when calling createHiveAgentLinkV1."
          );
        }
        const localVarPath = `/v1/hives/{hive_id}/ai-agents/{agent_id}/link`
          .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)))
          .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "POST" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     *
     * @summary Deletehiveagentlink
     * @param {string} hiveId
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteHiveAgentLinkV1: (hiveId, agentId, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'hiveId' is not null or undefined
        if (hiveId === null || hiveId === undefined) {
          throw new base_1.RequiredError(
            "hiveId",
            "Required parameter hiveId was null or undefined when calling deleteHiveAgentLinkV1."
          );
        }
        // verify required parameter 'agentId' is not null or undefined
        if (agentId === null || agentId === undefined) {
          throw new base_1.RequiredError(
            "agentId",
            "Required parameter agentId was null or undefined when calling deleteHiveAgentLinkV1."
          );
        }
        const localVarPath = `/v1/hives/{hive_id}/ai-agents/{agent_id}/link`
          .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)))
          .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "DELETE" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     *
     * @summary Listagentsofhive
     * @param {string} hiveId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAgentsOfHiveV1: (hiveId, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'hiveId' is not null or undefined
        if (hiveId === null || hiveId === undefined) {
          throw new base_1.RequiredError(
            "hiveId",
            "Required parameter hiveId was null or undefined when calling listAgentsOfHiveV1."
          );
        }
        const localVarPath = `/v1/hives/{hive_id}/ai-agents`.replace(
          `{${"hive_id"}}`,
          encodeURIComponent(String(hiveId))
        );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "GET" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     *
     * @summary Listhivesofagent
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHivesOfAgentV1: (agentId, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'agentId' is not null or undefined
        if (agentId === null || agentId === undefined) {
          throw new base_1.RequiredError(
            "agentId",
            "Required parameter agentId was null or undefined when calling listHivesOfAgentV1."
          );
        }
        const localVarPath = `/v1/ai-agents/{agent_id}/hives`.replace(
          `{${"agent_id"}}`,
          encodeURIComponent(String(agentId))
        );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "GET" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
  };
};
/**
 * HiveAgentLinkApi - functional programming interface
 * @export
 */
exports.HiveAgentLinkApiFp = function (configuration) {
  return {
    /**
     *
     * @summary Createhiveagentlink
     * @param {string} hiveId
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createHiveAgentLinkV1(hiveId, agentId, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .HiveAgentLinkApiAxiosParamCreator(configuration)
          .createHiveAgentLinkV1(hiveId, agentId, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     *
     * @summary Deletehiveagentlink
     * @param {string} hiveId
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteHiveAgentLinkV1(hiveId, agentId, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .HiveAgentLinkApiAxiosParamCreator(configuration)
          .deleteHiveAgentLinkV1(hiveId, agentId, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     *
     * @summary Listagentsofhive
     * @param {string} hiveId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAgentsOfHiveV1(hiveId, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .HiveAgentLinkApiAxiosParamCreator(configuration)
          .listAgentsOfHiveV1(hiveId, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     *
     * @summary Listhivesofagent
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHivesOfAgentV1(agentId, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .HiveAgentLinkApiAxiosParamCreator(configuration)
          .listHivesOfAgentV1(agentId, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
  };
};
/**
 * HiveAgentLinkApi - factory interface
 * @export
 */
exports.HiveAgentLinkApiFactory = function (configuration, basePath, axios) {
  return {
    /**
     *
     * @summary Createhiveagentlink
     * @param {string} hiveId
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createHiveAgentLinkV1(hiveId, agentId, options) {
      return exports
        .HiveAgentLinkApiFp(configuration)
        .createHiveAgentLinkV1(hiveId, agentId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletehiveagentlink
     * @param {string} hiveId
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteHiveAgentLinkV1(hiveId, agentId, options) {
      return exports
        .HiveAgentLinkApiFp(configuration)
        .deleteHiveAgentLinkV1(hiveId, agentId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Listagentsofhive
     * @param {string} hiveId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAgentsOfHiveV1(hiveId, options) {
      return exports
        .HiveAgentLinkApiFp(configuration)
        .listAgentsOfHiveV1(hiveId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Listhivesofagent
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHivesOfAgentV1(agentId, options) {
      return exports
        .HiveAgentLinkApiFp(configuration)
        .listHivesOfAgentV1(agentId, options)
        .then((request) => request(axios, basePath));
    },
  };
};
/**
 * HiveAgentLinkApi - object-oriented interface
 * @export
 * @class HiveAgentLinkApi
 * @extends {BaseAPI}
 */
class HiveAgentLinkApi extends base_1.BaseAPI {
  /**
   *
   * @summary Createhiveagentlink
   * @param {string} hiveId
   * @param {string} agentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HiveAgentLinkApi
   */
  createHiveAgentLinkV1(hiveId, agentId, options) {
    return exports
      .HiveAgentLinkApiFp(this.configuration)
      .createHiveAgentLinkV1(hiveId, agentId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Deletehiveagentlink
   * @param {string} hiveId
   * @param {string} agentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HiveAgentLinkApi
   */
  deleteHiveAgentLinkV1(hiveId, agentId, options) {
    return exports
      .HiveAgentLinkApiFp(this.configuration)
      .deleteHiveAgentLinkV1(hiveId, agentId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Listagentsofhive
   * @param {string} hiveId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HiveAgentLinkApi
   */
  listAgentsOfHiveV1(hiveId, options) {
    return exports
      .HiveAgentLinkApiFp(this.configuration)
      .listAgentsOfHiveV1(hiveId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Listhivesofagent
   * @param {string} agentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HiveAgentLinkApi
   */
  listHivesOfAgentV1(agentId, options) {
    return exports
      .HiveAgentLinkApiFp(this.configuration)
      .listHivesOfAgentV1(agentId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
exports.HiveAgentLinkApi = HiveAgentLinkApi;
/**
 * InternalApi - axios parameter creator
 * @export
 */
exports.InternalApiAxiosParamCreator = function (configuration) {
  return {
    /**
     * Accept invite and add new user to organization
     * @summary Acceptinvite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptInviteV1: (options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        const localVarPath = `/v1/invites/accept`;
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "POST" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     * Creates a new organization and adds the user as the \"ADMIN\" user for the org
     * @summary Createorganization
     * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrganizationV1: (bodyCreateOrganizationV1, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'bodyCreateOrganizationV1' is not null or undefined
        if (
          bodyCreateOrganizationV1 === null ||
          bodyCreateOrganizationV1 === undefined
        ) {
          throw new base_1.RequiredError(
            "bodyCreateOrganizationV1",
            "Required parameter bodyCreateOrganizationV1 was null or undefined when calling createOrganizationV1."
          );
        }
        const localVarPath = `/v1/organizations`;
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "POST" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        const needsSerialization =
          typeof bodyCreateOrganizationV1 !== "string" ||
          localVarRequestOptions.headers["Content-Type"] === "application/json";
        localVarRequestOptions.data = needsSerialization
          ? JSON.stringify(
              bodyCreateOrganizationV1 !== undefined
                ? bodyCreateOrganizationV1
                : {}
            )
          : bodyCreateOrganizationV1 || "";
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     * Delete a user
     * @summary Deleteuser
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserV1: (userId, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
          throw new base_1.RequiredError(
            "userId",
            "Required parameter userId was null or undefined when calling deleteUserV1."
          );
        }
        const localVarPath = `/v1/users/{user_id}`.replace(
          `{${"user_id"}}`,
          encodeURIComponent(String(userId))
        );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "DELETE" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     * List of all open invites from the organization
     * @summary Listinvites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInvitesV1: (options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        const localVarPath = `/v1/invites`;
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "GET" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     * Lists all users under the user\'s organization
     * @summary Listusers
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsersV1: (
      searchBy,
      searchValue,
      status,
      sortBy,
      sortOrder,
      skip,
      limit,
      options = {}
    ) =>
      __awaiter(this, void 0, void 0, function* () {
        const localVarPath = `/v1/users`;
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "GET" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        if (searchBy !== undefined) {
          localVarQueryParameter["search_by"] = searchBy;
        }
        if (searchValue !== undefined) {
          localVarQueryParameter["search_value"] = searchValue;
        }
        if (status !== undefined) {
          localVarQueryParameter["status"] = status;
        }
        if (sortBy !== undefined) {
          localVarQueryParameter["sort_by"] = sortBy;
        }
        if (sortOrder !== undefined) {
          localVarQueryParameter["sort_order"] = sortOrder;
        }
        if (skip !== undefined) {
          localVarQueryParameter["skip"] = skip;
        }
        if (limit !== undefined) {
          localVarQueryParameter["limit"] = limit;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     * Invite a new user to an organization or resend invite to the user if the user is already invited
     * @summary Inviteusers
     * @param {GuestInput} guestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendInviteV1: (guestInput, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'guestInput' is not null or undefined
        if (guestInput === null || guestInput === undefined) {
          throw new base_1.RequiredError(
            "guestInput",
            "Required parameter guestInput was null or undefined when calling sendInviteV1."
          );
        }
        const localVarPath = `/v1/invites`;
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "POST" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        const needsSerialization =
          typeof guestInput !== "string" ||
          localVarRequestOptions.headers["Content-Type"] === "application/json";
        localVarRequestOptions.data = needsSerialization
          ? JSON.stringify(guestInput !== undefined ? guestInput : {})
          : guestInput || "";
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     * Update user details
     * @summary Updateuser
     * @param {string} userId
     * @param {UpdateUserPayload} updateUserPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserV1: (userId, updateUserPayload, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
          throw new base_1.RequiredError(
            "userId",
            "Required parameter userId was null or undefined when calling updateUserV1."
          );
        }
        // verify required parameter 'updateUserPayload' is not null or undefined
        if (updateUserPayload === null || updateUserPayload === undefined) {
          throw new base_1.RequiredError(
            "updateUserPayload",
            "Required parameter updateUserPayload was null or undefined when calling updateUserV1."
          );
        }
        const localVarPath = `/v1/users/{user_id}`.replace(
          `{${"user_id"}}`,
          encodeURIComponent(String(userId))
        );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "PUT" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        const needsSerialization =
          typeof updateUserPayload !== "string" ||
          localVarRequestOptions.headers["Content-Type"] === "application/json";
        localVarRequestOptions.data = needsSerialization
          ? JSON.stringify(
              updateUserPayload !== undefined ? updateUserPayload : {}
            )
          : updateUserPayload || "";
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
  };
};
/**
 * InternalApi - functional programming interface
 * @export
 */
exports.InternalApiFp = function (configuration) {
  return {
    /**
     * Accept invite and add new user to organization
     * @summary Acceptinvite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptInviteV1(options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .InternalApiAxiosParamCreator(configuration)
          .acceptInviteV1(options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     * Creates a new organization and adds the user as the \"ADMIN\" user for the org
     * @summary Createorganization
     * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrganizationV1(bodyCreateOrganizationV1, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .InternalApiAxiosParamCreator(configuration)
          .createOrganizationV1(bodyCreateOrganizationV1, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     * Delete a user
     * @summary Deleteuser
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserV1(userId, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .InternalApiAxiosParamCreator(configuration)
          .deleteUserV1(userId, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     * List of all open invites from the organization
     * @summary Listinvites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInvitesV1(options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .InternalApiAxiosParamCreator(configuration)
          .listInvitesV1(options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     * Lists all users under the user\'s organization
     * @summary Listusers
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsersV1(
      searchBy,
      searchValue,
      status,
      sortBy,
      sortOrder,
      skip,
      limit,
      options
    ) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .InternalApiAxiosParamCreator(configuration)
          .listUsersV1(
            searchBy,
            searchValue,
            status,
            sortBy,
            sortOrder,
            skip,
            limit,
            options
          );
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     * Invite a new user to an organization or resend invite to the user if the user is already invited
     * @summary Inviteusers
     * @param {GuestInput} guestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendInviteV1(guestInput, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .InternalApiAxiosParamCreator(configuration)
          .sendInviteV1(guestInput, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     * Update user details
     * @summary Updateuser
     * @param {string} userId
     * @param {UpdateUserPayload} updateUserPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserV1(userId, updateUserPayload, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .InternalApiAxiosParamCreator(configuration)
          .updateUserV1(userId, updateUserPayload, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
  };
};
/**
 * InternalApi - factory interface
 * @export
 */
exports.InternalApiFactory = function (configuration, basePath, axios) {
  return {
    /**
     * Accept invite and add new user to organization
     * @summary Acceptinvite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptInviteV1(options) {
      return exports
        .InternalApiFp(configuration)
        .acceptInviteV1(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new organization and adds the user as the \"ADMIN\" user for the org
     * @summary Createorganization
     * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrganizationV1(bodyCreateOrganizationV1, options) {
      return exports
        .InternalApiFp(configuration)
        .createOrganizationV1(bodyCreateOrganizationV1, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a user
     * @summary Deleteuser
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserV1(userId, options) {
      return exports
        .InternalApiFp(configuration)
        .deleteUserV1(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List of all open invites from the organization
     * @summary Listinvites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInvitesV1(options) {
      return exports
        .InternalApiFp(configuration)
        .listInvitesV1(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists all users under the user\'s organization
     * @summary Listusers
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsersV1(
      searchBy,
      searchValue,
      status,
      sortBy,
      sortOrder,
      skip,
      limit,
      options
    ) {
      return exports
        .InternalApiFp(configuration)
        .listUsersV1(
          searchBy,
          searchValue,
          status,
          sortBy,
          sortOrder,
          skip,
          limit,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Invite a new user to an organization or resend invite to the user if the user is already invited
     * @summary Inviteusers
     * @param {GuestInput} guestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendInviteV1(guestInput, options) {
      return exports
        .InternalApiFp(configuration)
        .sendInviteV1(guestInput, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update user details
     * @summary Updateuser
     * @param {string} userId
     * @param {UpdateUserPayload} updateUserPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserV1(userId, updateUserPayload, options) {
      return exports
        .InternalApiFp(configuration)
        .updateUserV1(userId, updateUserPayload, options)
        .then((request) => request(axios, basePath));
    },
  };
};
/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
class InternalApi extends base_1.BaseAPI {
  /**
   * Accept invite and add new user to organization
   * @summary Acceptinvite
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InternalApi
   */
  acceptInviteV1(options) {
    return exports
      .InternalApiFp(this.configuration)
      .acceptInviteV1(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new organization and adds the user as the \"ADMIN\" user for the org
   * @summary Createorganization
   * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InternalApi
   */
  createOrganizationV1(bodyCreateOrganizationV1, options) {
    return exports
      .InternalApiFp(this.configuration)
      .createOrganizationV1(bodyCreateOrganizationV1, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Delete a user
   * @summary Deleteuser
   * @param {string} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InternalApi
   */
  deleteUserV1(userId, options) {
    return exports
      .InternalApiFp(this.configuration)
      .deleteUserV1(userId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * List of all open invites from the organization
   * @summary Listinvites
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InternalApi
   */
  listInvitesV1(options) {
    return exports
      .InternalApiFp(this.configuration)
      .listInvitesV1(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all users under the user\'s organization
   * @summary Listusers
   * @param {string} [searchBy]
   * @param {string} [searchValue]
   * @param {string} [status]
   * @param {string} [sortBy]
   * @param {SortOrder} [sortOrder]
   * @param {number} [skip]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InternalApi
   */
  listUsersV1(
    searchBy,
    searchValue,
    status,
    sortBy,
    sortOrder,
    skip,
    limit,
    options
  ) {
    return exports
      .InternalApiFp(this.configuration)
      .listUsersV1(
        searchBy,
        searchValue,
        status,
        sortBy,
        sortOrder,
        skip,
        limit,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Invite a new user to an organization or resend invite to the user if the user is already invited
   * @summary Inviteusers
   * @param {GuestInput} guestInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InternalApi
   */
  sendInviteV1(guestInput, options) {
    return exports
      .InternalApiFp(this.configuration)
      .sendInviteV1(guestInput, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Update user details
   * @summary Updateuser
   * @param {string} userId
   * @param {UpdateUserPayload} updateUserPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InternalApi
   */
  updateUserV1(userId, updateUserPayload, options) {
    return exports
      .InternalApiFp(this.configuration)
      .updateUserV1(userId, updateUserPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
exports.InternalApi = InternalApi;
/**
 * MetricsApi - axios parameter creator
 * @export
 */
exports.MetricsApiAxiosParamCreator = function (configuration) {
  return {
    /**
     *
     * @summary Getmetrics
     * @param {BatchMetricsRequests} batchMetricsRequests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetricsV1MetricsPost: (batchMetricsRequests, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'batchMetricsRequests' is not null or undefined
        if (
          batchMetricsRequests === null ||
          batchMetricsRequests === undefined
        ) {
          throw new base_1.RequiredError(
            "batchMetricsRequests",
            "Required parameter batchMetricsRequests was null or undefined when calling getMetricsV1MetricsPost."
          );
        }
        const localVarPath = `/v1/metrics`;
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "POST" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        const needsSerialization =
          typeof batchMetricsRequests !== "string" ||
          localVarRequestOptions.headers["Content-Type"] === "application/json";
        localVarRequestOptions.data = needsSerialization
          ? JSON.stringify(
              batchMetricsRequests !== undefined ? batchMetricsRequests : {}
            )
          : batchMetricsRequests || "";
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
  };
};
/**
 * MetricsApi - functional programming interface
 * @export
 */
exports.MetricsApiFp = function (configuration) {
  return {
    /**
     *
     * @summary Getmetrics
     * @param {BatchMetricsRequests} batchMetricsRequests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetricsV1MetricsPost(batchMetricsRequests, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .MetricsApiAxiosParamCreator(configuration)
          .getMetricsV1MetricsPost(batchMetricsRequests, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
  };
};
/**
 * MetricsApi - factory interface
 * @export
 */
exports.MetricsApiFactory = function (configuration, basePath, axios) {
  return {
    /**
     *
     * @summary Getmetrics
     * @param {BatchMetricsRequests} batchMetricsRequests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetricsV1MetricsPost(batchMetricsRequests, options) {
      return exports
        .MetricsApiFp(configuration)
        .getMetricsV1MetricsPost(batchMetricsRequests, options)
        .then((request) => request(axios, basePath));
    },
  };
};
/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
class MetricsApi extends base_1.BaseAPI {
  /**
   *
   * @summary Getmetrics
   * @param {BatchMetricsRequests} batchMetricsRequests
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  getMetricsV1MetricsPost(batchMetricsRequests, options) {
    return exports
      .MetricsApiFp(this.configuration)
      .getMetricsV1MetricsPost(batchMetricsRequests, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
exports.MetricsApi = MetricsApi;
/**
 * ProductsApi - axios parameter creator
 * @export
 */
exports.ProductsApiAxiosParamCreator = function (configuration) {
  return {
    /**
     *
     * @summary Createproduct
     * @param {ProductInput} productInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProductV1: (productInput, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'productInput' is not null or undefined
        if (productInput === null || productInput === undefined) {
          throw new base_1.RequiredError(
            "productInput",
            "Required parameter productInput was null or undefined when calling createProductV1."
          );
        }
        const localVarPath = `/v1/products`;
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "POST" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        const needsSerialization =
          typeof productInput !== "string" ||
          localVarRequestOptions.headers["Content-Type"] === "application/json";
        localVarRequestOptions.data = needsSerialization
          ? JSON.stringify(productInput !== undefined ? productInput : {})
          : productInput || "";
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     *
     * @summary Deleteproduct
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProductV1: (productId, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'productId' is not null or undefined
        if (productId === null || productId === undefined) {
          throw new base_1.RequiredError(
            "productId",
            "Required parameter productId was null or undefined when calling deleteProductV1."
          );
        }
        const localVarPath = `/v1/products/{product_id}`.replace(
          `{${"product_id"}}`,
          encodeURIComponent(String(productId))
        );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "DELETE" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     *
     * @summary Getproduct
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProductV1: (productId, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'productId' is not null or undefined
        if (productId === null || productId === undefined) {
          throw new base_1.RequiredError(
            "productId",
            "Required parameter productId was null or undefined when calling getProductV1."
          );
        }
        const localVarPath = `/v1/products/{product_id}`.replace(
          `{${"product_id"}}`,
          encodeURIComponent(String(productId))
        );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "GET" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     *
     * @summary Listproducts
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {Array<string>} [tags]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProductsV1: (
      searchBy,
      searchValue,
      status,
      sortBy,
      sortOrder,
      skip,
      limit,
      tags,
      options = {}
    ) =>
      __awaiter(this, void 0, void 0, function* () {
        const localVarPath = `/v1/products`;
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "GET" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        if (searchBy !== undefined) {
          localVarQueryParameter["search_by"] = searchBy;
        }
        if (searchValue !== undefined) {
          localVarQueryParameter["search_value"] = searchValue;
        }
        if (status !== undefined) {
          localVarQueryParameter["status"] = status;
        }
        if (sortBy !== undefined) {
          localVarQueryParameter["sort_by"] = sortBy;
        }
        if (sortOrder !== undefined) {
          localVarQueryParameter["sort_order"] = sortOrder;
        }
        if (skip !== undefined) {
          localVarQueryParameter["skip"] = skip;
        }
        if (limit !== undefined) {
          localVarQueryParameter["limit"] = limit;
        }
        if (tags) {
          localVarQueryParameter["tags"] = tags;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     *
     * @summary Updateproduct
     * @param {string} productId
     * @param {ProductInput} productInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProductV1: (productId, productInput, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'productId' is not null or undefined
        if (productId === null || productId === undefined) {
          throw new base_1.RequiredError(
            "productId",
            "Required parameter productId was null or undefined when calling updateProductV1."
          );
        }
        // verify required parameter 'productInput' is not null or undefined
        if (productInput === null || productInput === undefined) {
          throw new base_1.RequiredError(
            "productInput",
            "Required parameter productInput was null or undefined when calling updateProductV1."
          );
        }
        const localVarPath = `/v1/products/{product_id}`.replace(
          `{${"product_id"}}`,
          encodeURIComponent(String(productId))
        );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "PUT" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        const needsSerialization =
          typeof productInput !== "string" ||
          localVarRequestOptions.headers["Content-Type"] === "application/json";
        localVarRequestOptions.data = needsSerialization
          ? JSON.stringify(productInput !== undefined ? productInput : {})
          : productInput || "";
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
  };
};
/**
 * ProductsApi - functional programming interface
 * @export
 */
exports.ProductsApiFp = function (configuration) {
  return {
    /**
     *
     * @summary Createproduct
     * @param {ProductInput} productInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProductV1(productInput, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .ProductsApiAxiosParamCreator(configuration)
          .createProductV1(productInput, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     *
     * @summary Deleteproduct
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProductV1(productId, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .ProductsApiAxiosParamCreator(configuration)
          .deleteProductV1(productId, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     *
     * @summary Getproduct
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProductV1(productId, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .ProductsApiAxiosParamCreator(configuration)
          .getProductV1(productId, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     *
     * @summary Listproducts
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {Array<string>} [tags]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProductsV1(
      searchBy,
      searchValue,
      status,
      sortBy,
      sortOrder,
      skip,
      limit,
      tags,
      options
    ) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .ProductsApiAxiosParamCreator(configuration)
          .listProductsV1(
            searchBy,
            searchValue,
            status,
            sortBy,
            sortOrder,
            skip,
            limit,
            tags,
            options
          );
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     *
     * @summary Updateproduct
     * @param {string} productId
     * @param {ProductInput} productInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProductV1(productId, productInput, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .ProductsApiAxiosParamCreator(configuration)
          .updateProductV1(productId, productInput, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
  };
};
/**
 * ProductsApi - factory interface
 * @export
 */
exports.ProductsApiFactory = function (configuration, basePath, axios) {
  return {
    /**
     *
     * @summary Createproduct
     * @param {ProductInput} productInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProductV1(productInput, options) {
      return exports
        .ProductsApiFp(configuration)
        .createProductV1(productInput, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deleteproduct
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProductV1(productId, options) {
      return exports
        .ProductsApiFp(configuration)
        .deleteProductV1(productId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Getproduct
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProductV1(productId, options) {
      return exports
        .ProductsApiFp(configuration)
        .getProductV1(productId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Listproducts
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {Array<string>} [tags]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProductsV1(
      searchBy,
      searchValue,
      status,
      sortBy,
      sortOrder,
      skip,
      limit,
      tags,
      options
    ) {
      return exports
        .ProductsApiFp(configuration)
        .listProductsV1(
          searchBy,
          searchValue,
          status,
          sortBy,
          sortOrder,
          skip,
          limit,
          tags,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updateproduct
     * @param {string} productId
     * @param {ProductInput} productInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProductV1(productId, productInput, options) {
      return exports
        .ProductsApiFp(configuration)
        .updateProductV1(productId, productInput, options)
        .then((request) => request(axios, basePath));
    },
  };
};
/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
class ProductsApi extends base_1.BaseAPI {
  /**
   *
   * @summary Createproduct
   * @param {ProductInput} productInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  createProductV1(productInput, options) {
    return exports
      .ProductsApiFp(this.configuration)
      .createProductV1(productInput, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Deleteproduct
   * @param {string} productId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  deleteProductV1(productId, options) {
    return exports
      .ProductsApiFp(this.configuration)
      .deleteProductV1(productId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Getproduct
   * @param {string} productId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  getProductV1(productId, options) {
    return exports
      .ProductsApiFp(this.configuration)
      .getProductV1(productId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Listproducts
   * @param {string} [searchBy]
   * @param {string} [searchValue]
   * @param {string} [status]
   * @param {string} [sortBy]
   * @param {SortOrder} [sortOrder]
   * @param {number} [skip]
   * @param {number} [limit]
   * @param {Array<string>} [tags]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  listProductsV1(
    searchBy,
    searchValue,
    status,
    sortBy,
    sortOrder,
    skip,
    limit,
    tags,
    options
  ) {
    return exports
      .ProductsApiFp(this.configuration)
      .listProductsV1(
        searchBy,
        searchValue,
        status,
        sortBy,
        sortOrder,
        skip,
        limit,
        tags,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Updateproduct
   * @param {string} productId
   * @param {ProductInput} productInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  updateProductV1(productId, productInput, options) {
    return exports
      .ProductsApiFp(this.configuration)
      .updateProductV1(productId, productInput, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
exports.ProductsApi = ProductsApi;
/**
 * ProspectsApi - axios parameter creator
 * @export
 */
exports.ProspectsApiAxiosParamCreator = function (configuration) {
  return {
    /**
     * Creates a new prospect.
     * @summary Createprospect
     * @param {ProspectInput} prospectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProspectV1: (prospectInput, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'prospectInput' is not null or undefined
        if (prospectInput === null || prospectInput === undefined) {
          throw new base_1.RequiredError(
            "prospectInput",
            "Required parameter prospectInput was null or undefined when calling createProspectV1."
          );
        }
        const localVarPath = `/v1/prospects`;
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "POST" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        const needsSerialization =
          typeof prospectInput !== "string" ||
          localVarRequestOptions.headers["Content-Type"] === "application/json";
        localVarRequestOptions.data = needsSerialization
          ? JSON.stringify(prospectInput !== undefined ? prospectInput : {})
          : prospectInput || "";
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     * Deletes a specific prospect by ID.
     * @summary Deleteprospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProspectV1: (prospectId, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'prospectId' is not null or undefined
        if (prospectId === null || prospectId === undefined) {
          throw new base_1.RequiredError(
            "prospectId",
            "Required parameter prospectId was null or undefined when calling deleteProspectV1."
          );
        }
        const localVarPath = `/v1/prospects/{prospect_id}`.replace(
          `{${"prospect_id"}}`,
          encodeURIComponent(String(prospectId))
        );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "DELETE" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     * Fetches a specific prospect by ID.
     * @summary Getprospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProspectV1: (prospectId, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'prospectId' is not null or undefined
        if (prospectId === null || prospectId === undefined) {
          throw new base_1.RequiredError(
            "prospectId",
            "Required parameter prospectId was null or undefined when calling getProspectV1."
          );
        }
        const localVarPath = `/v1/prospects/{prospect_id}`.replace(
          `{${"prospect_id"}}`,
          encodeURIComponent(String(prospectId))
        );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "GET" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     * Lists all prospects under the user\'s organization
     * @summary Listprospects
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProspectsV1: (
      searchBy,
      searchValue,
      status,
      sortBy,
      sortOrder,
      skip,
      limit,
      options = {}
    ) =>
      __awaiter(this, void 0, void 0, function* () {
        const localVarPath = `/v1/prospects`;
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "GET" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        if (searchBy !== undefined) {
          localVarQueryParameter["search_by"] = searchBy;
        }
        if (searchValue !== undefined) {
          localVarQueryParameter["search_value"] = searchValue;
        }
        if (status !== undefined) {
          localVarQueryParameter["status"] = status;
        }
        if (sortBy !== undefined) {
          localVarQueryParameter["sort_by"] = sortBy;
        }
        if (sortOrder !== undefined) {
          localVarQueryParameter["sort_order"] = sortOrder;
        }
        if (skip !== undefined) {
          localVarQueryParameter["skip"] = skip;
        }
        if (limit !== undefined) {
          localVarQueryParameter["limit"] = limit;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
    /**
     * Updates a specific prospect by ID.
     * @summary Updateprospect
     * @param {string} prospectId
     * @param {ProspectInput} prospectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProspectV1: (prospectId, prospectInput, options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        // verify required parameter 'prospectId' is not null or undefined
        if (prospectId === null || prospectId === undefined) {
          throw new base_1.RequiredError(
            "prospectId",
            "Required parameter prospectId was null or undefined when calling updateProspectV1."
          );
        }
        // verify required parameter 'prospectInput' is not null or undefined
        if (prospectInput === null || prospectInput === undefined) {
          throw new base_1.RequiredError(
            "prospectInput",
            "Required parameter prospectInput was null or undefined when calling updateProspectV1."
          );
        }
        const localVarPath = `/v1/prospects/{prospect_id}`.replace(
          `{${"prospect_id"}}`,
          encodeURIComponent(String(prospectId))
        );
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "PUT" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        const needsSerialization =
          typeof prospectInput !== "string" ||
          localVarRequestOptions.headers["Content-Type"] === "application/json";
        localVarRequestOptions.data = needsSerialization
          ? JSON.stringify(prospectInput !== undefined ? prospectInput : {})
          : prospectInput || "";
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
  };
};
/**
 * ProspectsApi - functional programming interface
 * @export
 */
exports.ProspectsApiFp = function (configuration) {
  return {
    /**
     * Creates a new prospect.
     * @summary Createprospect
     * @param {ProspectInput} prospectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProspectV1(prospectInput, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .ProspectsApiAxiosParamCreator(configuration)
          .createProspectV1(prospectInput, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     * Deletes a specific prospect by ID.
     * @summary Deleteprospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProspectV1(prospectId, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .ProspectsApiAxiosParamCreator(configuration)
          .deleteProspectV1(prospectId, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     * Fetches a specific prospect by ID.
     * @summary Getprospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProspectV1(prospectId, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .ProspectsApiAxiosParamCreator(configuration)
          .getProspectV1(prospectId, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     * Lists all prospects under the user\'s organization
     * @summary Listprospects
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProspectsV1(
      searchBy,
      searchValue,
      status,
      sortBy,
      sortOrder,
      skip,
      limit,
      options
    ) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .ProspectsApiAxiosParamCreator(configuration)
          .listProspectsV1(
            searchBy,
            searchValue,
            status,
            sortBy,
            sortOrder,
            skip,
            limit,
            options
          );
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
    /**
     * Updates a specific prospect by ID.
     * @summary Updateprospect
     * @param {string} prospectId
     * @param {ProspectInput} prospectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProspectV1(prospectId, prospectInput, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .ProspectsApiAxiosParamCreator(configuration)
          .updateProspectV1(prospectId, prospectInput, options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
  };
};
/**
 * ProspectsApi - factory interface
 * @export
 */
exports.ProspectsApiFactory = function (configuration, basePath, axios) {
  return {
    /**
     * Creates a new prospect.
     * @summary Createprospect
     * @param {ProspectInput} prospectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProspectV1(prospectInput, options) {
      return exports
        .ProspectsApiFp(configuration)
        .createProspectV1(prospectInput, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes a specific prospect by ID.
     * @summary Deleteprospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProspectV1(prospectId, options) {
      return exports
        .ProspectsApiFp(configuration)
        .deleteProspectV1(prospectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetches a specific prospect by ID.
     * @summary Getprospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProspectV1(prospectId, options) {
      return exports
        .ProspectsApiFp(configuration)
        .getProspectV1(prospectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists all prospects under the user\'s organization
     * @summary Listprospects
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProspectsV1(
      searchBy,
      searchValue,
      status,
      sortBy,
      sortOrder,
      skip,
      limit,
      options
    ) {
      return exports
        .ProspectsApiFp(configuration)
        .listProspectsV1(
          searchBy,
          searchValue,
          status,
          sortBy,
          sortOrder,
          skip,
          limit,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates a specific prospect by ID.
     * @summary Updateprospect
     * @param {string} prospectId
     * @param {ProspectInput} prospectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProspectV1(prospectId, prospectInput, options) {
      return exports
        .ProspectsApiFp(configuration)
        .updateProspectV1(prospectId, prospectInput, options)
        .then((request) => request(axios, basePath));
    },
  };
};
/**
 * ProspectsApi - object-oriented interface
 * @export
 * @class ProspectsApi
 * @extends {BaseAPI}
 */
class ProspectsApi extends base_1.BaseAPI {
  /**
   * Creates a new prospect.
   * @summary Createprospect
   * @param {ProspectInput} prospectInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProspectsApi
   */
  createProspectV1(prospectInput, options) {
    return exports
      .ProspectsApiFp(this.configuration)
      .createProspectV1(prospectInput, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes a specific prospect by ID.
   * @summary Deleteprospect
   * @param {string} prospectId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProspectsApi
   */
  deleteProspectV1(prospectId, options) {
    return exports
      .ProspectsApiFp(this.configuration)
      .deleteProspectV1(prospectId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Fetches a specific prospect by ID.
   * @summary Getprospect
   * @param {string} prospectId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProspectsApi
   */
  getProspectV1(prospectId, options) {
    return exports
      .ProspectsApiFp(this.configuration)
      .getProspectV1(prospectId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all prospects under the user\'s organization
   * @summary Listprospects
   * @param {string} [searchBy]
   * @param {string} [searchValue]
   * @param {string} [status]
   * @param {string} [sortBy]
   * @param {SortOrder} [sortOrder]
   * @param {number} [skip]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProspectsApi
   */
  listProspectsV1(
    searchBy,
    searchValue,
    status,
    sortBy,
    sortOrder,
    skip,
    limit,
    options
  ) {
    return exports
      .ProspectsApiFp(this.configuration)
      .listProspectsV1(
        searchBy,
        searchValue,
        status,
        sortBy,
        sortOrder,
        skip,
        limit,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Updates a specific prospect by ID.
   * @summary Updateprospect
   * @param {string} prospectId
   * @param {ProspectInput} prospectInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProspectsApi
   */
  updateProspectV1(prospectId, prospectInput, options) {
    return exports
      .ProspectsApiFp(this.configuration)
      .updateProspectV1(prospectId, prospectInput, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
exports.ProspectsApi = ProspectsApi;
/**
 * VoiceModelsApi - axios parameter creator
 * @export
 */
exports.VoiceModelsApiAxiosParamCreator = function (configuration) {
  return {
    /**
     *
     * @summary Listvoicemodels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVoiceModelsV1: (options = {}) =>
      __awaiter(this, void 0, void 0, function* () {
        const localVarPath = `/v1/voice-models`;
        const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = Object.assign(
          Object.assign({ method: "GET" }, baseOptions),
          options
        );
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        // authentication HTTPBearer required
        // http bearer authentication required
        if (configuration && configuration.accessToken) {
          const accessToken =
            typeof configuration.accessToken === "function"
              ? configuration.accessToken()
              : configuration.accessToken;
          localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
        }
        localVarUrlObj.query = Object.assign(
          Object.assign(
            Object.assign({}, localVarUrlObj.query),
            localVarQueryParameter
          ),
          options.query
        );
        // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
        delete localVarUrlObj.search;
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = Object.assign(
          Object.assign(
            Object.assign({}, localVarHeaderParameter),
            headersFromBaseOptions
          ),
          options.headers
        );
        return {
          url: globalImportUrl.format(localVarUrlObj),
          options: localVarRequestOptions,
        };
      }),
  };
};
/**
 * VoiceModelsApi - functional programming interface
 * @export
 */
exports.VoiceModelsApiFp = function (configuration) {
  return {
    /**
     *
     * @summary Listvoicemodels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVoiceModelsV1(options) {
      return __awaiter(this, void 0, void 0, function* () {
        const localVarAxiosArgs = yield exports
          .VoiceModelsApiAxiosParamCreator(configuration)
          .listVoiceModelsV1(options);
        return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
          const axiosRequestArgs = Object.assign(
            Object.assign({}, localVarAxiosArgs.options),
            { url: basePath + localVarAxiosArgs.url }
          );
          return axios.request(axiosRequestArgs);
        };
      });
    },
  };
};
/**
 * VoiceModelsApi - factory interface
 * @export
 */
exports.VoiceModelsApiFactory = function (configuration, basePath, axios) {
  return {
    /**
     *
     * @summary Listvoicemodels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVoiceModelsV1(options) {
      return exports
        .VoiceModelsApiFp(configuration)
        .listVoiceModelsV1(options)
        .then((request) => request(axios, basePath));
    },
  };
};
/**
 * VoiceModelsApi - object-oriented interface
 * @export
 * @class VoiceModelsApi
 * @extends {BaseAPI}
 */
class VoiceModelsApi extends base_1.BaseAPI {
  /**
   *
   * @summary Listvoicemodels
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceModelsApi
   */
  listVoiceModelsV1(options) {
    return exports
      .VoiceModelsApiFp(this.configuration)
      .listVoiceModelsV1(options)
      .then((request) => request(this.axios, this.basePath));
  }
}
exports.VoiceModelsApi = VoiceModelsApi;
