// tslint:disable
/**
 * Trata AI API
 * Human like conversation to answer calls, drive engagement, automate follow-ups & schedule bookings 24/7  with end to end integrations ensuring you never miss a sales enquiry.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AIAgentInput
 */
export interface AIAgentInput {
    /**
     * Name of the AI agent
     * @type {string}
     * @memberof AIAgentInput
     */
    name: string;
    /**
     * Image URL for the AI agent
     * @type {string}
     * @memberof AIAgentInput
     */
    imageUrl: string;
    /**
     * Mission of the AI agent
     * @type {Mission}
     * @memberof AIAgentInput
     */
    mission?: Mission | null;
    /**
     * Status of the AI agent
     * @type {Status}
     * @memberof AIAgentInput
     */
    status: Status;
    /**
     * Role of the AI agent in the company
     * @type {string}
     * @memberof AIAgentInput
     */
    role: string;
    /**
     * Description of the role of the AI agent
     * @type {string}
     * @memberof AIAgentInput
     */
    roleDescription: string;
    /**
     * Timezone of the AI agent used for scheduling meetings
     * @type {string}
     * @memberof AIAgentInput
     */
    timezone: string;
    /**
     * Voice of the AI agent
     * @type {VoiceInput}
     * @memberof AIAgentInput
     */
    voice?: VoiceInput | null;
    /**
     * List of terms or phrases that the AI agent to prioritize for enhanced recognition
     * @type {Array<string>}
     * @memberof AIAgentInput
     */
    boostedKeywords?: Array<string> | null;
    /**
     * App in which the AI agent is running
     * @type {AppEnum}
     * @memberof AIAgentInput
     */
    app?: AppEnum | null;
}
/**
 * AI agent configured by businesses
 * @export
 * @interface AIAgentOutput
 */
export interface AIAgentOutput {
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    imageUrl?: string;
    /**
     * 
     * @type {Mission}
     * @memberof AIAgentOutput
     */
    mission?: Mission | null;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    roleDescription?: string;
    /**
     * 
     * @type {Transcriber}
     * @memberof AIAgentOutput
     */
    transcriber?: Transcriber | null;
    /**
     * 
     * @type {IntelligenceProvider}
     * @memberof AIAgentOutput
     */
    intelligenceProvider?: IntelligenceProvider | null;
    /**
     * 
     * @type {VoiceOutput}
     * @memberof AIAgentOutput
     */
    voice?: VoiceOutput | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AIAgentOutput
     */
    boostedKeywords?: Array<string> | null;
    /**
     * Application under which the AI agent is created
     * @type {AppEnum}
     * @memberof AIAgentOutput
     */
    app?: AppEnum | null;
    /**
     * Evaluation metrics for the conversation
     * @type {ConversationEvaluationMetrics}
     * @memberof AIAgentOutput
     */
    evaluationMetrics?: ConversationEvaluationMetrics | null;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    timezone?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Accent {
    American = 'American',
    Indian = 'Indian',
    Australian = 'Australian',
    British = 'British',
    Hindi = 'Hindi',
    MiddleEastern = 'Middle Eastern'
}

/**
 * 
 * @export
 * @interface AcceptInviteRequest
 */
export interface AcceptInviteRequest {
    /**
     * Name of the user
     * @type {string}
     * @memberof AcceptInviteRequest
     */
    name?: string | null;
}
/**
 * 
 * @export
 * @interface ActionInput
 */
export interface ActionInput {
    /**
     * Name of the action
     * @type {string}
     * @memberof ActionInput
     */
    name: string;
    /**
     * Description about the action and it should also contain when the action should be triggered
     * @type {string}
     * @memberof ActionInput
     */
    description?: string | null;
    /**
     * Parameters for the action. It should be a JSON schema object
     * @type {object}
     * @memberof ActionInput
     */
    parameters: object;
    /**
     * Endpoint for the action
     * @type {HttpActionEndpoint | InternalActionEndpoint | AgenticWorkflowActionEndpoint}
     * @memberof ActionInput
     */
    endpoint: HttpActionEndpoint | InternalActionEndpoint | AgenticWorkflowActionEndpoint;
    /**
     * Text to be rendered to user when action is invoked
     * @type {string}
     * @memberof ActionInput
     */
    userWaitingText?: string | null;
    /**
     * Text to be rendered to user when action is successful
     * @type {string}
     * @memberof ActionInput
     */
    userSuccessText?: string | null;
    /**
     * Text to be rendered to user when action is not successful
     * @type {string}
     * @memberof ActionInput
     */
    userErrorText?: string | null;
    /**
     * Trigger who invokes the action
     * @type {ActionInvocationTrigger}
     * @memberof ActionInput
     */
    invocationTrigger: ActionInvocationTrigger;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ActionInvocationTrigger {
    UserQuery = 'user_query',
    WebhookConversationStart = 'webhook.conversation_start',
    WebhookConversationEnd = 'webhook.conversation_end'
}

/**
 * Action entity to store the actions which can be performed by ai agents
 * @export
 * @interface ActionOutput
 */
export interface ActionOutput {
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    description?: string | null;
    /**
     * 
     * @type {object}
     * @memberof ActionOutput
     */
    parameters?: object | null;
    /**
     * 
     * @type {object}
     * @memberof ActionOutput
     */
    endpoint?: object | null;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    invocationTrigger?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    userWaitingText?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    userSuccessText?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    userErrorText?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Adaptability {
    OpenToChange = 'open to change',
    Resistant = 'resistant',
    Indifferent = 'indifferent'
}

/**
 * 
 * @export
 * @interface AddressInput
 */
export interface AddressInput {
    /**
     * Address line 1
     * @type {string}
     * @memberof AddressInput
     */
    line1: string;
    /**
     * Address line 2
     * @type {string}
     * @memberof AddressInput
     */
    line2?: string | null;
    /**
     * City
     * @type {string}
     * @memberof AddressInput
     */
    city?: string | null;
    /**
     * State
     * @type {string}
     * @memberof AddressInput
     */
    state?: string | null;
    /**
     * Country
     * @type {string}
     * @memberof AddressInput
     */
    country: string;
}
/**
 * 
 * @export
 * @interface AddressOutput
 */
export interface AddressOutput {
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    line1: string;
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    line2: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    city: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    state: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    country: string | null;
}
/**
 * 
 * @export
 * @interface AgentConfig
 */
export interface AgentConfig {
    /**
     * Enum class representing transcriber
     * @type {string}
     * @memberof AgentConfig
     */
    transcriber: string;
    /**
     * Enum class representing intelligence provider
     * @type {string}
     * @memberof AgentConfig
     */
    intelligenceProvider: string;
    /**
     * 
     * @type {string}
     * @memberof AgentConfig
     */
    synthesizer: string;
    /**
     * 
     * @type {string}
     * @memberof AgentConfig
     */
    embeddingsModelConfig: string;
    /**
     * 
     * @type {string}
     * @memberof AgentConfig
     */
    hiveStorageConfig: string;
    /**
     * 
     * @type {string}
     * @memberof AgentConfig
     */
    fillersConfig?: string | null;
}
/**
 * 
 * @export
 * @interface AgenticWorkflowActionEndpoint
 */
export interface AgenticWorkflowActionEndpoint {
    /**
     * Agentic workflow id
     * @type {string}
     * @memberof AgenticWorkflowActionEndpoint
     */
    workflowId: string;
}
/**
 * Connection represents an instance of an app with specific credentials and configuration
 * @export
 * @interface AgenticWorkflowDbModelsConnection
 */
export interface AgenticWorkflowDbModelsConnection {
    /**
     * The user who created.
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    createdBy?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    createdAt?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    updatedBy?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    updatedAt?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    orgId?: string;
    /**
     * The name of the connection
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    name?: string;
    /**
     * The unique identifier of the app
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    appId?: string;
    /**
     * The version of the app
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    appVersion?: string;
    /**
     * The description of the connection
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    description?: string | null;
    /**
     * OAuth or API key authentication configuration
     * @type {OAuthCredentials | ApiKeyCredentials | BasicAuthCredentials | NoAuthCredentials}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    credentials: OAuthCredentials | ApiKeyCredentials | BasicAuthCredentials | NoAuthCredentials;
    /**
     * Metadata for the connection
     * @type {object}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    connectionMetaData?: object | null;
    /**
     * The unique identifier of the connection
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface AgenticWorkflowModelsBaseBaseResponse
 */
export interface AgenticWorkflowModelsBaseBaseResponse {
    /**
     * The message of the response
     * @type {string}
     * @memberof AgenticWorkflowModelsBaseBaseResponse
     */
    message?: string;
    /**
     * The status of the response
     * @type {string}
     * @memberof AgenticWorkflowModelsBaseBaseResponse
     */
    status?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum AggregationFormula {
    COUNT = 'COUNT',
    SUM = 'SUM',
    MEDIAN = 'MEDIAN'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum AggregationPeriod {
    MONTHLY = 'MONTHLY',
    WEEKLY = 'WEEKLY',
    DAILY = 'DAILY'
}

/**
 * API key authentication configuration
 * @export
 * @interface ApiKeyAuth
 */
export interface ApiKeyAuth {
    /**
     * The type of authentication
     * @type {string}
     * @memberof ApiKeyAuth
     */
    authType?: ApiKeyAuthAuthTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiKeyAuthAuthTypeEnum {
    Apikey = 'apikey'
}

/**
 * 
 * @export
 * @interface ApiKeyCredentials
 */
export interface ApiKeyCredentials {
    /**
     * Credential type identifier
     * @type {string}
     * @memberof ApiKeyCredentials
     */
    credentialsType?: ApiKeyCredentialsCredentialsTypeEnum;
    /**
     * The API key for the app
     * @type {string}
     * @memberof ApiKeyCredentials
     */
    apiKey: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiKeyCredentialsCredentialsTypeEnum {
    Apikey = 'apikey'
}

/**
 * 
 * @export
 * @interface ApiKeyRequest
 */
export interface ApiKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiKeyRequest
     */
    key_type?: string | null;
}
/**
 * App represents an integration that can be connected to perform actions and triggers
 * @export
 * @interface App
 */
export interface App {
    /**
     * The user who created.
     * @type {string}
     * @memberof App
     */
    createdBy?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof App
     */
    createdAt?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof App
     */
    updatedBy?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof App
     */
    updatedAt?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof App
     */
    orgId?: string;
    /**
     * The name of the app
     * @type {string}
     * @memberof App
     */
    name?: string;
    /**
     * The description of the app
     * @type {string}
     * @memberof App
     */
    description?: string | null;
    /**
     * API Endpoint URL for the app
     * @type {string}
     * @memberof App
     */
    endpointUrl?: string | null;
    /**
     * URL to the app\'s logo image
     * @type {string}
     * @memberof App
     */
    logoUrl?: string | null;
    /**
     * Authentication configuration for the app
     * @type {Array<OAuth | ApiKeyAuth | BasicAuth | NoAuth>}
     * @memberof App
     */
    auth: Array<OAuth | ApiKeyAuth | BasicAuth | NoAuth>;
    /**
     * The version of the app
     * @type {string}
     * @memberof App
     */
    version?: string;
    /**
     * The unique identifier of the app
     * @type {string}
     * @memberof App
     */
    id?: string;
}
/**
 * AppAction represents an action that can be performed by an app
 * @export
 * @interface AppAction
 */
export interface AppAction {
    /**
     * The user who created.
     * @type {string}
     * @memberof AppAction
     */
    createdBy?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof AppAction
     */
    createdAt?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof AppAction
     */
    updatedBy?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof AppAction
     */
    updatedAt?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof AppAction
     */
    orgId?: string;
    /**
     * The type of the step, can be either trigger or action
     * @type {AppActionType}
     * @memberof AppAction
     */
    actionType: AppActionType;
    /**
     * The name of the step. This name should be unique within the app
     * @type {string}
     * @memberof AppAction
     */
    name?: string;
    /**
     * The description of the step
     * @type {string}
     * @memberof AppAction
     */
    description?: string;
    /**
     * JSON Schema for the step data
     * @type {object}
     * @memberof AppAction
     */
    dataSchema: object;
    /**
     * JSON Schema for the UI representation
     * @type {object}
     * @memberof AppAction
     */
    uiSchema: object;
    /**
     * This represents how this action should be displayed in the UI
     * @type {UiNodeType}
     * @memberof AppAction
     */
    uiNodeType: UiNodeType;
    /**
     * The ID of the app that this action belongs to
     * @type {string}
     * @memberof AppAction
     */
    appId: string;
    /**
     * The version of the app that this action belongs to
     * @type {string}
     * @memberof AppAction
     */
    appVersion: string;
    /**
     * The unique identifier of the app action
     * @type {string}
     * @memberof AppAction
     */
    id?: string;
}
/**
 * App Action Model
 * @export
 * @interface AppActionEntity
 */
export interface AppActionEntity {
    /**
     * The type of the step, can be either trigger or action
     * @type {AppActionType}
     * @memberof AppActionEntity
     */
    actionType: AppActionType;
    /**
     * The name of the step. This name should be unique within the app
     * @type {string}
     * @memberof AppActionEntity
     */
    name?: string;
    /**
     * The description of the step
     * @type {string}
     * @memberof AppActionEntity
     */
    description?: string;
    /**
     * JSON Schema for the step data
     * @type {object}
     * @memberof AppActionEntity
     */
    dataSchema: object;
    /**
     * JSON Schema for the UI representation
     * @type {object}
     * @memberof AppActionEntity
     */
    uiSchema: object;
    /**
     * This represents how this action should be displayed in the UI
     * @type {UiNodeType}
     * @memberof AppActionEntity
     */
    uiNodeType: UiNodeType;
}
/**
 * Enum for step types
 * @export
 * @enum {string}
 */
export enum AppActionType {
    TRIGGER = 'TRIGGER',
    ACTION = 'ACTION'
}

/**
 * App DTO Model filled by user
 * @export
 * @interface AppEntity
 */
export interface AppEntity {
    /**
     * The name of the app
     * @type {string}
     * @memberof AppEntity
     */
    name?: string;
    /**
     * The description of the app
     * @type {string}
     * @memberof AppEntity
     */
    description?: string | null;
    /**
     * API Endpoint URL for the app
     * @type {string}
     * @memberof AppEntity
     */
    endpointUrl?: string | null;
    /**
     * URL to the app\'s logo image
     * @type {string}
     * @memberof AppEntity
     */
    logoUrl?: string | null;
    /**
     * Authentication configuration for the app
     * @type {Array<OAuth | ApiKeyAuth | BasicAuth | NoAuth>}
     * @memberof AppEntity
     */
    auth: Array<OAuth | ApiKeyAuth | BasicAuth | NoAuth>;
    /**
     * The version of the app
     * @type {string}
     * @memberof AppEntity
     */
    version?: string;
    /**
     * Array of available actions with their configurations
     * @type {Array<AppActionEntity>}
     * @memberof AppEntity
     */
    actions: Array<AppActionEntity>;
}
/**
 * Enum which stores the list of apps which are used to create the conversation
 * @export
 * @enum {string}
 */
export enum AppEnum {
    TRATA = 'TRATA',
    TRATASPARR = 'TRATA_SPARR'
}

/**
 * 
 * @export
 * @interface AppResponse
 */
export interface AppResponse {
    /**
     * 
     * @type {App}
     * @memberof AppResponse
     */
    app: App;
    /**
     * 
     * @type {Array<AppAction>}
     * @memberof AppResponse
     */
    actions: Array<AppAction>;
}
/**
 * 
 * @export
 * @interface AvailablePhoneNumber
 */
export interface AvailablePhoneNumber {
    /**
     * 
     * @type {string}
     * @memberof AvailablePhoneNumber
     */
    phoneNumber: string;
    /**
     * 
     * @type {string}
     * @memberof AvailablePhoneNumber
     */
    countryCode: string;
    /**
     * 
     * @type {string}
     * @memberof AvailablePhoneNumber
     */
    locality: string | null;
    /**
     * 
     * @type {string}
     * @memberof AvailablePhoneNumber
     */
    region: string | null;
}
/**
 * 
 * @export
 * @interface BaseResponseInput
 */
export interface BaseResponseInput {
    /**
     * Address line 1
     * @type {string}
     * @memberof BaseResponseInput
     */
    message: string;
}
/**
 * Basic authentication configuration
 * @export
 * @interface BasicAuth
 */
export interface BasicAuth {
    /**
     * The type of authentication
     * @type {string}
     * @memberof BasicAuth
     */
    authType?: BasicAuthAuthTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum BasicAuthAuthTypeEnum {
    Basic = 'basic'
}

/**
 * 
 * @export
 * @interface BasicAuthCredentials
 */
export interface BasicAuthCredentials {
    /**
     * Credential type identifier
     * @type {string}
     * @memberof BasicAuthCredentials
     */
    credentialsType?: BasicAuthCredentialsCredentialsTypeEnum;
    /**
     * The username for the app
     * @type {string}
     * @memberof BasicAuthCredentials
     */
    username: string;
    /**
     * The password for the app
     * @type {string}
     * @memberof BasicAuthCredentials
     */
    password: string;
}

/**
    * @export
    * @enum {string}
    */
export enum BasicAuthCredentialsCredentialsTypeEnum {
    Basic = 'basic'
}

/**
 * 
 * @export
 * @interface BatchMetricsRequests
 */
export interface BatchMetricsRequests {
    /**
     * 
     * @type {Array<MetricsRequest>}
     * @memberof BatchMetricsRequests
     */
    requests: Array<MetricsRequest>;
}
/**
 * 
 * @export
 * @interface BatchMetricsResponse
 */
export interface BatchMetricsResponse {
    /**
     * 
     * @type {Array<MetricsResponse>}
     * @memberof BatchMetricsResponse
     */
    responses: Array<MetricsResponse>;
}
/**
 * 
 * @export
 * @interface BodyCreateOrganizationV1
 */
export interface BodyCreateOrganizationV1 {
    /**
     * 
     * @type {OrganizationInput}
     * @memberof BodyCreateOrganizationV1
     */
    org: OrganizationInput;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateOrganizationV1
     */
    adminUserName: string;
}
/**
 * 
 * @export
 * @interface BodyUploadFileV1
 */
export interface BodyUploadFileV1 {
    /**
     * 
     * @type {Array<any>}
     * @memberof BodyUploadFileV1
     */
    files: Array<any>;
}
/**
 * 
 * @export
 * @interface BodyUploadResellerFilesV1
 */
export interface BodyUploadResellerFilesV1 {
    /**
     * 
     * @type {Array<any>}
     * @memberof BodyUploadResellerFilesV1
     */
    files: Array<any>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CallSentiment {
    Positive = 'positive',
    Negative = 'negative',
    Neutral = 'neutral'
}

/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * Notes or comments to record
     * @type {string}
     * @memberof Comment
     */
    comment: string;
    /**
     * Star rating to record
     * @type {number}
     * @memberof Comment
     */
    rating: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CommunicationStyle {
    Direct = 'direct',
    Indirect = 'indirect',
    Verbose = 'verbose',
    Brief = 'brief'
}

/**
 * Condition Model for branching/looping logic
 * @export
 * @interface Condition
 */
export interface Condition {
    /**
     * Condition expression to evaluate
     * @type {string}
     * @memberof Condition
     */
    when: string;
    /**
     * Next step ID if condition is true
     * @type {string}
     * @memberof Condition
     */
    stepId: string;
}
/**
 * Core Connection Model
 * @export
 * @interface ConnectionCore
 */
export interface ConnectionCore {
    /**
     * The name of the connection
     * @type {string}
     * @memberof ConnectionCore
     */
    name?: string;
    /**
     * The unique identifier of the app
     * @type {string}
     * @memberof ConnectionCore
     */
    appId?: string;
    /**
     * The version of the app
     * @type {string}
     * @memberof ConnectionCore
     */
    appVersion?: string;
    /**
     * The description of the connection
     * @type {string}
     * @memberof ConnectionCore
     */
    description?: string | null;
    /**
     * OAuth or API key authentication configuration
     * @type {OAuthCredentials | ApiKeyCredentials | BasicAuthCredentials | NoAuthCredentials}
     * @memberof ConnectionCore
     */
    credentials: OAuthCredentials | ApiKeyCredentials | BasicAuthCredentials | NoAuthCredentials;
    /**
     * Metadata for the connection
     * @type {object}
     * @memberof ConnectionCore
     */
    connectionMetaData?: object | null;
}
/**
 * This represents the connection between the user and the assistant
 * @export
 * @interface ConnectionOutput
 */
export interface ConnectionOutput {
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    sourceName?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    sourceId?: string;
    /**
     * 
     * @type {object}
     * @memberof ConnectionOutput
     */
    sourceProps?: object | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    agentId?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    prospectId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface ConnectionSource
 */
export interface ConnectionSource {
    /**
     * Name of the source
     * @type {string}
     * @memberof ConnectionSource
     */
    sourceName?: ConnectionSourceSourceNameEnum;
    /**
     * Unique identifier for the source
     * @type {string}
     * @memberof ConnectionSource
     */
    sourceId: string;
    /**
     * Extra properties of source
     * @type {object}
     * @memberof ConnectionSource
     */
    sourceProps: object;
}

/**
    * @export
    * @enum {string}
    */
export enum ConnectionSourceSourceNameEnum {
    TWILIO = 'TWILIO',
    PLIVO = 'PLIVO',
    BROWSER = 'BROWSER'
}

/**
 * Expected output of the post conversation task
 * @export
 * @interface ConversationAnalyticsModel
 */
export interface ConversationAnalyticsModel {
    /**
     * Summary of the conversation happened with important details on the conversation. The summary should be concise and to the point. It should contain the important details of the conversation like name, phone number, email, address and any other details shared by the user.
     * @type {string}
     * @memberof ConversationAnalyticsModel
     */
    summary: string;
    /**
     * List of action items and the next steps to be performed from the conversation details.
     * @type {Array<string>}
     * @memberof ConversationAnalyticsModel
     */
    action_items: Array<string> | null;
    /**
     * If the user has given consent to store the audio of the conversation. Unless the user explicitly says yes, this should be false.
     * @type {boolean}
     * @memberof ConversationAnalyticsModel
     */
    is_audio_consent_given: boolean;
    /**
     * Extracted email address of the caller from the conversation details. Email should be a valid email address format
     * @type {string}
     * @memberof ConversationAnalyticsModel
     */
    email_address_of_caller: string | null;
    /**
     * Extracted name of the caller from the conversation details.
     * @type {string}
     * @memberof ConversationAnalyticsModel
     */
    name_of_caller: string | null;
    /**
     * Extracted phone number of the caller from the conversation details.
     * @type {string}
     * @memberof ConversationAnalyticsModel
     */
    phone_number_of_caller: string | null;
    /**
     * Extracted address of the caller from the conversation details.
     * @type {string}
     * @memberof ConversationAnalyticsModel
     */
    address_of_caller: string | null;
    /**
     * Sentiment of the caller based on the conversation details.
     * @type {CallSentiment}
     * @memberof ConversationAnalyticsModel
     */
    sentiment_of_caller: CallSentiment;
    /**
     * Status of the prospect after this conversation.
     * @type {ProspectStatus}
     * @memberof ConversationAnalyticsModel
     */
    prospectStatus: ProspectStatus | null;
}
/**
 * 
 * @export
 * @interface ConversationEndEvent
 */
export interface ConversationEndEvent {
    /**
     * 
     * @type {string}
     * @memberof ConversationEndEvent
     */
    timestamp: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationEndEvent
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationEndEvent
     */
    event_name: string;
    /**
     * 
     * @type {ConversationEndEventPayload}
     * @memberof ConversationEndEvent
     */
    payload?: ConversationEndEventPayload;
}
/**
 * 
 * @export
 * @interface ConversationEndEventPayload
 */
export interface ConversationEndEventPayload {
    /**
     * 
     * @type {ConversationOutput}
     * @memberof ConversationEndEventPayload
     */
    conversation: ConversationOutput;
}
/**
 * Model which stores the evaluation metrics for the conversation
 * @export
 * @interface ConversationEvaluation
 */
export interface ConversationEvaluation {
    /**
     * 
     * @type {Array<ConversationEvaluationData>}
     * @memberof ConversationEvaluation
     */
    aiEvaluations?: Array<ConversationEvaluationData>;
    /**
     * 
     * @type {string}
     * @memberof ConversationEvaluation
     */
    aiEvaluationSummary?: string | null;
    /**
     * 
     * @type {Array<ConversationEvaluationData>}
     * @memberof ConversationEvaluation
     */
    humanEvaluations?: Array<ConversationEvaluationData> | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationEvaluation
     */
    humanEvaluationSummary?: string | null;
}
/**
 * Model which stores the result of the evaluation metric for a conversation
 * @export
 * @interface ConversationEvaluationData
 */
export interface ConversationEvaluationData {
    /**
     * Name of the evaluation metric
     * @type {string}
     * @memberof ConversationEvaluationData
     */
    name?: string;
    /**
     * Description about the evaluation metric
     * @type {string}
     * @memberof ConversationEvaluationData
     */
    description?: string;
    /**
     * Value of the evaluation metric
     * @type {string}
     * @memberof ConversationEvaluationData
     */
    value?: string;
}
/**
 * Model which stores the details of each evaluation metric
 * @export
 * @interface ConversationEvaluationMetric
 */
export interface ConversationEvaluationMetric {
    /**
     * Name of the evaluation metric
     * @type {string}
     * @memberof ConversationEvaluationMetric
     */
    name?: string;
    /**
     * Description about the evaluation metric
     * @type {string}
     * @memberof ConversationEvaluationMetric
     */
    description?: string;
}
/**
 * Model which stores all the evaluation metrics which is used to evaluate the conversation
 * @export
 * @interface ConversationEvaluationMetrics
 */
export interface ConversationEvaluationMetrics {
    /**
     * 
     * @type {Array<ConversationEvaluationMetric>}
     * @memberof ConversationEvaluationMetrics
     */
    qualitativeMetrics: Array<ConversationEvaluationMetric> | null;
    /**
     * 
     * @type {Array<ConversationEvaluationMetric>}
     * @memberof ConversationEvaluationMetrics
     */
    quantitativeMetrics: Array<ConversationEvaluationMetric> | null;
}
/**
 * Any feedback added to the conversation by business is managed here.
 * @export
 * @interface ConversationFeedback
 */
export interface ConversationFeedback {
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    conversationId?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    feedback?: string;
    /**
     * 
     * @type {number}
     * @memberof ConversationFeedback
     */
    rating?: number;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface ConversationInput
 */
export interface ConversationInput {
    /**
     * Source from where the conversation originated. This can be device id, phone number, etc.
     * @type {string}
     * @memberof ConversationInput
     */
    source: string;
    /**
     * Type of the conversation source
     * @type {ConversationSourceType}
     * @memberof ConversationInput
     */
    sourceType: ConversationSourceType;
    /**
     * AI agent which handled the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    agentId: string;
    /**
     * URL to the full transcript of the conversation
     * @type {Array<DialogLine>}
     * @memberof ConversationInput
     */
    transcriptText?: Array<DialogLine> | null;
    /**
     * Summary of the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    transcriptSummary?: string | null;
    /**
     * URL to the recording of the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    transcriptRecordingUrl?: string | null;
    /**
     * Start time of the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    timestampStart: string;
    /**
     * End time of the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    timestampEnd?: string | null;
    /**
     * Analytics of the conversation
     * @type {ConversationAnalyticsModel}
     * @memberof ConversationInput
     */
    conversationAnalytics?: ConversationAnalyticsModel | null;
    /**
     * Comments from the admin on the conversation
     * @type {Array<Comment>}
     * @memberof ConversationInput
     */
    adminComments?: Array<Comment> | null;
    /**
     * Stats of the conversation
     * @type {ConversationStatsModel}
     * @memberof ConversationInput
     */
    conversationStats?: ConversationStatsModel | null;
}
/**
 * Any conversation happening between the end user and assistant is stored in this table
 * @export
 * @interface ConversationOutput
 */
export interface ConversationOutput {
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    prospectId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    source?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    sourceType?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    aiAgentId?: string;
    /**
     * 
     * @type {Array<DialogLine>}
     * @memberof ConversationOutput
     */
    transcriptText?: Array<DialogLine> | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    transcriptSummary?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    transcriptRecordingUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    timestampStart?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    timestampEnd?: string | null;
    /**
     * Analytics of the conversation
     * @type {ConversationAnalyticsModel}
     * @memberof ConversationOutput
     */
    conversationAnalytics?: ConversationAnalyticsModel | null;
    /**
     * Stats of the conversation
     * @type {ConversationStatsModel}
     * @memberof ConversationOutput
     */
    conversationStats?: ConversationStatsModel | null;
    /**
     * Application under which the conversation is created
     * @type {AppEnum}
     * @memberof ConversationOutput
     */
    app?: AppEnum | null;
    /**
     * Evaluation of the conversation
     * @type {ConversationEvaluation}
     * @memberof ConversationOutput
     */
    evaluation?: ConversationEvaluation | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ConversationSourceType {
    BROWSER = 'BROWSER',
    TWILIO = 'TWILIO',
    PLIVO = 'PLIVO'
}

/**
 * 
 * @export
 * @interface ConversationStartEvent
 */
export interface ConversationStartEvent {
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEvent
     */
    timestamp: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEvent
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEvent
     */
    event_name: string;
    /**
     * 
     * @type {ConversationStartEventPayload}
     * @memberof ConversationStartEvent
     */
    payload?: ConversationStartEventPayload;
}
/**
 * 
 * @export
 * @interface ConversationStartEventPayload
 */
export interface ConversationStartEventPayload {
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEventPayload
     */
    type: ConversationStartEventPayloadTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEventPayload
     */
    connection_id: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEventPayload
     */
    conversation_id: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEventPayload
     */
    ai_agent_id: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEventPayload
     */
    org_id: string;
    /**
     * 
     * @type {object}
     * @memberof ConversationStartEventPayload
     */
    caller_id: object | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ConversationStartEventPayloadTypeEnum {
    ConversationStart = 'conversation_start'
}

/**
 * 
 * @export
 * @interface ConversationStatsModel
 */
export interface ConversationStatsModel {
    /**
     * Total number of dialogs in the conversation
     * @type {number}
     * @memberof ConversationStatsModel
     */
    total_dialog: number;
    /**
     * Ratio of Agent dialogs to total dialogs
     * @type {number}
     * @memberof ConversationStatsModel
     */
    agent_dialog_ratio: number;
    /**
     * Ratio of User dialogs to total dialogs
     * @type {number}
     * @memberof ConversationStatsModel
     */
    user_dialog_ratio: number;
}
/**
 * 
 * @export
 * @interface CountryInfo
 */
export interface CountryInfo {
    /**
     * 
     * @type {string}
     * @memberof CountryInfo
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof CountryInfo
     */
    name: string;
}
/**
 * Credits details of the business
 * @export
 * @interface Credit
 */
export interface Credit {
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    creditTypeName?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    totalAvailable?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    consumed?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    durationStart?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    durationEnd?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DecisionMakingStyle {
    Logical = 'logical',
    Emotional = 'emotional',
    Impulsive = 'impulsive',
    Hesitant = 'hesitant'
}

/**
 * 
 * @export
 * @interface DialogLine
 */
export interface DialogLine {
    /**
     * 
     * @type {string}
     * @memberof DialogLine
     */
    speaker: string;
    /**
     * 
     * @type {string}
     * @memberof DialogLine
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof DialogLine
     */
    timestamp: string;
    /**
     * 
     * @type {string}
     * @memberof DialogLine
     */
    message_id: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum EngagementLevel {
    HighlyEngaged = 'highly engaged',
    Distracted = 'distracted',
    Uninterested = 'uninterested'
}

/**
 * 
 * @export
 * @interface ExternalReference
 */
export interface ExternalReference {
    /**
     * External service provider name
     * @type {string}
     * @memberof ExternalReference
     */
    providerName: string;
    /**
     * External service identifier
     * @type {string}
     * @memberof ExternalReference
     */
    id: string;
    /**
     * Props for the external reference
     * @type {object}
     * @memberof ExternalReference
     */
    providerProps?: object | null;
}
/**
 * 
 * @export
 * @interface ExternalServicePorviderInput
 */
export interface ExternalServicePorviderInput {
    /**
     * External service provider name
     * @type {string}
     * @memberof ExternalServicePorviderInput
     */
    providerName: string;
    /**
     * External service identifier
     * @type {string}
     * @memberof ExternalServicePorviderInput
     */
    id: string;
    /**
     * Props for the external service provider
     * @type {object}
     * @memberof ExternalServicePorviderInput
     */
    providerProps: object | null;
}
/**
 * 
 * @export
 * @interface ExternalServicePorviderOutput
 */
export interface ExternalServicePorviderOutput {
    /**
     * 
     * @type {string}
     * @memberof ExternalServicePorviderOutput
     */
    providerName: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalServicePorviderOutput
     */
    id: string;
    /**
     * 
     * @type {object}
     * @memberof ExternalServicePorviderOutput
     */
    providerProps: object | null;
}
/**
 * Stores the map of file id with respective file URL in storage manager
 * @export
 * @interface Files
 */
export interface Files {
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    fileName?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    fileUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum FrustrationTolerance {
    QuickToAnger = 'quick to anger',
    Understanding = 'understanding',
    Neutral = 'neutral'
}

/**
 * Guest users who are not verified by Trata yet
 * @export
 * @interface GuestInput
 */
export interface GuestInput {
    /**
     * 
     * @type {string}
     * @memberof GuestInput
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof GuestInput
     */
    role: string;
}
/**
 * Guest users who are not verified by Trata yet. They will not be able to use Trata until they are verified.
 * @export
 * @interface GuestOutput
 */
export interface GuestOutput {
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    role?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GuestOutput
     */
    isEmailVerified?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    last_sent_date?: string;
    /**
     * 
     * @type {number}
     * @memberof GuestOutput
     */
    sent_count?: number;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * Reference to all business knowledge base will be stored in Hive
 * @export
 * @interface Hive
 */
export interface Hive {
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    orgId?: string;
    /**
     * 
     * @type {HiveContentOutput}
     * @memberof Hive
     */
    content: HiveContentOutput;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface HiveContentInput
 */
export interface HiveContentInput {
    /**
     * 
     * @type {HiveType}
     * @memberof HiveContentInput
     */
    hiveType: HiveType;
    /**
     * URL of the content
     * @type {string}
     * @memberof HiveContentInput
     */
    url?: string | null;
    /**
     * List of file ids to be referenced for the hive
     * @type {Array<string>}
     * @memberof HiveContentInput
     */
    file_ids?: Array<string> | null;
    /**
     * To recursively crawl child pages, add this as props {\"crawl_child_pages\": true},  \"depth\": \"3\"
     * @type {object}
     * @memberof HiveContentInput
     */
    hiveProps?: object | null;
}
/**
 * 
 * @export
 * @interface HiveContentOutput
 */
export interface HiveContentOutput {
    /**
     * 
     * @type {HiveType}
     * @memberof HiveContentOutput
     */
    hiveType: HiveType;
    /**
     * URL of the content
     * @type {string}
     * @memberof HiveContentOutput
     */
    url?: string | null;
    /**
     * List of files to be referenced for the hive
     * @type {Array<Files>}
     * @memberof HiveContentOutput
     */
    files?: Array<Files> | null;
    /**
     * To recursively crawl child pages, add this as props {\"crawl_child_pages\": true},  \"depth\": \"3\"
     * @type {object}
     * @memberof HiveContentOutput
     */
    hiveProps?: object | null;
    /**
     * To add any internal props, add this as props {\"last_crawl_time\": \"123123123123\"}
     * @type {object}
     * @memberof HiveContentOutput
     */
    internalProps?: object | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum HiveType {
    WEBSITE = 'WEBSITE',
    GOOGLEDOCS = 'GOOGLE_DOCS',
    DOCS = 'DOCS',
    TRANSCRIPTS = 'TRANSCRIPTS'
}

/**
 * 
 * @export
 * @interface HttpActionEndpoint
 */
export interface HttpActionEndpoint {
    /**
     * Action endpoint URL
     * @type {string}
     * @memberof HttpActionEndpoint
     */
    url: string;
    /**
     * Method to be used for invoking the endpoint
     * @type {string}
     * @memberof HttpActionEndpoint
     */
    method?: HttpActionEndpointMethodEnum;
    /**
     * Headers for the endpoint
     * @type {object}
     * @memberof HttpActionEndpoint
     */
    headers?: object | null;
    /**
     * Payload for the endpoint
     * @type {object}
     * @memberof HttpActionEndpoint
     */
    payload?: object | null;
}

/**
    * @export
    * @enum {string}
    */
export enum HttpActionEndpointMethodEnum {
    GET = 'GET',
    POST = 'POST'
}

/**
 * 
 * @export
 * @interface IntelligenceProvider
 */
export interface IntelligenceProvider {
    /**
     * 
     * @type {string}
     * @memberof IntelligenceProvider
     */
    providerName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IntelligenceProvider
     */
    model?: string | null;
    /**
     * 
     * @type {object}
     * @memberof IntelligenceProvider
     */
    providerProps?: object | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum InteractionTone {
    Professional = 'professional',
    Casual = 'casual',
    Friendly = 'friendly',
    Authoritative = 'authoritative'
}

/**
 * Internal action endpoint to be used for calling the action inside the module. Not used by external users
 * @export
 * @interface InternalActionEndpoint
 */
export interface InternalActionEndpoint {
    /**
     * Module where the action is defined
     * @type {string}
     * @memberof InternalActionEndpoint
     */
    module: string;
    /**
     * Function to be called inside the module
     * @type {string}
     * @memberof InternalActionEndpoint
     */
    _function: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Language {
    English = 'English',
    Spanish = 'Spanish',
    Hindi = 'Hindi'
}

/**
 * 
 * @export
 * @interface LanguageAccentCombo
 */
export interface LanguageAccentCombo {
    /**
     * 
     * @type {Language}
     * @memberof LanguageAccentCombo
     */
    language: Language;
    /**
     * 
     * @type {Accent}
     * @memberof LanguageAccentCombo
     */
    accent: Accent;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MetricName {
    CALLS = 'CALLS',
    CALLDURATION = 'CALL_DURATION',
    SPARRCALLS = 'SPARR_CALLS',
    SPARRCALLDURATION = 'SPARR_CALL_DURATION',
    APPOINTMENTSCHEDULED = 'APPOINTMENT_SCHEDULED',
    PROSPECTS = 'PROSPECTS',
    INTERESTED = 'INTERESTED',
    NOTINTERESTED = 'NOT_INTERESTED'
}

/**
 * 
 * @export
 * @interface MetricResponseDataPoint
 */
export interface MetricResponseDataPoint {
    /**
     * Timestamp of the data point
     * @type {string}
     * @memberof MetricResponseDataPoint
     */
    timestamp: string;
    /**
     * Value which will be a string representation of integer or floating number
     * @type {string}
     * @memberof MetricResponseDataPoint
     */
    value: string;
}
/**
 * 
 * @export
 * @interface MetricsRequest
 */
export interface MetricsRequest {
    /**
     * Unique identifier for the metric request. This can be helped to co-relate the request and response
     * @type {string}
     * @memberof MetricsRequest
     */
    id: string;
    /**
     * Name of the metric
     * @type {MetricName}
     * @memberof MetricsRequest
     */
    name: MetricName;
    /**
     * Start date to get metric request
     * @type {string}
     * @memberof MetricsRequest
     */
    fromDate: string;
    /**
     * End date until get metric request
     * @type {string}
     * @memberof MetricsRequest
     */
    toDate: string;
    /**
     * Aggregation period for the metric request
     * @type {AggregationPeriod}
     * @memberof MetricsRequest
     */
    aggregationPeriod: AggregationPeriod;
    /**
     * Aggregation formula for the metric request
     * @type {AggregationFormula}
     * @memberof MetricsRequest
     */
    aggregationFormula: AggregationFormula;
}
/**
 * 
 * @export
 * @interface MetricsResponse
 */
export interface MetricsResponse {
    /**
     * Unique identifier for the metric response. This will help co-relate the request and response
     * @type {string}
     * @memberof MetricsResponse
     */
    id: string;
    /**
     * Name of the metric
     * @type {MetricName}
     * @memberof MetricsResponse
     */
    name: MetricName;
    /**
     * List of data points for the metric response
     * @type {Array<MetricResponseDataPoint>}
     * @memberof MetricsResponse
     */
    datapoints: Array<MetricResponseDataPoint>;
}
/**
 * 
 * @export
 * @interface Mission
 */
export interface Mission {
    /**
     * Full prompt instructions for LLM model
     * @type {string}
     * @memberof Mission
     */
    prompt?: string | null;
    /**
     * Objective of the mission
     * @type {string}
     * @memberof Mission
     */
    objective?: string | null;
    /**
     * Greeting message to be read by the AI agent
     * @type {string}
     * @memberof Mission
     */
    greeting: string | null;
    /**
     * Sequence of actions to be performed by the AI agent during the conversation.
     * @type {Array<Sequence>}
     * @memberof Mission
     */
    sequence?: Array<Sequence> | null;
    /**
     * Conclusion message to be read by the AI agent
     * @type {string}
     * @memberof Mission
     */
    farewell?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum NegotiationStyle {
    HardBargainer = 'hard bargainer',
    FriendlyNegotiator = 'friendly negotiator',
    NonNegotiator = 'non-negotiator'
}

/**
 * Defines how to determine the next step
 * @export
 * @interface NextStepResolver
 */
export interface NextStepResolver {
    /**
     * Array of conditions to evaluate
     * @type {Array<Condition>}
     * @memberof NextStepResolver
     */
    conditions?: Array<Condition> | null;
    /**
     * Direct next step ID
     * @type {string}
     * @memberof NextStepResolver
     */
    nextStepId?: string | null;
}
/**
 * No authentication configuration
 * @export
 * @interface NoAuth
 */
export interface NoAuth {
    /**
     * The type of authentication
     * @type {string}
     * @memberof NoAuth
     */
    authType?: NoAuthAuthTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum NoAuthAuthTypeEnum {
    Noauth = 'noauth'
}

/**
 * 
 * @export
 * @interface NoAuthCredentials
 */
export interface NoAuthCredentials {
    /**
     * Credential type identifier
     * @type {string}
     * @memberof NoAuthCredentials
     */
    credentialsType?: NoAuthCredentialsCredentialsTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum NoAuthCredentialsCredentialsTypeEnum {
    Noauth = 'noauth'
}

/**
 * 
 * @export
 * @interface NumberPurchaseRequest
 */
export interface NumberPurchaseRequest {
    /**
     * 
     * @type {string}
     * @memberof NumberPurchaseRequest
     */
    countryCode: string;
    /**
     * 
     * @type {string}
     * @memberof NumberPurchaseRequest
     */
    phoneNumber: string;
}
/**
 * OAuth authentication configuration
 * @export
 * @interface OAuth
 */
export interface OAuth {
    /**
     * The type of authentication
     * @type {string}
     * @memberof OAuth
     */
    authType?: OAuthAuthTypeEnum;
    /**
     * The client ID for the OAuth app
     * @type {string}
     * @memberof OAuth
     */
    clientId: string;
    /**
     * The client secret for the OAuth app
     * @type {string}
     * @memberof OAuth
     */
    clientSecret: string;
    /**
     * The redirect URI for the OAuth app
     * @type {string}
     * @memberof OAuth
     */
    redirectUri: string;
    /**
     * The scopes for the OAuth app
     * @type {Array<string>}
     * @memberof OAuth
     */
    scopes?: Array<string> | null;
    /**
     * The authorization URL for the OAuth app
     * @type {string}
     * @memberof OAuth
     */
    authUrl: string;
    /**
     * The token URL for the OAuth app
     * @type {string}
     * @memberof OAuth
     */
    tokenUrl: string;
}

/**
    * @export
    * @enum {string}
    */
export enum OAuthAuthTypeEnum {
    Oauth = 'oauth'
}

/**
 * 
 * @export
 * @interface OAuthCredentials
 */
export interface OAuthCredentials {
    /**
     * Credential type identifier
     * @type {string}
     * @memberof OAuthCredentials
     */
    credentialsType?: OAuthCredentialsCredentialsTypeEnum;
    /**
     * The code for the OAuth app
     * @type {string}
     * @memberof OAuthCredentials
     */
    code?: string | null;
    /**
     * The access token for the OAuth app
     * @type {string}
     * @memberof OAuthCredentials
     */
    accessToken?: string | null;
    /**
     * The refresh token for the OAuth app
     * @type {string}
     * @memberof OAuthCredentials
     */
    refreshToken?: string | null;
    /**
     * The expiration date of the access token
     * @type {string}
     * @memberof OAuthCredentials
     */
    expiresAt?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum OAuthCredentialsCredentialsTypeEnum {
    Oauth = 'oauth'
}

/**
 * Organization represents the business using Trata and all users are associated to this business entity
 * @export
 * @interface OrganizationInput
 */
export interface OrganizationInput {
    /**
     * Name of the organization
     * @type {string}
     * @memberof OrganizationInput
     */
    name: string;
    /**
     * Address of the organization
     * @type {AddressInput}
     * @memberof OrganizationInput
     */
    address?: AddressInput | null;
    /**
     * Tax details of the organization
     * @type {TaxDetailsInput}
     * @memberof OrganizationInput
     */
    tax?: TaxDetailsInput | null;
    /**
     * External references for the organization
     * @type {Array<ExternalServicePorviderInput>}
     * @memberof OrganizationInput
     */
    externalReferenceIds?: Array<ExternalServicePorviderInput> | null;
    /**
     * Configurations for all the agents going to be created in this org
     * @type {AgentConfig}
     * @memberof OrganizationInput
     */
    agentConfig?: AgentConfig | null;
}
/**
 * Organization represents the business using Trata and all users are associated to this business entity
 * @export
 * @interface OrganizationOutput
 */
export interface OrganizationOutput {
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    name?: string;
    /**
     * 
     * @type {AgentConfig}
     * @memberof OrganizationOutput
     */
    config: AgentConfig;
    /**
     * 
     * @type {AddressOutput}
     * @memberof OrganizationOutput
     */
    address: AddressOutput | null;
    /**
     * 
     * @type {TaxDetailsOutput}
     * @memberof OrganizationOutput
     */
    tax: TaxDetailsOutput | null;
    /**
     * 
     * @type {Array<ExternalServicePorviderOutput>}
     * @memberof OrganizationOutput
     */
    externalReferenceIds: Array<ExternalServicePorviderOutput> | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    updatedAt?: string;
    /**
     * 
     * @type {object}
     * @memberof OrganizationOutput
     */
    internalProps: object | null;
    /**
     * If the Organization is created by reseller, this field will have the reseller org id as the parent organization id
     * @type {string}
     * @memberof OrganizationOutput
     */
    parentOrgId?: string;
    /**
     * Type of the organization. Currently only CONSUMER & RESELLER are supported
     * @type {string}
     * @memberof OrganizationOutput
     */
    orgType?: string | null;
}
/**
 * 
 * @export
 * @interface OrganizationSettings
 */
export interface OrganizationSettings {
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    orgId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    domain?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    stripeKey?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    brandColor?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    buttonColor?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    secondaryColor?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    favicon?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    faviconUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    logo?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    logoUrl?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PatienceLevel {
    Impatient = 'impatient',
    Neutral = 'neutral',
    VeryPatient = 'very patient'
}

/**
 * 
 * @export
 * @interface PersonaAttributesAndTraits
 */
export interface PersonaAttributesAndTraits {
    /**
     * 
     * @type {PatienceLevel | string}
     * @memberof PersonaAttributesAndTraits
     */
    patience_level?: PatienceLevel | string | null;
    /**
     * 
     * @type {DecisionMakingStyle | string}
     * @memberof PersonaAttributesAndTraits
     */
    decision_making_style?: DecisionMakingStyle | string | null;
    /**
     * 
     * @type {CommunicationStyle | string}
     * @memberof PersonaAttributesAndTraits
     */
    communication_style?: CommunicationStyle | string | null;
    /**
     * 
     * @type {Adaptability | string}
     * @memberof PersonaAttributesAndTraits
     */
    adaptability?: Adaptability | string | null;
    /**
     * 
     * @type {FrustrationTolerance | string}
     * @memberof PersonaAttributesAndTraits
     */
    frustration_tolerance?: FrustrationTolerance | string | null;
    /**
     * 
     * @type {EngagementLevel | string}
     * @memberof PersonaAttributesAndTraits
     */
    engagement_level?: EngagementLevel | string | null;
    /**
     * 
     * @type {InteractionTone | string}
     * @memberof PersonaAttributesAndTraits
     */
    preferred_tone?: InteractionTone | string | null;
    /**
     * 
     * @type {NegotiationStyle | string}
     * @memberof PersonaAttributesAndTraits
     */
    negotiation_style?: NegotiationStyle | string | null;
}
/**
 * Price details of the business
 * @export
 * @interface Price
 */
export interface Price {
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    parentOrgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    planName?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    priceName?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof Price
     */
    price?: number;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    currency?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    interval?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    stripePriceId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    stripeProductId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    priceType?: string;
}
/**
 * 
 * @export
 * @interface ProductInput
 */
export interface ProductInput {
    /**
     * Product is active or not
     * @type {boolean}
     * @memberof ProductInput
     */
    active: boolean;
    /**
     * Default price of the product this is represented in the lowest currency denomination. Eg: 1000 for $10
     * @type {number}
     * @memberof ProductInput
     */
    defaultPrice: number;
    /**
     * Currency of the product
     * @type {string}
     * @memberof ProductInput
     */
    currency: ProductInputCurrencyEnum;
    /**
     * Description of the product
     * @type {string}
     * @memberof ProductInput
     */
    description: string;
    /**
     * Name of the product
     * @type {string}
     * @memberof ProductInput
     */
    name: string;
    /**
     * Product is shippable or not. Service is not shippable
     * @type {boolean}
     * @memberof ProductInput
     */
    shippable?: boolean;
    /**
     * List of features of the product
     * @type {Array<string>}
     * @memberof ProductInput
     */
    features?: Array<string> | null;
    /**
     * Product requires appointment scheduling or not
     * @type {boolean}
     * @memberof ProductInput
     */
    scheduleAppointment?: boolean;
    /**
     * Properties of the product
     * @type {object}
     * @memberof ProductInput
     */
    props?: object | null;
    /**
     * Tags for the product. This is used for grouping purpose. Eg: [\"gardening\", \"tools\"]
     * @type {Array<string>}
     * @memberof ProductInput
     */
    tags?: Array<string> | null;
    /**
     * 
     * @type {Status}
     * @memberof ProductInput
     */
    status: Status;
    /**
     * List of agent ids which are accessible for this product
     * @type {Array<string>}
     * @memberof ProductInput
     */
    agentIds?: Array<string> | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ProductInputCurrencyEnum {
    AED = 'AED',
    AFN = 'AFN',
    ALL = 'ALL',
    AMD = 'AMD',
    ANG = 'ANG',
    AOA = 'AOA',
    ARS = 'ARS',
    AUD = 'AUD',
    AWG = 'AWG',
    AZN = 'AZN',
    BAM = 'BAM',
    BBD = 'BBD',
    BDT = 'BDT',
    BGN = 'BGN',
    BHD = 'BHD',
    BIF = 'BIF',
    BMD = 'BMD',
    BND = 'BND',
    BOB = 'BOB',
    BOV = 'BOV',
    BRL = 'BRL',
    BSD = 'BSD',
    BTN = 'BTN',
    BWP = 'BWP',
    BYN = 'BYN',
    BZD = 'BZD',
    CAD = 'CAD',
    CDF = 'CDF',
    CHE = 'CHE',
    CHF = 'CHF',
    CHW = 'CHW',
    CLF = 'CLF',
    CLP = 'CLP',
    CNY = 'CNY',
    COP = 'COP',
    COU = 'COU',
    CRC = 'CRC',
    CUC = 'CUC',
    CUP = 'CUP',
    CVE = 'CVE',
    CZK = 'CZK',
    DJF = 'DJF',
    DKK = 'DKK',
    DOP = 'DOP',
    DZD = 'DZD',
    EGP = 'EGP',
    ERN = 'ERN',
    ETB = 'ETB',
    EUR = 'EUR',
    FJD = 'FJD',
    FKP = 'FKP',
    GBP = 'GBP',
    GEL = 'GEL',
    GHS = 'GHS',
    GIP = 'GIP',
    GMD = 'GMD',
    GNF = 'GNF',
    GTQ = 'GTQ',
    GYD = 'GYD',
    HKD = 'HKD',
    HNL = 'HNL',
    HRK = 'HRK',
    HTG = 'HTG',
    HUF = 'HUF',
    IDR = 'IDR',
    ILS = 'ILS',
    INR = 'INR',
    IQD = 'IQD',
    IRR = 'IRR',
    ISK = 'ISK',
    JMD = 'JMD',
    JOD = 'JOD',
    JPY = 'JPY',
    KES = 'KES',
    KGS = 'KGS',
    KHR = 'KHR',
    KMF = 'KMF',
    KPW = 'KPW',
    KRW = 'KRW',
    KWD = 'KWD',
    KYD = 'KYD',
    KZT = 'KZT',
    LAK = 'LAK',
    LBP = 'LBP',
    LKR = 'LKR',
    LRD = 'LRD',
    LSL = 'LSL',
    LYD = 'LYD',
    MAD = 'MAD',
    MDL = 'MDL',
    MGA = 'MGA',
    MKD = 'MKD',
    MMK = 'MMK',
    MNT = 'MNT',
    MOP = 'MOP',
    MRU = 'MRU',
    MUR = 'MUR',
    MVR = 'MVR',
    MWK = 'MWK',
    MXN = 'MXN',
    MXV = 'MXV',
    MYR = 'MYR',
    MZN = 'MZN',
    NAD = 'NAD',
    NGN = 'NGN',
    NIO = 'NIO',
    NOK = 'NOK',
    NPR = 'NPR',
    NZD = 'NZD',
    OMR = 'OMR',
    PAB = 'PAB',
    PEN = 'PEN',
    PGK = 'PGK',
    PHP = 'PHP',
    PKR = 'PKR',
    PLN = 'PLN',
    PYG = 'PYG',
    QAR = 'QAR',
    RON = 'RON',
    RSD = 'RSD',
    RUB = 'RUB',
    RWF = 'RWF',
    SAR = 'SAR',
    SBD = 'SBD',
    SCR = 'SCR',
    SDG = 'SDG',
    SEK = 'SEK',
    SGD = 'SGD',
    SHP = 'SHP',
    SLE = 'SLE',
    SLL = 'SLL',
    SOS = 'SOS',
    SRD = 'SRD',
    SSP = 'SSP',
    STN = 'STN',
    SVC = 'SVC',
    SYP = 'SYP',
    SZL = 'SZL',
    THB = 'THB',
    TJS = 'TJS',
    TMT = 'TMT',
    TND = 'TND',
    TOP = 'TOP',
    TRY = 'TRY',
    TTD = 'TTD',
    TWD = 'TWD',
    TZS = 'TZS',
    UAH = 'UAH',
    UGX = 'UGX',
    USD = 'USD',
    USN = 'USN',
    UYI = 'UYI',
    UYU = 'UYU',
    UYW = 'UYW',
    UZS = 'UZS',
    VED = 'VED',
    VES = 'VES',
    VND = 'VND',
    VUV = 'VUV',
    WST = 'WST',
    XAF = 'XAF',
    XCD = 'XCD',
    XOF = 'XOF',
    XPF = 'XPF',
    XSU = 'XSU',
    XUA = 'XUA',
    YER = 'YER',
    ZAR = 'ZAR',
    ZMW = 'ZMW',
    ZWL = 'ZWL'
}

/**
 * Product and services offered by the business
 * @export
 * @interface ProductOutput
 */
export interface ProductOutput {
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    orgId?: string;
    /**
     * Product is active or not
     * @type {boolean}
     * @memberof ProductOutput
     */
    active?: boolean;
    /**
     * Default price of the product this is represented in the lowest currency denomination. Eg: 1000 for $10
     * @type {number}
     * @memberof ProductOutput
     */
    defaultPrice?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    currency?: string | null;
    /**
     * Description of the product
     * @type {string}
     * @memberof ProductOutput
     */
    description?: string | null;
    /**
     * Name of the product
     * @type {string}
     * @memberof ProductOutput
     */
    name?: string;
    /**
     * Product is shippable or not. Service is not shippable
     * @type {boolean}
     * @memberof ProductOutput
     */
    shippable?: boolean;
    /**
     * List of features of the product
     * @type {Array<string>}
     * @memberof ProductOutput
     */
    features?: Array<string> | null;
    /**
     * Product requires appointment scheduling or not
     * @type {boolean}
     * @memberof ProductOutput
     */
    scheduleAppointment?: boolean;
    /**
     * Properties of the product
     * @type {object}
     * @memberof ProductOutput
     */
    props?: object | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductOutput
     */
    tags?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface ProductWithAgents
 */
export interface ProductWithAgents {
    /**
     * 
     * @type {ProductOutput}
     * @memberof ProductWithAgents
     */
    product: ProductOutput;
    /**
     * 
     * @type {Array<AIAgentOutput>}
     * @memberof ProductWithAgents
     */
    agents?: Array<AIAgentOutput>;
}
/**
 * 
 * @export
 * @interface PromptTemplate
 */
export interface PromptTemplate {
    /**
     * 
     * @type {string}
     * @memberof PromptTemplate
     */
    prompt: string;
    /**
     * 
     * @type {Array<Sequence>}
     * @memberof PromptTemplate
     */
    sequences: Array<Sequence>;
    /**
     * 
     * @type {string}
     * @memberof PromptTemplate
     */
    role: string;
    /**
     * 
     * @type {string}
     * @memberof PromptTemplate
     */
    roleDescription: string;
    /**
     * 
     * @type {string}
     * @memberof PromptTemplate
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ProspectInput
 */
export interface ProspectInput {
    /**
     * Name of the prospect
     * @type {string}
     * @memberof ProspectInput
     */
    name?: string | null;
    /**
     * Email of the prospect
     * @type {string}
     * @memberof ProspectInput
     */
    email?: string | null;
    /**
     * Phone number of the prospect
     * @type {string}
     * @memberof ProspectInput
     */
    phoneNumber?: string | null;
    /**
     * External references for the prospect
     * @type {Array<ExternalReference>}
     * @memberof ProspectInput
     */
    externalReference?: Array<ExternalReference> | null;
    /**
     * 
     * @type {ProspectStatus}
     * @memberof ProspectInput
     */
    status: ProspectStatus;
    /**
     * Props for the prospect
     * @type {object}
     * @memberof ProspectInput
     */
    prospectProps?: object | null;
}
/**
 * Prospects are the potential customers for business
 * @export
 * @interface ProspectOutput
 */
export interface ProspectOutput {
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    email?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    phoneNumber?: string | null;
    /**
     * 
     * @type {Array<ExternalReference>}
     * @memberof ProspectOutput
     */
    externalReference: Array<ExternalReference> | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    status: string;
    /**
     * 
     * @type {object}
     * @memberof ProspectOutput
     */
    prospectProps: object | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ProspectStatus {
    NEW = 'NEW',
    GENERALENQUIRY = 'GENERAL_ENQUIRY',
    SCHEDULEDCALLBACKWITHBOT = 'SCHEDULED_CALLBACK_WITH_BOT',
    SCHEDULEDAPPOINTMENTWITHPERSON = 'SCHEDULED_APPOINTMENT_WITH_PERSON',
    SCHEDULEDAPPOINTMENTFORSERVICE = 'SCHEDULED_APPOINTMENT_FOR_SERVICE',
    NOTINTERESTED = 'NOT_INTERESTED',
    PRODUCTORDERPLACED = 'PRODUCT_ORDER_PLACED',
    SERVICEORDERPLACED = 'SERVICE_ORDER_PLACED'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Role {
    ADMIN = 'ADMIN',
    READONLY = 'READ_ONLY',
    RESELLERADMIN = 'RESELLER_ADMIN'
}

/**
 * 
 * @export
 * @interface RoleTemplate
 */
export interface RoleTemplate {
    /**
     * 
     * @type {string}
     * @memberof RoleTemplate
     */
    roleName: string;
    /**
     * 
     * @type {string}
     * @memberof RoleTemplate
     */
    roleDescription: string;
}
/**
 * 
 * @export
 * @interface Sequence
 */
export interface Sequence {
    /**
     * Name of the stage
     * @type {string}
     * @memberof Sequence
     */
    stageName: string;
    /**
     * Description of the stage
     * @type {string}
     * @memberof Sequence
     */
    description: string;
    /**
     * Other notes that AI agent should know in this stage of conversation
     * @type {string}
     * @memberof Sequence
     */
    otherNotes?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SortOrder {
    Asc = 'asc',
    Desc = 'desc'
}

/**
 * 
 * @export
 * @interface SparrStatsData
 */
export interface SparrStatsData {
    /**
     * 
     * @type {number}
     * @memberof SparrStatsData
     */
    no_of_calls: number;
    /**
     * 
     * @type {number}
     * @memberof SparrStatsData
     */
    average_call_duration: number;
    /**
     * 
     * @type {number}
     * @memberof SparrStatsData
     */
    average_dialogs: number;
    /**
     * 
     * @type {number}
     * @memberof SparrStatsData
     */
    average_agent_dialog_ratio: number;
    /**
     * 
     * @type {number}
     * @memberof SparrStatsData
     */
    average_user_dialog_ratio: number;
}
/**
 * 
 * @export
 * @interface SparrStatsResponse
 */
export interface SparrStatsResponse {
    /**
     * Sparring stats of the organization
     * @type {SparrStatsData}
     * @memberof SparrStatsResponse
     */
    response: SparrStatsData;
}
/**
 * 
 * @export
 * @interface StatsData
 */
export interface StatsData {
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    no_of_prospects: number;
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    appointment_scheduled: number;
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    unqualified: number;
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    average_call_duration: number;
}
/**
 * 
 * @export
 * @interface StatsResponse
 */
export interface StatsResponse {
    /**
     * Overall stats of prospects
     * @type {StatsData}
     * @memberof StatsResponse
     */
    response: StatsData;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Status {
    Active = 'active',
    Inactive = 'inactive'
}

/**
 * Subscription details of the business
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    parentOrgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    subscriptionTypeName?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    planName?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    priceId?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    stripeSubscriptionId?: string;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    billingCycleStartDate?: number;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    updatedAt?: string;
}
/**
 * Subscription details of the business
 * @export
 * @interface SubscriptionInfo
 */
export interface SubscriptionInfo {
    /**
     * 
     * @type {Subscription}
     * @memberof SubscriptionInfo
     */
    subscription?: Subscription | null;
    /**
     * 
     * @type {Array<Credit>}
     * @memberof SubscriptionInfo
     */
    credits?: Array<Credit> | null;
}
/**
 * 
 * @export
 * @interface TaxDetailsInput
 */
export interface TaxDetailsInput {
    /**
     * Tax identifier
     * @type {string}
     * @memberof TaxDetailsInput
     */
    id: string;
    /**
     * Any extra info related to Tax
     * @type {object}
     * @memberof TaxDetailsInput
     */
    taxProps: object | null;
}
/**
 * 
 * @export
 * @interface TaxDetailsOutput
 */
export interface TaxDetailsOutput {
    /**
     * 
     * @type {string}
     * @memberof TaxDetailsOutput
     */
    id: string;
    /**
     * 
     * @type {object}
     * @memberof TaxDetailsOutput
     */
    taxProps: object | null;
}
/**
 * Telephone number details of the business
 * @export
 * @interface TelephoneNumber
 */
export interface TelephoneNumber {
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    countryCode?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    agentId?: string | null;
    /**
     * 
     * @type {object}
     * @memberof TelephoneNumber
     */
    internalProps?: object | null;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface Transcriber
 */
export interface Transcriber {
    /**
     * 
     * @type {string}
     * @memberof Transcriber
     */
    providerName?: string;
    /**
     * 
     * @type {string}
     * @memberof Transcriber
     */
    transcriberModel?: string | null;
    /**
     * 
     * @type {object}
     * @memberof Transcriber
     */
    providerProps?: object | null;
}
/**
 * Enum for UI node types
 * @export
 * @enum {string}
 */
export enum UiNodeType {
    ACTION = 'ACTION',
    CONDITION = 'CONDITION',
    LOOP = 'LOOP',
    SUBFLOW = 'SUBFLOW'
}

/**
 * Payload for updating user details API
 * @export
 * @interface UpdateUserPayload
 */
export interface UpdateUserPayload {
    /**
     * 
     * @type {Role}
     * @memberof UpdateUserPayload
     */
    role: Role | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserPayload
     */
    fullName: string | null;
}
/**
 * Model representing the users under an organization
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    fullName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    updatedAt?: string;
}
/**
 * User id to api key mapping table
 * @export
 * @interface UserApiKeyLink
 */
export interface UserApiKeyLink {
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    secretKey?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    keyType?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    expiresAt?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserApiKeyLink
     */
    isActive?: boolean;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string | number>}
     * @memberof ValidationError
     */
    loc: Array<string | number>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}
/**
 * Link table to store the list of ai agents accessible for each virtual prospect
 * @export
 * @interface VirtualProspectAIAgentLink
 */
export interface VirtualProspectAIAgentLink {
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectAIAgentLink
     */
    virtualProspectId?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectAIAgentLink
     */
    aiAgentId?: string;
}
/**
 * 
 * @export
 * @interface VirtualProspectInput
 */
export interface VirtualProspectInput {
    /**
     * Name of the virtual prospect
     * @type {string}
     * @memberof VirtualProspectInput
     */
    name: string;
    /**
     * Description of the virtual prospect
     * @type {string}
     * @memberof VirtualProspectInput
     */
    description?: string | null;
    /**
     * Attributes of the virtual prospect
     * @type {PersonaAttributesAndTraits}
     * @memberof VirtualProspectInput
     */
    personaAttributes: PersonaAttributesAndTraits;
    /**
     * Additional information about the virtual prospect
     * @type {string}
     * @memberof VirtualProspectInput
     */
    additionalInfo?: string | null;
}
/**
 * Virtual prospect details for sparring
 * @export
 * @interface VirtualProspectOutput
 */
export interface VirtualProspectOutput {
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    description?: string | null;
    /**
     * 
     * @type {PersonaAttributesAndTraits}
     * @memberof VirtualProspectOutput
     */
    personaAttributes: PersonaAttributesAndTraits | null;
    /**
     * Additional information about the virtual prospect
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    additionalInfo?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface VoiceInput
 */
export interface VoiceInput {
    /**
     * 
     * @type {string}
     * @memberof VoiceInput
     */
    gender: VoiceInputGenderEnum;
    /**
     * 
     * @type {LanguageAccentCombo}
     * @memberof VoiceInput
     */
    languageAccent: LanguageAccentCombo;
    /**
     * 
     * @type {string}
     * @memberof VoiceInput
     */
    modelId: string;
}

/**
    * @export
    * @enum {string}
    */
export enum VoiceInputGenderEnum {
    Male = 'Male',
    Female = 'Female',
    Neutral = 'Neutral'
}

/**
 * 
 * @export
 * @interface VoiceModel
 */
export interface VoiceModel {
    /**
     * 
     * @type {VoiceOutput}
     * @memberof VoiceModel
     */
    voice: VoiceOutput;
    /**
     * 
     * @type {string}
     * @memberof VoiceModel
     */
    previewUrl: string;
    /**
     * 
     * @type {string}
     * @memberof VoiceModel
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof VoiceModel
     */
    voiceDescription: string;
}
/**
 * 
 * @export
 * @interface VoiceOutput
 */
export interface VoiceOutput {
    /**
     * 
     * @type {string}
     * @memberof VoiceOutput
     */
    gender: VoiceOutputGenderEnum;
    /**
     * 
     * @type {LanguageAccentCombo}
     * @memberof VoiceOutput
     */
    languageAccent: LanguageAccentCombo;
    /**
     * 
     * @type {string}
     * @memberof VoiceOutput
     */
    modelId: string;
}

/**
    * @export
    * @enum {string}
    */
export enum VoiceOutputGenderEnum {
    Male = 'Male',
    Female = 'Female',
    Neutral = 'Neutral'
}

/**
 * Workflow represents a sequence of steps that can be performed by an app
 * @export
 * @interface Workflow
 */
export interface Workflow {
    /**
     * The user who created.
     * @type {string}
     * @memberof Workflow
     */
    createdBy?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof Workflow
     */
    createdAt?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof Workflow
     */
    updatedBy?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof Workflow
     */
    updatedAt?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof Workflow
     */
    orgId?: string;
    /**
     * The name of the workflow
     * @type {string}
     * @memberof Workflow
     */
    name?: string;
    /**
     * The description of the workflow
     * @type {string}
     * @memberof Workflow
     */
    description?: string | null;
    /**
     * The version of the workflow
     * @type {string}
     * @memberof Workflow
     */
    version?: string;
    /**
     * The steps of the workflow
     * @type {{ [key: string]: WorkflowStepOutput; }}
     * @memberof Workflow
     */
    steps: { [key: string]: WorkflowStepOutput; };
    /**
     * The id of the start step
     * @type {string}
     * @memberof Workflow
     */
    startStepId?: string;
    /**
     * The unique identifier of the workflow
     * @type {string}
     * @memberof Workflow
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface WorkflowActivityInfo
 */
export interface WorkflowActivityInfo {
    /**
     * 
     * @type {string}
     * @memberof WorkflowActivityInfo
     */
    step_name: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowActivityInfo
     */
    status: string;
    /**
     * 
     * @type {object}
     * @memberof WorkflowActivityInfo
     */
    input: object;
    /**
     * 
     * @type {object}
     * @memberof WorkflowActivityInfo
     */
    result: object;
    /**
     * 
     * @type {string}
     * @memberof WorkflowActivityInfo
     */
    start_time?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowActivityInfo
     */
    end_time?: string | null;
}
/**
 * Workflow Context Model
 * @export
 * @interface WorkflowContext
 */
export interface WorkflowContext {
    /**
     * The ID of the organization
     * @type {string}
     * @memberof WorkflowContext
     */
    orgId: string;
    /**
     * The ID of the workflow
     * @type {string}
     * @memberof WorkflowContext
     */
    workflowId: string;
    /**
     * The ID of the run
     * @type {string}
     * @memberof WorkflowContext
     */
    runId: string;
    /**
     * The input of the step
     * @type {object}
     * @memberof WorkflowContext
     */
    stepInput: object;
    /**
     * The response of the step
     * @type {object}
     * @memberof WorkflowContext
     */
    stepResponse: object;
}
/**
 * Core Workflow Model
 * @export
 * @interface WorkflowCore
 */
export interface WorkflowCore {
    /**
     * The name of the workflow
     * @type {string}
     * @memberof WorkflowCore
     */
    name?: string;
    /**
     * The description of the workflow
     * @type {string}
     * @memberof WorkflowCore
     */
    description?: string | null;
    /**
     * The version of the workflow
     * @type {string}
     * @memberof WorkflowCore
     */
    version?: string;
    /**
     * The steps of the workflow
     * @type {{ [key: string]: WorkflowStepInput; }}
     * @memberof WorkflowCore
     */
    steps: { [key: string]: WorkflowStepInput; };
    /**
     * The id of the start step
     * @type {string}
     * @memberof WorkflowCore
     */
    startStepId?: string;
}
/**
 * Core Workflow Execution Model
 * @export
 * @interface WorkflowExecution
 */
export interface WorkflowExecution {
    /**
     * The name of the workflow
     * @type {string}
     * @memberof WorkflowExecution
     */
    workflowName: string;
    /**
     * The start timestamp of the workflow
     * @type {string}
     * @memberof WorkflowExecution
     */
    workflowStartTimestamp: string | null;
    /**
     * The end timestamp of the workflow
     * @type {string}
     * @memberof WorkflowExecution
     */
    workflowEndTimestamp: string | null;
    /**
     * The id of the workflow
     * @type {string}
     * @memberof WorkflowExecution
     */
    workflowId: string;
    /**
     * The run id of the workflow
     * @type {string}
     * @memberof WorkflowExecution
     */
    workflowRunId: string;
    /**
     * The status of the workflow execution
     * @type {string}
     * @memberof WorkflowExecution
     */
    status: string;
    /**
     * The activity info of the workflow execution
     * @type {Array<WorkflowActivityInfo>}
     * @memberof WorkflowExecution
     */
    activityInfo: Array<WorkflowActivityInfo>;
    /**
     * The final result of the workflow execution
     * @type {object}
     * @memberof WorkflowExecution
     */
    result: object;
}
/**
 * Flow Step Model
 * @export
 * @interface WorkflowStepInput
 */
export interface WorkflowStepInput {
    /**
     * The id of the step
     * @type {string}
     * @memberof WorkflowStepInput
     */
    stepId?: string;
    /**
     * The connection id of the app
     * @type {string}
     * @memberof WorkflowStepInput
     */
    appConnectionId?: string | null;
    /**
     * The app action id of the app
     * @type {string}
     * @memberof WorkflowStepInput
     */
    appActionId?: string;
    /**
     * The id of the app
     * @type {string}
     * @memberof WorkflowStepInput
     */
    appId?: string;
    /**
     * The name of the app. It must match the app name in AppDefinition implementation
     * @type {string}
     * @memberof WorkflowStepInput
     */
    appName?: string;
    /**
     * The version of the app. It must match the app version in AppDefinition implementation
     * @type {string}
     * @memberof WorkflowStepInput
     */
    appVersion?: string;
    /**
     * The data resolver on how to resolve the data for the step
     * @type {string}
     * @memberof WorkflowStepInput
     */
    dataResolver?: string | null;
    /**
     * Resolver for determining the next step
     * @type {NextStepResolver}
     * @memberof WorkflowStepInput
     */
    nextStepResolver: NextStepResolver;
}
/**
 * Flow Step Model
 * @export
 * @interface WorkflowStepOutput
 */
export interface WorkflowStepOutput {
    /**
     * The id of the step
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    stepId?: string;
    /**
     * The connection id of the app
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    appConnectionId?: string | null;
    /**
     * The app action id of the app
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    appActionId?: string;
    /**
     * The id of the app
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    appId?: string;
    /**
     * The name of the app. It must match the app name in AppDefinition implementation
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    appName?: string;
    /**
     * The version of the app. It must match the app version in AppDefinition implementation
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    appVersion?: string;
    /**
     * The data resolver on how to resolve the data for the step
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    dataResolver?: string | null;
    /**
     * Resolver for determining the next step
     * @type {NextStepResolver}
     * @memberof WorkflowStepOutput
     */
    nextStepResolver: NextStepResolver;
}
/**
 * 
 * @export
 * @interface WorkflowStepTriggerRequest
 */
export interface WorkflowStepTriggerRequest {
    /**
     * 
     * @type {WorkflowContext}
     * @memberof WorkflowStepTriggerRequest
     */
    workflowContext: WorkflowContext;
    /**
     * 
     * @type {WorkflowStepInput}
     * @memberof WorkflowStepTriggerRequest
     */
    workflowStep: WorkflowStepInput;
}
/**
 * 
 * @export
 * @interface WorkflowStepTriggerResponse
 */
export interface WorkflowStepTriggerResponse {
    /**
     * 
     * @type {object}
     * @memberof WorkflowStepTriggerResponse
     */
    input: object;
    /**
     * 
     * @type {object}
     * @memberof WorkflowStepTriggerResponse
     */
    response: object;
}

/**
 * ActionAgentLinkApi - axios parameter creator
 * @export
 */
export const ActionAgentLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionAgentLinkV1: async (actionId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new RequiredError('actionId','Required parameter actionId was null or undefined when calling createActionAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling createActionAgentLinkV1.');
            }
            const localVarPath = `/v1/actions/{action_id}/ai-agents/{agent_id}/link`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionAgentLinkV1: async (actionId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new RequiredError('actionId','Required parameter actionId was null or undefined when calling deleteActionAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling deleteActionAgentLinkV1.');
            }
            const localVarPath = `/v1/actions/{action_id}/ai-agents/{agent_id}/link`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsOfAgentV1: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling listActionsOfAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}/actions`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionAgentLinkApi - functional programming interface
 * @export
 */
export const ActionAgentLinkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActionAgentLinkV1(actionId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ActionAgentLinkApiAxiosParamCreator(configuration).createActionAgentLinkV1(actionId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteActionAgentLinkV1(actionId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ActionAgentLinkApiAxiosParamCreator(configuration).deleteActionAgentLinkV1(actionId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActionsOfAgentV1(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActionOutput>>> {
            const localVarAxiosArgs = await ActionAgentLinkApiAxiosParamCreator(configuration).listActionsOfAgentV1(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ActionAgentLinkApi - factory interface
 * @export
 */
export const ActionAgentLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionAgentLinkV1(actionId: string, agentId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ActionAgentLinkApiFp(configuration).createActionAgentLinkV1(actionId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionAgentLinkV1(actionId: string, agentId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ActionAgentLinkApiFp(configuration).deleteActionAgentLinkV1(actionId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsOfAgentV1(agentId: string, options?: any): AxiosPromise<Array<ActionOutput>> {
            return ActionAgentLinkApiFp(configuration).listActionsOfAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionAgentLinkApi - object-oriented interface
 * @export
 * @class ActionAgentLinkApi
 * @extends {BaseAPI}
 */
export class ActionAgentLinkApi extends BaseAPI {
    /**
     * Create a Link Between an Action and an Agent
     * @summary Create a Link Between an Action and an Agent
     * @param {string} actionId ID of the action
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    public createActionAgentLinkV1(actionId: string, agentId: string, options?: any) {
        return ActionAgentLinkApiFp(this.configuration).createActionAgentLinkV1(actionId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Link Between an Action and an Agent
     * @summary Delete a Link Between an Action and an Agent
     * @param {string} actionId ID of the action
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    public deleteActionAgentLinkV1(actionId: string, agentId: string, options?: any) {
        return ActionAgentLinkApiFp(this.configuration).deleteActionAgentLinkV1(actionId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Actions Linked to a Specific Agent
     * @summary List All Actions Linked to a Specific Agent
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    public listActionsOfAgentV1(agentId: string, options?: any) {
        return ActionAgentLinkApiFp(this.configuration).listActionsOfAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionV1: async (actionInput: ActionInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionInput' is not null or undefined
            if (actionInput === null || actionInput === undefined) {
                throw new RequiredError('actionInput','Required parameter actionInput was null or undefined when calling createActionV1.');
            }
            const localVarPath = `/v1/actions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof actionInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(actionInput !== undefined ? actionInput : {}) : (actionInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionV1: async (actionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new RequiredError('actionId','Required parameter actionId was null or undefined when calling deleteActionV1.');
            }
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1: async (actionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new RequiredError('actionId','Required parameter actionId was null or undefined when calling getActionV1.');
            }
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Actions
         * @summary List All Actions
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/actions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActionV1: async (actionId: string, actionInput: ActionInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new RequiredError('actionId','Required parameter actionId was null or undefined when calling updateActionV1.');
            }
            // verify required parameter 'actionInput' is not null or undefined
            if (actionInput === null || actionInput === undefined) {
                throw new RequiredError('actionInput','Required parameter actionInput was null or undefined when calling updateActionV1.');
            }
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof actionInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(actionInput !== undefined ? actionInput : {}) : (actionInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActionV1(actionInput: ActionInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionOutput>> {
            const localVarAxiosArgs = await ActionsApiAxiosParamCreator(configuration).createActionV1(actionInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteActionV1(actionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ActionsApiAxiosParamCreator(configuration).deleteActionV1(actionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActionV1(actionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionOutput>> {
            const localVarAxiosArgs = await ActionsApiAxiosParamCreator(configuration).getActionV1(actionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Actions
         * @summary List All Actions
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActionsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActionOutput>>> {
            const localVarAxiosArgs = await ActionsApiAxiosParamCreator(configuration).listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateActionV1(actionId: string, actionInput: ActionInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionOutput>> {
            const localVarAxiosArgs = await ActionsApiAxiosParamCreator(configuration).updateActionV1(actionId, actionInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionV1(actionInput: ActionInput, options?: any): AxiosPromise<ActionOutput> {
            return ActionsApiFp(configuration).createActionV1(actionInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionV1(actionId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ActionsApiFp(configuration).deleteActionV1(actionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1(actionId: string, options?: any): AxiosPromise<ActionOutput> {
            return ActionsApiFp(configuration).getActionV1(actionId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Actions
         * @summary List All Actions
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<ActionOutput>> {
            return ActionsApiFp(configuration).listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActionV1(actionId: string, actionInput: ActionInput, options?: any): AxiosPromise<ActionOutput> {
            return ActionsApiFp(configuration).updateActionV1(actionId, actionInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI {
    /**
     * Create a New Action
     * @summary Create a New Action
     * @param {ActionInput} actionInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public createActionV1(actionInput: ActionInput, options?: any) {
        return ActionsApiFp(this.configuration).createActionV1(actionInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific Action by ID
     * @summary Delete a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public deleteActionV1(actionId: string, options?: any) {
        return ActionsApiFp(this.configuration).deleteActionV1(actionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Action by ID
     * @summary Get a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getActionV1(actionId: string, options?: any) {
        return ActionsApiFp(this.configuration).getActionV1(actionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Actions
     * @summary List All Actions
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public listActionsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return ActionsApiFp(this.configuration).listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific Action by ID
     * @summary Update a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {ActionInput} actionInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public updateActionV1(actionId: string, actionInput: ActionInput, options?: any) {
        return ActionsApiFp(this.configuration).updateActionV1(actionId, actionInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * AgentsApi - axios parameter creator
 * @export
 */
export const AgentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAIAgentV1: async (aIAgentInput: AIAgentInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'aIAgentInput' is not null or undefined
            if (aIAgentInput === null || aIAgentInput === undefined) {
                throw new RequiredError('aIAgentInput','Required parameter aIAgentInput was null or undefined when calling createAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof aIAgentInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(aIAgentInput !== undefined ? aIAgentInput : {}) : (aIAgentInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAIAgentV1: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling deleteAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIAgentV1: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling getAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All AI Agents
         * @summary List All AI Agents
         * @param {AppEnum} [app] 
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIAgentsV1: async (app?: AppEnum, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ai-agents`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIAgentV1: async (agentId: string, aIAgentInput: AIAgentInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling updateAIAgentV1.');
            }
            // verify required parameter 'aIAgentInput' is not null or undefined
            if (aIAgentInput === null || aIAgentInput === undefined) {
                throw new RequiredError('aIAgentInput','Required parameter aIAgentInput was null or undefined when calling updateAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof aIAgentInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(aIAgentInput !== undefined ? aIAgentInput : {}) : (aIAgentInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentsApi - functional programming interface
 * @export
 */
export const AgentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAIAgentV1(aIAgentInput: AIAgentInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AIAgentOutput>> {
            const localVarAxiosArgs = await AgentsApiAxiosParamCreator(configuration).createAIAgentV1(aIAgentInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAIAgentV1(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await AgentsApiAxiosParamCreator(configuration).deleteAIAgentV1(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAIAgentV1(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AIAgentOutput>> {
            const localVarAxiosArgs = await AgentsApiAxiosParamCreator(configuration).getAIAgentV1(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All AI Agents
         * @summary List All AI Agents
         * @param {AppEnum} [app] 
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAIAgentsV1(app?: AppEnum, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AIAgentOutput>>> {
            const localVarAxiosArgs = await AgentsApiAxiosParamCreator(configuration).listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAIAgentV1(agentId: string, aIAgentInput: AIAgentInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AIAgentOutput>> {
            const localVarAxiosArgs = await AgentsApiAxiosParamCreator(configuration).updateAIAgentV1(agentId, aIAgentInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AgentsApi - factory interface
 * @export
 */
export const AgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAIAgentV1(aIAgentInput: AIAgentInput, options?: any): AxiosPromise<AIAgentOutput> {
            return AgentsApiFp(configuration).createAIAgentV1(aIAgentInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAIAgentV1(agentId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return AgentsApiFp(configuration).deleteAIAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIAgentV1(agentId: string, options?: any): AxiosPromise<AIAgentOutput> {
            return AgentsApiFp(configuration).getAIAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All AI Agents
         * @summary List All AI Agents
         * @param {AppEnum} [app] 
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIAgentsV1(app?: AppEnum, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<AIAgentOutput>> {
            return AgentsApiFp(configuration).listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIAgentV1(agentId: string, aIAgentInput: AIAgentInput, options?: any): AxiosPromise<AIAgentOutput> {
            return AgentsApiFp(configuration).updateAIAgentV1(agentId, aIAgentInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AgentsApi - object-oriented interface
 * @export
 * @class AgentsApi
 * @extends {BaseAPI}
 */
export class AgentsApi extends BaseAPI {
    /**
     * Create a New AI Agent
     * @summary Create a New AI Agent
     * @param {AIAgentInput} aIAgentInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public createAIAgentV1(aIAgentInput: AIAgentInput, options?: any) {
        return AgentsApiFp(this.configuration).createAIAgentV1(aIAgentInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific AI Agent by ID
     * @summary Delete a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public deleteAIAgentV1(agentId: string, options?: any) {
        return AgentsApiFp(this.configuration).deleteAIAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific AI Agent by ID
     * @summary Get a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public getAIAgentV1(agentId: string, options?: any) {
        return AgentsApiFp(this.configuration).getAIAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All AI Agents
     * @summary List All AI Agents
     * @param {AppEnum} [app] 
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public listAIAgentsV1(app?: AppEnum, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return AgentsApiFp(this.configuration).listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific AI Agent by ID
     * @summary Update a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {AIAgentInput} aIAgentInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public updateAIAgentV1(agentId: string, aIAgentInput: AIAgentInput, options?: any) {
        return AgentsApiFp(this.configuration).updateAIAgentV1(agentId, aIAgentInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get fine grained analytics data from Trata AI like call, duration stats, etc.
         * @summary Get Metrics
         * @param {BatchMetricsRequests} batchMetricsRequests 
         * @param {string} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1MetricsPost: async (batchMetricsRequests: BatchMetricsRequests, app?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchMetricsRequests' is not null or undefined
            if (batchMetricsRequests === null || batchMetricsRequests === undefined) {
                throw new RequiredError('batchMetricsRequests','Required parameter batchMetricsRequests was null or undefined when calling getMetricsV1MetricsPost.');
            }
            const localVarPath = `/v1/metrics`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof batchMetricsRequests !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(batchMetricsRequests !== undefined ? batchMetricsRequests : {}) : (batchMetricsRequests || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get aggregated stats from Trata AI like call count, prospect count, etc.
         * @summary Get Aggregated Stats
         * @param {AppEnum} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallStatsV1StatsGet: async (app?: AppEnum, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/stats`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get fine grained analytics data from Trata AI like call, duration stats, etc.
         * @summary Get Metrics
         * @param {BatchMetricsRequests} batchMetricsRequests 
         * @param {string} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetricsV1MetricsPost(batchMetricsRequests: BatchMetricsRequests, app?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchMetricsResponse>> {
            const localVarAxiosArgs = await AnalyticsApiAxiosParamCreator(configuration).getMetricsV1MetricsPost(batchMetricsRequests, app, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get aggregated stats from Trata AI like call count, prospect count, etc.
         * @summary Get Aggregated Stats
         * @param {AppEnum} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOverallStatsV1StatsGet(app?: AppEnum, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsResponse>> {
            const localVarAxiosArgs = await AnalyticsApiAxiosParamCreator(configuration).getOverallStatsV1StatsGet(app, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get fine grained analytics data from Trata AI like call, duration stats, etc.
         * @summary Get Metrics
         * @param {BatchMetricsRequests} batchMetricsRequests 
         * @param {string} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1MetricsPost(batchMetricsRequests: BatchMetricsRequests, app?: string, options?: any): AxiosPromise<BatchMetricsResponse> {
            return AnalyticsApiFp(configuration).getMetricsV1MetricsPost(batchMetricsRequests, app, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregated stats from Trata AI like call count, prospect count, etc.
         * @summary Get Aggregated Stats
         * @param {AppEnum} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallStatsV1StatsGet(app?: AppEnum, options?: any): AxiosPromise<StatsResponse> {
            return AnalyticsApiFp(configuration).getOverallStatsV1StatsGet(app, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * Get fine grained analytics data from Trata AI like call, duration stats, etc.
     * @summary Get Metrics
     * @param {BatchMetricsRequests} batchMetricsRequests 
     * @param {string} [app] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getMetricsV1MetricsPost(batchMetricsRequests: BatchMetricsRequests, app?: string, options?: any) {
        return AnalyticsApiFp(this.configuration).getMetricsV1MetricsPost(batchMetricsRequests, app, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get aggregated stats from Trata AI like call count, prospect count, etc.
     * @summary Get Aggregated Stats
     * @param {AppEnum} [app] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getOverallStatsV1StatsGet(app?: AppEnum, options?: any) {
        return AnalyticsApiFp(this.configuration).getOverallStatsV1StatsGet(app, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ApiKeyApi - axios parameter creator
 * @export
 */
export const ApiKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyV1: async (apiKeyRequest: ApiKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeyRequest' is not null or undefined
            if (apiKeyRequest === null || apiKeyRequest === undefined) {
                throw new RequiredError('apiKeyRequest','Required parameter apiKeyRequest was null or undefined when calling createApiKeyV1.');
            }
            const localVarPath = `/v1/api-keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof apiKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(apiKeyRequest !== undefined ? apiKeyRequest : {}) : (apiKeyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyV1: async (keyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            if (keyId === null || keyId === undefined) {
                throw new RequiredError('keyId','Required parameter keyId was null or undefined when calling deleteApiKeyV1.');
            }
            const localVarPath = `/v1/api-keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallKeyV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/api-keys/call-key`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/api-keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeyApi - functional programming interface
 * @export
 */
export const ApiKeyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKeyV1(apiKeyRequest: ApiKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserApiKeyLink>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).createApiKeyV1(apiKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiKeyV1(keyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).deleteApiKeyV1(keyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCallKeyV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserApiKeyLink>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).getCallKeyV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApiKeysV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserApiKeyLink>>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).listApiKeysV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ApiKeyApi - factory interface
 * @export
 */
export const ApiKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyV1(apiKeyRequest: ApiKeyRequest, options?: any): AxiosPromise<UserApiKeyLink> {
            return ApiKeyApiFp(configuration).createApiKeyV1(apiKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyV1(keyId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ApiKeyApiFp(configuration).deleteApiKeyV1(keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallKeyV1(options?: any): AxiosPromise<UserApiKeyLink> {
            return ApiKeyApiFp(configuration).getCallKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysV1(options?: any): AxiosPromise<Array<UserApiKeyLink>> {
            return ApiKeyApiFp(configuration).listApiKeysV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiKeyApi - object-oriented interface
 * @export
 * @class ApiKeyApi
 * @extends {BaseAPI}
 */
export class ApiKeyApi extends BaseAPI {
    /**
     * 
     * @summary Create Api Key
     * @param {ApiKeyRequest} apiKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public createApiKeyV1(apiKeyRequest: ApiKeyRequest, options?: any) {
        return ApiKeyApiFp(this.configuration).createApiKeyV1(apiKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Api Key
     * @param {string} keyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public deleteApiKeyV1(keyId: string, options?: any) {
        return ApiKeyApiFp(this.configuration).deleteApiKeyV1(keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Call Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public getCallKeyV1(options?: any) {
        return ApiKeyApiFp(this.configuration).getCallKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Api Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public listApiKeysV1(options?: any) {
        return ApiKeyApiFp(this.configuration).listApiKeysV1(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * BillingApi - axios parameter creator
 * @export
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForBillableProductV1: async (billableProductId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'billableProductId' is not null or undefined
            if (billableProductId === null || billableProductId === undefined) {
                throw new RequiredError('billableProductId','Required parameter billableProductId was null or undefined when calling createCheckoutSessionForBillableProductV1.');
            }
            const localVarPath = `/v1/subscription/billable-products/{billable_product_id}/checkout`
                .replace(`{${"billable_product_id"}}`, encodeURIComponent(String(billableProductId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerSessionSecretV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription/customer-session-secret`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionBillableProductsV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription/billable-products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPortalV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription/portal`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckoutSessionForBillableProductV1(billableProductId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await BillingApiAxiosParamCreator(configuration).createCheckoutSessionForBillableProductV1(billableProductId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerSessionSecretV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await BillingApiAxiosParamCreator(configuration).getCustomerSessionSecretV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionBillableProductsV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Price>>> {
            const localVarAxiosArgs = await BillingApiAxiosParamCreator(configuration).getSubscriptionBillableProductsV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionPortalV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await BillingApiAxiosParamCreator(configuration).getSubscriptionPortalV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionInfo>> {
            const localVarAxiosArgs = await BillingApiAxiosParamCreator(configuration).getSubscriptionV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForBillableProductV1(billableProductId: string, options?: any): AxiosPromise<string> {
            return BillingApiFp(configuration).createCheckoutSessionForBillableProductV1(billableProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerSessionSecretV1(options?: any): AxiosPromise<string> {
            return BillingApiFp(configuration).getCustomerSessionSecretV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionBillableProductsV1(options?: any): AxiosPromise<Array<Price>> {
            return BillingApiFp(configuration).getSubscriptionBillableProductsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPortalV1(options?: any): AxiosPromise<string> {
            return BillingApiFp(configuration).getSubscriptionPortalV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionV1(options?: any): AxiosPromise<SubscriptionInfo> {
            return BillingApiFp(configuration).getSubscriptionV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI {
    /**
     * 
     * @summary Create Checkout Session For Billable Product
     * @param {string} billableProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public createCheckoutSessionForBillableProductV1(billableProductId: string, options?: any) {
        return BillingApiFp(this.configuration).createCheckoutSessionForBillableProductV1(billableProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Customer Session Secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getCustomerSessionSecretV1(options?: any) {
        return BillingApiFp(this.configuration).getCustomerSessionSecretV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Subscription Billable Products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getSubscriptionBillableProductsV1(options?: any) {
        return BillingApiFp(this.configuration).getSubscriptionBillableProductsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Subscription Portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getSubscriptionPortalV1(options?: any) {
        return BillingApiFp(this.configuration).getSubscriptionPortalV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getSubscriptionV1(options?: any) {
        return BillingApiFp(this.configuration).getSubscriptionV1(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ConversationProspectLinkApi - axios parameter creator
 * @export
 */
export const ConversationProspectLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationProspectLinkV1: async (conversationId: string, prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling createConversationProspectLinkV1.');
            }
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling createConversationProspectLinkV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}/prospects/{prospect_id}/links`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationProspectLinkV1: async (conversationId: string, prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling deleteConversationProspectLinkV1.');
            }
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling deleteConversationProspectLinkV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}/prospects/{prospect_id}/links`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsOfProspectsV1: async (prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling listConversationsOfProspectsV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}/conversations`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversationProspectLinkApi - functional programming interface
 * @export
 */
export const ConversationProspectLinkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ConversationProspectLinkApiAxiosParamCreator(configuration).createConversationProspectLinkV1(conversationId, prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ConversationProspectLinkApiAxiosParamCreator(configuration).deleteConversationProspectLinkV1(conversationId, prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConversationsOfProspectsV1(prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConversationOutput>>> {
            const localVarAxiosArgs = await ConversationProspectLinkApiAxiosParamCreator(configuration).listConversationsOfProspectsV1(prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ConversationProspectLinkApi - factory interface
 * @export
 */
export const ConversationProspectLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ConversationProspectLinkApiFp(configuration).createConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ConversationProspectLinkApiFp(configuration).deleteConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsOfProspectsV1(prospectId: string, options?: any): AxiosPromise<Array<ConversationOutput>> {
            return ConversationProspectLinkApiFp(configuration).listConversationsOfProspectsV1(prospectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConversationProspectLinkApi - object-oriented interface
 * @export
 * @class ConversationProspectLinkApi
 * @extends {BaseAPI}
 */
export class ConversationProspectLinkApi extends BaseAPI {
    /**
     * Create a link between a conversation and a prospect
     * @summary Create a link between a conversation and a prospect
     * @param {string} conversationId ID of the conversation
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    public createConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any) {
        return ConversationProspectLinkApiFp(this.configuration).createConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a link between a conversation and a prospect
     * @summary Delete a link between a conversation and a prospect
     * @param {string} conversationId ID of the conversation
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    public deleteConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any) {
        return ConversationProspectLinkApiFp(this.configuration).deleteConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all conversations linked to a specific prospect
     * @summary List all conversations linked to a specific prospect
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    public listConversationsOfProspectsV1(prospectId: string, options?: any) {
        return ConversationProspectLinkApiFp(this.configuration).listConversationsOfProspectsV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ConversationsApi - axios parameter creator
 * @export
 */
export const ConversationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedbackV1: async (conversationId: string, comment: Comment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling addFeedbackV1.');
            }
            // verify required parameter 'comment' is not null or undefined
            if (comment === null || comment === undefined) {
                throw new RequiredError('comment','Required parameter comment was null or undefined when calling addFeedbackV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}/feedback`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof comment !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(comment !== undefined ? comment : {}) : (comment || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationV1: async (conversationInput: ConversationInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationInput' is not null or undefined
            if (conversationInput === null || conversationInput === undefined) {
                throw new RequiredError('conversationInput','Required parameter conversationInput was null or undefined when calling createConversationV1.');
            }
            const localVarPath = `/v1/conversations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof conversationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(conversationInput !== undefined ? conversationInput : {}) : (conversationInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationV1: async (conversationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling deleteConversationV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationV1: async (conversationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling getConversationV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Conversations
         * @summary List All Conversations
         * @param {AppEnum} [app] 
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsV1: async (app?: AppEnum, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/conversations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationV1: async (conversationId: string, conversationInput: ConversationInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling updateConversationV1.');
            }
            // verify required parameter 'conversationInput' is not null or undefined
            if (conversationInput === null || conversationInput === undefined) {
                throw new RequiredError('conversationInput','Required parameter conversationInput was null or undefined when calling updateConversationV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof conversationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(conversationInput !== undefined ? conversationInput : {}) : (conversationInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversationsApi - functional programming interface
 * @export
 */
export const ConversationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFeedbackV1(conversationId: string, comment: Comment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationFeedback>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).addFeedbackV1(conversationId, comment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversationV1(conversationInput: ConversationInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationOutput>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).createConversationV1(conversationInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConversationV1(conversationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).deleteConversationV1(conversationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversationV1(conversationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationOutput>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).getConversationV1(conversationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Conversations
         * @summary List All Conversations
         * @param {AppEnum} [app] 
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConversationsV1(app?: AppEnum, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConversationOutput>>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConversationV1(conversationId: string, conversationInput: ConversationInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationOutput>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).updateConversationV1(conversationId, conversationInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ConversationsApi - factory interface
 * @export
 */
export const ConversationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedbackV1(conversationId: string, comment: Comment, options?: any): AxiosPromise<ConversationFeedback> {
            return ConversationsApiFp(configuration).addFeedbackV1(conversationId, comment, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationV1(conversationInput: ConversationInput, options?: any): AxiosPromise<ConversationOutput> {
            return ConversationsApiFp(configuration).createConversationV1(conversationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationV1(conversationId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ConversationsApiFp(configuration).deleteConversationV1(conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationV1(conversationId: string, options?: any): AxiosPromise<ConversationOutput> {
            return ConversationsApiFp(configuration).getConversationV1(conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Conversations
         * @summary List All Conversations
         * @param {AppEnum} [app] 
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsV1(app?: AppEnum, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<ConversationOutput>> {
            return ConversationsApiFp(configuration).listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationV1(conversationId: string, conversationInput: ConversationInput, options?: any): AxiosPromise<ConversationOutput> {
            return ConversationsApiFp(configuration).updateConversationV1(conversationId, conversationInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConversationsApi - object-oriented interface
 * @export
 * @class ConversationsApi
 * @extends {BaseAPI}
 */
export class ConversationsApi extends BaseAPI {
    /**
     * Add Feedback to a Specific Conversation
     * @summary Add Feedback to a Specific Conversation
     * @param {string} conversationId ID of the conversation
     * @param {Comment} comment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public addFeedbackV1(conversationId: string, comment: Comment, options?: any) {
        return ConversationsApiFp(this.configuration).addFeedbackV1(conversationId, comment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a New Conversation
     * @summary Create a New Conversation
     * @param {ConversationInput} conversationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public createConversationV1(conversationInput: ConversationInput, options?: any) {
        return ConversationsApiFp(this.configuration).createConversationV1(conversationInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific Conversation by ID
     * @summary Delete a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public deleteConversationV1(conversationId: string, options?: any) {
        return ConversationsApiFp(this.configuration).deleteConversationV1(conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Conversation by ID
     * @summary Get a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public getConversationV1(conversationId: string, options?: any) {
        return ConversationsApiFp(this.configuration).getConversationV1(conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Conversations
     * @summary List All Conversations
     * @param {AppEnum} [app] 
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public listConversationsV1(app?: AppEnum, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return ConversationsApiFp(this.configuration).listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific Conversation by ID
     * @summary Update a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {ConversationInput} conversationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public updateConversationV1(conversationId: string, conversationInput: ConversationInput, options?: any) {
        return ConversationsApiFp(this.configuration).updateConversationV1(conversationId, conversationInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * DataPlaneApi - axios parameter creator
 * @export
 */
export const DataPlaneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new connection for an AI Agent to start a voice conversation
         * @summary Create Connection
         * @param {string} agentId 
         * @param {ConnectionSource} connectionSource 
         * @param {string} [prospectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection: async (agentId: string, connectionSource: ConnectionSource, prospectId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling createConnection.');
            }
            // verify required parameter 'connectionSource' is not null or undefined
            if (connectionSource === null || connectionSource === undefined) {
                throw new RequiredError('connectionSource','Required parameter connectionSource was null or undefined when calling createConnection.');
            }
            const localVarPath = `/v1/connections`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (agentId !== undefined) {
                localVarQueryParameter['agentId'] = agentId;
            }

            if (prospectId !== undefined) {
                localVarQueryParameter['prospect_id'] = prospectId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof connectionSource !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(connectionSource !== undefined ? connectionSource : {}) : (connectionSource || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the audio stream xml for Plivo to start a voice conversation
         * @summary Get Audio Stream XML For Plivo
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlivoAudioStreamXml: async (connectionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            if (connectionId === null || connectionId === undefined) {
                throw new RequiredError('connectionId','Required parameter connectionId was null or undefined when calling getPlivoAudioStreamXml.');
            }
            const localVarPath = `/v1/connections/{connection_id}/plivo-audio-stream-xml`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataPlaneApi - functional programming interface
 * @export
 */
export const DataPlaneApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new connection for an AI Agent to start a voice conversation
         * @summary Create Connection
         * @param {string} agentId 
         * @param {ConnectionSource} connectionSource 
         * @param {string} [prospectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnection(agentId: string, connectionSource: ConnectionSource, prospectId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionOutput>> {
            const localVarAxiosArgs = await DataPlaneApiAxiosParamCreator(configuration).createConnection(agentId, connectionSource, prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the audio stream xml for Plivo to start a voice conversation
         * @summary Get Audio Stream XML For Plivo
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlivoAudioStreamXml(connectionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await DataPlaneApiAxiosParamCreator(configuration).getPlivoAudioStreamXml(connectionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DataPlaneApi - factory interface
 * @export
 */
export const DataPlaneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new connection for an AI Agent to start a voice conversation
         * @summary Create Connection
         * @param {string} agentId 
         * @param {ConnectionSource} connectionSource 
         * @param {string} [prospectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(agentId: string, connectionSource: ConnectionSource, prospectId?: string, options?: any): AxiosPromise<ConnectionOutput> {
            return DataPlaneApiFp(configuration).createConnection(agentId, connectionSource, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the audio stream xml for Plivo to start a voice conversation
         * @summary Get Audio Stream XML For Plivo
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlivoAudioStreamXml(connectionId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return DataPlaneApiFp(configuration).getPlivoAudioStreamXml(connectionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataPlaneApi - object-oriented interface
 * @export
 * @class DataPlaneApi
 * @extends {BaseAPI}
 */
export class DataPlaneApi extends BaseAPI {
    /**
     * Create a new connection for an AI Agent to start a voice conversation
     * @summary Create Connection
     * @param {string} agentId 
     * @param {ConnectionSource} connectionSource 
     * @param {string} [prospectId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPlaneApi
     */
    public createConnection(agentId: string, connectionSource: ConnectionSource, prospectId?: string, options?: any) {
        return DataPlaneApiFp(this.configuration).createConnection(agentId, connectionSource, prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the audio stream xml for Plivo to start a voice conversation
     * @summary Get Audio Stream XML For Plivo
     * @param {string} connectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPlaneApi
     */
    public getPlivoAudioStreamXml(connectionId: string, options?: any) {
        return DataPlaneApiFp(this.configuration).getPlivoAudioStreamXml(connectionId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete files from Trata account
         * @summary Delete Files
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1: async (fileIds: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileIds' is not null or undefined
            if (fileIds === null || fileIds === undefined) {
                throw new RequiredError('fileIds','Required parameter fileIds was null or undefined when calling deleteFileV1.');
            }
            const localVarPath = `/v1/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (fileIds !== undefined) {
                localVarQueryParameter['file_ids'] = fileIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete files from Trata reseller account
         * @summary Delete Files
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerFilesV1: async (fileIds: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileIds' is not null or undefined
            if (fileIds === null || fileIds === undefined) {
                throw new RequiredError('fileIds','Required parameter fileIds was null or undefined when calling deleteResellerFilesV1.');
            }
            const localVarPath = `/v1/resellers/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (fileIds !== undefined) {
                localVarQueryParameter['file_ids'] = fileIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files 
         * @param {string} [validator] Validator type to use for file validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1: async (files: Array<any>, validator?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'files' is not null or undefined
            if (files === null || files === undefined) {
                throw new RequiredError('files','Required parameter files was null or undefined when calling uploadFileV1.');
            }
            const localVarPath = `/v1/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (validator !== undefined) {
                localVarQueryParameter['validator'] = validator;
            }

            if (files) {
            
                localVarFormParams.append('files', files.join(COLLECTION_FORMATS.csv));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadResellerFilesV1: async (files: Array<any>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'files' is not null or undefined
            if (files === null || files === undefined) {
                throw new RequiredError('files','Required parameter files was null or undefined when calling uploadResellerFilesV1.');
            }
            const localVarPath = `/v1/resellers/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (files) {
            
                localVarFormParams.append('files', files.join(COLLECTION_FORMATS.csv));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete files from Trata account
         * @summary Delete Files
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileV1(fileIds: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await FilesApiAxiosParamCreator(configuration).deleteFileV1(fileIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete files from Trata reseller account
         * @summary Delete Files
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResellerFilesV1(fileIds: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await FilesApiAxiosParamCreator(configuration).deleteResellerFilesV1(fileIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files 
         * @param {string} [validator] Validator type to use for file validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileV1(files: Array<any>, validator?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Files>>> {
            const localVarAxiosArgs = await FilesApiAxiosParamCreator(configuration).uploadFileV1(files, validator, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadResellerFilesV1(files: Array<any>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Files>>> {
            const localVarAxiosArgs = await FilesApiAxiosParamCreator(configuration).uploadResellerFilesV1(files, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete files from Trata account
         * @summary Delete Files
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1(fileIds: string, options?: any): AxiosPromise<boolean> {
            return FilesApiFp(configuration).deleteFileV1(fileIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete files from Trata reseller account
         * @summary Delete Files
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerFilesV1(fileIds: string, options?: any): AxiosPromise<boolean> {
            return FilesApiFp(configuration).deleteResellerFilesV1(fileIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files 
         * @param {string} [validator] Validator type to use for file validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1(files: Array<any>, validator?: string, options?: any): AxiosPromise<Array<Files>> {
            return FilesApiFp(configuration).uploadFileV1(files, validator, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadResellerFilesV1(files: Array<any>, options?: any): AxiosPromise<Array<Files>> {
            return FilesApiFp(configuration).uploadResellerFilesV1(files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * Delete files from Trata account
     * @summary Delete Files
     * @param {string} fileIds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public deleteFileV1(fileIds: string, options?: any) {
        return FilesApiFp(this.configuration).deleteFileV1(fileIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete files from Trata reseller account
     * @summary Delete Files
     * @param {string} fileIds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public deleteResellerFilesV1(fileIds: string, options?: any) {
        return FilesApiFp(this.configuration).deleteResellerFilesV1(fileIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload file to Trata account to use in AI Agents
     * @summary Upload Files
     * @param {Array<any>} files 
     * @param {string} [validator] Validator type to use for file validation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public uploadFileV1(files: Array<any>, validator?: string, options?: any) {
        return FilesApiFp(this.configuration).uploadFileV1(files, validator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload file to Trata account to use in AI Agents
     * @summary Upload Files
     * @param {Array<any>} files 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public uploadResellerFilesV1(files: Array<any>, options?: any) {
        return FilesApiFp(this.configuration).uploadResellerFilesV1(files, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Heart Beat check to check the health of Trata Backend
         * @summary Heart Beat Status Of Trata Backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatusGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Heart Beat check to check the health of Workflow Service
         * @summary Heart Beat Status Of Workflow Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusWorkflowsStatusGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflows/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Heart Beat check to check the health of Trata Backend
         * @summary Heart Beat Status Of Trata Backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusStatusGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await HealthApiAxiosParamCreator(configuration).statusStatusGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Heart Beat check to check the health of Workflow Service
         * @summary Heart Beat Status Of Workflow Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusWorkflowsStatusGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await HealthApiAxiosParamCreator(configuration).statusWorkflowsStatusGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Heart Beat check to check the health of Trata Backend
         * @summary Heart Beat Status Of Trata Backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatusGet(options?: any): AxiosPromise<object> {
            return HealthApiFp(configuration).statusStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Heart Beat check to check the health of Workflow Service
         * @summary Heart Beat Status Of Workflow Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusWorkflowsStatusGet(options?: any): AxiosPromise<object> {
            return HealthApiFp(configuration).statusWorkflowsStatusGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * Heart Beat check to check the health of Trata Backend
     * @summary Heart Beat Status Of Trata Backend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public statusStatusGet(options?: any) {
        return HealthApiFp(this.configuration).statusStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Heart Beat check to check the health of Workflow Service
     * @summary Heart Beat Status Of Workflow Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public statusWorkflowsStatusGet(options?: any) {
        return HealthApiFp(this.configuration).statusWorkflowsStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * HiveApi - axios parameter creator
 * @export
 */
export const HiveApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1: async (hiveContentInput: HiveContentInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveContentInput' is not null or undefined
            if (hiveContentInput === null || hiveContentInput === undefined) {
                throw new RequiredError('hiveContentInput','Required parameter hiveContentInput was null or undefined when calling createHiveV1.');
            }
            const localVarPath = `/v1/hives`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof hiveContentInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(hiveContentInput !== undefined ? hiveContentInput : {}) : (hiveContentInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1: async (hiveId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling deleteHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1: async (hiveId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling getHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Hives
         * @summary List All Hives
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/hives`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1: async (hiveId: string, hiveContentOutput: HiveContentOutput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling updateHiveV1.');
            }
            // verify required parameter 'hiveContentOutput' is not null or undefined
            if (hiveContentOutput === null || hiveContentOutput === undefined) {
                throw new RequiredError('hiveContentOutput','Required parameter hiveContentOutput was null or undefined when calling updateHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof hiveContentOutput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(hiveContentOutput !== undefined ? hiveContentOutput : {}) : (hiveContentOutput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HiveApi - functional programming interface
 * @export
 */
export const HiveApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHiveV1(hiveContentInput: HiveContentInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>> {
            const localVarAxiosArgs = await HiveApiAxiosParamCreator(configuration).createHiveV1(hiveContentInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHiveV1(hiveId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await HiveApiAxiosParamCreator(configuration).deleteHiveV1(hiveId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHiveV1(hiveId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>> {
            const localVarAxiosArgs = await HiveApiAxiosParamCreator(configuration).getHiveV1(hiveId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Hives
         * @summary List All Hives
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHivesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hive>>> {
            const localVarAxiosArgs = await HiveApiAxiosParamCreator(configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHiveV1(hiveId: string, hiveContentOutput: HiveContentOutput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>> {
            const localVarAxiosArgs = await HiveApiAxiosParamCreator(configuration).updateHiveV1(hiveId, hiveContentOutput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HiveApi - factory interface
 * @export
 */
export const HiveApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1(hiveContentInput: HiveContentInput, options?: any): AxiosPromise<Hive> {
            return HiveApiFp(configuration).createHiveV1(hiveContentInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1(hiveId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return HiveApiFp(configuration).deleteHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1(hiveId: string, options?: any): AxiosPromise<Hive> {
            return HiveApiFp(configuration).getHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Hives
         * @summary List All Hives
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<Hive>> {
            return HiveApiFp(configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1(hiveId: string, hiveContentOutput: HiveContentOutput, options?: any): AxiosPromise<Hive> {
            return HiveApiFp(configuration).updateHiveV1(hiveId, hiveContentOutput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HiveApi - object-oriented interface
 * @export
 * @class HiveApi
 * @extends {BaseAPI}
 */
export class HiveApi extends BaseAPI {
    /**
     * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
     * @summary Create a New Hive
     * @param {HiveContentInput} hiveContentInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public createHiveV1(hiveContentInput: HiveContentInput, options?: any) {
        return HiveApiFp(this.configuration).createHiveV1(hiveContentInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific Hive by ID
     * @summary Delete a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public deleteHiveV1(hiveId: string, options?: any) {
        return HiveApiFp(this.configuration).deleteHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Hive by ID
     * @summary Get a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public getHiveV1(hiveId: string, options?: any) {
        return HiveApiFp(this.configuration).getHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Hives
     * @summary List All Hives
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public listHivesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return HiveApiFp(this.configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific Hive by ID
     * @summary Update a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {HiveContentOutput} hiveContentOutput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public updateHiveV1(hiveId: string, hiveContentOutput: HiveContentOutput, options?: any) {
        return HiveApiFp(this.configuration).updateHiveV1(hiveId, hiveContentOutput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * HiveAgentLinkApi - axios parameter creator
 * @export
 */
export const HiveAgentLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveAgentLinkV1: async (hiveId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling createHiveAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling createHiveAgentLinkV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}/ai-agents/{agent_id}/link`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveAgentLinkV1: async (hiveId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling deleteHiveAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling deleteHiveAgentLinkV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}/ai-agents/{agent_id}/link`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfHiveV1: async (hiveId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling listAgentsOfHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}/ai-agents`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesOfAgentV1: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling listHivesOfAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}/hives`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HiveAgentLinkApi - functional programming interface
 * @export
 */
export const HiveAgentLinkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHiveAgentLinkV1(hiveId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await HiveAgentLinkApiAxiosParamCreator(configuration).createHiveAgentLinkV1(hiveId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHiveAgentLinkV1(hiveId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await HiveAgentLinkApiAxiosParamCreator(configuration).deleteHiveAgentLinkV1(hiveId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAgentsOfHiveV1(hiveId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AIAgentOutput>>> {
            const localVarAxiosArgs = await HiveAgentLinkApiAxiosParamCreator(configuration).listAgentsOfHiveV1(hiveId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHivesOfAgentV1(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hive>>> {
            const localVarAxiosArgs = await HiveAgentLinkApiAxiosParamCreator(configuration).listHivesOfAgentV1(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HiveAgentLinkApi - factory interface
 * @export
 */
export const HiveAgentLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveAgentLinkV1(hiveId: string, agentId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return HiveAgentLinkApiFp(configuration).createHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveAgentLinkV1(hiveId: string, agentId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return HiveAgentLinkApiFp(configuration).deleteHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfHiveV1(hiveId: string, options?: any): AxiosPromise<Array<AIAgentOutput>> {
            return HiveAgentLinkApiFp(configuration).listAgentsOfHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesOfAgentV1(agentId: string, options?: any): AxiosPromise<Array<Hive>> {
            return HiveAgentLinkApiFp(configuration).listHivesOfAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HiveAgentLinkApi - object-oriented interface
 * @export
 * @class HiveAgentLinkApi
 * @extends {BaseAPI}
 */
export class HiveAgentLinkApi extends BaseAPI {
    /**
     * Create a Link Between a Hive and an Agent
     * @summary Create a Link Between a Hive and an Agent
     * @param {string} hiveId ID of the hive
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    public createHiveAgentLinkV1(hiveId: string, agentId: string, options?: any) {
        return HiveAgentLinkApiFp(this.configuration).createHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Link Between a Hive and an Agent
     * @summary Delete a Link Between a Hive and an Agent
     * @param {string} hiveId ID of the hive
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    public deleteHiveAgentLinkV1(hiveId: string, agentId: string, options?: any) {
        return HiveAgentLinkApiFp(this.configuration).deleteHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Agents Linked to a Specific Hive
     * @summary List All Agents Linked to a Specific Hive
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    public listAgentsOfHiveV1(hiveId: string, options?: any) {
        return HiveAgentLinkApiFp(this.configuration).listAgentsOfHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Hives Linked to a Specific Agent
     * @summary List All Hives Linked to a Specific Agent
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    public listHivesOfAgentV1(agentId: string, options?: any) {
        return HiveAgentLinkApiFp(this.configuration).listHivesOfAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * InternalApi - axios parameter creator
 * @export
 */
export const InternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteV1: async (acceptInviteRequest: AcceptInviteRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'acceptInviteRequest' is not null or undefined
            if (acceptInviteRequest === null || acceptInviteRequest === undefined) {
                throw new RequiredError('acceptInviteRequest','Required parameter acceptInviteRequest was null or undefined when calling acceptInviteV1.');
            }
            const localVarPath = `/v1/invites/accept`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof acceptInviteRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(acceptInviteRequest !== undefined ? acceptInviteRequest : {}) : (acceptInviteRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationV1: async (bodyCreateOrganizationV1: BodyCreateOrganizationV1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateOrganizationV1' is not null or undefined
            if (bodyCreateOrganizationV1 === null || bodyCreateOrganizationV1 === undefined) {
                throw new RequiredError('bodyCreateOrganizationV1','Required parameter bodyCreateOrganizationV1 was null or undefined when calling createOrganizationV1.');
            }
            const localVarPath = `/v1/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyCreateOrganizationV1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyCreateOrganizationV1 !== undefined ? bodyCreateOrganizationV1 : {}) : (bodyCreateOrganizationV1 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserV1.');
            }
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getorganizationbranding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBrandingV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organizations/branding`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/invites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInviteV1: async (guestInput: GuestInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guestInput' is not null or undefined
            if (guestInput === null || guestInput === undefined) {
                throw new RequiredError('guestInput','Required parameter guestInput was null or undefined when calling sendInviteV1.');
            }
            const localVarPath = `/v1/invites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof guestInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(guestInput !== undefined ? guestInput : {}) : (guestInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationV1: async (orgId: string, organizationInput: OrganizationInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            if (orgId === null || orgId === undefined) {
                throw new RequiredError('orgId','Required parameter orgId was null or undefined when calling updateOrganizationV1.');
            }
            // verify required parameter 'organizationInput' is not null or undefined
            if (organizationInput === null || organizationInput === undefined) {
                throw new RequiredError('organizationInput','Required parameter organizationInput was null or undefined when calling updateOrganizationV1.');
            }
            const localVarPath = `/v1/organizations/{org_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof organizationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(organizationInput !== undefined ? organizationInput : {}) : (organizationInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId 
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1: async (userId: string, updateUserPayload: UpdateUserPayload, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserV1.');
            }
            // verify required parameter 'updateUserPayload' is not null or undefined
            if (updateUserPayload === null || updateUserPayload === undefined) {
                throw new RequiredError('updateUserPayload','Required parameter updateUserPayload was null or undefined when calling updateUserV1.');
            }
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateUserPayload !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateUserPayload !== undefined ? updateUserPayload : {}) : (updateUserPayload || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalApi - functional programming interface
 * @export
 */
export const InternalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).acceptInviteV1(acceptInviteRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationV1(bodyCreateOrganizationV1: BodyCreateOrganizationV1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).createOrganizationV1(bodyCreateOrganizationV1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).deleteOrganizationV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserV1(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).deleteUserV1(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Getorganizationbranding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationBrandingV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSettings | object>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).getOrganizationBrandingV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationOutput>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).getOrganizationV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInvitesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuestOutput>>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsersV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).listUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendInviteV1(guestInput: GuestInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuestOutput>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).sendInviteV1(guestInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationV1(orgId: string, organizationInput: OrganizationInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationOutput>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).updateOrganizationV1(orgId, organizationInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId 
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserV1(userId: string, updateUserPayload: UpdateUserPayload, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).updateUserV1(userId, updateUserPayload, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InternalApi - factory interface
 * @export
 */
export const InternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: any): AxiosPromise<User> {
            return InternalApiFp(configuration).acceptInviteV1(acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationV1(bodyCreateOrganizationV1: BodyCreateOrganizationV1, options?: any): AxiosPromise<User> {
            return InternalApiFp(configuration).createOrganizationV1(bodyCreateOrganizationV1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationV1(options?: any): AxiosPromise<BaseResponseInput> {
            return InternalApiFp(configuration).deleteOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1(userId: string, options?: any): AxiosPromise<User> {
            return InternalApiFp(configuration).deleteUserV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getorganizationbranding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBrandingV1(options?: any): AxiosPromise<OrganizationSettings | object> {
            return InternalApiFp(configuration).getOrganizationBrandingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationV1(options?: any): AxiosPromise<OrganizationOutput> {
            return InternalApiFp(configuration).getOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<GuestOutput>> {
            return InternalApiFp(configuration).listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return InternalApiFp(configuration).listUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInviteV1(guestInput: GuestInput, options?: any): AxiosPromise<GuestOutput> {
            return InternalApiFp(configuration).sendInviteV1(guestInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationV1(orgId: string, organizationInput: OrganizationInput, options?: any): AxiosPromise<OrganizationOutput> {
            return InternalApiFp(configuration).updateOrganizationV1(orgId, organizationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId 
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1(userId: string, updateUserPayload: UpdateUserPayload, options?: any): AxiosPromise<User> {
            return InternalApiFp(configuration).updateUserV1(userId, updateUserPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
export class InternalApi extends BaseAPI {
    /**
     * Accept invite and add new user to organization
     * @summary Acceptinvite
     * @param {AcceptInviteRequest} acceptInviteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public acceptInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: any) {
        return InternalApiFp(this.configuration).acceptInviteV1(acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new organization and adds the user as the \"ADMIN\" user for the org
     * @summary Createorganization
     * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public createOrganizationV1(bodyCreateOrganizationV1: BodyCreateOrganizationV1, options?: any) {
        return InternalApiFp(this.configuration).createOrganizationV1(bodyCreateOrganizationV1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deleteorganization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public deleteOrganizationV1(options?: any) {
        return InternalApiFp(this.configuration).deleteOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user
     * @summary Deleteuser
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public deleteUserV1(userId: string, options?: any) {
        return InternalApiFp(this.configuration).deleteUserV1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Getorganizationbranding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getOrganizationBrandingV1(options?: any) {
        return InternalApiFp(this.configuration).getOrganizationBrandingV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Getorganization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getOrganizationV1(options?: any) {
        return InternalApiFp(this.configuration).getOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of all open invites from the organization
     * @summary Listinvites
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public listInvitesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return InternalApiFp(this.configuration).listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all users under the user\'s organization
     * @summary Listusers
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public listUsersV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return InternalApiFp(this.configuration).listUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a new user to an organization or resend invite to the user if the user is already invited
     * @summary Inviteusers
     * @param {GuestInput} guestInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public sendInviteV1(guestInput: GuestInput, options?: any) {
        return InternalApiFp(this.configuration).sendInviteV1(guestInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updateorganization
     * @param {string} orgId ID of the organization
     * @param {OrganizationInput} organizationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public updateOrganizationV1(orgId: string, organizationInput: OrganizationInput, options?: any) {
        return InternalApiFp(this.configuration).updateOrganizationV1(orgId, organizationInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user details
     * @summary Updateuser
     * @param {string} userId 
     * @param {UpdateUserPayload} updateUserPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public updateUserV1(userId: string, updateUserPayload: UpdateUserPayload, options?: any) {
        return InternalApiFp(this.configuration).updateUserV1(userId, updateUserPayload, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductV1: async (productInput: ProductInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productInput' is not null or undefined
            if (productInput === null || productInput === undefined) {
                throw new RequiredError('productInput','Required parameter productInput was null or undefined when calling createProductV1.');
            }
            const localVarPath = `/v1/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof productInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(productInput !== undefined ? productInput : {}) : (productInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductV1: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductV1: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfProductV1: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling listAgentsOfProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}/agents`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Products
         * @summary List All Products
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {Array<string>} [tags] Filter products by specific tags
         * @param {Array<string>} [productIds] Filter by specific product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (productIds) {
                localVarQueryParameter['product_ids'] = productIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductV1: async (productId: string, productInput: ProductInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling updateProductV1.');
            }
            // verify required parameter 'productInput' is not null or undefined
            if (productInput === null || productInput === undefined) {
                throw new RequiredError('productInput','Required parameter productInput was null or undefined when calling updateProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof productInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(productInput !== undefined ? productInput : {}) : (productInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProductV1(productInput: ProductInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOutput>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).createProductV1(productInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductV1(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).deleteProductV1(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductV1(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOutput>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).getProductV1(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAgentsOfProductV1(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AIAgentOutput>>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).listAgentsOfProductV1(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Products
         * @summary List All Products
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {Array<string>} [tags] Filter products by specific tags
         * @param {Array<string>} [productIds] Filter by specific product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProductsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductOutput>>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProductV1(productId: string, productInput: ProductInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOutput>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).updateProductV1(productId, productInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductV1(productInput: ProductInput, options?: any): AxiosPromise<ProductOutput> {
            return ProductsApiFp(configuration).createProductV1(productInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductV1(productId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ProductsApiFp(configuration).deleteProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductV1(productId: string, options?: any): AxiosPromise<ProductOutput> {
            return ProductsApiFp(configuration).getProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfProductV1(productId: string, options?: any): AxiosPromise<Array<AIAgentOutput>> {
            return ProductsApiFp(configuration).listAgentsOfProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Products
         * @summary List All Products
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {Array<string>} [tags] Filter products by specific tags
         * @param {Array<string>} [productIds] Filter by specific product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options?: any): AxiosPromise<Array<ProductOutput>> {
            return ProductsApiFp(configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductV1(productId: string, productInput: ProductInput, options?: any): AxiosPromise<ProductOutput> {
            return ProductsApiFp(configuration).updateProductV1(productId, productInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * Create a New Product
     * @summary Create a New Product
     * @param {ProductInput} productInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public createProductV1(productInput: ProductInput, options?: any) {
        return ProductsApiFp(this.configuration).createProductV1(productInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific Product by ID
     * @summary Delete a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProductV1(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).deleteProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Product by ID
     * @summary Get a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductV1(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).getProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Agents Linked to a Specific Product
     * @summary List All Agents Linked to a Specific Product
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listAgentsOfProductV1(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).listAgentsOfProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Products
     * @summary List All Products
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {Array<string>} [tags] Filter products by specific tags
     * @param {Array<string>} [productIds] Filter by specific product IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listProductsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options?: any) {
        return ProductsApiFp(this.configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific Product by ID
     * @summary Update a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {ProductInput} productInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProductV1(productId: string, productInput: ProductInput, options?: any) {
        return ProductsApiFp(this.configuration).updateProductV1(productId, productInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ProspectsApi - axios parameter creator
 * @export
 */
export const ProspectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProspectV1: async (prospectInput: ProspectInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectInput' is not null or undefined
            if (prospectInput === null || prospectInput === undefined) {
                throw new RequiredError('prospectInput','Required parameter prospectInput was null or undefined when calling createProspectV1.');
            }
            const localVarPath = `/v1/prospects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof prospectInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(prospectInput !== undefined ? prospectInput : {}) : (prospectInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProspectV1: async (prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling deleteProspectV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProspectV1: async (prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling getProspectV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Prospects
         * @summary List All Prospects
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProspectsV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/prospects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProspectV1: async (prospectId: string, prospectInput: ProspectInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling updateProspectV1.');
            }
            // verify required parameter 'prospectInput' is not null or undefined
            if (prospectInput === null || prospectInput === undefined) {
                throw new RequiredError('prospectInput','Required parameter prospectInput was null or undefined when calling updateProspectV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof prospectInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(prospectInput !== undefined ? prospectInput : {}) : (prospectInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProspectsApi - functional programming interface
 * @export
 */
export const ProspectsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProspectV1(prospectInput: ProspectInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProspectOutput>> {
            const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(configuration).createProspectV1(prospectInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProspectV1(prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(configuration).deleteProspectV1(prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProspectV1(prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProspectOutput>> {
            const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(configuration).getProspectV1(prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Prospects
         * @summary List All Prospects
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProspectsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProspectOutput>>> {
            const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(configuration).listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProspectV1(prospectId: string, prospectInput: ProspectInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProspectOutput>> {
            const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(configuration).updateProspectV1(prospectId, prospectInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProspectsApi - factory interface
 * @export
 */
export const ProspectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProspectV1(prospectInput: ProspectInput, options?: any): AxiosPromise<ProspectOutput> {
            return ProspectsApiFp(configuration).createProspectV1(prospectInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProspectV1(prospectId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ProspectsApiFp(configuration).deleteProspectV1(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProspectV1(prospectId: string, options?: any): AxiosPromise<ProspectOutput> {
            return ProspectsApiFp(configuration).getProspectV1(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Prospects
         * @summary List All Prospects
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProspectsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<ProspectOutput>> {
            return ProspectsApiFp(configuration).listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProspectV1(prospectId: string, prospectInput: ProspectInput, options?: any): AxiosPromise<ProspectOutput> {
            return ProspectsApiFp(configuration).updateProspectV1(prospectId, prospectInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProspectsApi - object-oriented interface
 * @export
 * @class ProspectsApi
 * @extends {BaseAPI}
 */
export class ProspectsApi extends BaseAPI {
    /**
     * Create a New Prospect
     * @summary Create a New Prospect
     * @param {ProspectInput} prospectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public createProspectV1(prospectInput: ProspectInput, options?: any) {
        return ProspectsApiFp(this.configuration).createProspectV1(prospectInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific Prospect by ID
     * @summary Delete a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public deleteProspectV1(prospectId: string, options?: any) {
        return ProspectsApiFp(this.configuration).deleteProspectV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Prospect by ID
     * @summary Get a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public getProspectV1(prospectId: string, options?: any) {
        return ProspectsApiFp(this.configuration).getProspectV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Prospects
     * @summary List All Prospects
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public listProspectsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return ProspectsApiFp(this.configuration).listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific Prospect by ID
     * @summary Update a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {ProspectInput} prospectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public updateProspectV1(prospectId: string, prospectInput: ProspectInput, options?: any) {
        return ProspectsApiFp(this.configuration).updateProspectV1(prospectId, prospectInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SparringApi - axios parameter creator
 * @export
 */
export const SparringApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a virtual prospect
         * @summary Create Virtual Prospect
         * @param {VirtualProspectInput} virtualProspectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualProspectV1SparrVirtualProspectsPost: async (virtualProspectInput: VirtualProspectInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualProspectInput' is not null or undefined
            if (virtualProspectInput === null || virtualProspectInput === undefined) {
                throw new RequiredError('virtualProspectInput','Required parameter virtualProspectInput was null or undefined when calling createVirtualProspectV1SparrVirtualProspectsPost.');
            }
            const localVarPath = `/v1/sparr/virtual-prospects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof virtualProspectInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(virtualProspectInput !== undefined ? virtualProspectInput : {}) : (virtualProspectInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a virtual prospect
         * @summary Delete Virtual Prospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete: async (prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete.');
            }
            const localVarPath = `/v1/sparr/virtual-prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get sparring stats from Trata AI like call count, prospect count, etc.
         * @summary Get Sparring Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSparringStatsV1SparrSparringStatsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/sparring-stats`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get virtual prospect associated with an agent
         * @summary Get Virtual Prospect by Agent ID
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet.');
            }
            const localVarPath = `/v1/sparr/agent/{agent_id}/virtual-prospect`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a virtual prospect
         * @summary Get Virtual Prospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectV1SparrVirtualProspectsProspectIdGet: async (prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling getVirtualProspectV1SparrVirtualProspectsProspectIdGet.');
            }
            const localVarPath = `/v1/sparr/virtual-prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Link a virtual prospect to an agent
         * @summary Link Virtual Prospect to Agent
         * @param {string} prospectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost: async (prospectId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost.');
            }
            const localVarPath = `/v1/sparr/virtual-prospects/{prospect_id}/agent/{agent_id}/link`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all virtual prospects
         * @summary List Virtual Prospects
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualProspectsV1SparrVirtualProspectsGet: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/virtual-prospects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a virtual prospect
         * @summary Update Virtual Prospect
         * @param {string} prospectId 
         * @param {VirtualProspectInput} virtualProspectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVirtualProspectV1SparrVirtualProspectsProspectIdPut: async (prospectId: string, virtualProspectInput: VirtualProspectInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling updateVirtualProspectV1SparrVirtualProspectsProspectIdPut.');
            }
            // verify required parameter 'virtualProspectInput' is not null or undefined
            if (virtualProspectInput === null || virtualProspectInput === undefined) {
                throw new RequiredError('virtualProspectInput','Required parameter virtualProspectInput was null or undefined when calling updateVirtualProspectV1SparrVirtualProspectsProspectIdPut.');
            }
            const localVarPath = `/v1/sparr/virtual-prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof virtualProspectInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(virtualProspectInput !== undefined ? virtualProspectInput : {}) : (virtualProspectInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SparringApi - functional programming interface
 * @export
 */
export const SparringApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a virtual prospect
         * @summary Create Virtual Prospect
         * @param {VirtualProspectInput} virtualProspectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput: VirtualProspectInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualProspectOutput>> {
            const localVarAxiosArgs = await SparringApiAxiosParamCreator(configuration).createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a virtual prospect
         * @summary Delete Virtual Prospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await SparringApiAxiosParamCreator(configuration).deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get sparring stats from Trata AI like call count, prospect count, etc.
         * @summary Get Sparring Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSparringStatsV1SparrSparringStatsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrStatsResponse>> {
            const localVarAxiosArgs = await SparringApiAxiosParamCreator(configuration).getSparringStatsV1SparrSparringStatsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get virtual prospect associated with an agent
         * @summary Get Virtual Prospect by Agent ID
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VirtualProspectOutput>>> {
            const localVarAxiosArgs = await SparringApiAxiosParamCreator(configuration).getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a virtual prospect
         * @summary Get Virtual Prospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualProspectOutput>> {
            const localVarAxiosArgs = await SparringApiAxiosParamCreator(configuration).getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Link a virtual prospect to an agent
         * @summary Link Virtual Prospect to Agent
         * @param {string} prospectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualProspectAIAgentLink>> {
            const localVarAxiosArgs = await SparringApiAxiosParamCreator(configuration).linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all virtual prospects
         * @summary List Virtual Prospects
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVirtualProspectsV1SparrVirtualProspectsGet(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VirtualProspectOutput>>> {
            const localVarAxiosArgs = await SparringApiAxiosParamCreator(configuration).listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a virtual prospect
         * @summary Update Virtual Prospect
         * @param {string} prospectId 
         * @param {VirtualProspectInput} virtualProspectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId: string, virtualProspectInput: VirtualProspectInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualProspectOutput>> {
            const localVarAxiosArgs = await SparringApiAxiosParamCreator(configuration).updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SparringApi - factory interface
 * @export
 */
export const SparringApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a virtual prospect
         * @summary Create Virtual Prospect
         * @param {VirtualProspectInput} virtualProspectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput: VirtualProspectInput, options?: any): AxiosPromise<VirtualProspectOutput> {
            return SparringApiFp(configuration).createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a virtual prospect
         * @summary Delete Virtual Prospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return SparringApiFp(configuration).deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get sparring stats from Trata AI like call count, prospect count, etc.
         * @summary Get Sparring Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSparringStatsV1SparrSparringStatsGet(options?: any): AxiosPromise<SparrStatsResponse> {
            return SparringApiFp(configuration).getSparringStatsV1SparrSparringStatsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get virtual prospect associated with an agent
         * @summary Get Virtual Prospect by Agent ID
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId: string, options?: any): AxiosPromise<Array<VirtualProspectOutput>> {
            return SparringApiFp(configuration).getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a virtual prospect
         * @summary Get Virtual Prospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId: string, options?: any): AxiosPromise<VirtualProspectOutput> {
            return SparringApiFp(configuration).getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Link a virtual prospect to an agent
         * @summary Link Virtual Prospect to Agent
         * @param {string} prospectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId: string, agentId: string, options?: any): AxiosPromise<VirtualProspectAIAgentLink> {
            return SparringApiFp(configuration).linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all virtual prospects
         * @summary List Virtual Prospects
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualProspectsV1SparrVirtualProspectsGet(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<VirtualProspectOutput>> {
            return SparringApiFp(configuration).listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a virtual prospect
         * @summary Update Virtual Prospect
         * @param {string} prospectId 
         * @param {VirtualProspectInput} virtualProspectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId: string, virtualProspectInput: VirtualProspectInput, options?: any): AxiosPromise<VirtualProspectOutput> {
            return SparringApiFp(configuration).updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SparringApi - object-oriented interface
 * @export
 * @class SparringApi
 * @extends {BaseAPI}
 */
export class SparringApi extends BaseAPI {
    /**
     * Create a virtual prospect
     * @summary Create Virtual Prospect
     * @param {VirtualProspectInput} virtualProspectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput: VirtualProspectInput, options?: any) {
        return SparringApiFp(this.configuration).createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a virtual prospect
     * @summary Delete Virtual Prospect
     * @param {string} prospectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId: string, options?: any) {
        return SparringApiFp(this.configuration).deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get sparring stats from Trata AI like call count, prospect count, etc.
     * @summary Get Sparring Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public getSparringStatsV1SparrSparringStatsGet(options?: any) {
        return SparringApiFp(this.configuration).getSparringStatsV1SparrSparringStatsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get virtual prospect associated with an agent
     * @summary Get Virtual Prospect by Agent ID
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId: string, options?: any) {
        return SparringApiFp(this.configuration).getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a virtual prospect
     * @summary Get Virtual Prospect
     * @param {string} prospectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId: string, options?: any) {
        return SparringApiFp(this.configuration).getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Link a virtual prospect to an agent
     * @summary Link Virtual Prospect to Agent
     * @param {string} prospectId 
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId: string, agentId: string, options?: any) {
        return SparringApiFp(this.configuration).linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all virtual prospects
     * @summary List Virtual Prospects
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public listVirtualProspectsV1SparrVirtualProspectsGet(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return SparringApiFp(this.configuration).listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a virtual prospect
     * @summary Update Virtual Prospect
     * @param {string} prospectId 
     * @param {VirtualProspectInput} virtualProspectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId: string, virtualProspectInput: VirtualProspectInput, options?: any) {
        return SparringApiFp(this.configuration).updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TelephonyApi - axios parameter creator
 * @export
 */
export const TelephonyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Agent Phones
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentPhonesV1: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling getAgentPhonesV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}/phones`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Link Phone To Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPhoneToAgentV1: async (phoneId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'phoneId' is not null or undefined
            if (phoneId === null || phoneId === undefined) {
                throw new RequiredError('phoneId','Required parameter phoneId was null or undefined when calling linkPhoneToAgentV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling linkPhoneToAgentV1.');
            }
            const localVarPath = `/v1/telephony/phones/{phone_id}/ai-agents/{agent_id}/link`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Available Phones
         * @param {string} countryCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailablePhonesV1: async (countryCode: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryCode' is not null or undefined
            if (countryCode === null || countryCode === undefined) {
                throw new RequiredError('countryCode','Required parameter countryCode was null or undefined when calling listAvailablePhonesV1.');
            }
            const localVarPath = `/v1/telephony/countries/{country_code}/available-phones`
                .replace(`{${"country_code"}}`, encodeURIComponent(String(countryCode)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Purchased Phones
         * @param {string} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPurchasedPhonesV1: async (countryCode?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/telephony/phones`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedCountriesV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/telephony/countries`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePhoneV1: async (numberPurchaseRequest: NumberPurchaseRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'numberPurchaseRequest' is not null or undefined
            if (numberPurchaseRequest === null || numberPurchaseRequest === undefined) {
                throw new RequiredError('numberPurchaseRequest','Required parameter numberPurchaseRequest was null or undefined when calling purchasePhoneV1.');
            }
            const localVarPath = `/v1/telephony/phones`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof numberPurchaseRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(numberPurchaseRequest !== undefined ? numberPurchaseRequest : {}) : (numberPurchaseRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Release Phone
         * @param {string} phoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePhoneV1: async (phoneId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'phoneId' is not null or undefined
            if (phoneId === null || phoneId === undefined) {
                throw new RequiredError('phoneId','Required parameter phoneId was null or undefined when calling releasePhoneV1.');
            }
            const localVarPath = `/v1/telephony/phones/{phone_id}`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlink Phone From Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPhoneFromAgentV1: async (phoneId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'phoneId' is not null or undefined
            if (phoneId === null || phoneId === undefined) {
                throw new RequiredError('phoneId','Required parameter phoneId was null or undefined when calling unlinkPhoneFromAgentV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling unlinkPhoneFromAgentV1.');
            }
            const localVarPath = `/v1/telephony/phones/{phone_id}/ai-agents/{agent_id}/link`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TelephonyApi - functional programming interface
 * @export
 */
export const TelephonyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Agent Phones
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgentPhonesV1(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TelephoneNumber>>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).getAgentPhonesV1(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Link Phone To Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkPhoneToAgentV1(phoneId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).linkPhoneToAgentV1(phoneId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Available Phones
         * @param {string} countryCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAvailablePhonesV1(countryCode: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AvailablePhoneNumber>>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).listAvailablePhonesV1(countryCode, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Purchased Phones
         * @param {string} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPurchasedPhonesV1(countryCode?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TelephoneNumber>>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).listPurchasedPhonesV1(countryCode, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSupportedCountriesV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CountryInfo>>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).listSupportedCountriesV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchasePhoneV1(numberPurchaseRequest: NumberPurchaseRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TelephoneNumber>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).purchasePhoneV1(numberPurchaseRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Release Phone
         * @param {string} phoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async releasePhoneV1(phoneId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).releasePhoneV1(phoneId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Unlink Phone From Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkPhoneFromAgentV1(phoneId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).unlinkPhoneFromAgentV1(phoneId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TelephonyApi - factory interface
 * @export
 */
export const TelephonyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get Agent Phones
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentPhonesV1(agentId: string, options?: any): AxiosPromise<Array<TelephoneNumber>> {
            return TelephonyApiFp(configuration).getAgentPhonesV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Link Phone To Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPhoneToAgentV1(phoneId: string, agentId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return TelephonyApiFp(configuration).linkPhoneToAgentV1(phoneId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Available Phones
         * @param {string} countryCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailablePhonesV1(countryCode: string, options?: any): AxiosPromise<Array<AvailablePhoneNumber>> {
            return TelephonyApiFp(configuration).listAvailablePhonesV1(countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Purchased Phones
         * @param {string} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPurchasedPhonesV1(countryCode?: string, options?: any): AxiosPromise<Array<TelephoneNumber>> {
            return TelephonyApiFp(configuration).listPurchasedPhonesV1(countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedCountriesV1(options?: any): AxiosPromise<Array<CountryInfo>> {
            return TelephonyApiFp(configuration).listSupportedCountriesV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePhoneV1(numberPurchaseRequest: NumberPurchaseRequest, options?: any): AxiosPromise<TelephoneNumber> {
            return TelephonyApiFp(configuration).purchasePhoneV1(numberPurchaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Release Phone
         * @param {string} phoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePhoneV1(phoneId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return TelephonyApiFp(configuration).releasePhoneV1(phoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlink Phone From Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPhoneFromAgentV1(phoneId: string, agentId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return TelephonyApiFp(configuration).unlinkPhoneFromAgentV1(phoneId, agentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TelephonyApi - object-oriented interface
 * @export
 * @class TelephonyApi
 * @extends {BaseAPI}
 */
export class TelephonyApi extends BaseAPI {
    /**
     * 
     * @summary Get Agent Phones
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public getAgentPhonesV1(agentId: string, options?: any) {
        return TelephonyApiFp(this.configuration).getAgentPhonesV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Link Phone To Agent
     * @param {string} phoneId 
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public linkPhoneToAgentV1(phoneId: string, agentId: string, options?: any) {
        return TelephonyApiFp(this.configuration).linkPhoneToAgentV1(phoneId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Available Phones
     * @param {string} countryCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public listAvailablePhonesV1(countryCode: string, options?: any) {
        return TelephonyApiFp(this.configuration).listAvailablePhonesV1(countryCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Purchased Phones
     * @param {string} [countryCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public listPurchasedPhonesV1(countryCode?: string, options?: any) {
        return TelephonyApiFp(this.configuration).listPurchasedPhonesV1(countryCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Supported Countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public listSupportedCountriesV1(options?: any) {
        return TelephonyApiFp(this.configuration).listSupportedCountriesV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purchase Phone
     * @param {NumberPurchaseRequest} numberPurchaseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public purchasePhoneV1(numberPurchaseRequest: NumberPurchaseRequest, options?: any) {
        return TelephonyApiFp(this.configuration).purchasePhoneV1(numberPurchaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Release Phone
     * @param {string} phoneId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public releasePhoneV1(phoneId: string, options?: any) {
        return TelephonyApiFp(this.configuration).releasePhoneV1(phoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlink Phone From Agent
     * @param {string} phoneId 
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public unlinkPhoneFromAgentV1(phoneId: string, agentId: string, options?: any) {
        return TelephonyApiFp(this.configuration).unlinkPhoneFromAgentV1(phoneId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UIApi - axios parameter creator
 * @export
 */
export const UIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Action Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionTemplatesV1: async (language?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ui/action-templates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Products
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {Array<string>} [tags] Filter products by specific tags
         * @param {Array<string>} [productIds] Filter by specific product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsDetailedV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ui/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (productIds) {
                localVarQueryParameter['product_ids'] = productIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Prompt Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptTemplatesV1: async (language?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ui/prompt-templates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Role Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleTemplatesV1: async (language?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ui/role-templates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UIApi - functional programming interface
 * @export
 */
export const UIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Action Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActionTemplatesV1(language?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActionInput>>> {
            const localVarAxiosArgs = await UIApiAxiosParamCreator(configuration).listActionTemplatesV1(language, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Products
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {Array<string>} [tags] Filter products by specific tags
         * @param {Array<string>} [productIds] Filter by specific product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProductsDetailedV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductWithAgents>>> {
            const localVarAxiosArgs = await UIApiAxiosParamCreator(configuration).listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Prompt Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPromptTemplatesV1(language?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: PromptTemplate; }>> {
            const localVarAxiosArgs = await UIApiAxiosParamCreator(configuration).listPromptTemplatesV1(language, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Role Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoleTemplatesV1(language?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleTemplate>>> {
            const localVarAxiosArgs = await UIApiAxiosParamCreator(configuration).listRoleTemplatesV1(language, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UIApi - factory interface
 * @export
 */
export const UIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary List Action Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionTemplatesV1(language?: string, options?: any): AxiosPromise<Array<ActionInput>> {
            return UIApiFp(configuration).listActionTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Products
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {Array<string>} [tags] Filter products by specific tags
         * @param {Array<string>} [productIds] Filter by specific product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsDetailedV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options?: any): AxiosPromise<Array<ProductWithAgents>> {
            return UIApiFp(configuration).listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Prompt Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptTemplatesV1(language?: string, options?: any): AxiosPromise<{ [key: string]: PromptTemplate; }> {
            return UIApiFp(configuration).listPromptTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Role Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleTemplatesV1(language?: string, options?: any): AxiosPromise<Array<RoleTemplate>> {
            return UIApiFp(configuration).listRoleTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UIApi - object-oriented interface
 * @export
 * @class UIApi
 * @extends {BaseAPI}
 */
export class UIApi extends BaseAPI {
    /**
     * 
     * @summary List Action Templates
     * @param {string} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    public listActionTemplatesV1(language?: string, options?: any) {
        return UIApiFp(this.configuration).listActionTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Products
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {Array<string>} [tags] Filter products by specific tags
     * @param {Array<string>} [productIds] Filter by specific product IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    public listProductsDetailedV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options?: any) {
        return UIApiFp(this.configuration).listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Prompt Templates
     * @param {string} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    public listPromptTemplatesV1(language?: string, options?: any) {
        return UIApiFp(this.configuration).listPromptTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Role Templates
     * @param {string} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    public listRoleTemplatesV1(language?: string, options?: any) {
        return UIApiFp(this.configuration).listRoleTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * VoiceModelsApi - axios parameter creator
 * @export
 */
export const VoiceModelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get List Of Voices Available For Conversations
         * @summary Get List Of Voices Available For Conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceModelsV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/voice-models`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoiceModelsApi - functional programming interface
 * @export
 */
export const VoiceModelsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get List Of Voices Available For Conversations
         * @summary Get List Of Voices Available For Conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVoiceModelsV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VoiceModel>>> {
            const localVarAxiosArgs = await VoiceModelsApiAxiosParamCreator(configuration).listVoiceModelsV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VoiceModelsApi - factory interface
 * @export
 */
export const VoiceModelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get List Of Voices Available For Conversations
         * @summary Get List Of Voices Available For Conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceModelsV1(options?: any): AxiosPromise<Array<VoiceModel>> {
            return VoiceModelsApiFp(configuration).listVoiceModelsV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VoiceModelsApi - object-oriented interface
 * @export
 * @class VoiceModelsApi
 * @extends {BaseAPI}
 */
export class VoiceModelsApi extends BaseAPI {
    /**
     * Get List Of Voices Available For Conversations
     * @summary Get List Of Voices Available For Conversations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceModelsApi
     */
    public listVoiceModelsV1(options?: any) {
        return VoiceModelsApiFp(this.configuration).listVoiceModelsV1(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WorkflowsApi - axios parameter creator
 * @export
 */
export const WorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Workflow
         * @param {WorkflowCore} workflowCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowV1WorkflowsPost: async (workflowCore: WorkflowCore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowCore' is not null or undefined
            if (workflowCore === null || workflowCore === undefined) {
                throw new RequiredError('workflowCore','Required parameter workflowCore was null or undefined when calling createWorkflowV1WorkflowsPost.');
            }
            const localVarPath = `/v1/workflows/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof workflowCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(workflowCore !== undefined ? workflowCore : {}) : (workflowCore || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowV1WorkflowsWorkflowIdDelete: async (workflowId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling deleteWorkflowV1WorkflowsWorkflowIdDelete.');
            }
            const localVarPath = `/v1/workflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowV1WorkflowsWorkflowIdGet: async (workflowId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling readWorkflowV1WorkflowsWorkflowIdGet.');
            }
            const localVarPath = `/v1/workflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Workflows
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowsV1WorkflowsGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/workflows/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger Workflow Step
         * @param {string} workflowId 
         * @param {string} stepId 
         * @param {WorkflowStepTriggerRequest} workflowStepTriggerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost: async (workflowId: string, stepId: string, workflowStepTriggerRequest: WorkflowStepTriggerRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost.');
            }
            // verify required parameter 'stepId' is not null or undefined
            if (stepId === null || stepId === undefined) {
                throw new RequiredError('stepId','Required parameter stepId was null or undefined when calling triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost.');
            }
            // verify required parameter 'workflowStepTriggerRequest' is not null or undefined
            if (workflowStepTriggerRequest === null || workflowStepTriggerRequest === undefined) {
                throw new RequiredError('workflowStepTriggerRequest','Required parameter workflowStepTriggerRequest was null or undefined when calling triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost.');
            }
            const localVarPath = `/v1/workflows/{workflow_id}/step/{step_id}/trigger`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)))
                .replace(`{${"step_id"}}`, encodeURIComponent(String(stepId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof workflowStepTriggerRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(workflowStepTriggerRequest !== undefined ? workflowStepTriggerRequest : {}) : (workflowStepTriggerRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Workflow
         * @param {string} workflowId 
         * @param {WorkflowCore} workflowCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowV1WorkflowsWorkflowIdPut: async (workflowId: string, workflowCore: WorkflowCore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling updateWorkflowV1WorkflowsWorkflowIdPut.');
            }
            // verify required parameter 'workflowCore' is not null or undefined
            if (workflowCore === null || workflowCore === undefined) {
                throw new RequiredError('workflowCore','Required parameter workflowCore was null or undefined when calling updateWorkflowV1WorkflowsWorkflowIdPut.');
            }
            const localVarPath = `/v1/workflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof workflowCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(workflowCore !== undefined ? workflowCore : {}) : (workflowCore || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsApi - functional programming interface
 * @export
 */
export const WorkflowsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Workflow
         * @param {WorkflowCore} workflowCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflowV1WorkflowsPost(workflowCore: WorkflowCore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await WorkflowsApiAxiosParamCreator(configuration).createWorkflowV1WorkflowsPost(workflowCore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await WorkflowsApiAxiosParamCreator(configuration).deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Read Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readWorkflowV1WorkflowsWorkflowIdGet(workflowId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await WorkflowsApiAxiosParamCreator(configuration).readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Read Workflows
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readWorkflowsV1WorkflowsGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workflow>>> {
            const localVarAxiosArgs = await WorkflowsApiAxiosParamCreator(configuration).readWorkflowsV1WorkflowsGet(skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Trigger Workflow Step
         * @param {string} workflowId 
         * @param {string} stepId 
         * @param {WorkflowStepTriggerRequest} workflowStepTriggerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId: string, stepId: string, workflowStepTriggerRequest: WorkflowStepTriggerRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowStepTriggerResponse>> {
            const localVarAxiosArgs = await WorkflowsApiAxiosParamCreator(configuration).triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update Workflow
         * @param {string} workflowId 
         * @param {WorkflowCore} workflowCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkflowV1WorkflowsWorkflowIdPut(workflowId: string, workflowCore: WorkflowCore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await WorkflowsApiAxiosParamCreator(configuration).updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkflowsApi - factory interface
 * @export
 */
export const WorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create Workflow
         * @param {WorkflowCore} workflowCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowV1WorkflowsPost(workflowCore: WorkflowCore, options?: any): AxiosPromise<Workflow> {
            return WorkflowsApiFp(configuration).createWorkflowV1WorkflowsPost(workflowCore, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId: string, options?: any): AxiosPromise<AgenticWorkflowModelsBaseBaseResponse> {
            return WorkflowsApiFp(configuration).deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowV1WorkflowsWorkflowIdGet(workflowId: string, options?: any): AxiosPromise<Workflow> {
            return WorkflowsApiFp(configuration).readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Workflows
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowsV1WorkflowsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Workflow>> {
            return WorkflowsApiFp(configuration).readWorkflowsV1WorkflowsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger Workflow Step
         * @param {string} workflowId 
         * @param {string} stepId 
         * @param {WorkflowStepTriggerRequest} workflowStepTriggerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId: string, stepId: string, workflowStepTriggerRequest: WorkflowStepTriggerRequest, options?: any): AxiosPromise<WorkflowStepTriggerResponse> {
            return WorkflowsApiFp(configuration).triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Workflow
         * @param {string} workflowId 
         * @param {WorkflowCore} workflowCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowV1WorkflowsWorkflowIdPut(workflowId: string, workflowCore: WorkflowCore, options?: any): AxiosPromise<Workflow> {
            return WorkflowsApiFp(configuration).updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsApi
 * @extends {BaseAPI}
 */
export class WorkflowsApi extends BaseAPI {
    /**
     * 
     * @summary Create Workflow
     * @param {WorkflowCore} workflowCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public createWorkflowV1WorkflowsPost(workflowCore: WorkflowCore, options?: any) {
        return WorkflowsApiFp(this.configuration).createWorkflowV1WorkflowsPost(workflowCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Workflow
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId: string, options?: any) {
        return WorkflowsApiFp(this.configuration).deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Workflow
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public readWorkflowV1WorkflowsWorkflowIdGet(workflowId: string, options?: any) {
        return WorkflowsApiFp(this.configuration).readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Workflows
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public readWorkflowsV1WorkflowsGet(skip?: number, limit?: number, options?: any) {
        return WorkflowsApiFp(this.configuration).readWorkflowsV1WorkflowsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger Workflow Step
     * @param {string} workflowId 
     * @param {string} stepId 
     * @param {WorkflowStepTriggerRequest} workflowStepTriggerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId: string, stepId: string, workflowStepTriggerRequest: WorkflowStepTriggerRequest, options?: any) {
        return WorkflowsApiFp(this.configuration).triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Workflow
     * @param {string} workflowId 
     * @param {WorkflowCore} workflowCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public updateWorkflowV1WorkflowsWorkflowIdPut(workflowId: string, workflowCore: WorkflowCore, options?: any) {
        return WorkflowsApiFp(this.configuration).updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WorkflowsApiHubspotApi - axios parameter creator
 * @export
 */
export const WorkflowsApiHubspotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Handle Hubspot Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/workflows/api/hubspot/webhook`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsApiHubspotApi - functional programming interface
 * @export
 */
export const WorkflowsApiHubspotApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Handle Hubspot Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await WorkflowsApiHubspotApiAxiosParamCreator(configuration).handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkflowsApiHubspotApi - factory interface
 * @export
 */
export const WorkflowsApiHubspotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Handle Hubspot Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options?: any): AxiosPromise<AgenticWorkflowModelsBaseBaseResponse> {
            return WorkflowsApiHubspotApiFp(configuration).handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsApiHubspotApi - object-oriented interface
 * @export
 * @class WorkflowsApiHubspotApi
 * @extends {BaseAPI}
 */
export class WorkflowsApiHubspotApi extends BaseAPI {
    /**
     * 
     * @summary Handle Hubspot Webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApiHubspotApi
     */
    public handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options?: any) {
        return WorkflowsApiHubspotApiFp(this.configuration).handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WorkflowsAppsApi - axios parameter creator
 * @export
 */
export const WorkflowsAppsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create App
         * @param {AppEntity} appEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAppV1WorkflowsAppsPost: async (appEntity: AppEntity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appEntity' is not null or undefined
            if (appEntity === null || appEntity === undefined) {
                throw new RequiredError('appEntity','Required parameter appEntity was null or undefined when calling createAppV1WorkflowsAppsPost.');
            }
            const localVarPath = `/v1/workflows/apps/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof appEntity !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(appEntity !== undefined ? appEntity : {}) : (appEntity || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete App
         * @param {string} appId 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppV1WorkflowsAppsAppIdDelete: async (appId: string, version?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling deleteAppV1WorkflowsAppsAppIdDelete.');
            }
            const localVarPath = `/v1/workflows/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Connections By App Id
         * @param {string} appId 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet: async (appId: string, version: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet.');
            }
            const localVarPath = `/v1/workflows/apps/{app_id}/versions/{version}/connections`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read App
         * @param {string} appId 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppV1WorkflowsAppsAppIdGet: async (appId: string, version?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling readAppV1WorkflowsAppsAppIdGet.');
            }
            const localVarPath = `/v1/workflows/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Apps
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppsV1WorkflowsAppsGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/workflows/apps/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update App
         * @param {string} appId 
         * @param {AppEntity} appEntity 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppV1WorkflowsAppsAppIdPut: async (appId: string, appEntity: AppEntity, version?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling updateAppV1WorkflowsAppsAppIdPut.');
            }
            // verify required parameter 'appEntity' is not null or undefined
            if (appEntity === null || appEntity === undefined) {
                throw new RequiredError('appEntity','Required parameter appEntity was null or undefined when calling updateAppV1WorkflowsAppsAppIdPut.');
            }
            const localVarPath = `/v1/workflows/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof appEntity !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(appEntity !== undefined ? appEntity : {}) : (appEntity || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsAppsApi - functional programming interface
 * @export
 */
export const WorkflowsAppsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create App
         * @param {AppEntity} appEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAppV1WorkflowsAppsPost(appEntity: AppEntity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppResponse>> {
            const localVarAxiosArgs = await WorkflowsAppsApiAxiosParamCreator(configuration).createAppV1WorkflowsAppsPost(appEntity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete App
         * @param {string} appId 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAppV1WorkflowsAppsAppIdDelete(appId: string, version?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await WorkflowsAppsApiAxiosParamCreator(configuration).deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Connections By App Id
         * @param {string} appId 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId: string, version: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConnectionCore>>> {
            const localVarAxiosArgs = await WorkflowsAppsApiAxiosParamCreator(configuration).getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Read App
         * @param {string} appId 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readAppV1WorkflowsAppsAppIdGet(appId: string, version?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppResponse>> {
            const localVarAxiosArgs = await WorkflowsAppsApiAxiosParamCreator(configuration).readAppV1WorkflowsAppsAppIdGet(appId, version, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Read Apps
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readAppsV1WorkflowsAppsGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AppResponse>>> {
            const localVarAxiosArgs = await WorkflowsAppsApiAxiosParamCreator(configuration).readAppsV1WorkflowsAppsGet(skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update App
         * @param {string} appId 
         * @param {AppEntity} appEntity 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAppV1WorkflowsAppsAppIdPut(appId: string, appEntity: AppEntity, version?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppResponse>> {
            const localVarAxiosArgs = await WorkflowsAppsApiAxiosParamCreator(configuration).updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkflowsAppsApi - factory interface
 * @export
 */
export const WorkflowsAppsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create App
         * @param {AppEntity} appEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAppV1WorkflowsAppsPost(appEntity: AppEntity, options?: any): AxiosPromise<AppResponse> {
            return WorkflowsAppsApiFp(configuration).createAppV1WorkflowsAppsPost(appEntity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete App
         * @param {string} appId 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppV1WorkflowsAppsAppIdDelete(appId: string, version?: string, options?: any): AxiosPromise<AgenticWorkflowModelsBaseBaseResponse> {
            return WorkflowsAppsApiFp(configuration).deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Connections By App Id
         * @param {string} appId 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId: string, version: string, options?: any): AxiosPromise<Array<ConnectionCore>> {
            return WorkflowsAppsApiFp(configuration).getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read App
         * @param {string} appId 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppV1WorkflowsAppsAppIdGet(appId: string, version?: string, options?: any): AxiosPromise<AppResponse> {
            return WorkflowsAppsApiFp(configuration).readAppV1WorkflowsAppsAppIdGet(appId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Apps
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppsV1WorkflowsAppsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<AppResponse>> {
            return WorkflowsAppsApiFp(configuration).readAppsV1WorkflowsAppsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update App
         * @param {string} appId 
         * @param {AppEntity} appEntity 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppV1WorkflowsAppsAppIdPut(appId: string, appEntity: AppEntity, version?: string, options?: any): AxiosPromise<AppResponse> {
            return WorkflowsAppsApiFp(configuration).updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsAppsApi - object-oriented interface
 * @export
 * @class WorkflowsAppsApi
 * @extends {BaseAPI}
 */
export class WorkflowsAppsApi extends BaseAPI {
    /**
     * 
     * @summary Create App
     * @param {AppEntity} appEntity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    public createAppV1WorkflowsAppsPost(appEntity: AppEntity, options?: any) {
        return WorkflowsAppsApiFp(this.configuration).createAppV1WorkflowsAppsPost(appEntity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete App
     * @param {string} appId 
     * @param {string} [version] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    public deleteAppV1WorkflowsAppsAppIdDelete(appId: string, version?: string, options?: any) {
        return WorkflowsAppsApiFp(this.configuration).deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Connections By App Id
     * @param {string} appId 
     * @param {string} version 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    public getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId: string, version: string, options?: any) {
        return WorkflowsAppsApiFp(this.configuration).getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read App
     * @param {string} appId 
     * @param {string} [version] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    public readAppV1WorkflowsAppsAppIdGet(appId: string, version?: string, options?: any) {
        return WorkflowsAppsApiFp(this.configuration).readAppV1WorkflowsAppsAppIdGet(appId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Apps
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    public readAppsV1WorkflowsAppsGet(skip?: number, limit?: number, options?: any) {
        return WorkflowsAppsApiFp(this.configuration).readAppsV1WorkflowsAppsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update App
     * @param {string} appId 
     * @param {AppEntity} appEntity 
     * @param {string} [version] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    public updateAppV1WorkflowsAppsAppIdPut(appId: string, appEntity: AppEntity, version?: string, options?: any) {
        return WorkflowsAppsApiFp(this.configuration).updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WorkflowsConnectionsApi - axios parameter creator
 * @export
 */
export const WorkflowsConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Connection
         * @param {ConnectionCore} connectionCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectionV1WorkflowsConnectionsPost: async (connectionCore: ConnectionCore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionCore' is not null or undefined
            if (connectionCore === null || connectionCore === undefined) {
                throw new RequiredError('connectionCore','Required parameter connectionCore was null or undefined when calling createConnectionV1WorkflowsConnectionsPost.');
            }
            const localVarPath = `/v1/workflows/connections/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof connectionCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(connectionCore !== undefined ? connectionCore : {}) : (connectionCore || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectionV1WorkflowsConnectionsConnectionIdDelete: async (connectionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            if (connectionId === null || connectionId === undefined) {
                throw new RequiredError('connectionId','Required parameter connectionId was null or undefined when calling deleteConnectionV1WorkflowsConnectionsConnectionIdDelete.');
            }
            const localVarPath = `/v1/workflows/connections/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionV1WorkflowsConnectionsConnectionIdGet: async (connectionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            if (connectionId === null || connectionId === undefined) {
                throw new RequiredError('connectionId','Required parameter connectionId was null or undefined when calling readConnectionV1WorkflowsConnectionsConnectionIdGet.');
            }
            const localVarPath = `/v1/workflows/connections/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Connections
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionsV1WorkflowsConnectionsGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/workflows/connections/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Connection
         * @param {string} connectionId 
         * @param {ConnectionCore} connectionCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnectionV1WorkflowsConnectionsConnectionIdPut: async (connectionId: string, connectionCore: ConnectionCore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            if (connectionId === null || connectionId === undefined) {
                throw new RequiredError('connectionId','Required parameter connectionId was null or undefined when calling updateConnectionV1WorkflowsConnectionsConnectionIdPut.');
            }
            // verify required parameter 'connectionCore' is not null or undefined
            if (connectionCore === null || connectionCore === undefined) {
                throw new RequiredError('connectionCore','Required parameter connectionCore was null or undefined when calling updateConnectionV1WorkflowsConnectionsConnectionIdPut.');
            }
            const localVarPath = `/v1/workflows/connections/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof connectionCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(connectionCore !== undefined ? connectionCore : {}) : (connectionCore || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsConnectionsApi - functional programming interface
 * @export
 */
export const WorkflowsConnectionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Connection
         * @param {ConnectionCore} connectionCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnectionV1WorkflowsConnectionsPost(connectionCore: ConnectionCore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowDbModelsConnection>> {
            const localVarAxiosArgs = await WorkflowsConnectionsApiAxiosParamCreator(configuration).createConnectionV1WorkflowsConnectionsPost(connectionCore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await WorkflowsConnectionsApiAxiosParamCreator(configuration).deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Read Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowDbModelsConnection>> {
            const localVarAxiosArgs = await WorkflowsConnectionsApiAxiosParamCreator(configuration).readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Read Connections
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readConnectionsV1WorkflowsConnectionsGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AgenticWorkflowDbModelsConnection>>> {
            const localVarAxiosArgs = await WorkflowsConnectionsApiAxiosParamCreator(configuration).readConnectionsV1WorkflowsConnectionsGet(skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update Connection
         * @param {string} connectionId 
         * @param {ConnectionCore} connectionCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId: string, connectionCore: ConnectionCore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowDbModelsConnection>> {
            const localVarAxiosArgs = await WorkflowsConnectionsApiAxiosParamCreator(configuration).updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkflowsConnectionsApi - factory interface
 * @export
 */
export const WorkflowsConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create Connection
         * @param {ConnectionCore} connectionCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectionV1WorkflowsConnectionsPost(connectionCore: ConnectionCore, options?: any): AxiosPromise<AgenticWorkflowDbModelsConnection> {
            return WorkflowsConnectionsApiFp(configuration).createConnectionV1WorkflowsConnectionsPost(connectionCore, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId: string, options?: any): AxiosPromise<AgenticWorkflowModelsBaseBaseResponse> {
            return WorkflowsConnectionsApiFp(configuration).deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId: string, options?: any): AxiosPromise<AgenticWorkflowDbModelsConnection> {
            return WorkflowsConnectionsApiFp(configuration).readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Connections
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionsV1WorkflowsConnectionsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<AgenticWorkflowDbModelsConnection>> {
            return WorkflowsConnectionsApiFp(configuration).readConnectionsV1WorkflowsConnectionsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Connection
         * @param {string} connectionId 
         * @param {ConnectionCore} connectionCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId: string, connectionCore: ConnectionCore, options?: any): AxiosPromise<AgenticWorkflowDbModelsConnection> {
            return WorkflowsConnectionsApiFp(configuration).updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsConnectionsApi - object-oriented interface
 * @export
 * @class WorkflowsConnectionsApi
 * @extends {BaseAPI}
 */
export class WorkflowsConnectionsApi extends BaseAPI {
    /**
     * 
     * @summary Create Connection
     * @param {ConnectionCore} connectionCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    public createConnectionV1WorkflowsConnectionsPost(connectionCore: ConnectionCore, options?: any) {
        return WorkflowsConnectionsApiFp(this.configuration).createConnectionV1WorkflowsConnectionsPost(connectionCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Connection
     * @param {string} connectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    public deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId: string, options?: any) {
        return WorkflowsConnectionsApiFp(this.configuration).deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Connection
     * @param {string} connectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    public readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId: string, options?: any) {
        return WorkflowsConnectionsApiFp(this.configuration).readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Connections
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    public readConnectionsV1WorkflowsConnectionsGet(skip?: number, limit?: number, options?: any) {
        return WorkflowsConnectionsApiFp(this.configuration).readConnectionsV1WorkflowsConnectionsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Connection
     * @param {string} connectionId 
     * @param {ConnectionCore} connectionCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    public updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId: string, connectionCore: ConnectionCore, options?: any) {
        return WorkflowsConnectionsApiFp(this.configuration).updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WorkflowsExecutionsApi - axios parameter creator
 * @export
 */
export const WorkflowsExecutionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Execute a workflow. This is an Sync call. This returns the status of the workflow
         * @summary Execute Workflow
         * @param {string} workflowId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost: async (workflowId: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost.');
            }
            const localVarPath = `/v1/workflows/executions/{workflow_id}/execute`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status of a workflow given the run id
         * @summary Get Workflow Status
         * @param {string} runId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet: async (runId: string, workflowId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet.');
            }
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet.');
            }
            const localVarPath = `/v1/workflows/executions/{workflow_id}/runs/{run_id}`
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)))
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Workflow Runs
         * @param {string} workflowId 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet: async (workflowId: string, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet.');
            }
            const localVarPath = `/v1/workflows/executions/{workflow_id}/runs`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger a workflow execution. This is an Async call. This returns a workflow id which can be queried to get the status of the workflow
         * @summary Trigger Workflow
         * @param {string} workflowId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost: async (workflowId: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost.');
            }
            const localVarPath = `/v1/workflows/executions/{workflow_id}/trigger`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsExecutionsApi - functional programming interface
 * @export
 */
export const WorkflowsExecutionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Execute a workflow. This is an Sync call. This returns the status of the workflow
         * @summary Execute Workflow
         * @param {string} workflowId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowExecution>> {
            const localVarAxiosArgs = await WorkflowsExecutionsApiAxiosParamCreator(configuration).executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the status of a workflow given the run id
         * @summary Get Workflow Status
         * @param {string} runId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId: string, workflowId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowExecution>> {
            const localVarAxiosArgs = await WorkflowsExecutionsApiAxiosParamCreator(configuration).getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Workflow Runs
         * @param {string} workflowId 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId: string, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowExecution>>> {
            const localVarAxiosArgs = await WorkflowsExecutionsApiAxiosParamCreator(configuration).listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Trigger a workflow execution. This is an Async call. This returns a workflow id which can be queried to get the status of the workflow
         * @summary Trigger Workflow
         * @param {string} workflowId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowExecution>> {
            const localVarAxiosArgs = await WorkflowsExecutionsApiAxiosParamCreator(configuration).triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkflowsExecutionsApi - factory interface
 * @export
 */
export const WorkflowsExecutionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Execute a workflow. This is an Sync call. This returns the status of the workflow
         * @summary Execute Workflow
         * @param {string} workflowId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId: string, body: object, options?: any): AxiosPromise<WorkflowExecution> {
            return WorkflowsExecutionsApiFp(configuration).executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status of a workflow given the run id
         * @summary Get Workflow Status
         * @param {string} runId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId: string, workflowId: string, options?: any): AxiosPromise<WorkflowExecution> {
            return WorkflowsExecutionsApiFp(configuration).getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Workflow Runs
         * @param {string} workflowId 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId: string, skip?: number, limit?: number, options?: any): AxiosPromise<Array<WorkflowExecution>> {
            return WorkflowsExecutionsApiFp(configuration).listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger a workflow execution. This is an Async call. This returns a workflow id which can be queried to get the status of the workflow
         * @summary Trigger Workflow
         * @param {string} workflowId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId: string, body: object, options?: any): AxiosPromise<WorkflowExecution> {
            return WorkflowsExecutionsApiFp(configuration).triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsExecutionsApi - object-oriented interface
 * @export
 * @class WorkflowsExecutionsApi
 * @extends {BaseAPI}
 */
export class WorkflowsExecutionsApi extends BaseAPI {
    /**
     * Execute a workflow. This is an Sync call. This returns the status of the workflow
     * @summary Execute Workflow
     * @param {string} workflowId 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsExecutionsApi
     */
    public executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId: string, body: object, options?: any) {
        return WorkflowsExecutionsApiFp(this.configuration).executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the status of a workflow given the run id
     * @summary Get Workflow Status
     * @param {string} runId 
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsExecutionsApi
     */
    public getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId: string, workflowId: string, options?: any) {
        return WorkflowsExecutionsApiFp(this.configuration).getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Workflow Runs
     * @param {string} workflowId 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsExecutionsApi
     */
    public listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId: string, skip?: number, limit?: number, options?: any) {
        return WorkflowsExecutionsApiFp(this.configuration).listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger a workflow execution. This is an Async call. This returns a workflow id which can be queried to get the status of the workflow
     * @summary Trigger Workflow
     * @param {string} workflowId 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsExecutionsApi
     */
    public triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId: string, body: object, options?: any) {
        return WorkflowsExecutionsApiFp(this.configuration).triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WorkflowsSubWorkflowsApi - axios parameter creator
 * @export
 */
export const WorkflowsSubWorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all sub workflows which can be invoked for a given workflow step
         * @summary Get Sub Workflows
         * @param {WorkflowStepInput} workflowStepInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost: async (workflowStepInput: WorkflowStepInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowStepInput' is not null or undefined
            if (workflowStepInput === null || workflowStepInput === undefined) {
                throw new RequiredError('workflowStepInput','Required parameter workflowStepInput was null or undefined when calling getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost.');
            }
            const localVarPath = `/v1/workflows/steps/sub_workflows`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof workflowStepInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(workflowStepInput !== undefined ? workflowStepInput : {}) : (workflowStepInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsSubWorkflowsApi - functional programming interface
 * @export
 */
export const WorkflowsSubWorkflowsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns all sub workflows which can be invoked for a given workflow step
         * @summary Get Sub Workflows
         * @param {WorkflowStepInput} workflowStepInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput: WorkflowStepInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workflow>>> {
            const localVarAxiosArgs = await WorkflowsSubWorkflowsApiAxiosParamCreator(configuration).getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkflowsSubWorkflowsApi - factory interface
 * @export
 */
export const WorkflowsSubWorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns all sub workflows which can be invoked for a given workflow step
         * @summary Get Sub Workflows
         * @param {WorkflowStepInput} workflowStepInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput: WorkflowStepInput, options?: any): AxiosPromise<Array<Workflow>> {
            return WorkflowsSubWorkflowsApiFp(configuration).getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsSubWorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsSubWorkflowsApi
 * @extends {BaseAPI}
 */
export class WorkflowsSubWorkflowsApi extends BaseAPI {
    /**
     * Returns all sub workflows which can be invoked for a given workflow step
     * @summary Get Sub Workflows
     * @param {WorkflowStepInput} workflowStepInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsSubWorkflowsApi
     */
    public getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput: WorkflowStepInput, options?: any) {
        return WorkflowsSubWorkflowsApiFp(this.configuration).getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options).then((request) => request(this.axios, this.basePath));
    }

}


