// tslint:disable
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as globalImportUrl from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 *
 * @export
 * @interface AIAgentInput
 */
export interface AIAgentInput {
  /**
   * Name of the AI agent
   * @type {string}
   * @memberof AIAgentInput
   */
  name?: string;
  /**
   * Image URL for the AI agent
   * @type {string}
   * @memberof AIAgentInput
   */
  imageUrl?: string;
  /**
   * Mission of the AI agent
   * @type {Mission}
   * @memberof AIAgentInput
   */
  mission?: Mission | null;
  /**
   *
   * @type {Status}
   * @memberof AIAgentInput
   */
  status: Status;
  /**
   * Role of the AI agent in the company
   * @type {string}
   * @memberof AIAgentInput
   */
  role?: string;
  /**
   * Description of the role of the AI agent
   * @type {string}
   * @memberof AIAgentInput
   */
  roleDescription?: string;
  /**
   *
   * @type {VoiceInput}
   * @memberof AIAgentInput
   */
  voice: VoiceInput | null;
}
/**
 * AI agent configured by businesses
 * @export
 * @interface AIAgentOutput
 */
export interface AIAgentOutput {
  /**
   *
   * @type {string}
   * @memberof AIAgentOutput
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof AIAgentOutput
   */
  orgId?: string;
  /**
   *
   * @type {string}
   * @memberof AIAgentOutput
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof AIAgentOutput
   */
  imageUrl?: string;
  /**
   *
   * @type {Mission}
   * @memberof AIAgentOutput
   */
  mission: Mission | null;
  /**
   *
   * @type {string}
   * @memberof AIAgentOutput
   */
  role?: string;
  /**
   *
   * @type {string}
   * @memberof AIAgentOutput
   */
  roleDescription?: string;
  /**
   *
   * @type {Transcriber}
   * @memberof AIAgentOutput
   */
  transcriber: Transcriber | null;
  /**
   *
   * @type {IntelligenceProvider}
   * @memberof AIAgentOutput
   */
  intelligenceProvider: IntelligenceProvider | null;
  /**
   *
   * @type {VoiceOutput}
   * @memberof AIAgentOutput
   */
  voice: VoiceOutput | null;
  /**
   *
   * @type {string}
   * @memberof AIAgentOutput
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof AIAgentOutput
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof AIAgentOutput
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof AIAgentOutput
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof AIAgentOutput
   */
  updatedAt?: string;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum Accent {
  American = "American",
  Indian = "Indian",
}

/**
 *
 * @export
 * @interface Address
 */
export interface Address {
  /**
   * Address line 1
   * @type {string}
   * @memberof Address
   */
  line1?: string;
  /**
   * Address line 2
   * @type {string}
   * @memberof Address
   */
  line2?: string | null;
  /**
   * City
   * @type {string}
   * @memberof Address
   */
  city?: string | null;
  /**
   * State
   * @type {string}
   * @memberof Address
   */
  state?: string | null;
  /**
   * Country
   * @type {string}
   * @memberof Address
   */
  country?: string;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum AggregationFormula {
  COUNT = "COUNT",
  SUM = "SUM",
  MEDIAN = "MEDIAN",
}

/**
 *
 * @export
 * @enum {string}
 */
export enum AggregationPeriod {
  MONTHLY = "MONTHLY",
  WEEKLY = "WEEKLY",
  DAILY = "DAILY",
}

/**
 *
 * @export
 * @interface BaseResponse
 */
export interface BaseResponse {
  /**
   * Address line 1
   * @type {string}
   * @memberof BaseResponse
   */
  message?: string;
}
/**
 *
 * @export
 * @interface BatchMetricsRequests
 */
export interface BatchMetricsRequests {
  /**
   *
   * @type {Array<MetricsRequest>}
   * @memberof BatchMetricsRequests
   */
  requests: Array<MetricsRequest>;
}
/**
 *
 * @export
 * @interface BatchMetricsResponse
 */
export interface BatchMetricsResponse {
  /**
   *
   * @type {Array<MetricsResponse>}
   * @memberof BatchMetricsResponse
   */
  responses: Array<MetricsResponse>;
}
/**
 *
 * @export
 * @interface BodyCreateOrganizationV1
 */
export interface BodyCreateOrganizationV1 {
  /**
   *
   * @type {Organization}
   * @memberof BodyCreateOrganizationV1
   */
  org: Organization;
  /**
   *
   * @type {string}
   * @memberof BodyCreateOrganizationV1
   */
  adminUserName: string;
}
/**
 *
 * @export
 * @interface Comment
 */
export interface Comment {
  /**
   * Notes or comments to record
   * @type {string}
   * @memberof Comment
   */
  comment?: string;
  /**
   * Star rating to record
   * @type {number}
   * @memberof Comment
   */
  rating?: number;
}
/**
 * Connection id string
 * @export
 * @interface Connection
 */
export interface Connection {
  /**
   *
   * @type {string}
   * @memberof Connection
   */
  id: string;
  /**
   *
   * @type {ConnectionType}
   * @memberof Connection
   */
  type: ConnectionType;
}
/**
 *
 * @export
 * @interface ConnectionSource
 */
export interface ConnectionSource {
  /**
   * Name of the source
   * @type {string}
   * @memberof ConnectionSource
   */
  sourceName?: string;
  /**
   * Unique identifier for the source
   * @type {string}
   * @memberof ConnectionSource
   */
  sourceId?: string;
  /**
   * Extra properties of source
   * @type {object}
   * @memberof ConnectionSource
   */
  sourceProps?: object;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum ConnectionType {
  Socket = "socket",
}

/**
 *
 * @export
 * @interface ConversationAnalytics
 */
export interface ConversationAnalytics {
  /**
   * Overall sentiment of the conversation
   * @type {Sentiment}
   * @memberof ConversationAnalytics
   */
  sentiment?: Sentiment;
  /**
   * Had any repetitive conversations or not as part of the request
   * @type {boolean}
   * @memberof ConversationAnalytics
   */
  repetitions?: boolean;
  /**
   * List of timestamps when the user interrupted the AI agent
   * @type {Array<string>}
   * @memberof ConversationAnalytics
   */
  backChannels?: Array<string> | null;
  /**
   * Hallucination analysis of the conversation
   * @type {object}
   * @memberof ConversationAnalytics
   */
  hallucinationAnalysis?: object | null;
}
/**
 * Any feedback added to the conversation by business is managed here.
 * @export
 * @interface ConversationFeedback
 */
export interface ConversationFeedback {
  /**
   *
   * @type {string}
   * @memberof ConversationFeedback
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ConversationFeedback
   */
  orgId?: string;
  /**
   *
   * @type {string}
   * @memberof ConversationFeedback
   */
  conversationId?: string;
  /**
   *
   * @type {string}
   * @memberof ConversationFeedback
   */
  feedback?: string;
  /**
   *
   * @type {number}
   * @memberof ConversationFeedback
   */
  rating?: number;
  /**
   *
   * @type {string}
   * @memberof ConversationFeedback
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof ConversationFeedback
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof ConversationFeedback
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof ConversationFeedback
   */
  updatedAt?: string;
}
/**
 *
 * @export
 * @interface ConversationInput
 */
export interface ConversationInput {
  /**
   * Source from where the conversation originated. This can be device id, phone number, etc.
   * @type {string}
   * @memberof ConversationInput
   */
  source?: string;
  /**
   * Type of the conversation source
   * @type {ConversationSourceType}
   * @memberof ConversationInput
   */
  sourceType?: ConversationSourceType;
  /**
   * AI agent which handled the conversation
   * @type {string}
   * @memberof ConversationInput
   */
  agentId?: string;
  /**
   * URL to the full transcript of the conversation
   * @type {string}
   * @memberof ConversationInput
   */
  transcriptTextUrl?: string | null;
  /**
   * Summary of the conversation
   * @type {string}
   * @memberof ConversationInput
   */
  transcriptSummary?: string | null;
  /**
   * URL to the recording of the conversation
   * @type {string}
   * @memberof ConversationInput
   */
  transcriptRecordingUrl?: string | null;
  /**
   * Start time of the conversation
   * @type {string}
   * @memberof ConversationInput
   */
  timestampStart?: string;
  /**
   * End time of the conversation
   * @type {string}
   * @memberof ConversationInput
   */
  timestampEnd?: string | null;
  /**
   * Analytics of the conversation
   * @type {ConversationAnalytics}
   * @memberof ConversationInput
   */
  conversationAnalytics?: ConversationAnalytics | null;
  /**
   *
   * @type {Status}
   * @memberof ConversationInput
   */
  status: Status;
  /**
   *
   * @type {Array<Comment>}
   * @memberof ConversationInput
   */
  adminComments: Array<Comment>;
}
/**
 * Any conversation happening between the end user and assistant is stored in this table
 * @export
 * @interface ConversationOutput
 */
export interface ConversationOutput {
  /**
   *
   * @type {string}
   * @memberof ConversationOutput
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ConversationOutput
   */
  orgId?: string;
  /**
   *
   * @type {string}
   * @memberof ConversationOutput
   */
  prospectId?: string | null;
  /**
   *
   * @type {string}
   * @memberof ConversationOutput
   */
  source?: string;
  /**
   *
   * @type {string}
   * @memberof ConversationOutput
   */
  sourceType?: string;
  /**
   *
   * @type {string}
   * @memberof ConversationOutput
   */
  aiAgentId?: string;
  /**
   *
   * @type {string}
   * @memberof ConversationOutput
   */
  transcriptTextUrl?: string | null;
  /**
   *
   * @type {string}
   * @memberof ConversationOutput
   */
  transcriptSummary?: string | null;
  /**
   *
   * @type {string}
   * @memberof ConversationOutput
   */
  transcriptRecordingUrl?: string | null;
  /**
   *
   * @type {string}
   * @memberof ConversationOutput
   */
  timestampStart?: string;
  /**
   *
   * @type {string}
   * @memberof ConversationOutput
   */
  timestampEnd?: string | null;
  /**
   * Analytics of the conversation
   * @type {ConversationAnalytics}
   * @memberof ConversationOutput
   */
  conversationAnalytics?: ConversationAnalytics | null;
  /**
   *
   * @type {string}
   * @memberof ConversationOutput
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof ConversationOutput
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof ConversationOutput
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof ConversationOutput
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof ConversationOutput
   */
  updatedAt?: string;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum ConversationSourceType {
  VOIP = "VOIP",
  PHONE = "PHONE",
}

/**
 *
 * @export
 * @interface ExternalReference
 */
export interface ExternalReference {
  /**
   * External service provider name
   * @type {string}
   * @memberof ExternalReference
   */
  providerName?: string;
  /**
   * External service identifier
   * @type {string}
   * @memberof ExternalReference
   */
  id?: string;
  /**
   * Props for the external reference
   * @type {any}
   * @memberof ExternalReference
   */
  providerProps?: any | null;
}
/**
 *
 * @export
 * @interface ExternalServicePorvider
 */
export interface ExternalServicePorvider {
  /**
   * External service provider name
   * @type {string}
   * @memberof ExternalServicePorvider
   */
  providerName?: string;
  /**
   * External service identifier
   * @type {string}
   * @memberof ExternalServicePorvider
   */
  id?: string;
  /**
   * Props for the external service provider
   * @type {object}
   * @memberof ExternalServicePorvider
   */
  providerProps?: object | null;
}
/**
 * Guest users who are not verified by Trata yet
 * @export
 * @interface GuestInput
 */
export interface GuestInput {
  /**
   *
   * @type {string}
   * @memberof GuestInput
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof GuestInput
   */
  role: string;
}
/**
 * Guest users who are not verified by Trata yet. They will not be able to use Trata until they are verified.
 * @export
 * @interface GuestOutput
 */
export interface GuestOutput {
  /**
   *
   * @type {string}
   * @memberof GuestOutput
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof GuestOutput
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof GuestOutput
   */
  orgId?: string;
  /**
   *
   * @type {string}
   * @memberof GuestOutput
   */
  role?: string;
  /**
   *
   * @type {boolean}
   * @memberof GuestOutput
   */
  isEmailVerified?: boolean;
  /**
   *
   * @type {string}
   * @memberof GuestOutput
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof GuestOutput
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof GuestOutput
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof GuestOutput
   */
  updatedAt?: string;
}
/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
  /**
   *
   * @type {Array<ValidationError>}
   * @memberof HTTPValidationError
   */
  detail?: Array<ValidationError>;
}
/**
 * Reference to all business knowledge base will be stored in Hive
 * @export
 * @interface Hive
 */
export interface Hive {
  /**
   *
   * @type {string}
   * @memberof Hive
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Hive
   */
  orgId?: string;
  /**
   *
   * @type {HiveContent}
   * @memberof Hive
   */
  content: HiveContent;
  /**
   *
   * @type {string}
   * @memberof Hive
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof Hive
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Hive
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof Hive
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof Hive
   */
  updatedAt?: string;
}
/**
 *
 * @export
 * @interface HiveContent
 */
export interface HiveContent {
  /**
   *
   * @type {HiveType}
   * @memberof HiveContent
   */
  hiveType: HiveType;
  /**
   * URL of the content
   * @type {string}
   * @memberof HiveContent
   */
  url?: string;
  /**
   * To recursively crawl child pages, add this as props {\"crawl_child_pages\": true}
   * @type {object}
   * @memberof HiveContent
   */
  hiveProps?: object | null;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum HiveType {
  WEBSITE = "WEBSITE",
  GOOGLEDOCS = "GOOGLE_DOCS",
  DOCS = "DOCS",
  TRANSCRIPTS = "TRANSCRIPTS",
}

/**
 *
 * @export
 * @interface IntelligenceProvider
 */
export interface IntelligenceProvider {
  /**
   *
   * @type {string}
   * @memberof IntelligenceProvider
   */
  providerName?: string | null;
  /**
   *
   * @type {string}
   * @memberof IntelligenceProvider
   */
  model?: string | null;
  /**
   *
   * @type {object}
   * @memberof IntelligenceProvider
   */
  providerProps?: object | null;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum Language {
  English = "English",
  Spanish = "Spanish",
}

/**
 *
 * @export
 * @interface LanguageAccentCombo
 */
export interface LanguageAccentCombo {
  /**
   *
   * @type {Language}
   * @memberof LanguageAccentCombo
   */
  language: Language;
  /**
   *
   * @type {Accent}
   * @memberof LanguageAccentCombo
   */
  accent: Accent;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum MetricName {
  CALLS = "CALLS",
  CALLDURATION = "CALL_DURATION",
  APPOINTMENTSCHEDULED = "APPOINTMENT_SCHEDULED",
  PROSPECTS = "PROSPECTS",
  INTERESTED = "INTERESTED",
  NOTINTERESTED = "NOT_INTERESTED",
}

/**
 *
 * @export
 * @interface MetricResponseDataPoint
 */
export interface MetricResponseDataPoint {
  /**
   * Timestamp of the data point
   * @type {string}
   * @memberof MetricResponseDataPoint
   */
  timestamp?: string;
  /**
   * Value which will be a string representation of integer or floating number
   * @type {string}
   * @memberof MetricResponseDataPoint
   */
  value?: string;
}
/**
 *
 * @export
 * @interface MetricsRequest
 */
export interface MetricsRequest {
  /**
   * Unique identifier for the metric request. This can be helped to co-relate the request and response
   * @type {string}
   * @memberof MetricsRequest
   */
  id?: string;
  /**
   * Name of the metric
   * @type {MetricName}
   * @memberof MetricsRequest
   */
  name?: MetricName;
  /**
   * Start date to get metric request
   * @type {string}
   * @memberof MetricsRequest
   */
  fromDate?: string;
  /**
   * End date until get metric request
   * @type {string}
   * @memberof MetricsRequest
   */
  toDate?: string;
  /**
   * Aggregation period for the metric request
   * @type {AggregationPeriod}
   * @memberof MetricsRequest
   */
  aggregationPeriod?: AggregationPeriod;
  /**
   * Aggregation formula for the metric request
   * @type {AggregationFormula}
   * @memberof MetricsRequest
   */
  aggregationFormula?: AggregationFormula;
}
/**
 *
 * @export
 * @interface MetricsResponse
 */
export interface MetricsResponse {
  /**
   * Unique identifier for the metric response. This will help co-relate the request and response
   * @type {string}
   * @memberof MetricsResponse
   */
  id?: string;
  /**
   * Name of the metric
   * @type {MetricName}
   * @memberof MetricsResponse
   */
  name?: MetricName;
  /**
   * List of data points for the metric response
   * @type {Array<MetricResponseDataPoint>}
   * @memberof MetricsResponse
   */
  datapoints?: Array<MetricResponseDataPoint>;
}
/**
 *
 * @export
 * @interface Mission
 */
export interface Mission {
  /**
   * Prompt instructions for LLM model
   * @type {string}
   * @memberof Mission
   */
  prompt?: string;
  /**
   * Greeting message to be read by the AI agent
   * @type {string}
   * @memberof Mission
   */
  greeting?: string | null;
  /**
   * Sequence of actions to be performed by the AI agent during the conversation.
   * @type {Array<Sequence>}
   * @memberof Mission
   */
  sequence?: Array<Sequence>;
  /**
   * Conclusion message to be read by the AI agent
   * @type {string}
   * @memberof Mission
   */
  conclusion?: string | null;
}
/**
 * Organization represents the business using Trata and all users are associated to this business entity
 * @export
 * @interface Organization
 */
export interface Organization {
  /**
   * Name of the organization
   * @type {string}
   * @memberof Organization
   */
  name?: string;
  /**
   * Address of the organization
   * @type {Address}
   * @memberof Organization
   */
  address?: Address | null;
  /**
   * Tax details of the organization
   * @type {TaxDetails}
   * @memberof Organization
   */
  tax?: TaxDetails | null;
  /**
   * External references for the organization
   * @type {Array<ExternalServicePorvider>}
   * @memberof Organization
   */
  externalReferenceIds?: Array<ExternalServicePorvider> | null;
}
/**
 *
 * @export
 * @interface ProductInput
 */
export interface ProductInput {
  /**
   * Product is active or not
   * @type {boolean}
   * @memberof ProductInput
   */
  active?: boolean;
  /**
   * Default price of the product this is represented in the lowest currency denomination. Eg: 1000 for $10
   * @type {number}
   * @memberof ProductInput
   */
  defaultPrice?: number;
  /**
   * Currency of the product
   * @type {string}
   * @memberof ProductInput
   */
  currency?: ProductInputCurrencyEnum;
  /**
   * Description of the product
   * @type {string}
   * @memberof ProductInput
   */
  description?: string;
  /**
   * Name of the product
   * @type {string}
   * @memberof ProductInput
   */
  name?: string;
  /**
   * Product is shippable or not. Service is not shippable
   * @type {boolean}
   * @memberof ProductInput
   */
  shippable?: boolean;
  /**
   * List of features of the product
   * @type {Array<string>}
   * @memberof ProductInput
   */
  features?: Array<string> | null;
  /**
   * Product requires appointment scheduling or not
   * @type {boolean}
   * @memberof ProductInput
   */
  scheduleAppointment?: boolean;
  /**
   * Properties of the product
   * @type {any}
   * @memberof ProductInput
   */
  props?: any | null;
  /**
   * Tags for the product. This is used for grouping purpose. Eg: [\"gardening\", \"tools\"]
   * @type {Array<string>}
   * @memberof ProductInput
   */
  tags?: Array<string> | null;
  /**
   *
   * @type {Status}
   * @memberof ProductInput
   */
  status: Status;
}

/**
 * @export
 * @enum {string}
 */
export enum ProductInputCurrencyEnum {
  AED = "AED",
  AFN = "AFN",
  ALL = "ALL",
  AMD = "AMD",
  ANG = "ANG",
  AOA = "AOA",
  ARS = "ARS",
  AUD = "AUD",
  AWG = "AWG",
  AZN = "AZN",
  BAM = "BAM",
  BBD = "BBD",
  BDT = "BDT",
  BGN = "BGN",
  BHD = "BHD",
  BIF = "BIF",
  BMD = "BMD",
  BND = "BND",
  BOB = "BOB",
  BOV = "BOV",
  BRL = "BRL",
  BSD = "BSD",
  BTN = "BTN",
  BWP = "BWP",
  BYN = "BYN",
  BZD = "BZD",
  CAD = "CAD",
  CDF = "CDF",
  CHE = "CHE",
  CHF = "CHF",
  CHW = "CHW",
  CLF = "CLF",
  CLP = "CLP",
  CNY = "CNY",
  COP = "COP",
  COU = "COU",
  CRC = "CRC",
  CUC = "CUC",
  CUP = "CUP",
  CVE = "CVE",
  CZK = "CZK",
  DJF = "DJF",
  DKK = "DKK",
  DOP = "DOP",
  DZD = "DZD",
  EGP = "EGP",
  ERN = "ERN",
  ETB = "ETB",
  EUR = "EUR",
  FJD = "FJD",
  FKP = "FKP",
  GBP = "GBP",
  GEL = "GEL",
  GHS = "GHS",
  GIP = "GIP",
  GMD = "GMD",
  GNF = "GNF",
  GTQ = "GTQ",
  GYD = "GYD",
  HKD = "HKD",
  HNL = "HNL",
  HRK = "HRK",
  HTG = "HTG",
  HUF = "HUF",
  IDR = "IDR",
  ILS = "ILS",
  INR = "INR",
  IQD = "IQD",
  IRR = "IRR",
  ISK = "ISK",
  JMD = "JMD",
  JOD = "JOD",
  JPY = "JPY",
  KES = "KES",
  KGS = "KGS",
  KHR = "KHR",
  KMF = "KMF",
  KPW = "KPW",
  KRW = "KRW",
  KWD = "KWD",
  KYD = "KYD",
  KZT = "KZT",
  LAK = "LAK",
  LBP = "LBP",
  LKR = "LKR",
  LRD = "LRD",
  LSL = "LSL",
  LYD = "LYD",
  MAD = "MAD",
  MDL = "MDL",
  MGA = "MGA",
  MKD = "MKD",
  MMK = "MMK",
  MNT = "MNT",
  MOP = "MOP",
  MRU = "MRU",
  MUR = "MUR",
  MVR = "MVR",
  MWK = "MWK",
  MXN = "MXN",
  MXV = "MXV",
  MYR = "MYR",
  MZN = "MZN",
  NAD = "NAD",
  NGN = "NGN",
  NIO = "NIO",
  NOK = "NOK",
  NPR = "NPR",
  NZD = "NZD",
  OMR = "OMR",
  PAB = "PAB",
  PEN = "PEN",
  PGK = "PGK",
  PHP = "PHP",
  PKR = "PKR",
  PLN = "PLN",
  PYG = "PYG",
  QAR = "QAR",
  RON = "RON",
  RSD = "RSD",
  RUB = "RUB",
  RWF = "RWF",
  SAR = "SAR",
  SBD = "SBD",
  SCR = "SCR",
  SDG = "SDG",
  SEK = "SEK",
  SGD = "SGD",
  SHP = "SHP",
  SLE = "SLE",
  SLL = "SLL",
  SOS = "SOS",
  SRD = "SRD",
  SSP = "SSP",
  STN = "STN",
  SVC = "SVC",
  SYP = "SYP",
  SZL = "SZL",
  THB = "THB",
  TJS = "TJS",
  TMT = "TMT",
  TND = "TND",
  TOP = "TOP",
  TRY = "TRY",
  TTD = "TTD",
  TWD = "TWD",
  TZS = "TZS",
  UAH = "UAH",
  UGX = "UGX",
  USD = "USD",
  USN = "USN",
  UYI = "UYI",
  UYU = "UYU",
  UYW = "UYW",
  UZS = "UZS",
  VED = "VED",
  VES = "VES",
  VND = "VND",
  VUV = "VUV",
  WST = "WST",
  XAF = "XAF",
  XCD = "XCD",
  XOF = "XOF",
  XPF = "XPF",
  XSU = "XSU",
  XUA = "XUA",
  YER = "YER",
  ZAR = "ZAR",
  ZMW = "ZMW",
  ZWL = "ZWL",
}

/**
 * Product and services offered by the business
 * @export
 * @interface ProductOutput
 */
export interface ProductOutput {
  /**
   *
   * @type {string}
   * @memberof ProductOutput
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ProductOutput
   */
  orgId?: string;
  /**
   * Product is active or not
   * @type {boolean}
   * @memberof ProductOutput
   */
  active?: boolean;
  /**
   * Default price of the product this is represented in the lowest currency denomination. Eg: 1000 for $10
   * @type {number}
   * @memberof ProductOutput
   */
  defaultPrice?: number | null;
  /**
   *
   * @type {string}
   * @memberof ProductOutput
   */
  currency?: string | null;
  /**
   * Description of the product
   * @type {string}
   * @memberof ProductOutput
   */
  description?: string | null;
  /**
   * Name of the product
   * @type {string}
   * @memberof ProductOutput
   */
  name?: string;
  /**
   * Product is shippable or not. Service is not shippable
   * @type {boolean}
   * @memberof ProductOutput
   */
  shippable?: boolean;
  /**
   * List of features of the product
   * @type {Array<string>}
   * @memberof ProductOutput
   */
  features?: Array<string> | null;
  /**
   * Product requires appointment scheduling or not
   * @type {boolean}
   * @memberof ProductOutput
   */
  scheduleAppointment?: boolean;
  /**
   * Properties of the product
   * @type {any}
   * @memberof ProductOutput
   */
  props?: any | null;
  /**
   *
   * @type {Array<string>}
   * @memberof ProductOutput
   */
  tags?: Array<string> | null;
  /**
   *
   * @type {string}
   * @memberof ProductOutput
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof ProductOutput
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof ProductOutput
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof ProductOutput
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof ProductOutput
   */
  updatedAt?: string;
}
/**
 *
 * @export
 * @interface ProspectInput
 */
export interface ProspectInput {
  /**
   * Name of the prospect
   * @type {string}
   * @memberof ProspectInput
   */
  name?: string;
  /**
   * Email of the prospect
   * @type {string}
   * @memberof ProspectInput
   */
  email?: string | null;
  /**
   * Phone number of the prospect
   * @type {string}
   * @memberof ProspectInput
   */
  phoneNumber?: string | null;
  /**
   * External references for the prospect
   * @type {Array<ExternalReference>}
   * @memberof ProspectInput
   */
  externalReference?: Array<ExternalReference> | null;
  /**
   *
   * @type {ProspectStatus}
   * @memberof ProspectInput
   */
  status: ProspectStatus;
  /**
   * Props for the prospect
   * @type {any}
   * @memberof ProspectInput
   */
  prospectProps?: any | null;
}
/**
 * Prospects are the potential customers for business
 * @export
 * @interface ProspectOutput
 */
export interface ProspectOutput {
  /**
   *
   * @type {string}
   * @memberof ProspectOutput
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ProspectOutput
   */
  orgId?: string;
  /**
   *
   * @type {string}
   * @memberof ProspectOutput
   */
  name?: string | null;
  /**
   *
   * @type {string}
   * @memberof ProspectOutput
   */
  email?: string | null;
  /**
   *
   * @type {string}
   * @memberof ProspectOutput
   */
  phoneNumber?: string | null;
  /**
   *
   * @type {Array<ExternalReference>}
   * @memberof ProspectOutput
   */
  externalReference: Array<ExternalReference> | null;
  /**
   *
   * @type {string}
   * @memberof ProspectOutput
   */
  status: string;
  /**
   *
   * @type {any}
   * @memberof ProspectOutput
   */
  prospectProps: any | null;
  /**
   *
   * @type {string}
   * @memberof ProspectOutput
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof ProspectOutput
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof ProspectOutput
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof ProspectOutput
   */
  updatedAt?: string;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum ProspectStatus {
  GENERALENQUIRY = "GENERAL_ENQUIRY",
  SCHEDULEDCALLBACKWITHBOT = "SCHEDULED_CALLBACK_WITH_BOT",
  SCHEDULEDAPPOINTMENTWITHPERSON = "SCHEDULED_APPOINTMENT_WITH_PERSON",
  SCHEDULEDAPPOINTMENTFORSERVICE = "SCHEDULED_APPOINTMENT_FOR_SERVICE",
  NOTINTERESTED = "NOT_INTERESTED",
  PRODUCTORDERPLACED = "PRODUCT_ORDER_PLACED",
  SERVICEORDERPLACED = "SERVICE_ORDER_PLACED",
}

/**
 *
 * @export
 * @enum {string}
 */
export enum Role {
  ADMIN = "ADMIN",
  READONLY = "READ_ONLY",
}

/**
 *
 * @export
 * @enum {string}
 */
export enum Sentiment {
  POSITIVE = "POSITIVE",
  EXCITED = "EXCITED",
  NEGATIVE = "NEGATIVE",
  BAD = "BAD",
}

/**
 *
 * @export
 * @interface Sequence
 */
export interface Sequence {
  /**
   * Name of the stage
   * @type {string}
   * @memberof Sequence
   */
  stageName?: string;
  /**
   * Description of the stage
   * @type {string}
   * @memberof Sequence
   */
  description?: string;
  /**
   * Other notes that AI agent should know in this stage of conversation
   * @type {string}
   * @memberof Sequence
   */
  otherNotes?: string | null;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum SortOrder {
  Asc = "asc",
  Desc = "desc",
}

/**
 *
 * @export
 * @enum {string}
 */
export enum Status {
  Active = "active",
  Inactive = "inactive",
}

/**
 *
 * @export
 * @interface TaxDetails
 */
export interface TaxDetails {
  /**
   * Tax identifier
   * @type {string}
   * @memberof TaxDetails
   */
  id?: string;
  /**
   * Any extra info related to Tax
   * @type {object}
   * @memberof TaxDetails
   */
  taxProps?: object | null;
}
/**
 *
 * @export
 * @interface Transcriber
 */
export interface Transcriber {
  /**
   *
   * @type {string}
   * @memberof Transcriber
   */
  providerName?: string;
  /**
   *
   * @type {string}
   * @memberof Transcriber
   */
  transcriberModel?: string | null;
  /**
   *
   * @type {object}
   * @memberof Transcriber
   */
  providerProps?: object | null;
}
/**
 * Payload for updating user details API
 * @export
 * @interface UpdateUserPayload
 */
export interface UpdateUserPayload {
  /**
   *
   * @type {Role}
   * @memberof UpdateUserPayload
   */
  role: Role | null;
  /**
   *
   * @type {string}
   * @memberof UpdateUserPayload
   */
  fullName: string | null;
}
/**
 * Model representing the users under an organization
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  orgId?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  role?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  fullName?: string | null;
  /**
   *
   * @type {string}
   * @memberof User
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  updatedAt?: string;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
  /**
   *
   * @type {Array<string | number>}
   * @memberof ValidationError
   */
  loc: Array<string | number>;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  msg: string;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  type: string;
}
/**
 *
 * @export
 * @interface VoiceInput
 */
export interface VoiceInput {
  /**
   *
   * @type {string}
   * @memberof VoiceInput
   */
  gender: VoiceInputGenderEnum;
  /**
   *
   * @type {LanguageAccentCombo}
   * @memberof VoiceInput
   */
  languageAccent: LanguageAccentCombo;
  /**
   *
   * @type {string}
   * @memberof VoiceInput
   */
  modelName?: string | null;
  /**
   *
   * @type {string}
   * @memberof VoiceInput
   */
  modelProvider: VoiceInputModelProviderEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum VoiceInputGenderEnum {
  Male = "Male",
  Female = "Female",
  Neutral = "Neutral",
}
/**
 * @export
 * @enum {string}
 */
export enum VoiceInputModelProviderEnum {
  Google = "Google",
  AWS = "AWS",
  Elevenlabs = "Elevenlabs",
  PlayHT = "PlayHT",
  Deepgram = "Deepgram",
}

/**
 *
 * @export
 * @interface VoiceOutput
 */
export interface VoiceOutput {
  /**
   *
   * @type {string}
   * @memberof VoiceOutput
   */
  gender: VoiceOutputGenderEnum;
  /**
   *
   * @type {LanguageAccentCombo}
   * @memberof VoiceOutput
   */
  languageAccent: LanguageAccentCombo;
  /**
   *
   * @type {string}
   * @memberof VoiceOutput
   */
  modelName?: string | null;
  /**
   *
   * @type {string}
   * @memberof VoiceOutput
   */
  modelProvider: VoiceOutputModelProviderEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum VoiceOutputGenderEnum {
  Male = "Male",
  Female = "Female",
  Neutral = "Neutral",
}
/**
 * @export
 * @enum {string}
 */
export enum VoiceOutputModelProviderEnum {
  Google = "Google",
  AWS = "AWS",
  Elevenlabs = "Elevenlabs",
  PlayHT = "PlayHT",
  Deepgram = "Deepgram",
}

/**
 * AgentsApi - axios parameter creator
 * @export
 */
export const AgentsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Creates a new AI agent.
     * @summary Createaiagent
     * @param {AIAgentInput} aIAgentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAIAgentV1: async (
      aIAgentInput: AIAgentInput,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'aIAgentInput' is not null or undefined
      if (aIAgentInput === null || aIAgentInput === undefined) {
        throw new RequiredError(
          "aIAgentInput",
          "Required parameter aIAgentInput was null or undefined when calling createAIAgentV1."
        );
      }
      const localVarPath = `/v1/ai-agents`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof aIAgentInput !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(aIAgentInput !== undefined ? aIAgentInput : {})
        : aIAgentInput || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes an AI agent.
     * @summary Deleteaiagent
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAIAgentV1: async (
      agentId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'agentId' is not null or undefined
      if (agentId === null || agentId === undefined) {
        throw new RequiredError(
          "agentId",
          "Required parameter agentId was null or undefined when calling deleteAIAgentV1."
        );
      }
      const localVarPath = `/v1/ai-agents/{agent_id}`.replace(
        `{${"agent_id"}}`,
        encodeURIComponent(String(agentId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets a specific AI agent by ID.
     * @summary Getaiagent
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAIAgentV1: async (
      agentId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'agentId' is not null or undefined
      if (agentId === null || agentId === undefined) {
        throw new RequiredError(
          "agentId",
          "Required parameter agentId was null or undefined when calling getAIAgentV1."
        );
      }
      const localVarPath = `/v1/ai-agents/{agent_id}`.replace(
        `{${"agent_id"}}`,
        encodeURIComponent(String(agentId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists all AI agents under the user\'s organization.
     * @summary Listaiagents
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAIAgentsV1: async (
      searchBy?: string,
      searchValue?: string,
      status?: string,
      sortBy?: string,
      sortOrder?: SortOrder,
      skip?: number,
      limit?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/ai-agents`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      if (searchBy !== undefined) {
        localVarQueryParameter["search_by"] = searchBy;
      }

      if (searchValue !== undefined) {
        localVarQueryParameter["search_value"] = searchValue;
      }

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sort_by"] = sortBy;
      }

      if (sortOrder !== undefined) {
        localVarQueryParameter["sort_order"] = sortOrder;
      }

      if (skip !== undefined) {
        localVarQueryParameter["skip"] = skip;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates an existing AI agent.
     * @summary Updateaiagent
     * @param {string} agentId
     * @param {AIAgentInput} aIAgentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAIAgentV1: async (
      agentId: string,
      aIAgentInput: AIAgentInput,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'agentId' is not null or undefined
      if (agentId === null || agentId === undefined) {
        throw new RequiredError(
          "agentId",
          "Required parameter agentId was null or undefined when calling updateAIAgentV1."
        );
      }
      // verify required parameter 'aIAgentInput' is not null or undefined
      if (aIAgentInput === null || aIAgentInput === undefined) {
        throw new RequiredError(
          "aIAgentInput",
          "Required parameter aIAgentInput was null or undefined when calling updateAIAgentV1."
        );
      }
      const localVarPath = `/v1/ai-agents/{agent_id}`.replace(
        `{${"agent_id"}}`,
        encodeURIComponent(String(agentId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof aIAgentInput !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(aIAgentInput !== undefined ? aIAgentInput : {})
        : aIAgentInput || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AgentsApi - functional programming interface
 * @export
 */
export const AgentsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Creates a new AI agent.
     * @summary Createaiagent
     * @param {AIAgentInput} aIAgentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAIAgentV1(
      aIAgentInput: AIAgentInput,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AIAgentOutput>
    > {
      const localVarAxiosArgs = await AgentsApiAxiosParamCreator(
        configuration
      ).createAIAgentV1(aIAgentInput, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Deletes an AI agent.
     * @summary Deleteaiagent
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAIAgentV1(
      agentId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>
    > {
      const localVarAxiosArgs = await AgentsApiAxiosParamCreator(
        configuration
      ).deleteAIAgentV1(agentId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Gets a specific AI agent by ID.
     * @summary Getaiagent
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAIAgentV1(
      agentId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AIAgentOutput>
    > {
      const localVarAxiosArgs = await AgentsApiAxiosParamCreator(
        configuration
      ).getAIAgentV1(agentId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Lists all AI agents under the user\'s organization.
     * @summary Listaiagents
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAIAgentsV1(
      searchBy?: string,
      searchValue?: string,
      status?: string,
      sortBy?: string,
      sortOrder?: SortOrder,
      skip?: number,
      limit?: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AIAgentOutput>>
    > {
      const localVarAxiosArgs = await AgentsApiAxiosParamCreator(
        configuration
      ).listAIAgentsV1(
        searchBy,
        searchValue,
        status,
        sortBy,
        sortOrder,
        skip,
        limit,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Updates an existing AI agent.
     * @summary Updateaiagent
     * @param {string} agentId
     * @param {AIAgentInput} aIAgentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateAIAgentV1(
      agentId: string,
      aIAgentInput: AIAgentInput,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AIAgentOutput>
    > {
      const localVarAxiosArgs = await AgentsApiAxiosParamCreator(
        configuration
      ).updateAIAgentV1(agentId, aIAgentInput, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * AgentsApi - factory interface
 * @export
 */
export const AgentsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Creates a new AI agent.
     * @summary Createaiagent
     * @param {AIAgentInput} aIAgentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAIAgentV1(
      aIAgentInput: AIAgentInput,
      options?: any
    ): AxiosPromise<AIAgentOutput> {
      return AgentsApiFp(configuration)
        .createAIAgentV1(aIAgentInput, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes an AI agent.
     * @summary Deleteaiagent
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAIAgentV1(
      agentId: string,
      options?: any
    ): AxiosPromise<BaseResponse> {
      return AgentsApiFp(configuration)
        .deleteAIAgentV1(agentId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets a specific AI agent by ID.
     * @summary Getaiagent
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAIAgentV1(agentId: string, options?: any): AxiosPromise<AIAgentOutput> {
      return AgentsApiFp(configuration)
        .getAIAgentV1(agentId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists all AI agents under the user\'s organization.
     * @summary Listaiagents
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAIAgentsV1(
      searchBy?: string,
      searchValue?: string,
      status?: string,
      sortBy?: string,
      sortOrder?: SortOrder,
      skip?: number,
      limit?: number,
      options?: any
    ): AxiosPromise<Array<AIAgentOutput>> {
      return AgentsApiFp(configuration)
        .listAIAgentsV1(
          searchBy,
          searchValue,
          status,
          sortBy,
          sortOrder,
          skip,
          limit,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates an existing AI agent.
     * @summary Updateaiagent
     * @param {string} agentId
     * @param {AIAgentInput} aIAgentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAIAgentV1(
      agentId: string,
      aIAgentInput: AIAgentInput,
      options?: any
    ): AxiosPromise<AIAgentOutput> {
      return AgentsApiFp(configuration)
        .updateAIAgentV1(agentId, aIAgentInput, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AgentsApi - object-oriented interface
 * @export
 * @class AgentsApi
 * @extends {BaseAPI}
 */
export class AgentsApi extends BaseAPI {
  /**
   * Creates a new AI agent.
   * @summary Createaiagent
   * @param {AIAgentInput} aIAgentInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentsApi
   */
  public createAIAgentV1(aIAgentInput: AIAgentInput, options?: any) {
    return AgentsApiFp(this.configuration)
      .createAIAgentV1(aIAgentInput, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes an AI agent.
   * @summary Deleteaiagent
   * @param {string} agentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentsApi
   */
  public deleteAIAgentV1(agentId: string, options?: any) {
    return AgentsApiFp(this.configuration)
      .deleteAIAgentV1(agentId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets a specific AI agent by ID.
   * @summary Getaiagent
   * @param {string} agentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentsApi
   */
  public getAIAgentV1(agentId: string, options?: any) {
    return AgentsApiFp(this.configuration)
      .getAIAgentV1(agentId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists all AI agents under the user\'s organization.
   * @summary Listaiagents
   * @param {string} [searchBy]
   * @param {string} [searchValue]
   * @param {string} [status]
   * @param {string} [sortBy]
   * @param {SortOrder} [sortOrder]
   * @param {number} [skip]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentsApi
   */
  public listAIAgentsV1(
    searchBy?: string,
    searchValue?: string,
    status?: string,
    sortBy?: string,
    sortOrder?: SortOrder,
    skip?: number,
    limit?: number,
    options?: any
  ) {
    return AgentsApiFp(this.configuration)
      .listAIAgentsV1(
        searchBy,
        searchValue,
        status,
        sortBy,
        sortOrder,
        skip,
        limit,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates an existing AI agent.
   * @summary Updateaiagent
   * @param {string} agentId
   * @param {AIAgentInput} aIAgentInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentsApi
   */
  public updateAIAgentV1(
    agentId: string,
    aIAgentInput: AIAgentInput,
    options?: any
  ) {
    return AgentsApiFp(this.configuration)
      .updateAIAgentV1(agentId, aIAgentInput, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ConversationProspectLinkApi - axios parameter creator
 * @export
 */
export const ConversationProspectLinkApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Createconversationprospectlink
     * @param {string} conversationId
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConversationProspectLinkV1: async (
      conversationId: string,
      prospectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'conversationId' is not null or undefined
      if (conversationId === null || conversationId === undefined) {
        throw new RequiredError(
          "conversationId",
          "Required parameter conversationId was null or undefined when calling createConversationProspectLinkV1."
        );
      }
      // verify required parameter 'prospectId' is not null or undefined
      if (prospectId === null || prospectId === undefined) {
        throw new RequiredError(
          "prospectId",
          "Required parameter prospectId was null or undefined when calling createConversationProspectLinkV1."
        );
      }
      const localVarPath =
        `/v1/conversations/{conversation_id}/prospects/{prospect_id}/links`
          .replace(
            `{${"conversation_id"}}`,
            encodeURIComponent(String(conversationId))
          )
          .replace(
            `{${"prospect_id"}}`,
            encodeURIComponent(String(prospectId))
          );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deleteconversationbyprospect
     * @param {string} conversationId
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConversationProspectLinkV1: async (
      conversationId: string,
      prospectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'conversationId' is not null or undefined
      if (conversationId === null || conversationId === undefined) {
        throw new RequiredError(
          "conversationId",
          "Required parameter conversationId was null or undefined when calling deleteConversationProspectLinkV1."
        );
      }
      // verify required parameter 'prospectId' is not null or undefined
      if (prospectId === null || prospectId === undefined) {
        throw new RequiredError(
          "prospectId",
          "Required parameter prospectId was null or undefined when calling deleteConversationProspectLinkV1."
        );
      }
      const localVarPath =
        `/v1/conversations/{conversation_id}/prospects/{prospect_id}/links`
          .replace(
            `{${"conversation_id"}}`,
            encodeURIComponent(String(conversationId))
          )
          .replace(
            `{${"prospect_id"}}`,
            encodeURIComponent(String(prospectId))
          );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Getconversationsbyprospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listConversationsOfProspectsV1: async (
      prospectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'prospectId' is not null or undefined
      if (prospectId === null || prospectId === undefined) {
        throw new RequiredError(
          "prospectId",
          "Required parameter prospectId was null or undefined when calling listConversationsOfProspectsV1."
        );
      }
      const localVarPath = `/v1/prospects/{prospect_id}/conversations`.replace(
        `{${"prospect_id"}}`,
        encodeURIComponent(String(prospectId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ConversationProspectLinkApi - functional programming interface
 * @export
 */
export const ConversationProspectLinkApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Createconversationprospectlink
     * @param {string} conversationId
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createConversationProspectLinkV1(
      conversationId: string,
      prospectId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>
    > {
      const localVarAxiosArgs =
        await ConversationProspectLinkApiAxiosParamCreator(
          configuration
        ).createConversationProspectLinkV1(conversationId, prospectId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Deleteconversationbyprospect
     * @param {string} conversationId
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteConversationProspectLinkV1(
      conversationId: string,
      prospectId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>
    > {
      const localVarAxiosArgs =
        await ConversationProspectLinkApiAxiosParamCreator(
          configuration
        ).deleteConversationProspectLinkV1(conversationId, prospectId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Getconversationsbyprospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listConversationsOfProspectsV1(
      prospectId: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ConversationOutput>>
    > {
      const localVarAxiosArgs =
        await ConversationProspectLinkApiAxiosParamCreator(
          configuration
        ).listConversationsOfProspectsV1(prospectId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * ConversationProspectLinkApi - factory interface
 * @export
 */
export const ConversationProspectLinkApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Createconversationprospectlink
     * @param {string} conversationId
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConversationProspectLinkV1(
      conversationId: string,
      prospectId: string,
      options?: any
    ): AxiosPromise<BaseResponse> {
      return ConversationProspectLinkApiFp(configuration)
        .createConversationProspectLinkV1(conversationId, prospectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deleteconversationbyprospect
     * @param {string} conversationId
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConversationProspectLinkV1(
      conversationId: string,
      prospectId: string,
      options?: any
    ): AxiosPromise<BaseResponse> {
      return ConversationProspectLinkApiFp(configuration)
        .deleteConversationProspectLinkV1(conversationId, prospectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Getconversationsbyprospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listConversationsOfProspectsV1(
      prospectId: string,
      options?: any
    ): AxiosPromise<Array<ConversationOutput>> {
      return ConversationProspectLinkApiFp(configuration)
        .listConversationsOfProspectsV1(prospectId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ConversationProspectLinkApi - object-oriented interface
 * @export
 * @class ConversationProspectLinkApi
 * @extends {BaseAPI}
 */
export class ConversationProspectLinkApi extends BaseAPI {
  /**
   *
   * @summary Createconversationprospectlink
   * @param {string} conversationId
   * @param {string} prospectId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConversationProspectLinkApi
   */
  public createConversationProspectLinkV1(
    conversationId: string,
    prospectId: string,
    options?: any
  ) {
    return ConversationProspectLinkApiFp(this.configuration)
      .createConversationProspectLinkV1(conversationId, prospectId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deleteconversationbyprospect
   * @param {string} conversationId
   * @param {string} prospectId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConversationProspectLinkApi
   */
  public deleteConversationProspectLinkV1(
    conversationId: string,
    prospectId: string,
    options?: any
  ) {
    return ConversationProspectLinkApiFp(this.configuration)
      .deleteConversationProspectLinkV1(conversationId, prospectId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Getconversationsbyprospect
   * @param {string} prospectId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConversationProspectLinkApi
   */
  public listConversationsOfProspectsV1(prospectId: string, options?: any) {
    return ConversationProspectLinkApiFp(this.configuration)
      .listConversationsOfProspectsV1(prospectId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ConversationsApi - axios parameter creator
 * @export
 */
export const ConversationsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Addfeedback
     * @param {string} conversationId
     * @param {Comment} comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFeedbackV1: async (
      conversationId: string,
      comment: Comment,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'conversationId' is not null or undefined
      if (conversationId === null || conversationId === undefined) {
        throw new RequiredError(
          "conversationId",
          "Required parameter conversationId was null or undefined when calling addFeedbackV1."
        );
      }
      // verify required parameter 'comment' is not null or undefined
      if (comment === null || comment === undefined) {
        throw new RequiredError(
          "comment",
          "Required parameter comment was null or undefined when calling addFeedbackV1."
        );
      }
      const localVarPath =
        `/v1/conversations/{conversation_id}/feedback`.replace(
          `{${"conversation_id"}}`,
          encodeURIComponent(String(conversationId))
        );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof comment !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(comment !== undefined ? comment : {})
        : comment || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Createconversation
     * @param {ConversationInput} conversationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConversationV1: async (
      conversationInput: ConversationInput,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'conversationInput' is not null or undefined
      if (conversationInput === null || conversationInput === undefined) {
        throw new RequiredError(
          "conversationInput",
          "Required parameter conversationInput was null or undefined when calling createConversationV1."
        );
      }
      const localVarPath = `/v1/conversations`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof conversationInput !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            conversationInput !== undefined ? conversationInput : {}
          )
        : conversationInput || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deleteconversation
     * @param {string} conversationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConversationV1: async (
      conversationId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'conversationId' is not null or undefined
      if (conversationId === null || conversationId === undefined) {
        throw new RequiredError(
          "conversationId",
          "Required parameter conversationId was null or undefined when calling deleteConversationV1."
        );
      }
      const localVarPath = `/v1/conversations/{conversation_id}`.replace(
        `{${"conversation_id"}}`,
        encodeURIComponent(String(conversationId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Getconversation
     * @param {string} conversationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConversationV1: async (
      conversationId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'conversationId' is not null or undefined
      if (conversationId === null || conversationId === undefined) {
        throw new RequiredError(
          "conversationId",
          "Required parameter conversationId was null or undefined when calling getConversationV1."
        );
      }
      const localVarPath = `/v1/conversations/{conversation_id}`.replace(
        `{${"conversation_id"}}`,
        encodeURIComponent(String(conversationId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Listconversations
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listConversationsV1: async (
      searchBy?: string,
      searchValue?: string,
      status?: string,
      sortBy?: string,
      sortOrder?: SortOrder,
      skip?: number,
      limit?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/conversations`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      if (searchBy !== undefined) {
        localVarQueryParameter["search_by"] = searchBy;
      }

      if (searchValue !== undefined) {
        localVarQueryParameter["search_value"] = searchValue;
      }

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sort_by"] = sortBy;
      }

      if (sortOrder !== undefined) {
        localVarQueryParameter["sort_order"] = sortOrder;
      }

      if (skip !== undefined) {
        localVarQueryParameter["skip"] = skip;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updateconversation
     * @param {string} conversationId
     * @param {ConversationInput} conversationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConversationV1: async (
      conversationId: string,
      conversationInput: ConversationInput,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'conversationId' is not null or undefined
      if (conversationId === null || conversationId === undefined) {
        throw new RequiredError(
          "conversationId",
          "Required parameter conversationId was null or undefined when calling updateConversationV1."
        );
      }
      // verify required parameter 'conversationInput' is not null or undefined
      if (conversationInput === null || conversationInput === undefined) {
        throw new RequiredError(
          "conversationInput",
          "Required parameter conversationInput was null or undefined when calling updateConversationV1."
        );
      }
      const localVarPath = `/v1/conversations/{conversation_id}`.replace(
        `{${"conversation_id"}}`,
        encodeURIComponent(String(conversationId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof conversationInput !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            conversationInput !== undefined ? conversationInput : {}
          )
        : conversationInput || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ConversationsApi - functional programming interface
 * @export
 */
export const ConversationsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Addfeedback
     * @param {string} conversationId
     * @param {Comment} comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addFeedbackV1(
      conversationId: string,
      comment: Comment,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ConversationFeedback>
    > {
      const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(
        configuration
      ).addFeedbackV1(conversationId, comment, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Createconversation
     * @param {ConversationInput} conversationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createConversationV1(
      conversationInput: ConversationInput,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ConversationOutput>
    > {
      const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(
        configuration
      ).createConversationV1(conversationInput, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Deleteconversation
     * @param {string} conversationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteConversationV1(
      conversationId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>
    > {
      const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(
        configuration
      ).deleteConversationV1(conversationId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Getconversation
     * @param {string} conversationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConversationV1(
      conversationId: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ConversationOutput>
    > {
      const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(
        configuration
      ).getConversationV1(conversationId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Listconversations
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listConversationsV1(
      searchBy?: string,
      searchValue?: string,
      status?: string,
      sortBy?: string,
      sortOrder?: SortOrder,
      skip?: number,
      limit?: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ConversationOutput>>
    > {
      const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(
        configuration
      ).listConversationsV1(
        searchBy,
        searchValue,
        status,
        sortBy,
        sortOrder,
        skip,
        limit,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Updateconversation
     * @param {string} conversationId
     * @param {ConversationInput} conversationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateConversationV1(
      conversationId: string,
      conversationInput: ConversationInput,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ConversationOutput>
    > {
      const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(
        configuration
      ).updateConversationV1(conversationId, conversationInput, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * ConversationsApi - factory interface
 * @export
 */
export const ConversationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Addfeedback
     * @param {string} conversationId
     * @param {Comment} comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFeedbackV1(
      conversationId: string,
      comment: Comment,
      options?: any
    ): AxiosPromise<ConversationFeedback> {
      return ConversationsApiFp(configuration)
        .addFeedbackV1(conversationId, comment, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Createconversation
     * @param {ConversationInput} conversationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConversationV1(
      conversationInput: ConversationInput,
      options?: any
    ): AxiosPromise<ConversationOutput> {
      return ConversationsApiFp(configuration)
        .createConversationV1(conversationInput, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deleteconversation
     * @param {string} conversationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConversationV1(
      conversationId: string,
      options?: any
    ): AxiosPromise<BaseResponse> {
      return ConversationsApiFp(configuration)
        .deleteConversationV1(conversationId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Getconversation
     * @param {string} conversationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConversationV1(
      conversationId: string,
      options?: any
    ): AxiosPromise<ConversationOutput> {
      return ConversationsApiFp(configuration)
        .getConversationV1(conversationId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Listconversations
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listConversationsV1(
      searchBy?: string,
      searchValue?: string,
      status?: string,
      sortBy?: string,
      sortOrder?: SortOrder,
      skip?: number,
      limit?: number,
      options?: any
    ): AxiosPromise<Array<ConversationOutput>> {
      return ConversationsApiFp(configuration)
        .listConversationsV1(
          searchBy,
          searchValue,
          status,
          sortBy,
          sortOrder,
          skip,
          limit,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updateconversation
     * @param {string} conversationId
     * @param {ConversationInput} conversationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConversationV1(
      conversationId: string,
      conversationInput: ConversationInput,
      options?: any
    ): AxiosPromise<ConversationOutput> {
      return ConversationsApiFp(configuration)
        .updateConversationV1(conversationId, conversationInput, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ConversationsApi - object-oriented interface
 * @export
 * @class ConversationsApi
 * @extends {BaseAPI}
 */
export class ConversationsApi extends BaseAPI {
  /**
   *
   * @summary Addfeedback
   * @param {string} conversationId
   * @param {Comment} comment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConversationsApi
   */
  public addFeedbackV1(
    conversationId: string,
    comment: Comment,
    options?: any
  ) {
    return ConversationsApiFp(this.configuration)
      .addFeedbackV1(conversationId, comment, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Createconversation
   * @param {ConversationInput} conversationInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConversationsApi
   */
  public createConversationV1(
    conversationInput: ConversationInput,
    options?: any
  ) {
    return ConversationsApiFp(this.configuration)
      .createConversationV1(conversationInput, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deleteconversation
   * @param {string} conversationId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConversationsApi
   */
  public deleteConversationV1(conversationId: string, options?: any) {
    return ConversationsApiFp(this.configuration)
      .deleteConversationV1(conversationId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Getconversation
   * @param {string} conversationId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConversationsApi
   */
  public getConversationV1(conversationId: string, options?: any) {
    return ConversationsApiFp(this.configuration)
      .getConversationV1(conversationId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Listconversations
   * @param {string} [searchBy]
   * @param {string} [searchValue]
   * @param {string} [status]
   * @param {string} [sortBy]
   * @param {SortOrder} [sortOrder]
   * @param {number} [skip]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConversationsApi
   */
  public listConversationsV1(
    searchBy?: string,
    searchValue?: string,
    status?: string,
    sortBy?: string,
    sortOrder?: SortOrder,
    skip?: number,
    limit?: number,
    options?: any
  ) {
    return ConversationsApiFp(this.configuration)
      .listConversationsV1(
        searchBy,
        searchValue,
        status,
        sortBy,
        sortOrder,
        skip,
        limit,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updateconversation
   * @param {string} conversationId
   * @param {ConversationInput} conversationInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConversationsApi
   */
  public updateConversationV1(
    conversationId: string,
    conversationInput: ConversationInput,
    options?: any
  ) {
    return ConversationsApiFp(this.configuration)
      .updateConversationV1(conversationId, conversationInput, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DataPlaneApi - axios parameter creator
 * @export
 */
export const DataPlaneApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Createconnection
     * @param {string} agentId
     * @param {string} prospectId
     * @param {ConnectionSource} connectionSource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConnection: async (
      agentId: string,
      prospectId: string,
      connectionSource: ConnectionSource,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'agentId' is not null or undefined
      if (agentId === null || agentId === undefined) {
        throw new RequiredError(
          "agentId",
          "Required parameter agentId was null or undefined when calling createConnection."
        );
      }
      // verify required parameter 'prospectId' is not null or undefined
      if (prospectId === null || prospectId === undefined) {
        throw new RequiredError(
          "prospectId",
          "Required parameter prospectId was null or undefined when calling createConnection."
        );
      }
      // verify required parameter 'connectionSource' is not null or undefined
      if (connectionSource === null || connectionSource === undefined) {
        throw new RequiredError(
          "connectionSource",
          "Required parameter connectionSource was null or undefined when calling createConnection."
        );
      }
      const localVarPath = `/connections`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      if (agentId !== undefined) {
        localVarQueryParameter["agentId"] = agentId;
      }

      if (prospectId !== undefined) {
        localVarQueryParameter["prospect_id"] = prospectId;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof connectionSource !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(connectionSource !== undefined ? connectionSource : {})
        : connectionSource || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DataPlaneApi - functional programming interface
 * @export
 */
export const DataPlaneApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Createconnection
     * @param {string} agentId
     * @param {string} prospectId
     * @param {ConnectionSource} connectionSource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createConnection(
      agentId: string,
      prospectId: string,
      connectionSource: ConnectionSource,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connection>
    > {
      const localVarAxiosArgs = await DataPlaneApiAxiosParamCreator(
        configuration
      ).createConnection(agentId, prospectId, connectionSource, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * DataPlaneApi - factory interface
 * @export
 */
export const DataPlaneApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Createconnection
     * @param {string} agentId
     * @param {string} prospectId
     * @param {ConnectionSource} connectionSource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConnection(
      agentId: string,
      prospectId: string,
      connectionSource: ConnectionSource,
      options?: any
    ): AxiosPromise<Connection> {
      return DataPlaneApiFp(configuration)
        .createConnection(agentId, prospectId, connectionSource, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DataPlaneApi - object-oriented interface
 * @export
 * @class DataPlaneApi
 * @extends {BaseAPI}
 */
export class DataPlaneApi extends BaseAPI {
  /**
   *
   * @summary Createconnection
   * @param {string} agentId
   * @param {string} prospectId
   * @param {ConnectionSource} connectionSource
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataPlaneApi
   */
  public createConnection(
    agentId: string,
    prospectId: string,
    connectionSource: ConnectionSource,
    options?: any
  ) {
    return DataPlaneApiFp(this.configuration)
      .createConnection(agentId, prospectId, connectionSource, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusStatusGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/status`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async statusStatusGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await HealthApiAxiosParamCreator(
        configuration
      ).statusStatusGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusStatusGet(options?: any): AxiosPromise<{ [key: string]: string }> {
      return HealthApiFp(configuration)
        .statusStatusGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
  /**
   *
   * @summary Status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public statusStatusGet(options?: any) {
    return HealthApiFp(this.configuration)
      .statusStatusGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HiveApi - axios parameter creator
 * @export
 */
export const HiveApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Createhive
     * @param {HiveContent} hiveContent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createHiveV1: async (
      hiveContent: HiveContent,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'hiveContent' is not null or undefined
      if (hiveContent === null || hiveContent === undefined) {
        throw new RequiredError(
          "hiveContent",
          "Required parameter hiveContent was null or undefined when calling createHiveV1."
        );
      }
      const localVarPath = `/v1/hives`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof hiveContent !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(hiveContent !== undefined ? hiveContent : {})
        : hiveContent || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletehive
     * @param {string} hiveId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteHiveV1: async (
      hiveId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'hiveId' is not null or undefined
      if (hiveId === null || hiveId === undefined) {
        throw new RequiredError(
          "hiveId",
          "Required parameter hiveId was null or undefined when calling deleteHiveV1."
        );
      }
      const localVarPath = `/v1/hives/{hive_id}`.replace(
        `{${"hive_id"}}`,
        encodeURIComponent(String(hiveId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gethive
     * @param {string} hiveId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHiveV1: async (
      hiveId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'hiveId' is not null or undefined
      if (hiveId === null || hiveId === undefined) {
        throw new RequiredError(
          "hiveId",
          "Required parameter hiveId was null or undefined when calling getHiveV1."
        );
      }
      const localVarPath = `/v1/hives/{hive_id}`.replace(
        `{${"hive_id"}}`,
        encodeURIComponent(String(hiveId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Listhives
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHivesV1: async (
      searchBy?: string,
      searchValue?: string,
      status?: string,
      sortBy?: string,
      sortOrder?: SortOrder,
      skip?: number,
      limit?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/hives`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      if (searchBy !== undefined) {
        localVarQueryParameter["search_by"] = searchBy;
      }

      if (searchValue !== undefined) {
        localVarQueryParameter["search_value"] = searchValue;
      }

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sort_by"] = sortBy;
      }

      if (sortOrder !== undefined) {
        localVarQueryParameter["sort_order"] = sortOrder;
      }

      if (skip !== undefined) {
        localVarQueryParameter["skip"] = skip;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updatehive
     * @param {string} hiveId
     * @param {HiveContent} hiveContent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateHiveV1: async (
      hiveId: string,
      hiveContent: HiveContent,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'hiveId' is not null or undefined
      if (hiveId === null || hiveId === undefined) {
        throw new RequiredError(
          "hiveId",
          "Required parameter hiveId was null or undefined when calling updateHiveV1."
        );
      }
      // verify required parameter 'hiveContent' is not null or undefined
      if (hiveContent === null || hiveContent === undefined) {
        throw new RequiredError(
          "hiveContent",
          "Required parameter hiveContent was null or undefined when calling updateHiveV1."
        );
      }
      const localVarPath = `/v1/hives/{hive_id}`.replace(
        `{${"hive_id"}}`,
        encodeURIComponent(String(hiveId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof hiveContent !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(hiveContent !== undefined ? hiveContent : {})
        : hiveContent || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HiveApi - functional programming interface
 * @export
 */
export const HiveApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Createhive
     * @param {HiveContent} hiveContent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createHiveV1(
      hiveContent: HiveContent,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>
    > {
      const localVarAxiosArgs = await HiveApiAxiosParamCreator(
        configuration
      ).createHiveV1(hiveContent, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Deletehive
     * @param {string} hiveId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteHiveV1(
      hiveId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>
    > {
      const localVarAxiosArgs = await HiveApiAxiosParamCreator(
        configuration
      ).deleteHiveV1(hiveId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Gethive
     * @param {string} hiveId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getHiveV1(
      hiveId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>
    > {
      const localVarAxiosArgs = await HiveApiAxiosParamCreator(
        configuration
      ).getHiveV1(hiveId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Listhives
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listHivesV1(
      searchBy?: string,
      searchValue?: string,
      status?: string,
      sortBy?: string,
      sortOrder?: SortOrder,
      skip?: number,
      limit?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hive>>
    > {
      const localVarAxiosArgs = await HiveApiAxiosParamCreator(
        configuration
      ).listHivesV1(
        searchBy,
        searchValue,
        status,
        sortBy,
        sortOrder,
        skip,
        limit,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Updatehive
     * @param {string} hiveId
     * @param {HiveContent} hiveContent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateHiveV1(
      hiveId: string,
      hiveContent: HiveContent,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>
    > {
      const localVarAxiosArgs = await HiveApiAxiosParamCreator(
        configuration
      ).updateHiveV1(hiveId, hiveContent, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * HiveApi - factory interface
 * @export
 */
export const HiveApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Createhive
     * @param {HiveContent} hiveContent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createHiveV1(hiveContent: HiveContent, options?: any): AxiosPromise<Hive> {
      return HiveApiFp(configuration)
        .createHiveV1(hiveContent, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletehive
     * @param {string} hiveId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteHiveV1(hiveId: string, options?: any): AxiosPromise<BaseResponse> {
      return HiveApiFp(configuration)
        .deleteHiveV1(hiveId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gethive
     * @param {string} hiveId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHiveV1(hiveId: string, options?: any): AxiosPromise<Hive> {
      return HiveApiFp(configuration)
        .getHiveV1(hiveId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Listhives
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHivesV1(
      searchBy?: string,
      searchValue?: string,
      status?: string,
      sortBy?: string,
      sortOrder?: SortOrder,
      skip?: number,
      limit?: number,
      options?: any
    ): AxiosPromise<Array<Hive>> {
      return HiveApiFp(configuration)
        .listHivesV1(
          searchBy,
          searchValue,
          status,
          sortBy,
          sortOrder,
          skip,
          limit,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updatehive
     * @param {string} hiveId
     * @param {HiveContent} hiveContent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateHiveV1(
      hiveId: string,
      hiveContent: HiveContent,
      options?: any
    ): AxiosPromise<Hive> {
      return HiveApiFp(configuration)
        .updateHiveV1(hiveId, hiveContent, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * HiveApi - object-oriented interface
 * @export
 * @class HiveApi
 * @extends {BaseAPI}
 */
export class HiveApi extends BaseAPI {
  /**
   *
   * @summary Createhive
   * @param {HiveContent} hiveContent
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HiveApi
   */
  public createHiveV1(hiveContent: HiveContent, options?: any) {
    return HiveApiFp(this.configuration)
      .createHiveV1(hiveContent, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletehive
   * @param {string} hiveId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HiveApi
   */
  public deleteHiveV1(hiveId: string, options?: any) {
    return HiveApiFp(this.configuration)
      .deleteHiveV1(hiveId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gethive
   * @param {string} hiveId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HiveApi
   */
  public getHiveV1(hiveId: string, options?: any) {
    return HiveApiFp(this.configuration)
      .getHiveV1(hiveId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Listhives
   * @param {string} [searchBy]
   * @param {string} [searchValue]
   * @param {string} [status]
   * @param {string} [sortBy]
   * @param {SortOrder} [sortOrder]
   * @param {number} [skip]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HiveApi
   */
  public listHivesV1(
    searchBy?: string,
    searchValue?: string,
    status?: string,
    sortBy?: string,
    sortOrder?: SortOrder,
    skip?: number,
    limit?: number,
    options?: any
  ) {
    return HiveApiFp(this.configuration)
      .listHivesV1(
        searchBy,
        searchValue,
        status,
        sortBy,
        sortOrder,
        skip,
        limit,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updatehive
   * @param {string} hiveId
   * @param {HiveContent} hiveContent
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HiveApi
   */
  public updateHiveV1(hiveId: string, hiveContent: HiveContent, options?: any) {
    return HiveApiFp(this.configuration)
      .updateHiveV1(hiveId, hiveContent, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HiveAgentLinkApi - axios parameter creator
 * @export
 */
export const HiveAgentLinkApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Createhiveagentlink
     * @param {string} hiveId
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createHiveAgentLinkV1: async (
      hiveId: string,
      agentId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'hiveId' is not null or undefined
      if (hiveId === null || hiveId === undefined) {
        throw new RequiredError(
          "hiveId",
          "Required parameter hiveId was null or undefined when calling createHiveAgentLinkV1."
        );
      }
      // verify required parameter 'agentId' is not null or undefined
      if (agentId === null || agentId === undefined) {
        throw new RequiredError(
          "agentId",
          "Required parameter agentId was null or undefined when calling createHiveAgentLinkV1."
        );
      }
      const localVarPath = `/v1/hives/{hive_id}/ai-agents/{agent_id}/link`
        .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)))
        .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletehiveagentlink
     * @param {string} hiveId
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteHiveAgentLinkV1: async (
      hiveId: string,
      agentId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'hiveId' is not null or undefined
      if (hiveId === null || hiveId === undefined) {
        throw new RequiredError(
          "hiveId",
          "Required parameter hiveId was null or undefined when calling deleteHiveAgentLinkV1."
        );
      }
      // verify required parameter 'agentId' is not null or undefined
      if (agentId === null || agentId === undefined) {
        throw new RequiredError(
          "agentId",
          "Required parameter agentId was null or undefined when calling deleteHiveAgentLinkV1."
        );
      }
      const localVarPath = `/v1/hives/{hive_id}/ai-agents/{agent_id}/link`
        .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)))
        .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Listagentsofhive
     * @param {string} hiveId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAgentsOfHiveV1: async (
      hiveId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'hiveId' is not null or undefined
      if (hiveId === null || hiveId === undefined) {
        throw new RequiredError(
          "hiveId",
          "Required parameter hiveId was null or undefined when calling listAgentsOfHiveV1."
        );
      }
      const localVarPath = `/v1/hives/{hive_id}/ai-agents`.replace(
        `{${"hive_id"}}`,
        encodeURIComponent(String(hiveId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Listhivesofagent
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHivesOfAgentV1: async (
      agentId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'agentId' is not null or undefined
      if (agentId === null || agentId === undefined) {
        throw new RequiredError(
          "agentId",
          "Required parameter agentId was null or undefined when calling listHivesOfAgentV1."
        );
      }
      const localVarPath = `/v1/ai-agents/{agent_id}/hives`.replace(
        `{${"agent_id"}}`,
        encodeURIComponent(String(agentId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HiveAgentLinkApi - functional programming interface
 * @export
 */
export const HiveAgentLinkApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Createhiveagentlink
     * @param {string} hiveId
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createHiveAgentLinkV1(
      hiveId: string,
      agentId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>
    > {
      const localVarAxiosArgs = await HiveAgentLinkApiAxiosParamCreator(
        configuration
      ).createHiveAgentLinkV1(hiveId, agentId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Deletehiveagentlink
     * @param {string} hiveId
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteHiveAgentLinkV1(
      hiveId: string,
      agentId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>
    > {
      const localVarAxiosArgs = await HiveAgentLinkApiAxiosParamCreator(
        configuration
      ).deleteHiveAgentLinkV1(hiveId, agentId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Listagentsofhive
     * @param {string} hiveId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAgentsOfHiveV1(
      hiveId: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AIAgentOutput>>
    > {
      const localVarAxiosArgs = await HiveAgentLinkApiAxiosParamCreator(
        configuration
      ).listAgentsOfHiveV1(hiveId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Listhivesofagent
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listHivesOfAgentV1(
      agentId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hive>>
    > {
      const localVarAxiosArgs = await HiveAgentLinkApiAxiosParamCreator(
        configuration
      ).listHivesOfAgentV1(agentId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * HiveAgentLinkApi - factory interface
 * @export
 */
export const HiveAgentLinkApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Createhiveagentlink
     * @param {string} hiveId
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createHiveAgentLinkV1(
      hiveId: string,
      agentId: string,
      options?: any
    ): AxiosPromise<BaseResponse> {
      return HiveAgentLinkApiFp(configuration)
        .createHiveAgentLinkV1(hiveId, agentId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletehiveagentlink
     * @param {string} hiveId
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteHiveAgentLinkV1(
      hiveId: string,
      agentId: string,
      options?: any
    ): AxiosPromise<BaseResponse> {
      return HiveAgentLinkApiFp(configuration)
        .deleteHiveAgentLinkV1(hiveId, agentId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Listagentsofhive
     * @param {string} hiveId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAgentsOfHiveV1(
      hiveId: string,
      options?: any
    ): AxiosPromise<Array<AIAgentOutput>> {
      return HiveAgentLinkApiFp(configuration)
        .listAgentsOfHiveV1(hiveId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Listhivesofagent
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHivesOfAgentV1(
      agentId: string,
      options?: any
    ): AxiosPromise<Array<Hive>> {
      return HiveAgentLinkApiFp(configuration)
        .listHivesOfAgentV1(agentId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * HiveAgentLinkApi - object-oriented interface
 * @export
 * @class HiveAgentLinkApi
 * @extends {BaseAPI}
 */
export class HiveAgentLinkApi extends BaseAPI {
  /**
   *
   * @summary Createhiveagentlink
   * @param {string} hiveId
   * @param {string} agentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HiveAgentLinkApi
   */
  public createHiveAgentLinkV1(hiveId: string, agentId: string, options?: any) {
    return HiveAgentLinkApiFp(this.configuration)
      .createHiveAgentLinkV1(hiveId, agentId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletehiveagentlink
   * @param {string} hiveId
   * @param {string} agentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HiveAgentLinkApi
   */
  public deleteHiveAgentLinkV1(hiveId: string, agentId: string, options?: any) {
    return HiveAgentLinkApiFp(this.configuration)
      .deleteHiveAgentLinkV1(hiveId, agentId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Listagentsofhive
   * @param {string} hiveId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HiveAgentLinkApi
   */
  public listAgentsOfHiveV1(hiveId: string, options?: any) {
    return HiveAgentLinkApiFp(this.configuration)
      .listAgentsOfHiveV1(hiveId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Listhivesofagent
   * @param {string} agentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HiveAgentLinkApi
   */
  public listHivesOfAgentV1(agentId: string, options?: any) {
    return HiveAgentLinkApiFp(this.configuration)
      .listHivesOfAgentV1(agentId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * InternalApi - axios parameter creator
 * @export
 */
export const InternalApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Accept invite and add new user to organization
     * @summary Acceptinvite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptInviteV1: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/invites/accept`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new organization and adds the user as the \"ADMIN\" user for the org
     * @summary Createorganization
     * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrganizationV1: async (
      bodyCreateOrganizationV1: BodyCreateOrganizationV1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'bodyCreateOrganizationV1' is not null or undefined
      if (
        bodyCreateOrganizationV1 === null ||
        bodyCreateOrganizationV1 === undefined
      ) {
        throw new RequiredError(
          "bodyCreateOrganizationV1",
          "Required parameter bodyCreateOrganizationV1 was null or undefined when calling createOrganizationV1."
        );
      }
      const localVarPath = `/v1/organizations`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof bodyCreateOrganizationV1 !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            bodyCreateOrganizationV1 !== undefined
              ? bodyCreateOrganizationV1
              : {}
          )
        : bodyCreateOrganizationV1 || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a user
     * @summary Deleteuser
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserV1: async (
      userId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          "userId",
          "Required parameter userId was null or undefined when calling deleteUserV1."
        );
      }
      const localVarPath = `/v1/users/{user_id}`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List of all open invites from the organization
     * @summary Listinvites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInvitesV1: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/invites`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists all users under the user\'s organization
     * @summary Listusers
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsersV1: async (
      searchBy?: string,
      searchValue?: string,
      status?: string,
      sortBy?: string,
      sortOrder?: SortOrder,
      skip?: number,
      limit?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/users`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      if (searchBy !== undefined) {
        localVarQueryParameter["search_by"] = searchBy;
      }

      if (searchValue !== undefined) {
        localVarQueryParameter["search_value"] = searchValue;
      }

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sort_by"] = sortBy;
      }

      if (sortOrder !== undefined) {
        localVarQueryParameter["sort_order"] = sortOrder;
      }

      if (skip !== undefined) {
        localVarQueryParameter["skip"] = skip;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Invite a new user to an organization or resend invite to the user if the user is already invited
     * @summary Inviteusers
     * @param {GuestInput} guestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendInviteV1: async (
      guestInput: GuestInput,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'guestInput' is not null or undefined
      if (guestInput === null || guestInput === undefined) {
        throw new RequiredError(
          "guestInput",
          "Required parameter guestInput was null or undefined when calling sendInviteV1."
        );
      }
      const localVarPath = `/v1/invites`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof guestInput !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(guestInput !== undefined ? guestInput : {})
        : guestInput || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update user details
     * @summary Updateuser
     * @param {string} userId
     * @param {UpdateUserPayload} updateUserPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserV1: async (
      userId: string,
      updateUserPayload: UpdateUserPayload,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          "userId",
          "Required parameter userId was null or undefined when calling updateUserV1."
        );
      }
      // verify required parameter 'updateUserPayload' is not null or undefined
      if (updateUserPayload === null || updateUserPayload === undefined) {
        throw new RequiredError(
          "updateUserPayload",
          "Required parameter updateUserPayload was null or undefined when calling updateUserV1."
        );
      }
      const localVarPath = `/v1/users/{user_id}`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof updateUserPayload !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            updateUserPayload !== undefined ? updateUserPayload : {}
          )
        : updateUserPayload || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InternalApi - functional programming interface
 * @export
 */
export const InternalApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Accept invite and add new user to organization
     * @summary Acceptinvite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async acceptInviteV1(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await InternalApiAxiosParamCreator(
        configuration
      ).acceptInviteV1(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Creates a new organization and adds the user as the \"ADMIN\" user for the org
     * @summary Createorganization
     * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createOrganizationV1(
      bodyCreateOrganizationV1: BodyCreateOrganizationV1,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await InternalApiAxiosParamCreator(
        configuration
      ).createOrganizationV1(bodyCreateOrganizationV1, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Delete a user
     * @summary Deleteuser
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserV1(
      userId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await InternalApiAxiosParamCreator(
        configuration
      ).deleteUserV1(userId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * List of all open invites from the organization
     * @summary Listinvites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listInvitesV1(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GuestOutput>>
    > {
      const localVarAxiosArgs = await InternalApiAxiosParamCreator(
        configuration
      ).listInvitesV1(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Lists all users under the user\'s organization
     * @summary Listusers
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listUsersV1(
      searchBy?: string,
      searchValue?: string,
      status?: string,
      sortBy?: string,
      sortOrder?: SortOrder,
      skip?: number,
      limit?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>
    > {
      const localVarAxiosArgs = await InternalApiAxiosParamCreator(
        configuration
      ).listUsersV1(
        searchBy,
        searchValue,
        status,
        sortBy,
        sortOrder,
        skip,
        limit,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Invite a new user to an organization or resend invite to the user if the user is already invited
     * @summary Inviteusers
     * @param {GuestInput} guestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendInviteV1(
      guestInput: GuestInput,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuestOutput>
    > {
      const localVarAxiosArgs = await InternalApiAxiosParamCreator(
        configuration
      ).sendInviteV1(guestInput, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Update user details
     * @summary Updateuser
     * @param {string} userId
     * @param {UpdateUserPayload} updateUserPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUserV1(
      userId: string,
      updateUserPayload: UpdateUserPayload,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await InternalApiAxiosParamCreator(
        configuration
      ).updateUserV1(userId, updateUserPayload, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * InternalApi - factory interface
 * @export
 */
export const InternalApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Accept invite and add new user to organization
     * @summary Acceptinvite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptInviteV1(options?: any): AxiosPromise<User> {
      return InternalApiFp(configuration)
        .acceptInviteV1(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new organization and adds the user as the \"ADMIN\" user for the org
     * @summary Createorganization
     * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrganizationV1(
      bodyCreateOrganizationV1: BodyCreateOrganizationV1,
      options?: any
    ): AxiosPromise<User> {
      return InternalApiFp(configuration)
        .createOrganizationV1(bodyCreateOrganizationV1, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a user
     * @summary Deleteuser
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserV1(userId: string, options?: any): AxiosPromise<User> {
      return InternalApiFp(configuration)
        .deleteUserV1(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List of all open invites from the organization
     * @summary Listinvites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInvitesV1(options?: any): AxiosPromise<Array<GuestOutput>> {
      return InternalApiFp(configuration)
        .listInvitesV1(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists all users under the user\'s organization
     * @summary Listusers
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsersV1(
      searchBy?: string,
      searchValue?: string,
      status?: string,
      sortBy?: string,
      sortOrder?: SortOrder,
      skip?: number,
      limit?: number,
      options?: any
    ): AxiosPromise<Array<User>> {
      return InternalApiFp(configuration)
        .listUsersV1(
          searchBy,
          searchValue,
          status,
          sortBy,
          sortOrder,
          skip,
          limit,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Invite a new user to an organization or resend invite to the user if the user is already invited
     * @summary Inviteusers
     * @param {GuestInput} guestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendInviteV1(
      guestInput: GuestInput,
      options?: any
    ): AxiosPromise<GuestOutput> {
      return InternalApiFp(configuration)
        .sendInviteV1(guestInput, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update user details
     * @summary Updateuser
     * @param {string} userId
     * @param {UpdateUserPayload} updateUserPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserV1(
      userId: string,
      updateUserPayload: UpdateUserPayload,
      options?: any
    ): AxiosPromise<User> {
      return InternalApiFp(configuration)
        .updateUserV1(userId, updateUserPayload, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
export class InternalApi extends BaseAPI {
  /**
   * Accept invite and add new user to organization
   * @summary Acceptinvite
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InternalApi
   */
  public acceptInviteV1(options?: any) {
    return InternalApiFp(this.configuration)
      .acceptInviteV1(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new organization and adds the user as the \"ADMIN\" user for the org
   * @summary Createorganization
   * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InternalApi
   */
  public createOrganizationV1(
    bodyCreateOrganizationV1: BodyCreateOrganizationV1,
    options?: any
  ) {
    return InternalApiFp(this.configuration)
      .createOrganizationV1(bodyCreateOrganizationV1, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a user
   * @summary Deleteuser
   * @param {string} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InternalApi
   */
  public deleteUserV1(userId: string, options?: any) {
    return InternalApiFp(this.configuration)
      .deleteUserV1(userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List of all open invites from the organization
   * @summary Listinvites
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InternalApi
   */
  public listInvitesV1(options?: any) {
    return InternalApiFp(this.configuration)
      .listInvitesV1(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists all users under the user\'s organization
   * @summary Listusers
   * @param {string} [searchBy]
   * @param {string} [searchValue]
   * @param {string} [status]
   * @param {string} [sortBy]
   * @param {SortOrder} [sortOrder]
   * @param {number} [skip]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InternalApi
   */
  public listUsersV1(
    searchBy?: string,
    searchValue?: string,
    status?: string,
    sortBy?: string,
    sortOrder?: SortOrder,
    skip?: number,
    limit?: number,
    options?: any
  ) {
    return InternalApiFp(this.configuration)
      .listUsersV1(
        searchBy,
        searchValue,
        status,
        sortBy,
        sortOrder,
        skip,
        limit,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Invite a new user to an organization or resend invite to the user if the user is already invited
   * @summary Inviteusers
   * @param {GuestInput} guestInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InternalApi
   */
  public sendInviteV1(guestInput: GuestInput, options?: any) {
    return InternalApiFp(this.configuration)
      .sendInviteV1(guestInput, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update user details
   * @summary Updateuser
   * @param {string} userId
   * @param {UpdateUserPayload} updateUserPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InternalApi
   */
  public updateUserV1(
    userId: string,
    updateUserPayload: UpdateUserPayload,
    options?: any
  ) {
    return InternalApiFp(this.configuration)
      .updateUserV1(userId, updateUserPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Getmetrics
     * @param {BatchMetricsRequests} batchMetricsRequests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetricsV1MetricsPost: async (
      batchMetricsRequests: BatchMetricsRequests,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'batchMetricsRequests' is not null or undefined
      if (batchMetricsRequests === null || batchMetricsRequests === undefined) {
        throw new RequiredError(
          "batchMetricsRequests",
          "Required parameter batchMetricsRequests was null or undefined when calling getMetricsV1MetricsPost."
        );
      }
      const localVarPath = `/v1/metrics`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof batchMetricsRequests !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            batchMetricsRequests !== undefined ? batchMetricsRequests : {}
          )
        : batchMetricsRequests || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Getmetrics
     * @param {BatchMetricsRequests} batchMetricsRequests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMetricsV1MetricsPost(
      batchMetricsRequests: BatchMetricsRequests,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BatchMetricsResponse>
    > {
      const localVarAxiosArgs = await MetricsApiAxiosParamCreator(
        configuration
      ).getMetricsV1MetricsPost(batchMetricsRequests, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Getmetrics
     * @param {BatchMetricsRequests} batchMetricsRequests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetricsV1MetricsPost(
      batchMetricsRequests: BatchMetricsRequests,
      options?: any
    ): AxiosPromise<BatchMetricsResponse> {
      return MetricsApiFp(configuration)
        .getMetricsV1MetricsPost(batchMetricsRequests, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
  /**
   *
   * @summary Getmetrics
   * @param {BatchMetricsRequests} batchMetricsRequests
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public getMetricsV1MetricsPost(
    batchMetricsRequests: BatchMetricsRequests,
    options?: any
  ) {
    return MetricsApiFp(this.configuration)
      .getMetricsV1MetricsPost(batchMetricsRequests, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Createproduct
     * @param {ProductInput} productInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProductV1: async (
      productInput: ProductInput,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'productInput' is not null or undefined
      if (productInput === null || productInput === undefined) {
        throw new RequiredError(
          "productInput",
          "Required parameter productInput was null or undefined when calling createProductV1."
        );
      }
      const localVarPath = `/v1/products`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof productInput !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(productInput !== undefined ? productInput : {})
        : productInput || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deleteproduct
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProductV1: async (
      productId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'productId' is not null or undefined
      if (productId === null || productId === undefined) {
        throw new RequiredError(
          "productId",
          "Required parameter productId was null or undefined when calling deleteProductV1."
        );
      }
      const localVarPath = `/v1/products/{product_id}`.replace(
        `{${"product_id"}}`,
        encodeURIComponent(String(productId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Getproduct
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProductV1: async (
      productId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'productId' is not null or undefined
      if (productId === null || productId === undefined) {
        throw new RequiredError(
          "productId",
          "Required parameter productId was null or undefined when calling getProductV1."
        );
      }
      const localVarPath = `/v1/products/{product_id}`.replace(
        `{${"product_id"}}`,
        encodeURIComponent(String(productId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Listproducts
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {Array<string>} [tags]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProductsV1: async (
      searchBy?: string,
      searchValue?: string,
      status?: string,
      sortBy?: string,
      sortOrder?: SortOrder,
      skip?: number,
      limit?: number,
      tags?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/products`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      if (searchBy !== undefined) {
        localVarQueryParameter["search_by"] = searchBy;
      }

      if (searchValue !== undefined) {
        localVarQueryParameter["search_value"] = searchValue;
      }

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sort_by"] = sortBy;
      }

      if (sortOrder !== undefined) {
        localVarQueryParameter["sort_order"] = sortOrder;
      }

      if (skip !== undefined) {
        localVarQueryParameter["skip"] = skip;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (tags) {
        localVarQueryParameter["tags"] = tags;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updateproduct
     * @param {string} productId
     * @param {ProductInput} productInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProductV1: async (
      productId: string,
      productInput: ProductInput,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'productId' is not null or undefined
      if (productId === null || productId === undefined) {
        throw new RequiredError(
          "productId",
          "Required parameter productId was null or undefined when calling updateProductV1."
        );
      }
      // verify required parameter 'productInput' is not null or undefined
      if (productInput === null || productInput === undefined) {
        throw new RequiredError(
          "productInput",
          "Required parameter productInput was null or undefined when calling updateProductV1."
        );
      }
      const localVarPath = `/v1/products/{product_id}`.replace(
        `{${"product_id"}}`,
        encodeURIComponent(String(productId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof productInput !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(productInput !== undefined ? productInput : {})
        : productInput || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Createproduct
     * @param {ProductInput} productInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createProductV1(
      productInput: ProductInput,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOutput>
    > {
      const localVarAxiosArgs = await ProductsApiAxiosParamCreator(
        configuration
      ).createProductV1(productInput, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Deleteproduct
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteProductV1(
      productId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>
    > {
      const localVarAxiosArgs = await ProductsApiAxiosParamCreator(
        configuration
      ).deleteProductV1(productId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Getproduct
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProductV1(
      productId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOutput>
    > {
      const localVarAxiosArgs = await ProductsApiAxiosParamCreator(
        configuration
      ).getProductV1(productId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Listproducts
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {Array<string>} [tags]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listProductsV1(
      searchBy?: string,
      searchValue?: string,
      status?: string,
      sortBy?: string,
      sortOrder?: SortOrder,
      skip?: number,
      limit?: number,
      tags?: Array<string>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ProductOutput>>
    > {
      const localVarAxiosArgs = await ProductsApiAxiosParamCreator(
        configuration
      ).listProductsV1(
        searchBy,
        searchValue,
        status,
        sortBy,
        sortOrder,
        skip,
        limit,
        tags,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Updateproduct
     * @param {string} productId
     * @param {ProductInput} productInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateProductV1(
      productId: string,
      productInput: ProductInput,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOutput>
    > {
      const localVarAxiosArgs = await ProductsApiAxiosParamCreator(
        configuration
      ).updateProductV1(productId, productInput, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Createproduct
     * @param {ProductInput} productInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProductV1(
      productInput: ProductInput,
      options?: any
    ): AxiosPromise<ProductOutput> {
      return ProductsApiFp(configuration)
        .createProductV1(productInput, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deleteproduct
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProductV1(
      productId: string,
      options?: any
    ): AxiosPromise<BaseResponse> {
      return ProductsApiFp(configuration)
        .deleteProductV1(productId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Getproduct
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProductV1(
      productId: string,
      options?: any
    ): AxiosPromise<ProductOutput> {
      return ProductsApiFp(configuration)
        .getProductV1(productId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Listproducts
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {Array<string>} [tags]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProductsV1(
      searchBy?: string,
      searchValue?: string,
      status?: string,
      sortBy?: string,
      sortOrder?: SortOrder,
      skip?: number,
      limit?: number,
      tags?: Array<string>,
      options?: any
    ): AxiosPromise<Array<ProductOutput>> {
      return ProductsApiFp(configuration)
        .listProductsV1(
          searchBy,
          searchValue,
          status,
          sortBy,
          sortOrder,
          skip,
          limit,
          tags,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updateproduct
     * @param {string} productId
     * @param {ProductInput} productInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProductV1(
      productId: string,
      productInput: ProductInput,
      options?: any
    ): AxiosPromise<ProductOutput> {
      return ProductsApiFp(configuration)
        .updateProductV1(productId, productInput, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
  /**
   *
   * @summary Createproduct
   * @param {ProductInput} productInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public createProductV1(productInput: ProductInput, options?: any) {
    return ProductsApiFp(this.configuration)
      .createProductV1(productInput, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deleteproduct
   * @param {string} productId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public deleteProductV1(productId: string, options?: any) {
    return ProductsApiFp(this.configuration)
      .deleteProductV1(productId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Getproduct
   * @param {string} productId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public getProductV1(productId: string, options?: any) {
    return ProductsApiFp(this.configuration)
      .getProductV1(productId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Listproducts
   * @param {string} [searchBy]
   * @param {string} [searchValue]
   * @param {string} [status]
   * @param {string} [sortBy]
   * @param {SortOrder} [sortOrder]
   * @param {number} [skip]
   * @param {number} [limit]
   * @param {Array<string>} [tags]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public listProductsV1(
    searchBy?: string,
    searchValue?: string,
    status?: string,
    sortBy?: string,
    sortOrder?: SortOrder,
    skip?: number,
    limit?: number,
    tags?: Array<string>,
    options?: any
  ) {
    return ProductsApiFp(this.configuration)
      .listProductsV1(
        searchBy,
        searchValue,
        status,
        sortBy,
        sortOrder,
        skip,
        limit,
        tags,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updateproduct
   * @param {string} productId
   * @param {ProductInput} productInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public updateProductV1(
    productId: string,
    productInput: ProductInput,
    options?: any
  ) {
    return ProductsApiFp(this.configuration)
      .updateProductV1(productId, productInput, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProspectsApi - axios parameter creator
 * @export
 */
export const ProspectsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Creates a new prospect.
     * @summary Createprospect
     * @param {ProspectInput} prospectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProspectV1: async (
      prospectInput: ProspectInput,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'prospectInput' is not null or undefined
      if (prospectInput === null || prospectInput === undefined) {
        throw new RequiredError(
          "prospectInput",
          "Required parameter prospectInput was null or undefined when calling createProspectV1."
        );
      }
      const localVarPath = `/v1/prospects`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof prospectInput !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(prospectInput !== undefined ? prospectInput : {})
        : prospectInput || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes a specific prospect by ID.
     * @summary Deleteprospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProspectV1: async (
      prospectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'prospectId' is not null or undefined
      if (prospectId === null || prospectId === undefined) {
        throw new RequiredError(
          "prospectId",
          "Required parameter prospectId was null or undefined when calling deleteProspectV1."
        );
      }
      const localVarPath = `/v1/prospects/{prospect_id}`.replace(
        `{${"prospect_id"}}`,
        encodeURIComponent(String(prospectId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetches a specific prospect by ID.
     * @summary Getprospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProspectV1: async (
      prospectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'prospectId' is not null or undefined
      if (prospectId === null || prospectId === undefined) {
        throw new RequiredError(
          "prospectId",
          "Required parameter prospectId was null or undefined when calling getProspectV1."
        );
      }
      const localVarPath = `/v1/prospects/{prospect_id}`.replace(
        `{${"prospect_id"}}`,
        encodeURIComponent(String(prospectId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists all prospects under the user\'s organization
     * @summary Listprospects
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProspectsV1: async (
      searchBy?: string,
      searchValue?: string,
      status?: string,
      sortBy?: string,
      sortOrder?: SortOrder,
      skip?: number,
      limit?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/prospects`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      if (searchBy !== undefined) {
        localVarQueryParameter["search_by"] = searchBy;
      }

      if (searchValue !== undefined) {
        localVarQueryParameter["search_value"] = searchValue;
      }

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sort_by"] = sortBy;
      }

      if (sortOrder !== undefined) {
        localVarQueryParameter["sort_order"] = sortOrder;
      }

      if (skip !== undefined) {
        localVarQueryParameter["skip"] = skip;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates a specific prospect by ID.
     * @summary Updateprospect
     * @param {string} prospectId
     * @param {ProspectInput} prospectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProspectV1: async (
      prospectId: string,
      prospectInput: ProspectInput,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'prospectId' is not null or undefined
      if (prospectId === null || prospectId === undefined) {
        throw new RequiredError(
          "prospectId",
          "Required parameter prospectId was null or undefined when calling updateProspectV1."
        );
      }
      // verify required parameter 'prospectInput' is not null or undefined
      if (prospectInput === null || prospectInput === undefined) {
        throw new RequiredError(
          "prospectInput",
          "Required parameter prospectInput was null or undefined when calling updateProspectV1."
        );
      }
      const localVarPath = `/v1/prospects/{prospect_id}`.replace(
        `{${"prospect_id"}}`,
        encodeURIComponent(String(prospectId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof prospectInput !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(prospectInput !== undefined ? prospectInput : {})
        : prospectInput || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProspectsApi - functional programming interface
 * @export
 */
export const ProspectsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Creates a new prospect.
     * @summary Createprospect
     * @param {ProspectInput} prospectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createProspectV1(
      prospectInput: ProspectInput,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProspectOutput>
    > {
      const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(
        configuration
      ).createProspectV1(prospectInput, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Deletes a specific prospect by ID.
     * @summary Deleteprospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteProspectV1(
      prospectId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>
    > {
      const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(
        configuration
      ).deleteProspectV1(prospectId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Fetches a specific prospect by ID.
     * @summary Getprospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProspectV1(
      prospectId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProspectOutput>
    > {
      const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(
        configuration
      ).getProspectV1(prospectId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Lists all prospects under the user\'s organization
     * @summary Listprospects
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listProspectsV1(
      searchBy?: string,
      searchValue?: string,
      status?: string,
      sortBy?: string,
      sortOrder?: SortOrder,
      skip?: number,
      limit?: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ProspectOutput>>
    > {
      const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(
        configuration
      ).listProspectsV1(
        searchBy,
        searchValue,
        status,
        sortBy,
        sortOrder,
        skip,
        limit,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Updates a specific prospect by ID.
     * @summary Updateprospect
     * @param {string} prospectId
     * @param {ProspectInput} prospectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateProspectV1(
      prospectId: string,
      prospectInput: ProspectInput,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProspectOutput>
    > {
      const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(
        configuration
      ).updateProspectV1(prospectId, prospectInput, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * ProspectsApi - factory interface
 * @export
 */
export const ProspectsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Creates a new prospect.
     * @summary Createprospect
     * @param {ProspectInput} prospectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProspectV1(
      prospectInput: ProspectInput,
      options?: any
    ): AxiosPromise<ProspectOutput> {
      return ProspectsApiFp(configuration)
        .createProspectV1(prospectInput, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes a specific prospect by ID.
     * @summary Deleteprospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProspectV1(
      prospectId: string,
      options?: any
    ): AxiosPromise<BaseResponse> {
      return ProspectsApiFp(configuration)
        .deleteProspectV1(prospectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetches a specific prospect by ID.
     * @summary Getprospect
     * @param {string} prospectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProspectV1(
      prospectId: string,
      options?: any
    ): AxiosPromise<ProspectOutput> {
      return ProspectsApiFp(configuration)
        .getProspectV1(prospectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists all prospects under the user\'s organization
     * @summary Listprospects
     * @param {string} [searchBy]
     * @param {string} [searchValue]
     * @param {string} [status]
     * @param {string} [sortBy]
     * @param {SortOrder} [sortOrder]
     * @param {number} [skip]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProspectsV1(
      searchBy?: string,
      searchValue?: string,
      status?: string,
      sortBy?: string,
      sortOrder?: SortOrder,
      skip?: number,
      limit?: number,
      options?: any
    ): AxiosPromise<Array<ProspectOutput>> {
      return ProspectsApiFp(configuration)
        .listProspectsV1(
          searchBy,
          searchValue,
          status,
          sortBy,
          sortOrder,
          skip,
          limit,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates a specific prospect by ID.
     * @summary Updateprospect
     * @param {string} prospectId
     * @param {ProspectInput} prospectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProspectV1(
      prospectId: string,
      prospectInput: ProspectInput,
      options?: any
    ): AxiosPromise<ProspectOutput> {
      return ProspectsApiFp(configuration)
        .updateProspectV1(prospectId, prospectInput, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ProspectsApi - object-oriented interface
 * @export
 * @class ProspectsApi
 * @extends {BaseAPI}
 */
export class ProspectsApi extends BaseAPI {
  /**
   * Creates a new prospect.
   * @summary Createprospect
   * @param {ProspectInput} prospectInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProspectsApi
   */
  public createProspectV1(prospectInput: ProspectInput, options?: any) {
    return ProspectsApiFp(this.configuration)
      .createProspectV1(prospectInput, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a specific prospect by ID.
   * @summary Deleteprospect
   * @param {string} prospectId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProspectsApi
   */
  public deleteProspectV1(prospectId: string, options?: any) {
    return ProspectsApiFp(this.configuration)
      .deleteProspectV1(prospectId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetches a specific prospect by ID.
   * @summary Getprospect
   * @param {string} prospectId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProspectsApi
   */
  public getProspectV1(prospectId: string, options?: any) {
    return ProspectsApiFp(this.configuration)
      .getProspectV1(prospectId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists all prospects under the user\'s organization
   * @summary Listprospects
   * @param {string} [searchBy]
   * @param {string} [searchValue]
   * @param {string} [status]
   * @param {string} [sortBy]
   * @param {SortOrder} [sortOrder]
   * @param {number} [skip]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProspectsApi
   */
  public listProspectsV1(
    searchBy?: string,
    searchValue?: string,
    status?: string,
    sortBy?: string,
    sortOrder?: SortOrder,
    skip?: number,
    limit?: number,
    options?: any
  ) {
    return ProspectsApiFp(this.configuration)
      .listProspectsV1(
        searchBy,
        searchValue,
        status,
        sortBy,
        sortOrder,
        skip,
        limit,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates a specific prospect by ID.
   * @summary Updateprospect
   * @param {string} prospectId
   * @param {ProspectInput} prospectInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProspectsApi
   */
  public updateProspectV1(
    prospectId: string,
    prospectInput: ProspectInput,
    options?: any
  ) {
    return ProspectsApiFp(this.configuration)
      .updateProspectV1(prospectId, prospectInput, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * VoiceModelsApi - axios parameter creator
 * @export
 */
export const VoiceModelsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Listvoicemodels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVoiceModelsV1: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/voice-models`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken()
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * VoiceModelsApi - functional programming interface
 * @export
 */
export const VoiceModelsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Listvoicemodels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listVoiceModelsV1(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>
    > {
      const localVarAxiosArgs = await VoiceModelsApiAxiosParamCreator(
        configuration
      ).listVoiceModelsV1(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * VoiceModelsApi - factory interface
 * @export
 */
export const VoiceModelsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Listvoicemodels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVoiceModelsV1(options?: any): AxiosPromise<Array<object>> {
      return VoiceModelsApiFp(configuration)
        .listVoiceModelsV1(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * VoiceModelsApi - object-oriented interface
 * @export
 * @class VoiceModelsApi
 * @extends {BaseAPI}
 */
export class VoiceModelsApi extends BaseAPI {
  /**
   *
   * @summary Listvoicemodels
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceModelsApi
   */
  public listVoiceModelsV1(options?: any) {
    return VoiceModelsApiFp(this.configuration)
      .listVoiceModelsV1(options)
      .then((request) => request(this.axios, this.basePath));
  }
}
