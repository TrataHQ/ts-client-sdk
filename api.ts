// tslint:disable
/**
 * Trata AI API
 * Human like conversation to answer calls, drive engagement, automate follow-ups & schedule bookings 24/7  with end to end integrations ensuring you never miss a sales enquiry.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AIAgentInput
 */
export interface AIAgentInput {
    /**
     * Name of the AI agent
     * @type {string}
     * @memberof AIAgentInput
     */
    name: string;
    /**
     * Image URL for the AI agent
     * @type {string}
     * @memberof AIAgentInput
     */
    imageUrl: string;
    /**
     * Mission of the AI agent
     * @type {Mission}
     * @memberof AIAgentInput
     */
    mission?: Mission | null;
    /**
     * Status of the AI agent
     * @type {Status}
     * @memberof AIAgentInput
     */
    status: Status;
    /**
     * Role of the AI agent in the company
     * @type {string}
     * @memberof AIAgentInput
     */
    role: string;
    /**
     * Description of the role of the AI agent
     * @type {string}
     * @memberof AIAgentInput
     */
    roleDescription: string;
    /**
     * Timezone of the AI agent used for scheduling meetings
     * @type {string}
     * @memberof AIAgentInput
     */
    timezone: string;
    /**
     * Voice of the AI agent
     * @type {VoiceInput}
     * @memberof AIAgentInput
     */
    voice?: VoiceInput | null;
    /**
     * List of terms or phrases that the AI agent to prioritize for enhanced recognition
     * @type {Array<string>}
     * @memberof AIAgentInput
     */
    boostedKeywords?: Array<string> | null;
    /**
     * App in which the AI agent is running
     * @type {AppEnumInput}
     * @memberof AIAgentInput
     */
    app?: AppEnumInput | null;
    /**
     * Evaluation metrics for the conversation
     * @type {ConversationEvaluationMetrics}
     * @memberof AIAgentInput
     */
    evaluationMetrics?: ConversationEvaluationMetrics | null;
}
/**
 * AI agent configured by businesses
 * @export
 * @interface AIAgentOutput
 */
export interface AIAgentOutput {
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    imageUrl?: string;
    /**
     * 
     * @type {Mission}
     * @memberof AIAgentOutput
     */
    mission?: Mission | null;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    roleDescription?: string;
    /**
     * 
     * @type {Transcriber}
     * @memberof AIAgentOutput
     */
    transcriber?: Transcriber | null;
    /**
     * 
     * @type {IntelligenceProvider}
     * @memberof AIAgentOutput
     */
    intelligenceProvider?: IntelligenceProvider | null;
    /**
     * 
     * @type {VoiceOutput}
     * @memberof AIAgentOutput
     */
    voice?: VoiceOutput | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AIAgentOutput
     */
    boostedKeywords?: Array<string> | null;
    /**
     * Application under which the AI agent is created
     * @type {AppEnumOutput}
     * @memberof AIAgentOutput
     */
    app?: AppEnumOutput | null;
    /**
     * Evaluation metrics for the conversation
     * @type {ConversationEvaluationMetrics}
     * @memberof AIAgentOutput
     */
    evaluationMetrics?: ConversationEvaluationMetrics | null;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    timezone?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Accent {
    American = 'American',
    Indian = 'Indian',
    Australian = 'Australian',
    British = 'British',
    Hindi = 'Hindi',
    MiddleEastern = 'Middle Eastern'
}

/**
 * 
 * @export
 * @interface AcceptInviteRequest
 */
export interface AcceptInviteRequest {
    /**
     * Name of the user
     * @type {string}
     * @memberof AcceptInviteRequest
     */
    name?: string | null;
    /**
     * Password for the user
     * @type {string}
     * @memberof AcceptInviteRequest
     */
    password?: string | null;
}
/**
 * 
 * @export
 * @interface ActionInput
 */
export interface ActionInput {
    /**
     * Name of the action
     * @type {string}
     * @memberof ActionInput
     */
    name: string;
    /**
     * Description about the action and it should also contain when the action should be triggered
     * @type {string}
     * @memberof ActionInput
     */
    description?: string | null;
    /**
     * Parameters for the action. It should be a JSON schema object
     * @type {object}
     * @memberof ActionInput
     */
    parameters: object;
    /**
     * Endpoint for the action
     * @type {HttpActionEndpoint | InternalActionEndpoint | AgenticWorkflowActionEndpoint}
     * @memberof ActionInput
     */
    endpoint: HttpActionEndpoint | InternalActionEndpoint | AgenticWorkflowActionEndpoint;
    /**
     * Text to be rendered to user when action is invoked
     * @type {string}
     * @memberof ActionInput
     */
    userWaitingText?: string | null;
    /**
     * Text to be rendered to user when action is successful
     * @type {string}
     * @memberof ActionInput
     */
    userSuccessText?: string | null;
    /**
     * Text to be rendered to user when action is not successful
     * @type {string}
     * @memberof ActionInput
     */
    userErrorText?: string | null;
    /**
     * Trigger who invokes the action
     * @type {ActionInvocationTrigger}
     * @memberof ActionInput
     */
    invocationTrigger: ActionInvocationTrigger;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ActionInvocationTrigger {
    UserQuery = 'user_query',
    WebhookConversationStart = 'webhook.conversation_start',
    WebhookConversationEnd = 'webhook.conversation_end'
}

/**
 * Action entity to store the actions which can be performed by ai agents
 * @export
 * @interface ActionOutput
 */
export interface ActionOutput {
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    description?: string | null;
    /**
     * 
     * @type {object}
     * @memberof ActionOutput
     */
    parameters?: object | null;
    /**
     * 
     * @type {object}
     * @memberof ActionOutput
     */
    endpoint?: object | null;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    invocationTrigger?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    userWaitingText?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    userSuccessText?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    userErrorText?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Adaptability {
    OpenToChange = 'open to change',
    Resistant = 'resistant',
    Indifferent = 'indifferent'
}

/**
 * 
 * @export
 * @interface AddressInput
 */
export interface AddressInput {
    /**
     * Address line 1
     * @type {string}
     * @memberof AddressInput
     */
    line1: string;
    /**
     * Address line 2
     * @type {string}
     * @memberof AddressInput
     */
    line2?: string | null;
    /**
     * City
     * @type {string}
     * @memberof AddressInput
     */
    city?: string | null;
    /**
     * State
     * @type {string}
     * @memberof AddressInput
     */
    state?: string | null;
    /**
     * Country
     * @type {string}
     * @memberof AddressInput
     */
    country: string;
}
/**
 * 
 * @export
 * @interface AddressOutput
 */
export interface AddressOutput {
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    line1: string;
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    line2: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    city: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    state: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    country: string | null;
}
/**
 * 
 * @export
 * @interface AgentConfig
 */
export interface AgentConfig {
    /**
     * Enum class representing transcriber
     * @type {string}
     * @memberof AgentConfig
     */
    transcriber: string;
    /**
     * Enum class representing intelligence provider
     * @type {string}
     * @memberof AgentConfig
     */
    intelligenceProvider: string;
    /**
     * 
     * @type {string}
     * @memberof AgentConfig
     */
    synthesizer: string;
    /**
     * 
     * @type {string}
     * @memberof AgentConfig
     */
    embeddingsModelConfig: string;
    /**
     * 
     * @type {string}
     * @memberof AgentConfig
     */
    hiveStorageConfig: string;
    /**
     * 
     * @type {string}
     * @memberof AgentConfig
     */
    fillersConfig?: string | null;
}
/**
 * 
 * @export
 * @interface AgenticWorkflowActionEndpoint
 */
export interface AgenticWorkflowActionEndpoint {
    /**
     * Agentic workflow id
     * @type {string}
     * @memberof AgenticWorkflowActionEndpoint
     */
    workflowId: string;
}
/**
 * Enum which stores the list of apps which are used to create the conversation
 * @export
 * @enum {string}
 */
export enum AgenticWorkflowAdkModelsWorkflowAppEnum {
    TRATA = 'TRATA',
    TRATASPARR = 'TRATA_SPARR'
}

/**
 * Connection represents an instance of an app with specific credentials and configuration
 * @export
 * @interface AgenticWorkflowDbModelsConnection
 */
export interface AgenticWorkflowDbModelsConnection {
    /**
     * The user who created.
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    createdBy?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    createdAt?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    updatedBy?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    updatedAt?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    orgId?: string;
    /**
     * The name of the connection
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    name?: string;
    /**
     * The unique identifier of the app
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    appId?: string;
    /**
     * The version of the app
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    appVersion?: string;
    /**
     * The description of the connection
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    description?: string | null;
    /**
     * OAuth or API key authentication configuration
     * @type {OAuthCredentials | ApiKeyCredentials | BasicAuthCredentials | NoAuthCredentials}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    credentials: OAuthCredentials | ApiKeyCredentials | BasicAuthCredentials | NoAuthCredentials;
    /**
     * Metadata for the connection
     * @type {object}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    connectionMetaData?: object | null;
    /**
     * The unique identifier of the connection
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface AgenticWorkflowModelsBaseBaseResponse
 */
export interface AgenticWorkflowModelsBaseBaseResponse {
    /**
     * The message of the response
     * @type {string}
     * @memberof AgenticWorkflowModelsBaseBaseResponse
     */
    message?: string;
    /**
     * The status of the response
     * @type {string}
     * @memberof AgenticWorkflowModelsBaseBaseResponse
     */
    status?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum AggregationFormula {
    COUNT = 'COUNT',
    SUM = 'SUM',
    MEDIAN = 'MEDIAN'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum AggregationPeriod {
    MONTHLY = 'MONTHLY',
    WEEKLY = 'WEEKLY',
    DAILY = 'DAILY'
}

/**
 * 
 * @export
 * @interface AnalyticsModelInput
 */
export interface AnalyticsModelInput {
    /**
     * 
     * @type {SparrModelsAnalyticsConversationAnalyticsModel}
     * @memberof AnalyticsModelInput
     */
    conversation_analytics: SparrModelsAnalyticsConversationAnalyticsModel;
    /**
     * 
     * @type {GoalsAnalyticsModel}
     * @memberof AnalyticsModelInput
     */
    goals_analytics: GoalsAnalyticsModel;
    /**
     * 
     * @type {CoachAnalyticsModel}
     * @memberof AnalyticsModelInput
     */
    coach_analytics: CoachAnalyticsModel;
    /**
     * 
     * @type {SystemMetrics}
     * @memberof AnalyticsModelInput
     */
    system_metrics: SystemMetrics | null;
    /**
     * 
     * @type {any}
     * @memberof AnalyticsModelInput
     */
    weighted_scores: any | null;
}
/**
 * 
 * @export
 * @interface AnalyticsModelOutput
 */
export interface AnalyticsModelOutput {
    /**
     * 
     * @type {SparrModelsAnalyticsConversationAnalyticsModel}
     * @memberof AnalyticsModelOutput
     */
    conversation_analytics: SparrModelsAnalyticsConversationAnalyticsModel;
    /**
     * 
     * @type {GoalsAnalyticsModel}
     * @memberof AnalyticsModelOutput
     */
    goals_analytics: GoalsAnalyticsModel;
    /**
     * 
     * @type {CoachAnalyticsModel}
     * @memberof AnalyticsModelOutput
     */
    coach_analytics: CoachAnalyticsModel;
    /**
     * 
     * @type {SystemMetrics}
     * @memberof AnalyticsModelOutput
     */
    system_metrics: SystemMetrics | null;
    /**
     * 
     * @type {any}
     * @memberof AnalyticsModelOutput
     */
    weighted_scores: any | null;
}
/**
 * API key authentication configuration
 * @export
 * @interface ApiKeyAuth
 */
export interface ApiKeyAuth {
    /**
     * The type of authentication
     * @type {string}
     * @memberof ApiKeyAuth
     */
    authType?: ApiKeyAuthAuthTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiKeyAuthAuthTypeEnum {
    Apikey = 'apikey'
}

/**
 * 
 * @export
 * @interface ApiKeyCredentials
 */
export interface ApiKeyCredentials {
    /**
     * Credential type identifier
     * @type {string}
     * @memberof ApiKeyCredentials
     */
    credentialsType?: ApiKeyCredentialsCredentialsTypeEnum;
    /**
     * The API key for the app
     * @type {string}
     * @memberof ApiKeyCredentials
     */
    apiKey: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiKeyCredentialsCredentialsTypeEnum {
    Apikey = 'apikey'
}

/**
 * 
 * @export
 * @interface ApiKeyRequest
 */
export interface ApiKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiKeyRequest
     */
    key_type?: string | null;
}
/**
 * App represents an integration that can be connected to perform actions and triggers
 * @export
 * @interface App
 */
export interface App {
    /**
     * The user who created.
     * @type {string}
     * @memberof App
     */
    createdBy?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof App
     */
    createdAt?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof App
     */
    updatedBy?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof App
     */
    updatedAt?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof App
     */
    orgId?: string;
    /**
     * The name of the app
     * @type {string}
     * @memberof App
     */
    name?: string;
    /**
     * The description of the app
     * @type {string}
     * @memberof App
     */
    description?: string | null;
    /**
     * API Endpoint URL for the app
     * @type {string}
     * @memberof App
     */
    endpointUrl?: string | null;
    /**
     * URL to the app\'s logo image
     * @type {string}
     * @memberof App
     */
    logoUrl?: string | null;
    /**
     * Authentication configuration for the app
     * @type {Array<OAuth | ApiKeyAuth | BasicAuth | NoAuth>}
     * @memberof App
     */
    auth: Array<OAuth | ApiKeyAuth | BasicAuth | NoAuth>;
    /**
     * The version of the app
     * @type {string}
     * @memberof App
     */
    version?: string;
    /**
     * The unique identifier of the app
     * @type {string}
     * @memberof App
     */
    id?: string;
}
/**
 * AppAction represents an action that can be performed by an app
 * @export
 * @interface AppAction
 */
export interface AppAction {
    /**
     * The user who created.
     * @type {string}
     * @memberof AppAction
     */
    createdBy?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof AppAction
     */
    createdAt?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof AppAction
     */
    updatedBy?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof AppAction
     */
    updatedAt?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof AppAction
     */
    orgId?: string;
    /**
     * The type of the step, can be either trigger or action
     * @type {AppActionType}
     * @memberof AppAction
     */
    actionType: AppActionType;
    /**
     * The name of the step. This name should be unique within the app
     * @type {string}
     * @memberof AppAction
     */
    name?: string;
    /**
     * The description of the step
     * @type {string}
     * @memberof AppAction
     */
    description?: string;
    /**
     * JSON Schema for the step data
     * @type {object}
     * @memberof AppAction
     */
    dataSchema: object;
    /**
     * JSON Schema for the UI representation
     * @type {object}
     * @memberof AppAction
     */
    uiSchema: object;
    /**
     * This represents how this action should be displayed in the UI
     * @type {UiNodeType}
     * @memberof AppAction
     */
    uiNodeType: UiNodeType;
    /**
     * The ID of the app that this action belongs to
     * @type {string}
     * @memberof AppAction
     */
    appId: string;
    /**
     * The version of the app that this action belongs to
     * @type {string}
     * @memberof AppAction
     */
    appVersion: string;
    /**
     * The unique identifier of the app action
     * @type {string}
     * @memberof AppAction
     */
    id?: string;
}
/**
 * App Action Model
 * @export
 * @interface AppActionEntity
 */
export interface AppActionEntity {
    /**
     * The type of the step, can be either trigger or action
     * @type {AppActionType}
     * @memberof AppActionEntity
     */
    actionType: AppActionType;
    /**
     * The name of the step. This name should be unique within the app
     * @type {string}
     * @memberof AppActionEntity
     */
    name?: string;
    /**
     * The description of the step
     * @type {string}
     * @memberof AppActionEntity
     */
    description?: string;
    /**
     * JSON Schema for the step data
     * @type {object}
     * @memberof AppActionEntity
     */
    dataSchema: object;
    /**
     * JSON Schema for the UI representation
     * @type {object}
     * @memberof AppActionEntity
     */
    uiSchema: object;
    /**
     * This represents how this action should be displayed in the UI
     * @type {UiNodeType}
     * @memberof AppActionEntity
     */
    uiNodeType: UiNodeType;
}
/**
 * Enum for step types
 * @export
 * @enum {string}
 */
export enum AppActionType {
    TRIGGER = 'TRIGGER',
    ACTION = 'ACTION'
}

/**
 * App DTO Model filled by user
 * @export
 * @interface AppEntity
 */
export interface AppEntity {
    /**
     * The name of the app
     * @type {string}
     * @memberof AppEntity
     */
    name?: string;
    /**
     * The description of the app
     * @type {string}
     * @memberof AppEntity
     */
    description?: string | null;
    /**
     * API Endpoint URL for the app
     * @type {string}
     * @memberof AppEntity
     */
    endpointUrl?: string | null;
    /**
     * URL to the app\'s logo image
     * @type {string}
     * @memberof AppEntity
     */
    logoUrl?: string | null;
    /**
     * Authentication configuration for the app
     * @type {Array<OAuth | ApiKeyAuth | BasicAuth | NoAuth>}
     * @memberof AppEntity
     */
    auth: Array<OAuth | ApiKeyAuth | BasicAuth | NoAuth>;
    /**
     * The version of the app
     * @type {string}
     * @memberof AppEntity
     */
    version?: string;
    /**
     * Array of available actions with their configurations
     * @type {Array<AppActionEntity>}
     * @memberof AppEntity
     */
    actions: Array<AppActionEntity>;
}
/**
 * Enum which stores the list of apps which are used to create the conversation
 * @export
 * @enum {string}
 */
export enum AppEnumInput {
    TRATA = 'TRATA',
    TRATASPARR = 'TRATA_SPARR',
    TRATASPARRV1 = 'TRATA_SPARR_V1'
}

/**
 * Enum which stores the list of apps which are used to create the conversation
 * @export
 * @enum {string}
 */
export enum AppEnumOutput {
    TRATA = 'TRATA',
    TRATASPARR = 'TRATA_SPARR',
    TRATASPARRV1 = 'TRATA_SPARR_V1'
}

/**
 * 
 * @export
 * @interface AppResponse
 */
export interface AppResponse {
    /**
     * 
     * @type {App}
     * @memberof AppResponse
     */
    app: App;
    /**
     * 
     * @type {Array<AppAction>}
     * @memberof AppResponse
     */
    actions: Array<AppAction>;
}
/**
 * Audit log details of the business
 * @export
 * @interface AuditLog
 */
export interface AuditLog {
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    action?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    description?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum AuthRole {
    Owner = 'Owner',
    Admin = 'Admin',
    Member = 'Member'
}

/**
 * 
 * @export
 * @interface AvailablePhoneNumber
 */
export interface AvailablePhoneNumber {
    /**
     * 
     * @type {string}
     * @memberof AvailablePhoneNumber
     */
    phoneNumber: string;
    /**
     * 
     * @type {string}
     * @memberof AvailablePhoneNumber
     */
    countryCode: string;
    /**
     * 
     * @type {string}
     * @memberof AvailablePhoneNumber
     */
    locality: string | null;
    /**
     * 
     * @type {string}
     * @memberof AvailablePhoneNumber
     */
    region: string | null;
}
/**
 * 
 * @export
 * @interface BaseResponseInput
 */
export interface BaseResponseInput {
    /**
     * Address line 1
     * @type {string}
     * @memberof BaseResponseInput
     */
    message: string;
}
/**
 * Basic authentication configuration
 * @export
 * @interface BasicAuth
 */
export interface BasicAuth {
    /**
     * The type of authentication
     * @type {string}
     * @memberof BasicAuth
     */
    authType?: BasicAuthAuthTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum BasicAuthAuthTypeEnum {
    Basic = 'basic'
}

/**
 * 
 * @export
 * @interface BasicAuthCredentials
 */
export interface BasicAuthCredentials {
    /**
     * Credential type identifier
     * @type {string}
     * @memberof BasicAuthCredentials
     */
    credentialsType?: BasicAuthCredentialsCredentialsTypeEnum;
    /**
     * The username for the app
     * @type {string}
     * @memberof BasicAuthCredentials
     */
    username: string;
    /**
     * The password for the app
     * @type {string}
     * @memberof BasicAuthCredentials
     */
    password: string;
}

/**
    * @export
    * @enum {string}
    */
export enum BasicAuthCredentialsCredentialsTypeEnum {
    Basic = 'basic'
}

/**
 * 
 * @export
 * @interface BasicCredentials
 */
export interface BasicCredentials {
    /**
     * Email of the user
     * @type {string}
     * @memberof BasicCredentials
     */
    email: string;
    /**
     * Password of the user
     * @type {string}
     * @memberof BasicCredentials
     */
    password: string;
}
/**
 * 
 * @export
 * @interface BatchMetricsRequestsInput
 */
export interface BatchMetricsRequestsInput {
    /**
     * 
     * @type {Array<MetricsRequestInput>}
     * @memberof BatchMetricsRequestsInput
     */
    requests: Array<MetricsRequestInput>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BatchMetricsRequestsInput
     */
    orgIds?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface BatchMetricsResponseInput
 */
export interface BatchMetricsResponseInput {
    /**
     * 
     * @type {Array<MetricsResponseInput>}
     * @memberof BatchMetricsResponseInput
     */
    responses: Array<MetricsResponseInput>;
}
/**
 * 
 * @export
 * @interface BodyCreateCustomerOrganizationV1
 */
export interface BodyCreateCustomerOrganizationV1 {
    /**
     * 
     * @type {OrganizationInput}
     * @memberof BodyCreateCustomerOrganizationV1
     */
    customer_org: OrganizationInput;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateCustomerOrganizationV1
     */
    adminUserName: string;
}
/**
 * 
 * @export
 * @interface BodyCreateOrganizationV1
 */
export interface BodyCreateOrganizationV1 {
    /**
     * 
     * @type {OrganizationInput}
     * @memberof BodyCreateOrganizationV1
     */
    org: OrganizationInput;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateOrganizationV1
     */
    adminUserName: string;
}
/**
 * 
 * @export
 * @interface BodyCreateResellerOrganizationV1
 */
export interface BodyCreateResellerOrganizationV1 {
    /**
     * 
     * @type {OrganizationInput}
     * @memberof BodyCreateResellerOrganizationV1
     */
    org: OrganizationInput;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateResellerOrganizationV1
     */
    adminUserName: string;
}
/**
 * 
 * @export
 * @interface BodyUploadFileV1
 */
export interface BodyUploadFileV1 {
    /**
     * 
     * @type {Array<any>}
     * @memberof BodyUploadFileV1
     */
    files: Array<any>;
}
/**
 * 
 * @export
 * @interface BodyUploadFileV1WorkflowsWorkflowIdFilePost
 */
export interface BodyUploadFileV1WorkflowsWorkflowIdFilePost {
    /**
     * 
     * @type {any}
     * @memberof BodyUploadFileV1WorkflowsWorkflowIdFilePost
     */
    file: any;
}
/**
 * 
 * @export
 * @interface BodyUploadResellerFilesV1
 */
export interface BodyUploadResellerFilesV1 {
    /**
     * 
     * @type {Array<any>}
     * @memberof BodyUploadResellerFilesV1
     */
    files: Array<any>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CallSentiment {
    Positive = 'positive',
    Negative = 'negative',
    Neutral = 'neutral'
}

/**
 * 
 * @export
 * @interface CoachAnalyticsModel
 */
export interface CoachAnalyticsModel {
    /**
     * Provide 2 to 3 straightforward examples of how the role player could have improved their handling of the conversation. Quote the exact words used by the role player and suggest an alternative response that better aligns with the intended goals. Additionally, specify which goal could have been better achieved with the improved response.
     * @type {Array<string>}
     * @memberof CoachAnalyticsModel
     */
    coaching_points?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * Notes or comments to record
     * @type {string}
     * @memberof Comment
     */
    comment: string;
    /**
     * Star rating to record
     * @type {number}
     * @memberof Comment
     */
    rating: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CommunicationStyle {
    Direct = 'direct',
    Indirect = 'indirect',
    Verbose = 'verbose',
    Brief = 'brief'
}

/**
 * Condition Model for branching/looping logic
 * @export
 * @interface Condition
 */
export interface Condition {
    /**
     * Condition expression to evaluate
     * @type {string}
     * @memberof Condition
     */
    when: string;
    /**
     * Next step ID if condition is true
     * @type {string}
     * @memberof Condition
     */
    stepId: string;
}
/**
 * Core Connection Model
 * @export
 * @interface ConnectionCore
 */
export interface ConnectionCore {
    /**
     * The name of the connection
     * @type {string}
     * @memberof ConnectionCore
     */
    name?: string;
    /**
     * The unique identifier of the app
     * @type {string}
     * @memberof ConnectionCore
     */
    appId?: string;
    /**
     * The version of the app
     * @type {string}
     * @memberof ConnectionCore
     */
    appVersion?: string;
    /**
     * The description of the connection
     * @type {string}
     * @memberof ConnectionCore
     */
    description?: string | null;
    /**
     * OAuth or API key authentication configuration
     * @type {OAuthCredentials | ApiKeyCredentials | BasicAuthCredentials | NoAuthCredentials}
     * @memberof ConnectionCore
     */
    credentials: OAuthCredentials | ApiKeyCredentials | BasicAuthCredentials | NoAuthCredentials;
    /**
     * Metadata for the connection
     * @type {object}
     * @memberof ConnectionCore
     */
    connectionMetaData?: object | null;
}
/**
 * This represents the connection between the user and the assistant
 * @export
 * @interface ConnectionOutput
 */
export interface ConnectionOutput {
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    sourceName?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    sourceId?: string;
    /**
     * 
     * @type {object}
     * @memberof ConnectionOutput
     */
    sourceProps?: object | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    agentId?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    prospectId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface ConnectionSource
 */
export interface ConnectionSource {
    /**
     * Name of the source
     * @type {string}
     * @memberof ConnectionSource
     */
    sourceName?: ConnectionSourceSourceNameEnum;
    /**
     * Unique identifier for the source
     * @type {string}
     * @memberof ConnectionSource
     */
    sourceId: string;
    /**
     * Extra properties of source
     * @type {object}
     * @memberof ConnectionSource
     */
    sourceProps: object;
}

/**
    * @export
    * @enum {string}
    */
export enum ConnectionSourceSourceNameEnum {
    TWILIO = 'TWILIO',
    PLIVO = 'PLIVO',
    BROWSER = 'BROWSER'
}

/**
 * Expected output of the post conversation task
 * @export
 * @interface ConversationAnalyticsModelInput
 */
export interface ConversationAnalyticsModelInput {
    /**
     * Summary of the conversation happened with important details on the conversation. The summary should be concise and to the point. It should contain the important details of the conversation like name, phone number, email, address and any other details shared by the user.
     * @type {string}
     * @memberof ConversationAnalyticsModelInput
     */
    summary: string | null;
    /**
     * List of action items and the next steps to be performed from the conversation details.
     * @type {Array<string>}
     * @memberof ConversationAnalyticsModelInput
     */
    action_items: Array<string> | null;
    /**
     * If the user has given consent to store the audio of the conversation. Unless the user explicitly says yes, this should be false.
     * @type {boolean}
     * @memberof ConversationAnalyticsModelInput
     */
    is_audio_consent_given: boolean;
    /**
     * Extracted email address of the caller from the conversation details. Email should be a valid email address format
     * @type {string}
     * @memberof ConversationAnalyticsModelInput
     */
    email_address_of_caller: string | null;
    /**
     * Extracted name of the caller from the conversation details.
     * @type {string}
     * @memberof ConversationAnalyticsModelInput
     */
    name_of_caller: string | null;
    /**
     * Extracted phone number of the caller from the conversation details.
     * @type {string}
     * @memberof ConversationAnalyticsModelInput
     */
    phone_number_of_caller: string | null;
    /**
     * Extracted address of the caller from the conversation details.
     * @type {string}
     * @memberof ConversationAnalyticsModelInput
     */
    address_of_caller: string | null;
    /**
     * Sentiment of the caller based on the conversation details.
     * @type {CallSentiment}
     * @memberof ConversationAnalyticsModelInput
     */
    sentiment_of_caller: CallSentiment;
    /**
     * Status of the prospect after this conversation.
     * @type {ProspectStatus}
     * @memberof ConversationAnalyticsModelInput
     */
    prospectStatus: ProspectStatus | null;
}
/**
 * 
 * @export
 * @interface ConversationEndEvent
 */
export interface ConversationEndEvent {
    /**
     * 
     * @type {string}
     * @memberof ConversationEndEvent
     */
    timestamp: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationEndEvent
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationEndEvent
     */
    event_name: string;
    /**
     * 
     * @type {ConversationEndEventPayload}
     * @memberof ConversationEndEvent
     */
    payload?: ConversationEndEventPayload;
}
/**
 * 
 * @export
 * @interface ConversationEndEventPayload
 */
export interface ConversationEndEventPayload {
    /**
     * 
     * @type {ConversationOutput}
     * @memberof ConversationEndEventPayload
     */
    conversation: ConversationOutput;
}
/**
 * Model which stores the evaluation metrics for the conversation
 * @export
 * @interface ConversationEvaluation
 */
export interface ConversationEvaluation {
    /**
     * 
     * @type {string}
     * @memberof ConversationEvaluation
     */
    aiEvaluationSummary: string | null;
    /**
     * 
     * @type {Array<ConversationEvaluationData>}
     * @memberof ConversationEvaluation
     */
    aiEvaluations: Array<ConversationEvaluationData>;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof ConversationEvaluation
     */
    aiWhatWentWell: string | Array<string> | null;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof ConversationEvaluation
     */
    aiWhatCanBeImproved: string | Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationEvaluation
     */
    humanEvaluationSummary: string | null;
    /**
     * 
     * @type {Array<ConversationEvaluationData>}
     * @memberof ConversationEvaluation
     */
    humanEvaluations: Array<ConversationEvaluationData> | null;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof ConversationEvaluation
     */
    humanWhatWentWell: string | Array<string> | null;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof ConversationEvaluation
     */
    humanWhatCanBeImproved: string | Array<string> | null;
}
/**
 * Model which stores the result of the evaluation metric for a conversation
 * @export
 * @interface ConversationEvaluationData
 */
export interface ConversationEvaluationData {
    /**
     * Name of the evaluation metric
     * @type {string}
     * @memberof ConversationEvaluationData
     */
    name?: string;
    /**
     * Description about the evaluation metric
     * @type {string}
     * @memberof ConversationEvaluationData
     */
    description?: string;
    /**
     * Value of the evaluation metric
     * @type {string}
     * @memberof ConversationEvaluationData
     */
    value?: string;
}
/**
 * Model which stores the details of each evaluation metric
 * @export
 * @interface ConversationEvaluationMetric
 */
export interface ConversationEvaluationMetric {
    /**
     * Name of the evaluation metric
     * @type {string}
     * @memberof ConversationEvaluationMetric
     */
    name?: string;
    /**
     * Description about the evaluation metric
     * @type {string}
     * @memberof ConversationEvaluationMetric
     */
    description?: string;
}
/**
 * Model which stores all the evaluation metrics which is used to evaluate the conversation
 * @export
 * @interface ConversationEvaluationMetrics
 */
export interface ConversationEvaluationMetrics {
    /**
     * 
     * @type {Array<ConversationEvaluationMetric>}
     * @memberof ConversationEvaluationMetrics
     */
    qualitativeMetrics: Array<ConversationEvaluationMetric> | null;
    /**
     * 
     * @type {Array<ConversationEvaluationMetric>}
     * @memberof ConversationEvaluationMetrics
     */
    quantitativeMetrics: Array<ConversationEvaluationMetric> | null;
}
/**
 * Any feedback added to the conversation by business is managed here.
 * @export
 * @interface ConversationFeedback
 */
export interface ConversationFeedback {
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    conversationId?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    feedback?: string;
    /**
     * 
     * @type {number}
     * @memberof ConversationFeedback
     */
    rating?: number;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface ConversationInput
 */
export interface ConversationInput {
    /**
     * Source from where the conversation originated. This can be device id, phone number, etc.
     * @type {string}
     * @memberof ConversationInput
     */
    source: string;
    /**
     * Type of the conversation source
     * @type {ConversationSourceType}
     * @memberof ConversationInput
     */
    sourceType: ConversationSourceType;
    /**
     * AI agent which handled the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    agentId: string;
    /**
     * App in which the conversation is created
     * @type {AppEnumInput}
     * @memberof ConversationInput
     */
    app?: AppEnumInput | null;
    /**
     * URL to the full transcript of the conversation
     * @type {Array<DialogLine>}
     * @memberof ConversationInput
     */
    transcriptText?: Array<DialogLine> | null;
    /**
     * Summary of the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    transcriptSummary?: string | null;
    /**
     * URL to the recording of the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    transcriptRecordingUrl?: string | null;
    /**
     * Start time of the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    timestampStart: string;
    /**
     * End time of the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    timestampEnd?: string | null;
    /**
     * Analytics of the conversation
     * @type {ConversationAnalyticsModelInput}
     * @memberof ConversationInput
     */
    conversationAnalytics?: ConversationAnalyticsModelInput | null;
    /**
     * Comments from the admin on the conversation
     * @type {Array<Comment>}
     * @memberof ConversationInput
     */
    adminComments?: Array<Comment> | null;
    /**
     * Stats of the conversation
     * @type {ConversationStatsModel}
     * @memberof ConversationInput
     */
    conversationStats?: ConversationStatsModel | null;
    /**
     * Evaluation of the conversation
     * @type {ConversationEvaluation}
     * @memberof ConversationInput
     */
    evaluation?: ConversationEvaluation | null;
}
/**
 * Any conversation happening between the end user and assistant is stored in this table
 * @export
 * @interface ConversationOutput
 */
export interface ConversationOutput {
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    prospectId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    source?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    sourceType?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    aiAgentId?: string;
    /**
     * 
     * @type {Array<DialogLine>}
     * @memberof ConversationOutput
     */
    transcriptText?: Array<DialogLine> | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    transcriptSummary?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    transcriptRecordingUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    timestampStart?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    timestampEnd?: string | null;
    /**
     * Analytics of the conversation
     * @type {ConversationAnalyticsModelInput}
     * @memberof ConversationOutput
     */
    conversationAnalytics?: ConversationAnalyticsModelInput | null;
    /**
     * Stats of the conversation
     * @type {ConversationStatsModel}
     * @memberof ConversationOutput
     */
    conversationStats?: ConversationStatsModel | null;
    /**
     * Application under which the conversation is created
     * @type {AppEnumOutput}
     * @memberof ConversationOutput
     */
    app?: AppEnumOutput | null;
    /**
     * Evaluation of the conversation
     * @type {ConversationEvaluation}
     * @memberof ConversationOutput
     */
    evaluation?: ConversationEvaluation | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ConversationSourceType {
    BROWSER = 'BROWSER',
    TWILIO = 'TWILIO',
    PLIVO = 'PLIVO'
}

/**
 * 
 * @export
 * @interface ConversationStartEvent
 */
export interface ConversationStartEvent {
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEvent
     */
    timestamp: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEvent
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEvent
     */
    event_name: string;
    /**
     * 
     * @type {ConversationStartEventPayload}
     * @memberof ConversationStartEvent
     */
    payload?: ConversationStartEventPayload;
}
/**
 * 
 * @export
 * @interface ConversationStartEventPayload
 */
export interface ConversationStartEventPayload {
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEventPayload
     */
    type: ConversationStartEventPayloadTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEventPayload
     */
    connection_id: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEventPayload
     */
    conversation_id: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEventPayload
     */
    ai_agent_id: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEventPayload
     */
    org_id: string;
    /**
     * 
     * @type {object}
     * @memberof ConversationStartEventPayload
     */
    caller_id: object | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ConversationStartEventPayloadTypeEnum {
    ConversationStart = 'conversation_start'
}

/**
 * 
 * @export
 * @interface ConversationStatsModel
 */
export interface ConversationStatsModel {
    /**
     * Total number of dialogs in the conversation
     * @type {number}
     * @memberof ConversationStatsModel
     */
    total_dialog: number;
    /**
     * Ratio of Agent dialogs to total dialogs
     * @type {number}
     * @memberof ConversationStatsModel
     */
    agent_dialog_ratio: number;
    /**
     * Ratio of User dialogs to total dialogs
     * @type {number}
     * @memberof ConversationStatsModel
     */
    user_dialog_ratio: number;
}
/**
 * 
 * @export
 * @interface CountryInfo
 */
export interface CountryInfo {
    /**
     * 
     * @type {string}
     * @memberof CountryInfo
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof CountryInfo
     */
    name: string;
}
/**
 * Course represents a course that can be used in a scenario
 * @export
 * @interface Course
 */
export interface Course {
    /**
     * The user who created.
     * @type {string}
     * @memberof Course
     */
    createdBy?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof Course
     */
    createdAt?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof Course
     */
    updatedBy?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof Course
     */
    updatedAt?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof Course
     */
    orgId?: string;
    /**
     * The name of the course
     * @type {string}
     * @memberof Course
     */
    name: string;
    /**
     * The photo URL of the course
     * @type {string}
     * @memberof Course
     */
    photoUrl?: string | null;
    /**
     * The description of the course
     * @type {string}
     * @memberof Course
     */
    description: string;
    /**
     * The status of the course
     * @type {string}
     * @memberof Course
     */
    status: string;
    /**
     * The tags of the course
     * @type {Array<string>}
     * @memberof Course
     */
    tags?: Array<string> | null;
    /**
     * The unique identifier of the course
     * @type {string}
     * @memberof Course
     */
    id?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CourseCompletionStatus {
    NOTSTARTED = 'NOT_STARTED',
    INPROGRESS = 'IN_PROGRESS',
    COMPLETED = 'COMPLETED'
}

/**
 * 
 * @export
 * @interface CourseCore
 */
export interface CourseCore {
    /**
     * The name of the course
     * @type {string}
     * @memberof CourseCore
     */
    name: string;
    /**
     * The photo URL of the course
     * @type {string}
     * @memberof CourseCore
     */
    photoUrl?: string | null;
    /**
     * The description of the course
     * @type {string}
     * @memberof CourseCore
     */
    description: string;
    /**
     * The status of the course
     * @type {string}
     * @memberof CourseCore
     */
    status: string;
    /**
     * The tags of the course
     * @type {Array<string>}
     * @memberof CourseCore
     */
    tags?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CourseRequest
 */
export interface CourseRequest {
    /**
     * 
     * @type {CourseCore}
     * @memberof CourseRequest
     */
    course: CourseCore;
    /**
     * 
     * @type {Array<ModuleCore>}
     * @memberof CourseRequest
     */
    modules: Array<ModuleCore>;
}
/**
 * 
 * @export
 * @interface CourseResponse
 */
export interface CourseResponse {
    /**
     * 
     * @type {Course}
     * @memberof CourseResponse
     */
    course: Course;
    /**
     * 
     * @type {Array<Module>}
     * @memberof CourseResponse
     */
    modules: Array<Module>;
}
/**
 * 
 * @export
 * @interface CourseUpdateRequest
 */
export interface CourseUpdateRequest {
    /**
     * 
     * @type {CourseCore}
     * @memberof CourseUpdateRequest
     */
    course: CourseCore;
    /**
     * 
     * @type {Array<ModuleUpdateRequest>}
     * @memberof CourseUpdateRequest
     */
    modules: Array<ModuleUpdateRequest>;
}
/**
 * Credits details of the business
 * @export
 * @interface Credit
 */
export interface Credit {
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    creditTypeName?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    totalAvailable?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    consumed?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    durationStart?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    durationEnd?: string;
}
/**
 * Enum for the type of credit
 * @export
 * @enum {string}
 */
export enum CreditTypeEnum {
    PhoneNumbers = 'phone_numbers',
    CallSeconds = 'call_seconds',
    CallHours = 'call_hours',
    Emails = 'emails',
    LinkedInScraping = 'linked_in_scraping',
    Courses = 'courses',
    RecordingAndTranscription = 'recording_and_transcription',
    Users = 'users',
    AdvancedIntelligence = 'advanced_intelligence',
    RolePlayCustomization = 'role_play_customization'
}

/**
 * 
 * @export
 * @interface CustomerBranding
 */
export interface CustomerBranding {
    /**
     * Name of the organization
     * @type {string}
     * @memberof CustomerBranding
     */
    name?: string | null;
    /**
     * Brand color of the organization
     * @type {string}
     * @memberof CustomerBranding
     */
    brandColor?: string | null;
    /**
     * Button color of the organization
     * @type {string}
     * @memberof CustomerBranding
     */
    buttonColor?: string | null;
    /**
     * Secondary color of the organization
     * @type {string}
     * @memberof CustomerBranding
     */
    secondaryColor?: string | null;
    /**
     * Text color of the organization
     * @type {string}
     * @memberof CustomerBranding
     */
    textColor?: string | null;
    /**
     * Favicon of the organization
     * @type {string}
     * @memberof CustomerBranding
     */
    favicon?: string | null;
    /**
     * Favicon URL of the organization
     * @type {string}
     * @memberof CustomerBranding
     */
    faviconUrl?: string | null;
    /**
     * Logo of the organization
     * @type {string}
     * @memberof CustomerBranding
     */
    logo?: string | null;
    /**
     * Logo URL of the organization
     * @type {string}
     * @memberof CustomerBranding
     */
    logoUrl?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DecisionMakingStyle {
    Logical = 'logical',
    Emotional = 'emotional',
    Impulsive = 'impulsive',
    Hesitant = 'hesitant'
}

/**
 * 
 * @export
 * @interface DialogLine
 */
export interface DialogLine {
    /**
     * 
     * @type {string}
     * @memberof DialogLine
     */
    speaker: DialogLineSpeakerEnum;
    /**
     * 
     * @type {string}
     * @memberof DialogLine
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof DialogLine
     */
    timestamp: string;
    /**
     * 
     * @type {string}
     * @memberof DialogLine
     */
    message_id: string;
}

/**
    * @export
    * @enum {string}
    */
export enum DialogLineSpeakerEnum {
    USER = 'USER',
    AI = 'AI',
    TOOL = 'TOOL',
    AITOOLREQUEST = 'AI - TOOL REQUEST'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum EngagementLevel {
    HighlyEngaged = 'highly engaged',
    Distracted = 'distracted',
    Uninterested = 'uninterested'
}

/**
 * 
 * @export
 * @interface ExternalReference
 */
export interface ExternalReference {
    /**
     * External service provider name
     * @type {string}
     * @memberof ExternalReference
     */
    providerName: string;
    /**
     * External service identifier
     * @type {string}
     * @memberof ExternalReference
     */
    id: string;
    /**
     * Props for the external reference
     * @type {object}
     * @memberof ExternalReference
     */
    providerProps?: object | null;
}
/**
 * 
 * @export
 * @interface ExternalServiceProviderInput
 */
export interface ExternalServiceProviderInput {
    /**
     * External service provider name
     * @type {string}
     * @memberof ExternalServiceProviderInput
     */
    providerName: string;
    /**
     * External service identifier
     * @type {string}
     * @memberof ExternalServiceProviderInput
     */
    id: string;
    /**
     * Props for the external service provider
     * @type {object}
     * @memberof ExternalServiceProviderInput
     */
    providerProps: object | null;
}
/**
 * 
 * @export
 * @interface ExternalServiceProviderOutput
 */
export interface ExternalServiceProviderOutput {
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceProviderOutput
     */
    providerName: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceProviderOutput
     */
    id: string;
    /**
     * 
     * @type {object}
     * @memberof ExternalServiceProviderOutput
     */
    providerProps: object | null;
}
/**
 * Feedback represents a feedback that can be given to a persona
 * @export
 * @interface Feedback
 */
export interface Feedback {
    /**
     * The user who created.
     * @type {string}
     * @memberof Feedback
     */
    createdBy?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof Feedback
     */
    createdAt?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof Feedback
     */
    updatedBy?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof Feedback
     */
    updatedAt?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof Feedback
     */
    orgId?: string;
    /**
     * The ID of the user who made the call
     * @type {string}
     * @memberof Feedback
     */
    userId: string;
    /**
     * The name of the user who made the call
     * @type {string}
     * @memberof Feedback
     */
    userName: string | null;
    /**
     * The ID of the AI agent
     * @type {string}
     * @memberof Feedback
     */
    aiAgentId: string | null;
    /**
     * The ID of the scenario
     * @type {string}
     * @memberof Feedback
     */
    scenarioId: string;
    /**
     * The name of the scenario
     * @type {string}
     * @memberof Feedback
     */
    scenarioName: string | null;
    /**
     * The ID of the persona
     * @type {string}
     * @memberof Feedback
     */
    personaId: string;
    /**
     * The name of the persona
     * @type {string}
     * @memberof Feedback
     */
    personaName: string | null;
    /**
     * The start timestamp of the conversation
     * @type {string}
     * @memberof Feedback
     */
    startTimestamp: string;
    /**
     * The end timestamp of the conversation
     * @type {string}
     * @memberof Feedback
     */
    endTimestamp: string;
    /**
     * The time in seconds when sparring started
     * @type {number}
     * @memberof Feedback
     */
    startSparringAt?: number;
    /**
     * The time in seconds when sparring ended
     * @type {number}
     * @memberof Feedback
     */
    endSparringAt?: number;
    /**
     * The top insights from the conversation
     * @type {Array<string>}
     * @memberof Feedback
     */
    topInsights: Array<string>;
    /**
     * The URL of the recording of the conversation
     * @type {string}
     * @memberof Feedback
     */
    recordingUrl: string;
    /**
     * The transcript of the conversation
     * @type {Array<SparrDialogLine>}
     * @memberof Feedback
     */
    transcript: Array<SparrDialogLine>;
    /**
     * The complete transcript of the conversation
     * @type {Array<SparrDialogLine>}
     * @memberof Feedback
     */
    completeTranscript?: Array<SparrDialogLine> | null;
    /**
     * The analytics of the conversation
     * @type {AnalyticsModelOutput}
     * @memberof Feedback
     */
    analytics: AnalyticsModelOutput;
    /**
     * The overall score of the conversation out of 100 based on the weightage of each goal
     * @type {number}
     * @memberof Feedback
     */
    overallScore: number;
    /**
     * The status of the feedback
     * @type {string}
     * @memberof Feedback
     */
    status?: string;
    /**
     * The unique identifier of the feedback
     * @type {string}
     * @memberof Feedback
     */
    id?: string;
    /**
     * The version of the feedback
     * @type {number}
     * @memberof Feedback
     */
    version?: number;
}
/**
 * 
 * @export
 * @interface FeedbackCore
 */
export interface FeedbackCore {
    /**
     * The ID of the user who made the call
     * @type {string}
     * @memberof FeedbackCore
     */
    userId: string;
    /**
     * The name of the user who made the call
     * @type {string}
     * @memberof FeedbackCore
     */
    userName: string | null;
    /**
     * The ID of the AI agent
     * @type {string}
     * @memberof FeedbackCore
     */
    aiAgentId: string | null;
    /**
     * The ID of the scenario
     * @type {string}
     * @memberof FeedbackCore
     */
    scenarioId: string;
    /**
     * The name of the scenario
     * @type {string}
     * @memberof FeedbackCore
     */
    scenarioName: string | null;
    /**
     * The ID of the persona
     * @type {string}
     * @memberof FeedbackCore
     */
    personaId: string;
    /**
     * The name of the persona
     * @type {string}
     * @memberof FeedbackCore
     */
    personaName: string | null;
    /**
     * The start timestamp of the conversation
     * @type {string}
     * @memberof FeedbackCore
     */
    startTimestamp: string;
    /**
     * The end timestamp of the conversation
     * @type {string}
     * @memberof FeedbackCore
     */
    endTimestamp: string;
    /**
     * The time in seconds when sparring started
     * @type {number}
     * @memberof FeedbackCore
     */
    startSparringAt?: number;
    /**
     * The time in seconds when sparring ended
     * @type {number}
     * @memberof FeedbackCore
     */
    endSparringAt?: number;
    /**
     * The top insights from the conversation
     * @type {Array<string>}
     * @memberof FeedbackCore
     */
    topInsights: Array<string>;
    /**
     * The URL of the recording of the conversation
     * @type {string}
     * @memberof FeedbackCore
     */
    recordingUrl: string;
    /**
     * The transcript of the conversation
     * @type {Array<SparrDialogLine>}
     * @memberof FeedbackCore
     */
    transcript: Array<SparrDialogLine>;
    /**
     * The complete transcript of the conversation
     * @type {Array<SparrDialogLine>}
     * @memberof FeedbackCore
     */
    completeTranscript?: Array<SparrDialogLine> | null;
    /**
     * The analytics of the conversation
     * @type {AnalyticsModelInput}
     * @memberof FeedbackCore
     */
    analytics: AnalyticsModelInput;
    /**
     * The overall score of the conversation out of 100 based on the weightage of each goal
     * @type {number}
     * @memberof FeedbackCore
     */
    overallScore: number;
    /**
     * The status of the feedback
     * @type {string}
     * @memberof FeedbackCore
     */
    status?: string;
}
/**
 * Stores the map of file id with respective file URL in storage manager
 * @export
 * @interface Files
 */
export interface Files {
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    fileName?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    fileUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface FillerWords
 */
export interface FillerWords {
    /**
     * 
     * @type {any}
     * @memberof FillerWords
     */
    words: any | null;
    /**
     * 
     * @type {number}
     * @memberof FillerWords
     */
    total: number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum FrustrationTolerance {
    QuickToAnger = 'quick to anger',
    Understanding = 'understanding',
    Neutral = 'neutral'
}

/**
 * 
 * @export
 * @interface Goal
 */
export interface Goal {
    /**
     * The name of the goal
     * @type {string}
     * @memberof Goal
     */
    name: string;
    /**
     * The description of the goal
     * @type {string}
     * @memberof Goal
     */
    description: string;
    /**
     * The weightage of the goal in percentage
     * @type {number}
     * @memberof Goal
     */
    weightage: number;
}
/**
 * 
 * @export
 * @interface GoalsAnalyticsModel
 */
export interface GoalsAnalyticsModel {
    /**
     * 
     * @type {object}
     * @memberof GoalsAnalyticsModel
     */
    goals: object | null;
}
/**
 * Guest users who are not verified by Trata yet
 * @export
 * @interface GuestInput
 */
export interface GuestInput {
    /**
     * 
     * @type {string}
     * @memberof GuestInput
     */
    email: string;
    /**
     * 
     * @type {Role}
     * @memberof GuestInput
     */
    role: Role;
}
/**
 * Guest users who are not verified by Trata yet. They will not be able to use Trata until they are verified.
 * @export
 * @interface GuestOutput
 */
export interface GuestOutput {
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    role?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GuestOutput
     */
    isEmailVerified?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    last_sent_date?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    guestInviteCode?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GuestOutput
     */
    sent_count?: number;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * Reference to all business knowledge base will be stored in Hive
 * @export
 * @interface Hive
 */
export interface Hive {
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    orgId?: string;
    /**
     * 
     * @type {HiveContentOutput}
     * @memberof Hive
     */
    content: HiveContentOutput;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface HiveContentInput
 */
export interface HiveContentInput {
    /**
     * 
     * @type {HiveType}
     * @memberof HiveContentInput
     */
    hiveType: HiveType;
    /**
     * URL of the content
     * @type {string}
     * @memberof HiveContentInput
     */
    url?: string | null;
    /**
     * List of file ids to be referenced for the hive
     * @type {Array<string>}
     * @memberof HiveContentInput
     */
    file_ids?: Array<string> | null;
    /**
     * To recursively crawl child pages, add this as props {\"crawl_child_pages\": true},  \"depth\": \"3\"
     * @type {object}
     * @memberof HiveContentInput
     */
    hiveProps?: object | null;
}
/**
 * 
 * @export
 * @interface HiveContentOutput
 */
export interface HiveContentOutput {
    /**
     * 
     * @type {HiveType}
     * @memberof HiveContentOutput
     */
    hiveType: HiveType;
    /**
     * URL of the content
     * @type {string}
     * @memberof HiveContentOutput
     */
    url?: string | null;
    /**
     * List of files to be referenced for the hive
     * @type {Array<Files>}
     * @memberof HiveContentOutput
     */
    files?: Array<Files> | null;
    /**
     * To recursively crawl child pages, add this as props {\"crawl_child_pages\": true},  \"depth\": \"3\"
     * @type {object}
     * @memberof HiveContentOutput
     */
    hiveProps?: object | null;
    /**
     * To add any internal props, add this as props {\"last_crawl_time\": \"123123123123\"}
     * @type {object}
     * @memberof HiveContentOutput
     */
    internalProps?: object | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum HiveType {
    WEBSITE = 'WEBSITE',
    GOOGLEDOCS = 'GOOGLE_DOCS',
    DOCS = 'DOCS',
    TRANSCRIPTS = 'TRANSCRIPTS'
}

/**
 * 
 * @export
 * @interface HttpActionEndpoint
 */
export interface HttpActionEndpoint {
    /**
     * Action endpoint URL
     * @type {string}
     * @memberof HttpActionEndpoint
     */
    url: string;
    /**
     * Method to be used for invoking the endpoint
     * @type {string}
     * @memberof HttpActionEndpoint
     */
    method?: HttpActionEndpointMethodEnum;
    /**
     * Headers for the endpoint
     * @type {object}
     * @memberof HttpActionEndpoint
     */
    headers?: object | null;
    /**
     * Payload for the endpoint
     * @type {object}
     * @memberof HttpActionEndpoint
     */
    payload?: object | null;
}

/**
    * @export
    * @enum {string}
    */
export enum HttpActionEndpointMethodEnum {
    GET = 'GET',
    POST = 'POST'
}

/**
 * 
 * @export
 * @interface IntelligenceProvider
 */
export interface IntelligenceProvider {
    /**
     * 
     * @type {string}
     * @memberof IntelligenceProvider
     */
    providerName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IntelligenceProvider
     */
    model?: string | null;
    /**
     * 
     * @type {object}
     * @memberof IntelligenceProvider
     */
    providerProps?: object | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum InteractionTone {
    Professional = 'professional',
    Casual = 'casual',
    Friendly = 'friendly',
    Authoritative = 'authoritative'
}

/**
 * Internal action endpoint to be used for calling the action inside the module. Not used by external users
 * @export
 * @interface InternalActionEndpoint
 */
export interface InternalActionEndpoint {
    /**
     * Module where the action is defined
     * @type {string}
     * @memberof InternalActionEndpoint
     */
    module: string;
    /**
     * Function to be called inside the module
     * @type {string}
     * @memberof InternalActionEndpoint
     */
    _function: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Language {
    English = 'English',
    Spanish = 'Spanish',
    Hindi = 'Hindi'
}

/**
 * 
 * @export
 * @interface LanguageAccentCombo
 */
export interface LanguageAccentCombo {
    /**
     * 
     * @type {Language}
     * @memberof LanguageAccentCombo
     */
    language: Language;
    /**
     * 
     * @type {Accent}
     * @memberof LanguageAccentCombo
     */
    accent: Accent;
}
/**
 * 
 * @export
 * @interface LongestMonologue
 */
export interface LongestMonologue {
    /**
     * 
     * @type {string}
     * @memberof LongestMonologue
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof LongestMonologue
     */
    start_at_seconds: number;
    /**
     * 
     * @type {number}
     * @memberof LongestMonologue
     */
    end_at_seconds: number;
    /**
     * 
     * @type {number}
     * @memberof LongestMonologue
     */
    duration: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MetricNameInput {
    CALLS = 'CALLS',
    CALLDURATION = 'CALL_DURATION',
    SPARRCALLS = 'SPARR_CALLS',
    SPARRCALLDURATION = 'SPARR_CALL_DURATION',
    APPOINTMENTSCHEDULED = 'APPOINTMENT_SCHEDULED',
    CREDITSCONSUMED = 'CREDITS_CONSUMED',
    CREDITSCONSUMEDPHONENUMBERS = 'CREDITS_CONSUMED_PHONE_NUMBERS',
    CREDITSCONSUMEDCALLSECONDS = 'CREDITS_CONSUMED_CALL_SECONDS',
    CREDITSCONSUMEDEMAILS = 'CREDITS_CONSUMED_EMAILS',
    CREDITSCONSUMEDLEADGENERATION = 'CREDITS_CONSUMED_LEAD_GENERATION',
    CREDITSCONSUMEDLINKEDINSCRAPING = 'CREDITS_CONSUMED_LINKED_IN_SCRAPING',
    CREDITSCONSUMEDCOURSES = 'CREDITS_CONSUMED_COURSES',
    CREDITSTOTAL = 'CREDITS_TOTAL',
    CREDITSTOTALPHONENUMBERS = 'CREDITS_TOTAL_PHONE_NUMBERS',
    CREDITSTOTALCALLSECONDS = 'CREDITS_TOTAL_CALL_SECONDS',
    CREDITSTOTALEMAILS = 'CREDITS_TOTAL_EMAILS',
    CREDITSTOTALLEADGENERATION = 'CREDITS_TOTAL_LEAD_GENERATION',
    CREDITSTOTALLINKEDINSCRAPING = 'CREDITS_TOTAL_LINKED_IN_SCRAPING',
    CREDITSTOTALCOURSES = 'CREDITS_TOTAL_COURSES',
    CREDITBURNRATE = 'CREDIT_BURN_RATE',
    CREDITBURNRATEPHONENUMBERS = 'CREDIT_BURN_RATE_PHONE_NUMBERS',
    CREDITBURNRATECALLSECONDS = 'CREDIT_BURN_RATE_CALL_SECONDS',
    CREDITBURNRATEEMAILS = 'CREDIT_BURN_RATE_EMAILS',
    CREDITBURNRATELEADGENERATION = 'CREDIT_BURN_RATE_LEAD_GENERATION',
    CREDITBURNRATELINKEDINSCRAPING = 'CREDIT_BURN_RATE_LINKED_IN_SCRAPING',
    CREDITBURNRATECOURSES = 'CREDIT_BURN_RATE_COURSES',
    TOTALREVENUE = 'TOTAL_REVENUE',
    PROFIT = 'PROFIT',
    REVENUEBYSUBSCRIPTION = 'REVENUE_BY_SUBSCRIPTION',
    REVENUEBYADDONS = 'REVENUE_BY_ADD_ONS',
    MONTHLYRECURRINGREVENUE = 'MONTHLY_RECURRING_REVENUE',
    ONETIMEREVENUE = 'ONE_TIME_REVENUE',
    ACTIVESUBSCRIPTIONS = 'ACTIVE_SUBSCRIPTIONS',
    NUMBEROFACTIVEPAYINGCUSTOMERS = 'NUMBER_OF_ACTIVE_PAYING_CUSTOMERS',
    AVERAGEREVENUEPERACTIVEPAYINGCUSTOMER = 'AVERAGE_REVENUE_PER_ACTIVE_PAYING_CUSTOMER',
    TOTALHOURSCONSUMED = 'TOTAL_HOURS_CONSUMED',
    PROSPECTS = 'PROSPECTS',
    INTERESTED = 'INTERESTED',
    NOTINTERESTED = 'NOT_INTERESTED',
    NEWCUSTOMERS = 'NEW_CUSTOMERS'
}

/**
 * 
 * @export
 * @interface MetricResponseDataPointInput
 */
export interface MetricResponseDataPointInput {
    /**
     * Timestamp of the data point
     * @type {string}
     * @memberof MetricResponseDataPointInput
     */
    timestamp: string;
    /**
     * Value which will be a string representation of integer or floating number
     * @type {string}
     * @memberof MetricResponseDataPointInput
     */
    value: string;
}
/**
 * 
 * @export
 * @interface MetricsRequestInput
 */
export interface MetricsRequestInput {
    /**
     * Unique identifier for the metric request. This can be helped to co-relate the request and response
     * @type {string}
     * @memberof MetricsRequestInput
     */
    id: string;
    /**
     * Name of the metric
     * @type {MetricNameInput}
     * @memberof MetricsRequestInput
     */
    name: MetricNameInput;
    /**
     * Start date to get metric request
     * @type {string}
     * @memberof MetricsRequestInput
     */
    fromDate: string;
    /**
     * End date until get metric request
     * @type {string}
     * @memberof MetricsRequestInput
     */
    toDate: string;
    /**
     * Aggregation period for the metric request
     * @type {AggregationPeriod}
     * @memberof MetricsRequestInput
     */
    aggregationPeriod: AggregationPeriod;
    /**
     * Aggregation formula for the metric request
     * @type {AggregationFormula}
     * @memberof MetricsRequestInput
     */
    aggregationFormula: AggregationFormula;
}
/**
 * 
 * @export
 * @interface MetricsResponseInput
 */
export interface MetricsResponseInput {
    /**
     * Unique identifier for the metric response. This will help co-relate the request and response
     * @type {string}
     * @memberof MetricsResponseInput
     */
    id: string;
    /**
     * Name of the metric
     * @type {MetricNameInput}
     * @memberof MetricsResponseInput
     */
    name: MetricNameInput;
    /**
     * List of data points for the metric response
     * @type {Array<MetricResponseDataPointInput>}
     * @memberof MetricsResponseInput
     */
    datapoints: Array<MetricResponseDataPointInput>;
}
/**
 * 
 * @export
 * @interface Mission
 */
export interface Mission {
    /**
     * Full prompt instructions for LLM model
     * @type {string}
     * @memberof Mission
     */
    prompt?: string | null;
    /**
     * Objective of the mission
     * @type {string}
     * @memberof Mission
     */
    objective?: string | null;
    /**
     * Greeting message to be read by the AI agent
     * @type {string}
     * @memberof Mission
     */
    greeting: string | null;
    /**
     * Sequence of actions to be performed by the AI agent during the conversation.
     * @type {Array<Sequence>}
     * @memberof Mission
     */
    sequence?: Array<Sequence> | null;
    /**
     * Conclusion message to be read by the AI agent
     * @type {string}
     * @memberof Mission
     */
    farewell?: string | null;
}
/**
 * Module represents a module that can be used in a course
 * @export
 * @interface Module
 */
export interface Module {
    /**
     * The user who created.
     * @type {string}
     * @memberof Module
     */
    createdBy?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof Module
     */
    createdAt?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof Module
     */
    updatedBy?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof Module
     */
    updatedAt?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof Module
     */
    orgId?: string;
    /**
     * The name of the module
     * @type {string}
     * @memberof Module
     */
    name: string;
    /**
     * The description of the module
     * @type {string}
     * @memberof Module
     */
    description: string;
    /**
     * The tags of the module
     * @type {Array<string>}
     * @memberof Module
     */
    tags?: Array<string> | null;
    /**
     * The difficulty level of the module
     * @type {string}
     * @memberof Module
     */
    difficultyLevel: string;
    /**
     * The ID of the persona
     * @type {string}
     * @memberof Module
     */
    personaId: string;
    /**
     * The name of the persona
     * @type {string}
     * @memberof Module
     */
    personaName: string | null;
    /**
     * The ID of the scenario
     * @type {string}
     * @memberof Module
     */
    scenarioId: string;
    /**
     * The name of the scenario
     * @type {string}
     * @memberof Module
     */
    scenarioName: string | null;
    /**
     * The expected completion score of the module out of 100
     * @type {number}
     * @memberof Module
     */
    passingScorePercentage: number;
    /**
     * The unique identifier of the module
     * @type {string}
     * @memberof Module
     */
    id?: string;
    /**
     * The ID of the course
     * @type {string}
     * @memberof Module
     */
    courseId: string;
    /**
     * The name of the course
     * @type {string}
     * @memberof Module
     */
    courseName: string | null;
    /**
     * The order of the module in the course
     * @type {number}
     * @memberof Module
     */
    moduleOrder: number;
}
/**
 * 
 * @export
 * @interface ModuleAnalytics
 */
export interface ModuleAnalytics {
    /**
     * The module information
     * @type {Module}
     * @memberof ModuleAnalytics
     */
    module: Module;
    /**
     * The number of attempts
     * @type {number}
     * @memberof ModuleAnalytics
     */
    numberOfAttempts: number;
    /**
     * The status of the last attempt
     * @type {ModuleAttemptStatus}
     * @memberof ModuleAnalytics
     */
    lastAttemptStatus: ModuleAttemptStatus;
    /**
     * Whether the module is completed
     * @type {boolean}
     * @memberof ModuleAnalytics
     */
    isModuleCompleted: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ModuleAttemptStatus {
    PASSED = 'PASSED',
    FAILED = 'FAILED',
    NOTATTEMPTED = 'NOT_ATTEMPTED'
}

/**
 * 
 * @export
 * @interface ModuleCore
 */
export interface ModuleCore {
    /**
     * The name of the module
     * @type {string}
     * @memberof ModuleCore
     */
    name: string;
    /**
     * The description of the module
     * @type {string}
     * @memberof ModuleCore
     */
    description: string;
    /**
     * The tags of the module
     * @type {Array<string>}
     * @memberof ModuleCore
     */
    tags?: Array<string> | null;
    /**
     * The difficulty level of the module
     * @type {string}
     * @memberof ModuleCore
     */
    difficultyLevel: string;
    /**
     * The ID of the persona
     * @type {string}
     * @memberof ModuleCore
     */
    personaId: string;
    /**
     * The name of the persona
     * @type {string}
     * @memberof ModuleCore
     */
    personaName: string | null;
    /**
     * The ID of the scenario
     * @type {string}
     * @memberof ModuleCore
     */
    scenarioId: string;
    /**
     * The name of the scenario
     * @type {string}
     * @memberof ModuleCore
     */
    scenarioName: string | null;
    /**
     * The expected completion score of the module out of 100
     * @type {number}
     * @memberof ModuleCore
     */
    passingScorePercentage: number;
}
/**
 * 
 * @export
 * @interface ModuleUpdateRequest
 */
export interface ModuleUpdateRequest {
    /**
     * The name of the module
     * @type {string}
     * @memberof ModuleUpdateRequest
     */
    name: string;
    /**
     * The description of the module
     * @type {string}
     * @memberof ModuleUpdateRequest
     */
    description: string;
    /**
     * The tags of the module
     * @type {Array<string>}
     * @memberof ModuleUpdateRequest
     */
    tags?: Array<string> | null;
    /**
     * The difficulty level of the module
     * @type {string}
     * @memberof ModuleUpdateRequest
     */
    difficultyLevel: string;
    /**
     * The ID of the persona
     * @type {string}
     * @memberof ModuleUpdateRequest
     */
    personaId: string;
    /**
     * The name of the persona
     * @type {string}
     * @memberof ModuleUpdateRequest
     */
    personaName: string | null;
    /**
     * The ID of the scenario
     * @type {string}
     * @memberof ModuleUpdateRequest
     */
    scenarioId: string;
    /**
     * The name of the scenario
     * @type {string}
     * @memberof ModuleUpdateRequest
     */
    scenarioName: string | null;
    /**
     * The expected completion score of the module out of 100
     * @type {number}
     * @memberof ModuleUpdateRequest
     */
    passingScorePercentage: number;
    /**
     * 
     * @type {string}
     * @memberof ModuleUpdateRequest
     */
    id?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum NegotiationStyle {
    HardBargainer = 'hard bargainer',
    FriendlyNegotiator = 'friendly negotiator',
    NonNegotiator = 'non-negotiator'
}

/**
 * Defines how to determine the next step
 * @export
 * @interface NextStepResolver
 */
export interface NextStepResolver {
    /**
     * Array of conditions to evaluate
     * @type {Array<Condition>}
     * @memberof NextStepResolver
     */
    conditions?: Array<Condition> | null;
    /**
     * Direct next step ID
     * @type {string}
     * @memberof NextStepResolver
     */
    nextStepId?: string | null;
}
/**
 * No authentication configuration
 * @export
 * @interface NoAuth
 */
export interface NoAuth {
    /**
     * The type of authentication
     * @type {string}
     * @memberof NoAuth
     */
    authType?: NoAuthAuthTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum NoAuthAuthTypeEnum {
    Noauth = 'noauth'
}

/**
 * 
 * @export
 * @interface NoAuthCredentials
 */
export interface NoAuthCredentials {
    /**
     * Credential type identifier
     * @type {string}
     * @memberof NoAuthCredentials
     */
    credentialsType?: NoAuthCredentialsCredentialsTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum NoAuthCredentialsCredentialsTypeEnum {
    Noauth = 'noauth'
}

/**
 * 
 * @export
 * @interface NumberPurchaseRequest
 */
export interface NumberPurchaseRequest {
    /**
     * 
     * @type {string}
     * @memberof NumberPurchaseRequest
     */
    countryCode: string;
    /**
     * 
     * @type {string}
     * @memberof NumberPurchaseRequest
     */
    phoneNumber: string;
}
/**
 * OAuth authentication configuration
 * @export
 * @interface OAuth
 */
export interface OAuth {
    /**
     * The type of authentication
     * @type {string}
     * @memberof OAuth
     */
    authType?: OAuthAuthTypeEnum;
    /**
     * The client ID for the OAuth app
     * @type {string}
     * @memberof OAuth
     */
    clientId: string;
    /**
     * The client secret for the OAuth app
     * @type {string}
     * @memberof OAuth
     */
    clientSecret: string;
    /**
     * The redirect URI for the OAuth app
     * @type {string}
     * @memberof OAuth
     */
    redirectUri: string;
    /**
     * The scopes for the OAuth app
     * @type {Array<string>}
     * @memberof OAuth
     */
    scopes?: Array<string> | null;
    /**
     * The authorization URL for the OAuth app
     * @type {string}
     * @memberof OAuth
     */
    authUrl: string;
    /**
     * The token URL for the OAuth app
     * @type {string}
     * @memberof OAuth
     */
    tokenUrl: string;
}

/**
    * @export
    * @enum {string}
    */
export enum OAuthAuthTypeEnum {
    Oauth = 'oauth'
}

/**
 * 
 * @export
 * @interface OAuthCredentials
 */
export interface OAuthCredentials {
    /**
     * Credential type identifier
     * @type {string}
     * @memberof OAuthCredentials
     */
    credentialsType?: OAuthCredentialsCredentialsTypeEnum;
    /**
     * The code for the OAuth app
     * @type {string}
     * @memberof OAuthCredentials
     */
    code?: string | null;
    /**
     * The access token for the OAuth app
     * @type {string}
     * @memberof OAuthCredentials
     */
    accessToken?: string | null;
    /**
     * The refresh token for the OAuth app
     * @type {string}
     * @memberof OAuthCredentials
     */
    refreshToken?: string | null;
    /**
     * The expiration date of the access token
     * @type {string}
     * @memberof OAuthCredentials
     */
    expiresAt?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum OAuthCredentialsCredentialsTypeEnum {
    Oauth = 'oauth'
}

/**
 * 
 * @export
 * @interface Objection
 */
export interface Objection {
    /**
     * The objection to be handled
     * @type {string}
     * @memberof Objection
     */
    objection: string;
    /**
     * The rebuttal to the objection
     * @type {string}
     * @memberof Objection
     */
    rebuttal: string;
}
/**
 * 
 * @export
 * @interface OrgUsersPriceCredits
 */
export interface OrgUsersPriceCredits {
    /**
     * 
     * @type {OrganizationOutput}
     * @memberof OrgUsersPriceCredits
     */
    organization: OrganizationOutput;
    /**
     * 
     * @type {Array<User>}
     * @memberof OrgUsersPriceCredits
     */
    users: Array<User>;
    /**
     * 
     * @type {Array<Price>}
     * @memberof OrgUsersPriceCredits
     */
    prices?: Array<Price> | null;
    /**
     * 
     * @type {Array<Credit>}
     * @memberof OrgUsersPriceCredits
     */
    credits?: Array<Credit> | null;
    /**
     * 
     * @type {string}
     * @memberof OrgUsersPriceCredits
     */
    resellerAdminUserCredentials?: string | null;
}
/**
 * 
 * @export
 * @interface OrgWithUsers
 */
export interface OrgWithUsers {
    /**
     * 
     * @type {OrganizationOutput}
     * @memberof OrgWithUsers
     */
    organization: OrganizationOutput;
    /**
     * 
     * @type {Array<User>}
     * @memberof OrgWithUsers
     */
    users: Array<User>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum OrganizationInitializationStatus {
    PENDING = 'PENDING',
    COMPLETED = 'COMPLETED',
    FAILED = 'FAILED'
}

/**
 * Organization represents the business using Trata and all users are associated to this business entity
 * @export
 * @interface OrganizationInput
 */
export interface OrganizationInput {
    /**
     * Name of the organization
     * @type {string}
     * @memberof OrganizationInput
     */
    name: string;
    /**
     * Address of the organization
     * @type {AddressInput}
     * @memberof OrganizationInput
     */
    address?: AddressInput | null;
    /**
     * Tax details of the organization
     * @type {TaxDetailsInput}
     * @memberof OrganizationInput
     */
    tax?: TaxDetailsInput | null;
    /**
     * External references for the organization
     * @type {Array<ExternalServiceProviderInput>}
     * @memberof OrganizationInput
     */
    externalReferenceIds?: Array<ExternalServiceProviderInput> | null;
    /**
     * Billing email address of the organization
     * @type {string}
     * @memberof OrganizationInput
     */
    billingEmailAddress?: string | null;
    /**
     * Website URL of the organization
     * @type {string}
     * @memberof OrganizationInput
     */
    websiteUrl?: string | null;
    /**
     * Configurations for all the agents going to be created in this org
     * @type {AgentConfig}
     * @memberof OrganizationInput
     */
    agentConfig?: AgentConfig | null;
    /**
     * Application type for the organization
     * @type {AppEnumInput}
     * @memberof OrganizationInput
     */
    app?: AppEnumInput | null;
    /**
     * Type of the organization
     * @type {string}
     * @memberof OrganizationInput
     */
    orgType?: string | null;
    /**
     * Additional information about the organization
     * @type {string}
     * @memberof OrganizationInput
     */
    additionalInfo?: string | null;
}
/**
 * Organization represents the business using Trata and all users are associated to this business entity
 * @export
 * @interface OrganizationOutput
 */
export interface OrganizationOutput {
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    name?: string;
    /**
     * 
     * @type {AgentConfig}
     * @memberof OrganizationOutput
     */
    config: AgentConfig;
    /**
     * 
     * @type {AddressOutput}
     * @memberof OrganizationOutput
     */
    address: AddressOutput | null;
    /**
     * 
     * @type {TaxDetailsOutput}
     * @memberof OrganizationOutput
     */
    tax: TaxDetailsOutput | null;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationOutput
     */
    isActiveSubscription?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    billingEmailAddress?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    websiteUrl?: string | null;
    /**
     * 
     * @type {Array<ExternalServiceProviderOutput>}
     * @memberof OrganizationOutput
     */
    externalReferenceIds: Array<ExternalServiceProviderOutput> | null;
    /**
     * 
     * @type {OrganizationInitializationStatus}
     * @memberof OrganizationOutput
     */
    isInitialized?: OrganizationInitializationStatus;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    updatedAt?: string;
    /**
     * 
     * @type {object}
     * @memberof OrganizationOutput
     */
    internalProps: object | null;
    /**
     * 
     * @type {object}
     * @memberof OrganizationOutput
     */
    adminProps: object | null;
    /**
     * If the Organization is created by reseller, this field will have the reseller org id as the parent organization id
     * @type {string}
     * @memberof OrganizationOutput
     */
    parentOrgId?: string;
    /**
     * Type of the organization. Currently only CONSUMER & RESELLER are supported
     * @type {string}
     * @memberof OrganizationOutput
     */
    orgType?: string | null;
    /**
     * 
     * @type {AppEnumOutput}
     * @memberof OrganizationOutput
     */
    app?: AppEnumOutput;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    additionalInfo?: string | null;
}
/**
 * 
 * @export
 * @interface OrganizationSettings
 */
export interface OrganizationSettings {
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    domain?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    brandColor?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    buttonColor?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    secondaryColor?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    textColor?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    favicon?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    faviconUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    logo?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    logoUrl?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PatienceLevel {
    Impatient = 'impatient',
    Neutral = 'neutral',
    VeryPatient = 'very patient'
}

/**
 * Persona represents a persona that can be used in a scenario
 * @export
 * @interface Persona
 */
export interface Persona {
    /**
     * The user who created.
     * @type {string}
     * @memberof Persona
     */
    createdBy?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof Persona
     */
    createdAt?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof Persona
     */
    updatedBy?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof Persona
     */
    updatedAt?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof Persona
     */
    orgId?: string;
    /**
     * The name of the persona
     * @type {string}
     * @memberof Persona
     */
    name: string;
    /**
     * The title of the persona
     * @type {string}
     * @memberof Persona
     */
    title: string;
    /**
     * The context of the persona
     * @type {string}
     * @memberof Persona
     */
    context: string;
    /**
     * The voice of the persona
     * @type {SparrVoiceOutput}
     * @memberof Persona
     */
    voice: SparrVoiceOutput;
    /**
     * The demeanor of the persona
     * @type {SparrDemeanorOutput}
     * @memberof Persona
     */
    demeanor: SparrDemeanorOutput;
    /**
     * The additional background of the persona
     * @type {string}
     * @memberof Persona
     */
    additionalBackground: string;
    /**
     * The work history of the persona
     * @type {Array<SparrWorkDetails>}
     * @memberof Persona
     */
    workHistory: Array<SparrWorkDetails>;
    /**
     * The LinkedIn URL of the persona
     * @type {string}
     * @memberof Persona
     */
    linkedInUrl: string;
    /**
     * The Twitter URL of the persona
     * @type {string}
     * @memberof Persona
     */
    twitterUrl: string | null;
    /**
     * The website URL of the persona
     * @type {string}
     * @memberof Persona
     */
    blogUrl: string | null;
    /**
     * Whether the persona is inherited from the parent persona
     * @type {boolean}
     * @memberof Persona
     */
    isInherited?: boolean;
    /**
     * The profile picture URL of the persona
     * @type {string}
     * @memberof Persona
     */
    profilePictureUrl: string | null;
    /**
     * The status of the persona
     * @type {string}
     * @memberof Persona
     */
    status?: string;
    /**
     * The unique identifier of the persona
     * @type {string}
     * @memberof Persona
     */
    id?: string;
    /**
     * The version of the persona
     * @type {number}
     * @memberof Persona
     */
    version?: number;
}
/**
 * 
 * @export
 * @interface PersonaAttributesAndTraits
 */
export interface PersonaAttributesAndTraits {
    /**
     * 
     * @type {PatienceLevel | string}
     * @memberof PersonaAttributesAndTraits
     */
    patience_level?: PatienceLevel | string | null;
    /**
     * 
     * @type {DecisionMakingStyle | string}
     * @memberof PersonaAttributesAndTraits
     */
    decision_making_style?: DecisionMakingStyle | string | null;
    /**
     * 
     * @type {CommunicationStyle | string}
     * @memberof PersonaAttributesAndTraits
     */
    communication_style?: CommunicationStyle | string | null;
    /**
     * 
     * @type {Adaptability | string}
     * @memberof PersonaAttributesAndTraits
     */
    adaptability?: Adaptability | string | null;
    /**
     * 
     * @type {FrustrationTolerance | string}
     * @memberof PersonaAttributesAndTraits
     */
    frustration_tolerance?: FrustrationTolerance | string | null;
    /**
     * 
     * @type {EngagementLevel | string}
     * @memberof PersonaAttributesAndTraits
     */
    engagement_level?: EngagementLevel | string | null;
    /**
     * 
     * @type {InteractionTone | string}
     * @memberof PersonaAttributesAndTraits
     */
    preferred_tone?: InteractionTone | string | null;
    /**
     * 
     * @type {NegotiationStyle | string}
     * @memberof PersonaAttributesAndTraits
     */
    negotiation_style?: NegotiationStyle | string | null;
}
/**
 * 
 * @export
 * @interface PersonaCore
 */
export interface PersonaCore {
    /**
     * The name of the persona
     * @type {string}
     * @memberof PersonaCore
     */
    name: string;
    /**
     * The title of the persona
     * @type {string}
     * @memberof PersonaCore
     */
    title: string;
    /**
     * The context of the persona
     * @type {string}
     * @memberof PersonaCore
     */
    context: string;
    /**
     * The voice of the persona
     * @type {SparrVoiceInput}
     * @memberof PersonaCore
     */
    voice: SparrVoiceInput;
    /**
     * The demeanor of the persona
     * @type {SparrDemeanorInput}
     * @memberof PersonaCore
     */
    demeanor: SparrDemeanorInput;
    /**
     * The additional background of the persona
     * @type {string}
     * @memberof PersonaCore
     */
    additionalBackground: string;
    /**
     * The work history of the persona
     * @type {Array<SparrWorkDetails>}
     * @memberof PersonaCore
     */
    workHistory: Array<SparrWorkDetails>;
    /**
     * The LinkedIn URL of the persona
     * @type {string}
     * @memberof PersonaCore
     */
    linkedInUrl: string;
    /**
     * The Twitter URL of the persona
     * @type {string}
     * @memberof PersonaCore
     */
    twitterUrl: string | null;
    /**
     * The website URL of the persona
     * @type {string}
     * @memberof PersonaCore
     */
    blogUrl: string | null;
    /**
     * Whether the persona is inherited from the parent persona
     * @type {boolean}
     * @memberof PersonaCore
     */
    isInherited?: boolean;
    /**
     * The profile picture URL of the persona
     * @type {string}
     * @memberof PersonaCore
     */
    profilePictureUrl: string | null;
    /**
     * The status of the persona
     * @type {string}
     * @memberof PersonaCore
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface PersonaSearchResponse
 */
export interface PersonaSearchResponse {
    /**
     * 
     * @type {Array<Persona>}
     * @memberof PersonaSearchResponse
     */
    items: Array<Persona>;
    /**
     * 
     * @type {number}
     * @memberof PersonaSearchResponse
     */
    total: number;
    /**
     * 
     * @type {number}
     * @memberof PersonaSearchResponse
     */
    pages: number;
    /**
     * 
     * @type {number}
     * @memberof PersonaSearchResponse
     */
    current_page: number;
    /**
     * 
     * @type {number}
     * @memberof PersonaSearchResponse
     */
    page_size: number;
}
/**
 * Price tier details of the business
 * @export
 * @interface Price
 */
export interface Price {
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    parentOrgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    priceName?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    description?: string;
    /**
     * Determines customer/reseller using custom price or default price
     * @type {boolean}
     * @memberof Price
     */
    isDefault?: boolean | null;
    /**
     * Currency of the price, e.g. USD, INR, EUR, GBP, etc.
     * @type {string}
     * @memberof Price
     */
    currency?: string;
    /**
     * Stripe price ID for this price tier
     * @type {string}
     * @memberof Price
     */
    stripePriceId?: string | null;
    /**
     * Stripe product ID for this price tier
     * @type {string}
     * @memberof Price
     */
    stripeProductId?: string | null;
    /**
     * Interval of the price, e.g. monthly, yearly, etc.
     * @type {PriceInterval}
     * @memberof Price
     */
    priceInterval?: PriceInterval | null;
    /**
     * List of price items included in this price tier
     * @type {Array<PriceItem>}
     * @memberof Price
     */
    priceItems?: Array<PriceItem> | null;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PriceInterval {
    OneTime = 'one_time',
    Monthly = 'monthly',
    Quarterly = 'quarterly',
    Yearly = 'yearly'
}

/**
 * Price item details for a price tier
 * @export
 * @interface PriceItem
 */
export interface PriceItem {
    /**
     * Name of the price item
     * @type {string}
     * @memberof PriceItem
     */
    name?: string;
    /**
     * Description of the price item
     * @type {string}
     * @memberof PriceItem
     */
    description?: string;
    /**
     * Quantity of the price item
     * @type {number}
     * @memberof PriceItem
     */
    quantity?: number | null;
    /**
     * Price of the price item in the lowest currency unit (e.g. cents, paise)
     * @type {number}
     * @memberof PriceItem
     */
    pricePerQuantity?: number | null;
    /**
     * Type of the credit
     * @type {CreditTypeEnum}
     * @memberof PriceItem
     */
    creditType?: CreditTypeEnum;
}
/**
 * 
 * @export
 * @interface PricingRequest
 */
export interface PricingRequest {
    /**
     * Price name
     * @type {string}
     * @memberof PricingRequest
     */
    priceName: string;
    /**
     * Description
     * @type {string}
     * @memberof PricingRequest
     */
    description: string;
    /**
     * Currency
     * @type {string}
     * @memberof PricingRequest
     */
    currency: string;
    /**
     * Price interval
     * @type {PriceInterval}
     * @memberof PricingRequest
     */
    priceInterval: PriceInterval;
    /**
     * List of price items included in this price tier
     * @type {Array<PriceItem>}
     * @memberof PricingRequest
     */
    priceItems?: Array<PriceItem> | null;
}
/**
 * 
 * @export
 * @interface ProductInput
 */
export interface ProductInput {
    /**
     * Product is active or not
     * @type {boolean}
     * @memberof ProductInput
     */
    active: boolean;
    /**
     * Default price of the product this is represented in the lowest currency denomination. Eg: 1000 for $10
     * @type {number}
     * @memberof ProductInput
     */
    defaultPrice: number;
    /**
     * Currency of the product
     * @type {string}
     * @memberof ProductInput
     */
    currency: ProductInputCurrencyEnum;
    /**
     * Description of the product
     * @type {string}
     * @memberof ProductInput
     */
    description: string;
    /**
     * Name of the product
     * @type {string}
     * @memberof ProductInput
     */
    name: string;
    /**
     * Product is shippable or not. Service is not shippable
     * @type {boolean}
     * @memberof ProductInput
     */
    shippable?: boolean;
    /**
     * List of features of the product
     * @type {Array<string>}
     * @memberof ProductInput
     */
    features?: Array<string> | null;
    /**
     * Product requires appointment scheduling or not
     * @type {boolean}
     * @memberof ProductInput
     */
    scheduleAppointment?: boolean;
    /**
     * Properties of the product
     * @type {object}
     * @memberof ProductInput
     */
    props?: object | null;
    /**
     * Tags for the product. This is used for grouping purpose. Eg: [\"gardening\", \"tools\"]
     * @type {Array<string>}
     * @memberof ProductInput
     */
    tags?: Array<string> | null;
    /**
     * 
     * @type {Status}
     * @memberof ProductInput
     */
    status: Status;
    /**
     * List of agent ids which are accessible for this product
     * @type {Array<string>}
     * @memberof ProductInput
     */
    agentIds?: Array<string> | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ProductInputCurrencyEnum {
    AED = 'AED',
    AFN = 'AFN',
    ALL = 'ALL',
    AMD = 'AMD',
    ANG = 'ANG',
    AOA = 'AOA',
    ARS = 'ARS',
    AUD = 'AUD',
    AWG = 'AWG',
    AZN = 'AZN',
    BAM = 'BAM',
    BBD = 'BBD',
    BDT = 'BDT',
    BGN = 'BGN',
    BHD = 'BHD',
    BIF = 'BIF',
    BMD = 'BMD',
    BND = 'BND',
    BOB = 'BOB',
    BOV = 'BOV',
    BRL = 'BRL',
    BSD = 'BSD',
    BTN = 'BTN',
    BWP = 'BWP',
    BYN = 'BYN',
    BZD = 'BZD',
    CAD = 'CAD',
    CDF = 'CDF',
    CHE = 'CHE',
    CHF = 'CHF',
    CHW = 'CHW',
    CLF = 'CLF',
    CLP = 'CLP',
    CNY = 'CNY',
    COP = 'COP',
    COU = 'COU',
    CRC = 'CRC',
    CUC = 'CUC',
    CUP = 'CUP',
    CVE = 'CVE',
    CZK = 'CZK',
    DJF = 'DJF',
    DKK = 'DKK',
    DOP = 'DOP',
    DZD = 'DZD',
    EGP = 'EGP',
    ERN = 'ERN',
    ETB = 'ETB',
    EUR = 'EUR',
    FJD = 'FJD',
    FKP = 'FKP',
    GBP = 'GBP',
    GEL = 'GEL',
    GHS = 'GHS',
    GIP = 'GIP',
    GMD = 'GMD',
    GNF = 'GNF',
    GTQ = 'GTQ',
    GYD = 'GYD',
    HKD = 'HKD',
    HNL = 'HNL',
    HRK = 'HRK',
    HTG = 'HTG',
    HUF = 'HUF',
    IDR = 'IDR',
    ILS = 'ILS',
    INR = 'INR',
    IQD = 'IQD',
    IRR = 'IRR',
    ISK = 'ISK',
    JMD = 'JMD',
    JOD = 'JOD',
    JPY = 'JPY',
    KES = 'KES',
    KGS = 'KGS',
    KHR = 'KHR',
    KMF = 'KMF',
    KPW = 'KPW',
    KRW = 'KRW',
    KWD = 'KWD',
    KYD = 'KYD',
    KZT = 'KZT',
    LAK = 'LAK',
    LBP = 'LBP',
    LKR = 'LKR',
    LRD = 'LRD',
    LSL = 'LSL',
    LYD = 'LYD',
    MAD = 'MAD',
    MDL = 'MDL',
    MGA = 'MGA',
    MKD = 'MKD',
    MMK = 'MMK',
    MNT = 'MNT',
    MOP = 'MOP',
    MRU = 'MRU',
    MUR = 'MUR',
    MVR = 'MVR',
    MWK = 'MWK',
    MXN = 'MXN',
    MXV = 'MXV',
    MYR = 'MYR',
    MZN = 'MZN',
    NAD = 'NAD',
    NGN = 'NGN',
    NIO = 'NIO',
    NOK = 'NOK',
    NPR = 'NPR',
    NZD = 'NZD',
    OMR = 'OMR',
    PAB = 'PAB',
    PEN = 'PEN',
    PGK = 'PGK',
    PHP = 'PHP',
    PKR = 'PKR',
    PLN = 'PLN',
    PYG = 'PYG',
    QAR = 'QAR',
    RON = 'RON',
    RSD = 'RSD',
    RUB = 'RUB',
    RWF = 'RWF',
    SAR = 'SAR',
    SBD = 'SBD',
    SCR = 'SCR',
    SDG = 'SDG',
    SEK = 'SEK',
    SGD = 'SGD',
    SHP = 'SHP',
    SLE = 'SLE',
    SLL = 'SLL',
    SOS = 'SOS',
    SRD = 'SRD',
    SSP = 'SSP',
    STN = 'STN',
    SVC = 'SVC',
    SYP = 'SYP',
    SZL = 'SZL',
    THB = 'THB',
    TJS = 'TJS',
    TMT = 'TMT',
    TND = 'TND',
    TOP = 'TOP',
    TRY = 'TRY',
    TTD = 'TTD',
    TWD = 'TWD',
    TZS = 'TZS',
    UAH = 'UAH',
    UGX = 'UGX',
    USD = 'USD',
    USN = 'USN',
    UYI = 'UYI',
    UYU = 'UYU',
    UYW = 'UYW',
    UZS = 'UZS',
    VED = 'VED',
    VES = 'VES',
    VND = 'VND',
    VUV = 'VUV',
    WST = 'WST',
    XAF = 'XAF',
    XCD = 'XCD',
    XOF = 'XOF',
    XPF = 'XPF',
    XSU = 'XSU',
    XUA = 'XUA',
    YER = 'YER',
    ZAR = 'ZAR',
    ZMW = 'ZMW',
    ZWL = 'ZWL'
}

/**
 * Product and services offered by the business
 * @export
 * @interface ProductOutput
 */
export interface ProductOutput {
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    orgId?: string;
    /**
     * Product is active or not
     * @type {boolean}
     * @memberof ProductOutput
     */
    active?: boolean;
    /**
     * Default price of the product this is represented in the lowest currency denomination. Eg: 1000 for $10
     * @type {number}
     * @memberof ProductOutput
     */
    defaultPrice?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    currency?: string | null;
    /**
     * Description of the product
     * @type {string}
     * @memberof ProductOutput
     */
    description?: string | null;
    /**
     * Name of the product
     * @type {string}
     * @memberof ProductOutput
     */
    name?: string;
    /**
     * Product is shippable or not. Service is not shippable
     * @type {boolean}
     * @memberof ProductOutput
     */
    shippable?: boolean;
    /**
     * List of features of the product
     * @type {Array<string>}
     * @memberof ProductOutput
     */
    features?: Array<string> | null;
    /**
     * Product requires appointment scheduling or not
     * @type {boolean}
     * @memberof ProductOutput
     */
    scheduleAppointment?: boolean;
    /**
     * Properties of the product
     * @type {object}
     * @memberof ProductOutput
     */
    props?: object | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductOutput
     */
    tags?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface ProductWithAgents
 */
export interface ProductWithAgents {
    /**
     * 
     * @type {ProductOutput}
     * @memberof ProductWithAgents
     */
    product: ProductOutput;
    /**
     * 
     * @type {Array<AIAgentOutput>}
     * @memberof ProductWithAgents
     */
    agents?: Array<AIAgentOutput>;
}
/**
 * 
 * @export
 * @interface PromptTemplate
 */
export interface PromptTemplate {
    /**
     * 
     * @type {string}
     * @memberof PromptTemplate
     */
    prompt: string;
    /**
     * 
     * @type {Array<Sequence>}
     * @memberof PromptTemplate
     */
    sequences: Array<Sequence>;
    /**
     * 
     * @type {string}
     * @memberof PromptTemplate
     */
    role: string;
    /**
     * 
     * @type {string}
     * @memberof PromptTemplate
     */
    roleDescription: string;
    /**
     * 
     * @type {string}
     * @memberof PromptTemplate
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ProspectInput
 */
export interface ProspectInput {
    /**
     * Name of the prospect
     * @type {string}
     * @memberof ProspectInput
     */
    name?: string | null;
    /**
     * Email of the prospect
     * @type {string}
     * @memberof ProspectInput
     */
    email?: string | null;
    /**
     * Phone number of the prospect
     * @type {string}
     * @memberof ProspectInput
     */
    phoneNumber?: string | null;
    /**
     * External references for the prospect
     * @type {Array<ExternalReference>}
     * @memberof ProspectInput
     */
    externalReference?: Array<ExternalReference> | null;
    /**
     * 
     * @type {ProspectStatus}
     * @memberof ProspectInput
     */
    status: ProspectStatus;
    /**
     * Props for the prospect
     * @type {object}
     * @memberof ProspectInput
     */
    prospectProps?: object | null;
}
/**
 * Prospects are the potential customers for business
 * @export
 * @interface ProspectOutput
 */
export interface ProspectOutput {
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    email?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    phoneNumber?: string | null;
    /**
     * 
     * @type {Array<ExternalReference>}
     * @memberof ProspectOutput
     */
    externalReference: Array<ExternalReference> | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    status: string;
    /**
     * 
     * @type {object}
     * @memberof ProspectOutput
     */
    prospectProps: object | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ProspectStatus {
    NEW = 'NEW',
    GENERALENQUIRY = 'GENERAL_ENQUIRY',
    SCHEDULEDCALLBACKWITHBOT = 'SCHEDULED_CALLBACK_WITH_BOT',
    SCHEDULEDAPPOINTMENTWITHPERSON = 'SCHEDULED_APPOINTMENT_WITH_PERSON',
    SCHEDULEDAPPOINTMENTFORSERVICE = 'SCHEDULED_APPOINTMENT_FOR_SERVICE',
    NOTINTERESTED = 'NOT_INTERESTED',
    PRODUCTORDERPLACED = 'PRODUCT_ORDER_PLACED',
    SERVICEORDERPLACED = 'SERVICE_ORDER_PLACED'
}

/**
 * 
 * @export
 * @interface ResellerBatchMetricsRequests
 */
export interface ResellerBatchMetricsRequests {
    /**
     * 
     * @type {Array<string>}
     * @memberof ResellerBatchMetricsRequests
     */
    organizations?: Array<string> | null;
    /**
     * 
     * @type {Array<MetricsRequestInput>}
     * @memberof ResellerBatchMetricsRequests
     */
    requests: Array<MetricsRequestInput>;
}
/**
 * 
 * @export
 * @interface ResellerCourseAssignment
 */
export interface ResellerCourseAssignment {
    /**
     * List of organization ids to assign the course to
     * @type {Array<string>}
     * @memberof ResellerCourseAssignment
     */
    orgs: Array<string>;
}
/**
 * 
 * @export
 * @interface ResellerPaymentAccountDetails
 */
export interface ResellerPaymentAccountDetails {
    /**
     * Business name of the reseller
     * @type {string}
     * @memberof ResellerPaymentAccountDetails
     */
    businessName: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Role {
    ADMIN = 'ADMIN',
    READONLY = 'READ_ONLY',
    OWNER = 'OWNER',
    RESELLERADMIN = 'RESELLER_ADMIN'
}

/**
 * 
 * @export
 * @interface RoleTemplate
 */
export interface RoleTemplate {
    /**
     * 
     * @type {string}
     * @memberof RoleTemplate
     */
    roleName: string;
    /**
     * 
     * @type {string}
     * @memberof RoleTemplate
     */
    roleDescription: string;
}
/**
 * Scenario represents a sequence of steps that can be performed by an app
 * @export
 * @interface Scenario
 */
export interface Scenario {
    /**
     * The user who created.
     * @type {string}
     * @memberof Scenario
     */
    createdBy?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof Scenario
     */
    createdAt?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof Scenario
     */
    updatedBy?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof Scenario
     */
    updatedAt?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof Scenario
     */
    orgId?: string;
    /**
     * The name of the scenario
     * @type {string}
     * @memberof Scenario
     */
    name: string;
    /**
     * The description of the scenario
     * @type {string}
     * @memberof Scenario
     */
    description: string;
    /**
     * The objections to be handled for the scenario
     * @type {Array<Objection>}
     * @memberof Scenario
     */
    objections: Array<Objection>;
    /**
     * The type of call to be used for this scenario
     * @type {string}
     * @memberof Scenario
     */
    callType?: string | null;
    /**
     * The goals to be achieved for the scenario
     * @type {Array<Goal>}
     * @memberof Scenario
     */
    goals: Array<Goal>;
    /**
     * The playbook to be followed for the scenario
     * @type {Array<Step>}
     * @memberof Scenario
     */
    playbook: Array<Step>;
    /**
     * Whether the scenario is inherited from the parent scenario
     * @type {boolean}
     * @memberof Scenario
     */
    isInherited?: boolean;
    /**
     * The status of the scenario
     * @type {string}
     * @memberof Scenario
     */
    status?: string;
    /**
     * The unique identifier of the scenario
     * @type {string}
     * @memberof Scenario
     */
    id?: string;
    /**
     * The version of the scenario
     * @type {number}
     * @memberof Scenario
     */
    version?: number;
}
/**
 * 
 * @export
 * @interface ScenarioCore
 */
export interface ScenarioCore {
    /**
     * The name of the scenario
     * @type {string}
     * @memberof ScenarioCore
     */
    name: string;
    /**
     * The description of the scenario
     * @type {string}
     * @memberof ScenarioCore
     */
    description: string;
    /**
     * The objections to be handled for the scenario
     * @type {Array<Objection>}
     * @memberof ScenarioCore
     */
    objections: Array<Objection>;
    /**
     * The type of call to be used for this scenario
     * @type {string}
     * @memberof ScenarioCore
     */
    callType?: string | null;
    /**
     * The goals to be achieved for the scenario
     * @type {Array<Goal>}
     * @memberof ScenarioCore
     */
    goals: Array<Goal>;
    /**
     * The playbook to be followed for the scenario
     * @type {Array<Step>}
     * @memberof ScenarioCore
     */
    playbook: Array<Step>;
    /**
     * Whether the scenario is inherited from the parent scenario
     * @type {boolean}
     * @memberof ScenarioCore
     */
    isInherited?: boolean;
    /**
     * The status of the scenario
     * @type {string}
     * @memberof ScenarioCore
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface ScenarioSearchResponse
 */
export interface ScenarioSearchResponse {
    /**
     * 
     * @type {Array<Scenario>}
     * @memberof ScenarioSearchResponse
     */
    items: Array<Scenario>;
    /**
     * 
     * @type {number}
     * @memberof ScenarioSearchResponse
     */
    total: number;
    /**
     * 
     * @type {number}
     * @memberof ScenarioSearchResponse
     */
    pages: number;
    /**
     * 
     * @type {number}
     * @memberof ScenarioSearchResponse
     */
    current_page: number;
    /**
     * 
     * @type {number}
     * @memberof ScenarioSearchResponse
     */
    page_size: number;
}
/**
 * 
 * @export
 * @interface Sequence
 */
export interface Sequence {
    /**
     * Name of the stage
     * @type {string}
     * @memberof Sequence
     */
    stageName: string;
    /**
     * Description of the stage
     * @type {string}
     * @memberof Sequence
     */
    description: string;
    /**
     * Other notes that AI agent should know in this stage of conversation
     * @type {string}
     * @memberof Sequence
     */
    otherNotes?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SortOrder {
    Asc = 'asc',
    Desc = 'desc'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum SparrAdaptability {
    OpenToChange = 'open to change',
    Resistant = 'resistant',
    Indifferent = 'indifferent'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum SparrCommunicationStyle {
    Direct = 'direct',
    Indirect = 'indirect',
    Verbose = 'verbose',
    Brief = 'brief'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum SparrDecisionMakingStyle {
    Logical = 'logical',
    Emotional = 'emotional',
    Impulsive = 'impulsive',
    Hesitant = 'hesitant'
}

/**
 * 
 * @export
 * @interface SparrDemeanorInput
 */
export interface SparrDemeanorInput {
    /**
     * 
     * @type {SparrPersonaAttributesAndTraits}
     * @memberof SparrDemeanorInput
     */
    personaTraits?: SparrPersonaAttributesAndTraits | null;
    /**
     * 
     * @type {SparrExcitementLevel | string}
     * @memberof SparrDemeanorInput
     */
    excitementLevel?: SparrExcitementLevel | string | null;
    /**
     * 
     * @type {SparrRudenessLevel | string}
     * @memberof SparrDemeanorInput
     */
    rudenessLevel?: SparrRudenessLevel | string | null;
}
/**
 * 
 * @export
 * @interface SparrDemeanorOutput
 */
export interface SparrDemeanorOutput {
    /**
     * 
     * @type {SparrPersonaAttributesAndTraits}
     * @memberof SparrDemeanorOutput
     */
    personaTraits?: SparrPersonaAttributesAndTraits | null;
    /**
     * 
     * @type {SparrExcitementLevel | string}
     * @memberof SparrDemeanorOutput
     */
    excitementLevel?: SparrExcitementLevel | string | null;
    /**
     * 
     * @type {SparrRudenessLevel | string}
     * @memberof SparrDemeanorOutput
     */
    rudenessLevel?: SparrRudenessLevel | string | null;
}
/**
 * 
 * @export
 * @interface SparrDialogLine
 */
export interface SparrDialogLine {
    /**
     * 
     * @type {string}
     * @memberof SparrDialogLine
     */
    speaker: SparrDialogLineSpeakerEnum;
    /**
     * 
     * @type {string}
     * @memberof SparrDialogLine
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof SparrDialogLine
     */
    timestamp: string;
    /**
     * 
     * @type {string}
     * @memberof SparrDialogLine
     */
    message_id: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SparrDialogLineSpeakerEnum {
    USER = 'USER',
    AI = 'AI',
    TOOL = 'TOOL',
    AITOOLREQUEST = 'AI - TOOL REQUEST'
}

/**
 * 
 * @export
 * @interface SparrDialogLineWithSentiment
 */
export interface SparrDialogLineWithSentiment {
    /**
     * 
     * @type {string}
     * @memberof SparrDialogLineWithSentiment
     */
    speaker: string;
    /**
     * 
     * @type {string}
     * @memberof SparrDialogLineWithSentiment
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SparrDialogLineWithSentiment
     */
    start_at_seconds: number;
    /**
     * 
     * @type {number}
     * @memberof SparrDialogLineWithSentiment
     */
    end_at_seconds: number;
    /**
     * 
     * @type {string}
     * @memberof SparrDialogLineWithSentiment
     */
    sentiment: SparrDialogLineWithSentimentSentimentEnum;
    /**
     * 
     * @type {number}
     * @memberof SparrDialogLineWithSentiment
     */
    sentiment_score: number;
    /**
     * 
     * @type {string}
     * @memberof SparrDialogLineWithSentiment
     */
    id: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SparrDialogLineWithSentimentSentimentEnum {
    POSITIVE = 'POSITIVE',
    NEGATIVE = 'NEGATIVE',
    NEUTRAL = 'NEUTRAL'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum SparrEngagementLevel {
    HighlyEngaged = 'highly engaged',
    Distracted = 'distracted',
    Uninterested = 'uninterested'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum SparrExcitementLevel {
    Neutral = 'neutral',
    Interested = 'interested',
    Excited = 'excited',
    Overjoyed = 'overjoyed',
    Euphoric = 'euphoric'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum SparrFrustrationTolerance {
    Neutral = 'neutral',
    QuickToAnger = 'quick to anger',
    Understanding = 'understanding'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum SparrInteractionTone {
    Casual = 'casual',
    Professional = 'professional',
    Friendly = 'friendly',
    Authoritative = 'authoritative'
}

/**
 * 
 * @export
 * @interface SparrLanguageAccentCombo
 */
export interface SparrLanguageAccentCombo {
    /**
     * 
     * @type {SparrVoiceLanguage}
     * @memberof SparrLanguageAccentCombo
     */
    language: SparrVoiceLanguage;
    /**
     * 
     * @type {SparrVoiceAccent}
     * @memberof SparrLanguageAccentCombo
     */
    accent: SparrVoiceAccent;
}
/**
 * 
 * @export
 * @interface SparrModelsAnalyticsBatchMetricsRequests
 */
export interface SparrModelsAnalyticsBatchMetricsRequests {
    /**
     * 
     * @type {Array<SparrModelsAnalyticsMetricsRequest>}
     * @memberof SparrModelsAnalyticsBatchMetricsRequests
     */
    requests: Array<SparrModelsAnalyticsMetricsRequest>;
    /**
     * Optional list of user IDs to filter metrics by
     * @type {Array<string>}
     * @memberof SparrModelsAnalyticsBatchMetricsRequests
     */
    userIds?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface SparrModelsAnalyticsBatchMetricsResponse
 */
export interface SparrModelsAnalyticsBatchMetricsResponse {
    /**
     * 
     * @type {Array<SparrModelsAnalyticsMetricsResponse>}
     * @memberof SparrModelsAnalyticsBatchMetricsResponse
     */
    responses: Array<SparrModelsAnalyticsMetricsResponse>;
}
/**
 * Expected output of the post conversation task
 * @export
 * @interface SparrModelsAnalyticsConversationAnalyticsModel
 */
export interface SparrModelsAnalyticsConversationAnalyticsModel {
    /**
     * This is a sparring conversation. So you have to evaluate the role player\'s conversation skill and provide feedback summary on the same to role player when the role player is conversing in the sparring mode. You shouldn\'t evaluate the AI responses. Keep the feedback summary fun, quirky and engaging. Use American style of writing, use phrases where appropriate. Make it more subtle engaging and also more interesting. Dont be robotic or too formal.
     * @type {string}
     * @memberof SparrModelsAnalyticsConversationAnalyticsModel
     */
    evaluation_summary: string | null;
    /**
     * List of top insights from the role player\'s conversation details. This should be a list of 3-5 points based on the conversation details.
     * @type {Array<string>}
     * @memberof SparrModelsAnalyticsConversationAnalyticsModel
     */
    top_insights: Array<string> | null;
    /**
     * Provide a list of what went well in the conversation. Note that this is a sparring conversation. So you have to evaluate the sales representative\'s conversation skill and provide feedback on the same to sales representative when the sales representative is conversing in the sparring mode. You shouldn\'t evaluate the AI responses. Your evaluation should be based on the metrics provided in the model. This should be a list of 3-5 points based on the metrics name and description provided in the model. Give the list with 1-2 sentences for each point. Use American style of writing, use phrases where appropriate. Make it more subtle engaging and also more interesting. Dont be robotic or too formal.
     * @type {Array<string>}
     * @memberof SparrModelsAnalyticsConversationAnalyticsModel
     */
    what_went_well: Array<string> | null;
    /**
     * Provide a list of what can be improved in the conversation. Note that this is a sparring conversation. So you have to evaluate the sales representative\'s conversation skill and provide feedback on the same to sales representative when the sales representative is conversing in the sparring mode. You shouldn\'t evaluate the AI responses. Your evaluation should be based on the metrics provided in the model. This should be a list of 2-3 points based on the metrics name and description provided in the model. Give the list with 1-2 sentences for each point. Use American style of writing, use phrases where appropriate. Make it more subtle engaging and also more interesting. Dont be robotic or too formal.
     * @type {Array<string>}
     * @memberof SparrModelsAnalyticsConversationAnalyticsModel
     */
    what_can_be_improved: Array<string> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SparrModelsAnalyticsMetricName {
    CALLS = 'CALLS',
    CALLDURATION = 'CALL_DURATION',
    TALKRATIO = 'TALK_RATIO',
    AVERAGEFILLERWORDSCOUNT = 'AVERAGE_FILLER_WORDS_COUNT',
    AVERAGEOVERALLSCORE = 'AVERAGE_OVERALL_SCORE',
    AVERAGELONGESTMONOLOGUE = 'AVERAGE_LONGEST_MONOLOGUE',
    AVERAGEMODULESCOMPLETED = 'AVERAGE_MODULES_COMPLETED',
    AVERAGEACTIVEDAYS = 'AVERAGE_ACTIVE_DAYS'
}

/**
 * 
 * @export
 * @interface SparrModelsAnalyticsMetricResponseDataPoint
 */
export interface SparrModelsAnalyticsMetricResponseDataPoint {
    /**
     * Timestamp of the data point
     * @type {string}
     * @memberof SparrModelsAnalyticsMetricResponseDataPoint
     */
    timestamp: string;
    /**
     * Value which will be a string representation of integer or floating number
     * @type {string}
     * @memberof SparrModelsAnalyticsMetricResponseDataPoint
     */
    value: string;
    /**
     * Optional weight value for the data point
     * @type {string}
     * @memberof SparrModelsAnalyticsMetricResponseDataPoint
     */
    weight?: string | null;
}
/**
 * 
 * @export
 * @interface SparrModelsAnalyticsMetricsRequest
 */
export interface SparrModelsAnalyticsMetricsRequest {
    /**
     * Unique identifier for the metric request. This can be helped to co-relate the request and response
     * @type {string}
     * @memberof SparrModelsAnalyticsMetricsRequest
     */
    id: string;
    /**
     * Name of the metric
     * @type {SparrModelsAnalyticsMetricName}
     * @memberof SparrModelsAnalyticsMetricsRequest
     */
    name: SparrModelsAnalyticsMetricName;
    /**
     * Start date to get metric request
     * @type {string}
     * @memberof SparrModelsAnalyticsMetricsRequest
     */
    fromDate: string;
    /**
     * End date until get metric request
     * @type {string}
     * @memberof SparrModelsAnalyticsMetricsRequest
     */
    toDate: string;
    /**
     * Aggregation period for the metric request
     * @type {AggregationPeriod}
     * @memberof SparrModelsAnalyticsMetricsRequest
     */
    aggregationPeriod: AggregationPeriod;
    /**
     * Aggregation formula for the metric request
     * @type {AggregationFormula}
     * @memberof SparrModelsAnalyticsMetricsRequest
     */
    aggregationFormula: AggregationFormula;
}
/**
 * 
 * @export
 * @interface SparrModelsAnalyticsMetricsResponse
 */
export interface SparrModelsAnalyticsMetricsResponse {
    /**
     * Unique identifier for the metric response. This will help co-relate the request and response
     * @type {string}
     * @memberof SparrModelsAnalyticsMetricsResponse
     */
    id: string;
    /**
     * Name of the metric
     * @type {SparrModelsAnalyticsMetricName}
     * @memberof SparrModelsAnalyticsMetricsResponse
     */
    name: SparrModelsAnalyticsMetricName;
    /**
     * List of data points for the metric response
     * @type {Array<SparrModelsAnalyticsMetricResponseDataPoint>}
     * @memberof SparrModelsAnalyticsMetricsResponse
     */
    datapoints: Array<SparrModelsAnalyticsMetricResponseDataPoint>;
}
/**
 * 
 * @export
 * @interface SparrModelsBaseBaseResponse
 */
export interface SparrModelsBaseBaseResponse {
    /**
     * The message of the response
     * @type {string}
     * @memberof SparrModelsBaseBaseResponse
     */
    message?: string;
    /**
     * The status of the response
     * @type {string}
     * @memberof SparrModelsBaseBaseResponse
     */
    status?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SparrNegotiationStyle {
    HardBargainer = 'hard bargainer',
    FriendlyNegotiator = 'friendly negotiator',
    NonNegotiator = 'non-negotiator'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum SparrPatienceLevel {
    Neutral = 'neutral',
    VeryPatient = 'very patient',
    Impatient = 'impatient'
}

/**
 * 
 * @export
 * @interface SparrPersonaAttributesAndTraits
 */
export interface SparrPersonaAttributesAndTraits {
    /**
     * 
     * @type {SparrPatienceLevel | string}
     * @memberof SparrPersonaAttributesAndTraits
     */
    patience_level?: SparrPatienceLevel | string | null;
    /**
     * 
     * @type {SparrDecisionMakingStyle | string}
     * @memberof SparrPersonaAttributesAndTraits
     */
    decision_making_style?: SparrDecisionMakingStyle | string | null;
    /**
     * 
     * @type {SparrCommunicationStyle | string}
     * @memberof SparrPersonaAttributesAndTraits
     */
    communication_style?: SparrCommunicationStyle | string | null;
    /**
     * 
     * @type {SparrAdaptability | string}
     * @memberof SparrPersonaAttributesAndTraits
     */
    adaptability?: SparrAdaptability | string | null;
    /**
     * 
     * @type {SparrFrustrationTolerance | string}
     * @memberof SparrPersonaAttributesAndTraits
     */
    frustration_tolerance?: SparrFrustrationTolerance | string | null;
    /**
     * 
     * @type {SparrEngagementLevel | string}
     * @memberof SparrPersonaAttributesAndTraits
     */
    engagement_level?: SparrEngagementLevel | string | null;
    /**
     * 
     * @type {SparrInteractionTone | string}
     * @memberof SparrPersonaAttributesAndTraits
     */
    preferred_tone?: SparrInteractionTone | string | null;
    /**
     * 
     * @type {SparrNegotiationStyle | string}
     * @memberof SparrPersonaAttributesAndTraits
     */
    negotiation_style?: SparrNegotiationStyle | string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SparrRudenessLevel {
    Courteous = 'courteous',
    Direct = 'direct',
    Irritable = 'irritable',
    Aggressive = 'aggressive',
    Toxic = 'toxic'
}

/**
 * 
 * @export
 * @interface SparrStatsData
 */
export interface SparrStatsData {
    /**
     * 
     * @type {number}
     * @memberof SparrStatsData
     */
    no_of_calls: number;
    /**
     * 
     * @type {number}
     * @memberof SparrStatsData
     */
    average_call_duration: number;
    /**
     * 
     * @type {number}
     * @memberof SparrStatsData
     */
    average_dialogs: number;
    /**
     * 
     * @type {number}
     * @memberof SparrStatsData
     */
    average_agent_dialog_ratio: number;
    /**
     * 
     * @type {number}
     * @memberof SparrStatsData
     */
    average_user_dialog_ratio: number;
}
/**
 * 
 * @export
 * @interface SparrStatsResponse
 */
export interface SparrStatsResponse {
    /**
     * Sparring stats of the organization
     * @type {SparrStatsData}
     * @memberof SparrStatsResponse
     */
    response: SparrStatsData;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SparrVoiceAccent {
    American = 'American',
    Indian = 'Indian',
    Australian = 'Australian',
    British = 'British',
    Hindi = 'Hindi',
    MiddleEastern = 'Middle Eastern'
}

/**
 * 
 * @export
 * @interface SparrVoiceInput
 */
export interface SparrVoiceInput {
    /**
     * 
     * @type {SparrLanguageAccentCombo}
     * @memberof SparrVoiceInput
     */
    languageAccent: SparrLanguageAccentCombo;
    /**
     * 
     * @type {string}
     * @memberof SparrVoiceInput
     */
    modelId: string;
    /**
     * 
     * @type {string}
     * @memberof SparrVoiceInput
     */
    playbackSpeed?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SparrVoiceInput
     */
    backgroundNoise?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SparrVoiceLanguage {
    English = 'English',
    Spanish = 'Spanish',
    Hindi = 'Hindi'
}

/**
 * 
 * @export
 * @interface SparrVoiceOutput
 */
export interface SparrVoiceOutput {
    /**
     * 
     * @type {SparrLanguageAccentCombo}
     * @memberof SparrVoiceOutput
     */
    languageAccent: SparrLanguageAccentCombo;
    /**
     * 
     * @type {string}
     * @memberof SparrVoiceOutput
     */
    modelId: string;
    /**
     * 
     * @type {string}
     * @memberof SparrVoiceOutput
     */
    playbackSpeed?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SparrVoiceOutput
     */
    backgroundNoise?: boolean;
}
/**
 * 
 * @export
 * @interface SparrWorkDetails
 */
export interface SparrWorkDetails {
    /**
     * The company of the persona
     * @type {string}
     * @memberof SparrWorkDetails
     */
    companyName: string | null;
    /**
     * The title of the persona
     * @type {string}
     * @memberof SparrWorkDetails
     */
    jobTitle: string | null;
    /**
     * The description of the persona
     * @type {string}
     * @memberof SparrWorkDetails
     */
    description: string | null;
    /**
     * The start date of the persona
     * @type {string}
     * @memberof SparrWorkDetails
     */
    startDate: string | null;
    /**
     * The end date of the persona
     * @type {string}
     * @memberof SparrWorkDetails
     */
    endDate: string | null;
}
/**
 * 
 * @export
 * @interface StatsData
 */
export interface StatsData {
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    no_of_prospects: number;
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    appointment_scheduled: number;
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    unqualified: number;
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    average_call_duration: number;
}
/**
 * 
 * @export
 * @interface StatsResponse
 */
export interface StatsResponse {
    /**
     * Overall stats of prospects
     * @type {StatsData}
     * @memberof StatsResponse
     */
    response: StatsData;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Status {
    Active = 'active',
    Inactive = 'inactive',
    Pending = 'pending',
    Archived = 'archived'
}

/**
 * 
 * @export
 * @interface Step
 */
export interface Step {
    /**
     * The name of the step
     * @type {string}
     * @memberof Step
     */
    name: string;
    /**
     * The description of the step
     * @type {string}
     * @memberof Step
     */
    description: string;
}
/**
 * Subscription details of the business
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    parentOrgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    subscriptionTypeName?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    planName?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    priceId?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    stripeSubscriptionId?: string;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    billingCycleStartDate?: number;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    updatedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    nextRenewalDate?: string;
}
/**
 * Subscription details of the business
 * @export
 * @interface SubscriptionInfo
 */
export interface SubscriptionInfo {
    /**
     * 
     * @type {Subscription}
     * @memberof SubscriptionInfo
     */
    subscription?: Subscription | null;
    /**
     * 
     * @type {Array<Credit>}
     * @memberof SubscriptionInfo
     */
    credits?: Array<Credit> | null;
}
/**
 * 
 * @export
 * @interface SystemMetrics
 */
export interface SystemMetrics {
    /**
     * 
     * @type {string}
     * @memberof SystemMetrics
     */
    average_sentiment: string | null;
    /**
     * 
     * @type {FillerWords}
     * @memberof SystemMetrics
     */
    filler_words: FillerWords | null;
    /**
     * 
     * @type {LongestMonologue}
     * @memberof SystemMetrics
     */
    longest_monologue: LongestMonologue | null;
    /**
     * 
     * @type {number}
     * @memberof SystemMetrics
     */
    speech_pace: number | null;
    /**
     * 
     * @type {number}
     * @memberof SystemMetrics
     */
    user_talk_ratio?: number | null;
    /**
     * 
     * @type {Array<SparrDialogLineWithSentiment>}
     * @memberof SystemMetrics
     */
    dialog_lines_sentiment: Array<SparrDialogLineWithSentiment> | null;
}
/**
 * 
 * @export
 * @interface TaxDetailsInput
 */
export interface TaxDetailsInput {
    /**
     * Tax identifier
     * @type {string}
     * @memberof TaxDetailsInput
     */
    id: string;
    /**
     * Any extra info related to Tax
     * @type {object}
     * @memberof TaxDetailsInput
     */
    taxProps: object | null;
}
/**
 * 
 * @export
 * @interface TaxDetailsOutput
 */
export interface TaxDetailsOutput {
    /**
     * 
     * @type {string}
     * @memberof TaxDetailsOutput
     */
    id: string;
    /**
     * 
     * @type {object}
     * @memberof TaxDetailsOutput
     */
    taxProps: object | null;
}
/**
 * Telephone number details of the business
 * @export
 * @interface TelephoneNumber
 */
export interface TelephoneNumber {
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    countryCode?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    agentId?: string | null;
    /**
     * 
     * @type {object}
     * @memberof TelephoneNumber
     */
    internalProps?: object | null;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface Transcriber
 */
export interface Transcriber {
    /**
     * 
     * @type {string}
     * @memberof Transcriber
     */
    providerName?: string;
    /**
     * 
     * @type {string}
     * @memberof Transcriber
     */
    transcriberModel?: string | null;
    /**
     * 
     * @type {object}
     * @memberof Transcriber
     */
    providerProps?: object | null;
}
/**
 * Enum for UI node types
 * @export
 * @enum {string}
 */
export enum UiNodeType {
    ACTION = 'ACTION',
    CONDITION = 'CONDITION',
    LOOP = 'LOOP',
    SUBFLOW = 'SUBFLOW'
}

/**
 * 
 * @export
 * @interface UpdateResellerOrganizationRequest
 */
export interface UpdateResellerOrganizationRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateResellerOrganizationRequest
     */
    name?: string | null;
    /**
     * 
     * @type {AddressInput}
     * @memberof UpdateResellerOrganizationRequest
     */
    address?: AddressInput | null;
    /**
     * 
     * @type {TaxDetailsInput}
     * @memberof UpdateResellerOrganizationRequest
     */
    tax?: TaxDetailsInput | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateResellerOrganizationRequest
     */
    billingEmailAddress?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateResellerOrganizationRequest
     */
    websiteUrl?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * Name of the user
     * @type {string}
     * @memberof UpdateUserRequest
     */
    name: string;
    /**
     * Role of the user
     * @type {AuthRole}
     * @memberof UpdateUserRequest
     */
    role: AuthRole;
}
/**
 * 
 * @export
 * @interface UploadFileResponse
 */
export interface UploadFileResponse {
    /**
     * 
     * @type {string}
     * @memberof UploadFileResponse
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof UploadFileResponse
     */
    fileUrl: string;
}
/**
 * Model representing the users under an organization
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    phoneNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    fullName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    updatedAt?: string;
}
/**
 * User id to api key mapping table
 * @export
 * @interface UserApiKeyLink
 */
export interface UserApiKeyLink {
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    secretKey?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    keyType?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    expiresAt?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserApiKeyLink
     */
    isActive?: boolean;
}
/**
 * UserCourseAssignment represents a user\'s assignment to a course
 * @export
 * @interface UserCourseAssignment
 */
export interface UserCourseAssignment {
    /**
     * The user who created.
     * @type {string}
     * @memberof UserCourseAssignment
     */
    createdBy?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof UserCourseAssignment
     */
    createdAt?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof UserCourseAssignment
     */
    updatedBy?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof UserCourseAssignment
     */
    updatedAt?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof UserCourseAssignment
     */
    orgId?: string;
    /**
     * The ID of the user who is taking the course
     * @type {string}
     * @memberof UserCourseAssignment
     */
    userId: string;
    /**
     * The ID of the course
     * @type {string}
     * @memberof UserCourseAssignment
     */
    courseId: string;
    /**
     * The name of the course
     * @type {string}
     * @memberof UserCourseAssignment
     */
    courseName: string | null;
    /**
     * The completion status of the course
     * @type {CourseCompletionStatus}
     * @memberof UserCourseAssignment
     */
    courseCompletionStatus: CourseCompletionStatus;
    /**
     * The score of the course out of 100
     * @type {number}
     * @memberof UserCourseAssignment
     */
    courseScore: number;
    /**
     * The unique identifier of the user course assignment
     * @type {string}
     * @memberof UserCourseAssignment
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface UserCourseAssignmentAnalyticsResponse
 */
export interface UserCourseAssignmentAnalyticsResponse {
    /**
     * The course assignment
     * @type {UserCourseAssignment}
     * @memberof UserCourseAssignmentAnalyticsResponse
     */
    userCourseAssignment: UserCourseAssignment;
    /**
     * Analytics for the course for all modules
     * @type {Array<ModuleAnalytics>}
     * @memberof UserCourseAssignmentAnalyticsResponse
     */
    courseAnalytics: Array<ModuleAnalytics>;
}
/**
 * UserModuleAttempt represents a user\'s attempt at a module
 * @export
 * @interface UserModuleAttempt
 */
export interface UserModuleAttempt {
    /**
     * The user who created.
     * @type {string}
     * @memberof UserModuleAttempt
     */
    createdBy?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof UserModuleAttempt
     */
    createdAt?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof UserModuleAttempt
     */
    updatedBy?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof UserModuleAttempt
     */
    updatedAt?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof UserModuleAttempt
     */
    orgId?: string;
    /**
     * The ID of the user who is taking the module
     * @type {string}
     * @memberof UserModuleAttempt
     */
    userId: string;
    /**
     * The ID of the course
     * @type {string}
     * @memberof UserModuleAttempt
     */
    courseId: string;
    /**
     * The ID of the module
     * @type {string}
     * @memberof UserModuleAttempt
     */
    moduleId: string;
    /**
     * The completion status of the module
     * @type {ModuleAttemptStatus}
     * @memberof UserModuleAttempt
     */
    attemptStatus: ModuleAttemptStatus;
    /**
     * The score of the module out of 100
     * @type {number}
     * @memberof UserModuleAttempt
     */
    attemptScore: number;
    /**
     * The ID of the feedback
     * @type {string}
     * @memberof UserModuleAttempt
     */
    feedbackId: string;
    /**
     * The unique identifier of the user module attempt
     * @type {string}
     * @memberof UserModuleAttempt
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface UserModuleAttemptCore
 */
export interface UserModuleAttemptCore {
    /**
     * The ID of the user who is taking the module
     * @type {string}
     * @memberof UserModuleAttemptCore
     */
    userId: string;
    /**
     * The ID of the course
     * @type {string}
     * @memberof UserModuleAttemptCore
     */
    courseId: string;
    /**
     * The ID of the module
     * @type {string}
     * @memberof UserModuleAttemptCore
     */
    moduleId: string;
    /**
     * The completion status of the module
     * @type {ModuleAttemptStatus}
     * @memberof UserModuleAttemptCore
     */
    attemptStatus: ModuleAttemptStatus;
    /**
     * The score of the module out of 100
     * @type {number}
     * @memberof UserModuleAttemptCore
     */
    attemptScore: number;
    /**
     * The ID of the feedback
     * @type {string}
     * @memberof UserModuleAttemptCore
     */
    feedbackId: string;
}
/**
 * 
 * @export
 * @interface UserModuleAttemptResponse
 */
export interface UserModuleAttemptResponse {
    /**
     * The ID of the user who is taking the module
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    userId: string;
    /**
     * The ID of the course
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    courseId: string;
    /**
     * The ID of the module
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    moduleId: string;
    /**
     * The completion status of the module
     * @type {ModuleAttemptStatus}
     * @memberof UserModuleAttemptResponse
     */
    attemptStatus: ModuleAttemptStatus;
    /**
     * The score of the module out of 100
     * @type {number}
     * @memberof UserModuleAttemptResponse
     */
    attemptScore: number;
    /**
     * The ID of the user module attempt
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    id: string;
    /**
     * The ID of the feedback
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    feedbackId: string;
    /**
     * The name of the module
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    moduleName: string | null;
    /**
     * The passing score percentage of the module
     * @type {number}
     * @memberof UserModuleAttemptResponse
     */
    passingScorePercentage: number;
    /**
     * The difficulty level of the module
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    difficultyLevel: string;
    /**
     * The name of the persona
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    personaName: string | null;
    /**
     * The name of the scenario
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    scenarioName: string | null;
    /**
     * The date and time the module was created
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    createdAt: string;
    /**
     * The user who created the module
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    createdBy: string | null;
    /**
     * The date and time the module was updated
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    updatedAt: string | null;
    /**
     * The user who updated the module
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    updatedBy: string | null;
}
/**
 * Payload for creating a new user
 * @export
 * @interface UserPayload
 */
export interface UserPayload {
    /**
     * 
     * @type {string}
     * @memberof UserPayload
     */
    email?: string | null;
    /**
     * 
     * @type {Role}
     * @memberof UserPayload
     */
    role?: Role | null;
    /**
     * 
     * @type {string}
     * @memberof UserPayload
     */
    fullName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserPayload
     */
    phoneNumber?: string | null;
}
/**
 * 
 * @export
 * @interface UserRecentActivity
 */
export interface UserRecentActivity {
    /**
     * 
     * @type {string}
     * @memberof UserRecentActivity
     */
    date: string;
    /**
     * 
     * @type {string}
     * @memberof UserRecentActivity
     */
    sparr_persona_name: string;
    /**
     * 
     * @type {string}
     * @memberof UserRecentActivity
     */
    sparr_scenario_name: string;
    /**
     * 
     * @type {string}
     * @memberof UserRecentActivity
     */
    sentiment: string;
    /**
     * 
     * @type {number}
     * @memberof UserRecentActivity
     */
    score: number;
}
/**
 * 
 * @export
 * @interface UserStats
 */
export interface UserStats {
    /**
     * 
     * @type {{ [key: string]: UserStatsItem; }}
     * @memberof UserStats
     */
    sparr_stats: { [key: string]: UserStatsItem; };
    /**
     * 
     * @type {Array<UserRecentActivity>}
     * @memberof UserStats
     */
    recent_activity: Array<UserRecentActivity>;
}
/**
 * 
 * @export
 * @interface UserStatsItem
 */
export interface UserStatsItem {
    /**
     * 
     * @type {number}
     * @memberof UserStatsItem
     */
    total_calls: number;
    /**
     * 
     * @type {number}
     * @memberof UserStatsItem
     */
    average_score: number;
    /**
     * 
     * @type {number}
     * @memberof UserStatsItem
     */
    total_sparr_minutes: number;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string | number>}
     * @memberof ValidationError
     */
    loc: Array<string | number>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}
/**
 * Link table to store the list of ai agents accessible for each virtual prospect
 * @export
 * @interface VirtualProspectAIAgentLink
 */
export interface VirtualProspectAIAgentLink {
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectAIAgentLink
     */
    virtualProspectId?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectAIAgentLink
     */
    aiAgentId?: string;
}
/**
 * 
 * @export
 * @interface VirtualProspectInput
 */
export interface VirtualProspectInput {
    /**
     * Name of the virtual prospect
     * @type {string}
     * @memberof VirtualProspectInput
     */
    name: string;
    /**
     * Description of the virtual prospect
     * @type {string}
     * @memberof VirtualProspectInput
     */
    description?: string | null;
    /**
     * Attributes of the virtual prospect
     * @type {PersonaAttributesAndTraits}
     * @memberof VirtualProspectInput
     */
    personaAttributes: PersonaAttributesAndTraits;
    /**
     * Additional information about the virtual prospect
     * @type {string}
     * @memberof VirtualProspectInput
     */
    additionalInfo?: string | null;
    /**
     * Voice of the virtual prospect
     * @type {VoiceInput}
     * @memberof VirtualProspectInput
     */
    voice?: VoiceInput | null;
    /**
     * Type of the virtual prospect
     * @type {VirtualProspectTypeEnum}
     * @memberof VirtualProspectInput
     */
    virtualProspectType?: VirtualProspectTypeEnum | null;
    /**
     * Context for the virtual prospect
     * @type {string}
     * @memberof VirtualProspectInput
     */
    context?: string | null;
}
/**
 * Virtual prospect details for sparring
 * @export
 * @interface VirtualProspectOutput
 */
export interface VirtualProspectOutput {
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    description?: string | null;
    /**
     * 
     * @type {PersonaAttributesAndTraits}
     * @memberof VirtualProspectOutput
     */
    personaAttributes: PersonaAttributesAndTraits | null;
    /**
     * Additional information about the virtual prospect
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    additionalInfo?: string | null;
    /**
     * 
     * @type {VoiceOutput}
     * @memberof VirtualProspectOutput
     */
    voice?: VoiceOutput | null;
    /**
     * Context for the virtual prospect
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    context?: string | null;
    /**
     * Type of the virtual prospect
     * @type {VirtualProspectTypeEnum}
     * @memberof VirtualProspectOutput
     */
    virtualProspectType?: VirtualProspectTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    updatedAt?: string;
}
/**
 * Enum which stores the list of types of sparring calls
 * @export
 * @enum {string}
 */
export enum VirtualProspectTypeEnum {
    INBOUND = 'INBOUND',
    OUTBOUND = 'OUTBOUND'
}

/**
 * 
 * @export
 * @interface VoiceInput
 */
export interface VoiceInput {
    /**
     * 
     * @type {string}
     * @memberof VoiceInput
     */
    gender: VoiceInputGenderEnum;
    /**
     * 
     * @type {LanguageAccentCombo}
     * @memberof VoiceInput
     */
    languageAccent: LanguageAccentCombo;
    /**
     * 
     * @type {string}
     * @memberof VoiceInput
     */
    modelId: string;
    /**
     * 
     * @type {string}
     * @memberof VoiceInput
     */
    playbackSpeed?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof VoiceInput
     */
    backgroundNoise?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum VoiceInputGenderEnum {
    Male = 'Male',
    Female = 'Female',
    Neutral = 'Neutral'
}

/**
 * 
 * @export
 * @interface VoiceModel
 */
export interface VoiceModel {
    /**
     * 
     * @type {VoiceOutput}
     * @memberof VoiceModel
     */
    voice: VoiceOutput;
    /**
     * 
     * @type {string}
     * @memberof VoiceModel
     */
    previewUrl: string;
    /**
     * 
     * @type {string}
     * @memberof VoiceModel
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof VoiceModel
     */
    voiceDescription: string;
}
/**
 * 
 * @export
 * @interface VoiceOutput
 */
export interface VoiceOutput {
    /**
     * 
     * @type {string}
     * @memberof VoiceOutput
     */
    gender: VoiceOutputGenderEnum;
    /**
     * 
     * @type {LanguageAccentCombo}
     * @memberof VoiceOutput
     */
    languageAccent: LanguageAccentCombo;
    /**
     * 
     * @type {string}
     * @memberof VoiceOutput
     */
    modelId: string;
    /**
     * 
     * @type {string}
     * @memberof VoiceOutput
     */
    playbackSpeed?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof VoiceOutput
     */
    backgroundNoise?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum VoiceOutputGenderEnum {
    Male = 'Male',
    Female = 'Female',
    Neutral = 'Neutral'
}

/**
 * Workflow represents a sequence of steps that can be performed by an app
 * @export
 * @interface Workflow
 */
export interface Workflow {
    /**
     * The user who created.
     * @type {string}
     * @memberof Workflow
     */
    createdBy?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof Workflow
     */
    createdAt?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof Workflow
     */
    updatedBy?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof Workflow
     */
    updatedAt?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof Workflow
     */
    orgId?: string;
    /**
     * The name of the workflow
     * @type {string}
     * @memberof Workflow
     */
    name?: string;
    /**
     * The description of the workflow
     * @type {string}
     * @memberof Workflow
     */
    description?: string | null;
    /**
     * The version of the workflow
     * @type {string}
     * @memberof Workflow
     */
    version?: string;
    /**
     * The steps of the workflow
     * @type {{ [key: string]: WorkflowStepOutput; }}
     * @memberof Workflow
     */
    steps: { [key: string]: WorkflowStepOutput; };
    /**
     * The id of the start step
     * @type {string}
     * @memberof Workflow
     */
    startStepId?: string;
    /**
     * The unique identifier of the workflow
     * @type {string}
     * @memberof Workflow
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface WorkflowActivityInfo
 */
export interface WorkflowActivityInfo {
    /**
     * 
     * @type {string}
     * @memberof WorkflowActivityInfo
     */
    step_name: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowActivityInfo
     */
    status: string;
    /**
     * 
     * @type {object}
     * @memberof WorkflowActivityInfo
     */
    input: object;
    /**
     * 
     * @type {object}
     * @memberof WorkflowActivityInfo
     */
    result: object;
    /**
     * 
     * @type {string}
     * @memberof WorkflowActivityInfo
     */
    start_time?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowActivityInfo
     */
    end_time?: string | null;
}
/**
 * Workflow Context Model
 * @export
 * @interface WorkflowContext
 */
export interface WorkflowContext {
    /**
     * The ID of the organization
     * @type {string}
     * @memberof WorkflowContext
     */
    orgId: string;
    /**
     * The ID of the workflow
     * @type {string}
     * @memberof WorkflowContext
     */
    workflowId: string;
    /**
     * The ID of the run
     * @type {string}
     * @memberof WorkflowContext
     */
    runId: string;
    /**
     * The input of the step
     * @type {object}
     * @memberof WorkflowContext
     */
    stepInput: object;
    /**
     * The response of the step
     * @type {object}
     * @memberof WorkflowContext
     */
    stepResponse: object;
}
/**
 * Core Workflow Model
 * @export
 * @interface WorkflowCore
 */
export interface WorkflowCore {
    /**
     * The name of the workflow
     * @type {string}
     * @memberof WorkflowCore
     */
    name?: string;
    /**
     * The description of the workflow
     * @type {string}
     * @memberof WorkflowCore
     */
    description?: string | null;
    /**
     * The version of the workflow
     * @type {string}
     * @memberof WorkflowCore
     */
    version?: string;
    /**
     * The steps of the workflow
     * @type {{ [key: string]: WorkflowStepInput; }}
     * @memberof WorkflowCore
     */
    steps: { [key: string]: WorkflowStepInput; };
    /**
     * The id of the start step
     * @type {string}
     * @memberof WorkflowCore
     */
    startStepId?: string;
}
/**
 * Core Workflow Execution Model
 * @export
 * @interface WorkflowExecution
 */
export interface WorkflowExecution {
    /**
     * The name of the workflow
     * @type {string}
     * @memberof WorkflowExecution
     */
    workflowName: string;
    /**
     * The start timestamp of the workflow
     * @type {string}
     * @memberof WorkflowExecution
     */
    workflowStartTimestamp: string | null;
    /**
     * The end timestamp of the workflow
     * @type {string}
     * @memberof WorkflowExecution
     */
    workflowEndTimestamp: string | null;
    /**
     * The id of the workflow
     * @type {string}
     * @memberof WorkflowExecution
     */
    workflowId: string;
    /**
     * The run id of the workflow
     * @type {string}
     * @memberof WorkflowExecution
     */
    workflowRunId: string;
    /**
     * The status of the workflow execution
     * @type {string}
     * @memberof WorkflowExecution
     */
    status: string;
    /**
     * The activity info of the workflow execution
     * @type {Array<WorkflowActivityInfo>}
     * @memberof WorkflowExecution
     */
    activityInfo: Array<WorkflowActivityInfo>;
    /**
     * The final result of the workflow execution
     * @type {object}
     * @memberof WorkflowExecution
     */
    result: object;
}
/**
 * Flow Step Model
 * @export
 * @interface WorkflowStepInput
 */
export interface WorkflowStepInput {
    /**
     * The id of the step
     * @type {string}
     * @memberof WorkflowStepInput
     */
    stepId?: string;
    /**
     * The connection id of the app
     * @type {string}
     * @memberof WorkflowStepInput
     */
    appConnectionId?: string | null;
    /**
     * The app action id of the app
     * @type {string}
     * @memberof WorkflowStepInput
     */
    appActionId?: string;
    /**
     * The id of the app
     * @type {string}
     * @memberof WorkflowStepInput
     */
    appId?: string;
    /**
     * The name of the app. It must match the app name in AppDefinition implementation
     * @type {string}
     * @memberof WorkflowStepInput
     */
    appName?: string;
    /**
     * The version of the app. It must match the app version in AppDefinition implementation
     * @type {string}
     * @memberof WorkflowStepInput
     */
    appVersion?: string;
    /**
     * The data resolver on how to resolve the data for the step
     * @type {string}
     * @memberof WorkflowStepInput
     */
    dataResolver?: string | null;
    /**
     * Resolver for determining the next step
     * @type {NextStepResolver}
     * @memberof WorkflowStepInput
     */
    nextStepResolver: NextStepResolver;
}
/**
 * Flow Step Model
 * @export
 * @interface WorkflowStepOutput
 */
export interface WorkflowStepOutput {
    /**
     * The id of the step
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    stepId?: string;
    /**
     * The connection id of the app
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    appConnectionId?: string | null;
    /**
     * The app action id of the app
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    appActionId?: string;
    /**
     * The id of the app
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    appId?: string;
    /**
     * The name of the app. It must match the app name in AppDefinition implementation
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    appName?: string;
    /**
     * The version of the app. It must match the app version in AppDefinition implementation
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    appVersion?: string;
    /**
     * The data resolver on how to resolve the data for the step
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    dataResolver?: string | null;
    /**
     * Resolver for determining the next step
     * @type {NextStepResolver}
     * @memberof WorkflowStepOutput
     */
    nextStepResolver: NextStepResolver;
}
/**
 * 
 * @export
 * @interface WorkflowStepTriggerRequest
 */
export interface WorkflowStepTriggerRequest {
    /**
     * 
     * @type {WorkflowContext}
     * @memberof WorkflowStepTriggerRequest
     */
    workflowContext: WorkflowContext;
    /**
     * 
     * @type {WorkflowStepInput}
     * @memberof WorkflowStepTriggerRequest
     */
    workflowStep: WorkflowStepInput;
}
/**
 * 
 * @export
 * @interface WorkflowStepTriggerResponse
 */
export interface WorkflowStepTriggerResponse {
    /**
     * 
     * @type {object}
     * @memberof WorkflowStepTriggerResponse
     */
    input: object;
    /**
     * 
     * @type {object}
     * @memberof WorkflowStepTriggerResponse
     */
    response: object;
}

/**
 * ActionAgentLinkApi - axios parameter creator
 * @export
 */
export const ActionAgentLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionAgentLinkV1: async (actionId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new RequiredError('actionId','Required parameter actionId was null or undefined when calling createActionAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling createActionAgentLinkV1.');
            }
            const localVarPath = `/v1/actions/{action_id}/ai-agents/{agent_id}/link`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionAgentLinkV1: async (actionId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new RequiredError('actionId','Required parameter actionId was null or undefined when calling deleteActionAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling deleteActionAgentLinkV1.');
            }
            const localVarPath = `/v1/actions/{action_id}/ai-agents/{agent_id}/link`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsOfAgentV1: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling listActionsOfAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}/actions`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionAgentLinkApi - functional programming interface
 * @export
 */
export const ActionAgentLinkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActionAgentLinkV1(actionId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ActionAgentLinkApiAxiosParamCreator(configuration).createActionAgentLinkV1(actionId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteActionAgentLinkV1(actionId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ActionAgentLinkApiAxiosParamCreator(configuration).deleteActionAgentLinkV1(actionId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActionsOfAgentV1(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActionOutput>>> {
            const localVarAxiosArgs = await ActionAgentLinkApiAxiosParamCreator(configuration).listActionsOfAgentV1(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ActionAgentLinkApi - factory interface
 * @export
 */
export const ActionAgentLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionAgentLinkV1(actionId: string, agentId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ActionAgentLinkApiFp(configuration).createActionAgentLinkV1(actionId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionAgentLinkV1(actionId: string, agentId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ActionAgentLinkApiFp(configuration).deleteActionAgentLinkV1(actionId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsOfAgentV1(agentId: string, options?: any): AxiosPromise<Array<ActionOutput>> {
            return ActionAgentLinkApiFp(configuration).listActionsOfAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionAgentLinkApi - object-oriented interface
 * @export
 * @class ActionAgentLinkApi
 * @extends {BaseAPI}
 */
export class ActionAgentLinkApi extends BaseAPI {
    /**
     * Create a Link Between an Action and an Agent
     * @summary Create a Link Between an Action and an Agent
     * @param {string} actionId ID of the action
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    public createActionAgentLinkV1(actionId: string, agentId: string, options?: any) {
        return ActionAgentLinkApiFp(this.configuration).createActionAgentLinkV1(actionId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Link Between an Action and an Agent
     * @summary Delete a Link Between an Action and an Agent
     * @param {string} actionId ID of the action
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    public deleteActionAgentLinkV1(actionId: string, agentId: string, options?: any) {
        return ActionAgentLinkApiFp(this.configuration).deleteActionAgentLinkV1(actionId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Actions Linked to a Specific Agent
     * @summary List All Actions Linked to a Specific Agent
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    public listActionsOfAgentV1(agentId: string, options?: any) {
        return ActionAgentLinkApiFp(this.configuration).listActionsOfAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionV1: async (actionInput: ActionInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionInput' is not null or undefined
            if (actionInput === null || actionInput === undefined) {
                throw new RequiredError('actionInput','Required parameter actionInput was null or undefined when calling createActionV1.');
            }
            const localVarPath = `/v1/actions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof actionInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(actionInput !== undefined ? actionInput : {}) : (actionInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionV1: async (actionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new RequiredError('actionId','Required parameter actionId was null or undefined when calling deleteActionV1.');
            }
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1: async (actionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new RequiredError('actionId','Required parameter actionId was null or undefined when calling getActionV1.');
            }
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Actions
         * @summary List All Actions
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/actions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActionV1: async (actionId: string, actionInput: ActionInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new RequiredError('actionId','Required parameter actionId was null or undefined when calling updateActionV1.');
            }
            // verify required parameter 'actionInput' is not null or undefined
            if (actionInput === null || actionInput === undefined) {
                throw new RequiredError('actionInput','Required parameter actionInput was null or undefined when calling updateActionV1.');
            }
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof actionInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(actionInput !== undefined ? actionInput : {}) : (actionInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActionV1(actionInput: ActionInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionOutput>> {
            const localVarAxiosArgs = await ActionsApiAxiosParamCreator(configuration).createActionV1(actionInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteActionV1(actionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ActionsApiAxiosParamCreator(configuration).deleteActionV1(actionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActionV1(actionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionOutput>> {
            const localVarAxiosArgs = await ActionsApiAxiosParamCreator(configuration).getActionV1(actionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Actions
         * @summary List All Actions
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActionsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActionOutput>>> {
            const localVarAxiosArgs = await ActionsApiAxiosParamCreator(configuration).listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateActionV1(actionId: string, actionInput: ActionInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionOutput>> {
            const localVarAxiosArgs = await ActionsApiAxiosParamCreator(configuration).updateActionV1(actionId, actionInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionV1(actionInput: ActionInput, options?: any): AxiosPromise<ActionOutput> {
            return ActionsApiFp(configuration).createActionV1(actionInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionV1(actionId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ActionsApiFp(configuration).deleteActionV1(actionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1(actionId: string, options?: any): AxiosPromise<ActionOutput> {
            return ActionsApiFp(configuration).getActionV1(actionId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Actions
         * @summary List All Actions
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): AxiosPromise<Array<ActionOutput>> {
            return ActionsApiFp(configuration).listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActionV1(actionId: string, actionInput: ActionInput, options?: any): AxiosPromise<ActionOutput> {
            return ActionsApiFp(configuration).updateActionV1(actionId, actionInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI {
    /**
     * Create a New Action
     * @summary Create a New Action
     * @param {ActionInput} actionInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public createActionV1(actionInput: ActionInput, options?: any) {
        return ActionsApiFp(this.configuration).createActionV1(actionInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific Action by ID
     * @summary Delete a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public deleteActionV1(actionId: string, options?: any) {
        return ActionsApiFp(this.configuration).deleteActionV1(actionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Action by ID
     * @summary Get a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getActionV1(actionId: string, options?: any) {
        return ActionsApiFp(this.configuration).getActionV1(actionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Actions
     * @summary List All Actions
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [updatedAfter] 
     * @param {string} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public listActionsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any) {
        return ActionsApiFp(this.configuration).listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific Action by ID
     * @summary Update a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {ActionInput} actionInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public updateActionV1(actionId: string, actionInput: ActionInput, options?: any) {
        return ActionsApiFp(this.configuration).updateActionV1(actionId, actionInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * AgentsApi - axios parameter creator
 * @export
 */
export const AgentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAIAgentV1: async (aIAgentInput: AIAgentInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'aIAgentInput' is not null or undefined
            if (aIAgentInput === null || aIAgentInput === undefined) {
                throw new RequiredError('aIAgentInput','Required parameter aIAgentInput was null or undefined when calling createAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof aIAgentInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(aIAgentInput !== undefined ? aIAgentInput : {}) : (aIAgentInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAIAgentV1: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling deleteAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIAgentV1: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling getAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All AI Agents
         * @summary List All AI Agents
         * @param {AppEnumInput} [app] 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIAgentsV1: async (app?: AppEnumInput, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ai-agents`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIAgentV1: async (agentId: string, aIAgentInput: AIAgentInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling updateAIAgentV1.');
            }
            // verify required parameter 'aIAgentInput' is not null or undefined
            if (aIAgentInput === null || aIAgentInput === undefined) {
                throw new RequiredError('aIAgentInput','Required parameter aIAgentInput was null or undefined when calling updateAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof aIAgentInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(aIAgentInput !== undefined ? aIAgentInput : {}) : (aIAgentInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentsApi - functional programming interface
 * @export
 */
export const AgentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAIAgentV1(aIAgentInput: AIAgentInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AIAgentOutput>> {
            const localVarAxiosArgs = await AgentsApiAxiosParamCreator(configuration).createAIAgentV1(aIAgentInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAIAgentV1(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await AgentsApiAxiosParamCreator(configuration).deleteAIAgentV1(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAIAgentV1(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AIAgentOutput>> {
            const localVarAxiosArgs = await AgentsApiAxiosParamCreator(configuration).getAIAgentV1(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All AI Agents
         * @summary List All AI Agents
         * @param {AppEnumInput} [app] 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAIAgentsV1(app?: AppEnumInput, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AIAgentOutput>>> {
            const localVarAxiosArgs = await AgentsApiAxiosParamCreator(configuration).listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAIAgentV1(agentId: string, aIAgentInput: AIAgentInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AIAgentOutput>> {
            const localVarAxiosArgs = await AgentsApiAxiosParamCreator(configuration).updateAIAgentV1(agentId, aIAgentInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AgentsApi - factory interface
 * @export
 */
export const AgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAIAgentV1(aIAgentInput: AIAgentInput, options?: any): AxiosPromise<AIAgentOutput> {
            return AgentsApiFp(configuration).createAIAgentV1(aIAgentInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAIAgentV1(agentId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return AgentsApiFp(configuration).deleteAIAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIAgentV1(agentId: string, options?: any): AxiosPromise<AIAgentOutput> {
            return AgentsApiFp(configuration).getAIAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All AI Agents
         * @summary List All AI Agents
         * @param {AppEnumInput} [app] 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIAgentsV1(app?: AppEnumInput, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): AxiosPromise<Array<AIAgentOutput>> {
            return AgentsApiFp(configuration).listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIAgentV1(agentId: string, aIAgentInput: AIAgentInput, options?: any): AxiosPromise<AIAgentOutput> {
            return AgentsApiFp(configuration).updateAIAgentV1(agentId, aIAgentInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AgentsApi - object-oriented interface
 * @export
 * @class AgentsApi
 * @extends {BaseAPI}
 */
export class AgentsApi extends BaseAPI {
    /**
     * Create a New AI Agent
     * @summary Create a New AI Agent
     * @param {AIAgentInput} aIAgentInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public createAIAgentV1(aIAgentInput: AIAgentInput, options?: any) {
        return AgentsApiFp(this.configuration).createAIAgentV1(aIAgentInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific AI Agent by ID
     * @summary Delete a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public deleteAIAgentV1(agentId: string, options?: any) {
        return AgentsApiFp(this.configuration).deleteAIAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific AI Agent by ID
     * @summary Get a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public getAIAgentV1(agentId: string, options?: any) {
        return AgentsApiFp(this.configuration).getAIAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All AI Agents
     * @summary List All AI Agents
     * @param {AppEnumInput} [app] 
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [updatedAfter] 
     * @param {string} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public listAIAgentsV1(app?: AppEnumInput, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any) {
        return AgentsApiFp(this.configuration).listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific AI Agent by ID
     * @summary Update a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {AIAgentInput} aIAgentInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public updateAIAgentV1(agentId: string, aIAgentInput: AIAgentInput, options?: any) {
        return AgentsApiFp(this.configuration).updateAIAgentV1(agentId, aIAgentInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get fine grained analytics data from Trata AI like call, duration stats, etc.
         * @summary Get Metrics
         * @param {BatchMetricsRequestsInput} batchMetricsRequestsInput 
         * @param {string} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1MetricsPost: async (batchMetricsRequestsInput: BatchMetricsRequestsInput, app?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchMetricsRequestsInput' is not null or undefined
            if (batchMetricsRequestsInput === null || batchMetricsRequestsInput === undefined) {
                throw new RequiredError('batchMetricsRequestsInput','Required parameter batchMetricsRequestsInput was null or undefined when calling getMetricsV1MetricsPost.');
            }
            const localVarPath = `/v1/metrics`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof batchMetricsRequestsInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(batchMetricsRequestsInput !== undefined ? batchMetricsRequestsInput : {}) : (batchMetricsRequestsInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get aggregated stats from Trata AI like call count, prospect count, etc.
         * @summary Get Aggregated Stats
         * @param {AppEnumInput} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallStatsV1StatsGet: async (app?: AppEnumInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/stats`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get fine grained analytics data from Trata AI like call, duration stats, etc.
         * @summary Get Metrics
         * @param {BatchMetricsRequestsInput} batchMetricsRequestsInput 
         * @param {string} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetricsV1MetricsPost(batchMetricsRequestsInput: BatchMetricsRequestsInput, app?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchMetricsResponseInput>> {
            const localVarAxiosArgs = await AnalyticsApiAxiosParamCreator(configuration).getMetricsV1MetricsPost(batchMetricsRequestsInput, app, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get aggregated stats from Trata AI like call count, prospect count, etc.
         * @summary Get Aggregated Stats
         * @param {AppEnumInput} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOverallStatsV1StatsGet(app?: AppEnumInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsResponse>> {
            const localVarAxiosArgs = await AnalyticsApiAxiosParamCreator(configuration).getOverallStatsV1StatsGet(app, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get fine grained analytics data from Trata AI like call, duration stats, etc.
         * @summary Get Metrics
         * @param {BatchMetricsRequestsInput} batchMetricsRequestsInput 
         * @param {string} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1MetricsPost(batchMetricsRequestsInput: BatchMetricsRequestsInput, app?: string, options?: any): AxiosPromise<BatchMetricsResponseInput> {
            return AnalyticsApiFp(configuration).getMetricsV1MetricsPost(batchMetricsRequestsInput, app, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregated stats from Trata AI like call count, prospect count, etc.
         * @summary Get Aggregated Stats
         * @param {AppEnumInput} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallStatsV1StatsGet(app?: AppEnumInput, options?: any): AxiosPromise<StatsResponse> {
            return AnalyticsApiFp(configuration).getOverallStatsV1StatsGet(app, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * Get fine grained analytics data from Trata AI like call, duration stats, etc.
     * @summary Get Metrics
     * @param {BatchMetricsRequestsInput} batchMetricsRequestsInput 
     * @param {string} [app] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getMetricsV1MetricsPost(batchMetricsRequestsInput: BatchMetricsRequestsInput, app?: string, options?: any) {
        return AnalyticsApiFp(this.configuration).getMetricsV1MetricsPost(batchMetricsRequestsInput, app, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get aggregated stats from Trata AI like call count, prospect count, etc.
     * @summary Get Aggregated Stats
     * @param {AppEnumInput} [app] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getOverallStatsV1StatsGet(app?: AppEnumInput, options?: any) {
        return AnalyticsApiFp(this.configuration).getOverallStatsV1StatsGet(app, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ApiKeyApi - axios parameter creator
 * @export
 */
export const ApiKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyV1: async (apiKeyRequest: ApiKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeyRequest' is not null or undefined
            if (apiKeyRequest === null || apiKeyRequest === undefined) {
                throw new RequiredError('apiKeyRequest','Required parameter apiKeyRequest was null or undefined when calling createApiKeyV1.');
            }
            const localVarPath = `/v1/api-keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof apiKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(apiKeyRequest !== undefined ? apiKeyRequest : {}) : (apiKeyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyV1: async (keyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            if (keyId === null || keyId === undefined) {
                throw new RequiredError('keyId','Required parameter keyId was null or undefined when calling deleteApiKeyV1.');
            }
            const localVarPath = `/v1/api-keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallKeyV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/api-keys/call-key`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/api-keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeyApi - functional programming interface
 * @export
 */
export const ApiKeyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKeyV1(apiKeyRequest: ApiKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserApiKeyLink>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).createApiKeyV1(apiKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiKeyV1(keyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).deleteApiKeyV1(keyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCallKeyV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserApiKeyLink>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).getCallKeyV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApiKeysV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserApiKeyLink>>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).listApiKeysV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ApiKeyApi - factory interface
 * @export
 */
export const ApiKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyV1(apiKeyRequest: ApiKeyRequest, options?: any): AxiosPromise<UserApiKeyLink> {
            return ApiKeyApiFp(configuration).createApiKeyV1(apiKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyV1(keyId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ApiKeyApiFp(configuration).deleteApiKeyV1(keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallKeyV1(options?: any): AxiosPromise<UserApiKeyLink> {
            return ApiKeyApiFp(configuration).getCallKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysV1(options?: any): AxiosPromise<Array<UserApiKeyLink>> {
            return ApiKeyApiFp(configuration).listApiKeysV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiKeyApi - object-oriented interface
 * @export
 * @class ApiKeyApi
 * @extends {BaseAPI}
 */
export class ApiKeyApi extends BaseAPI {
    /**
     * 
     * @summary Create Api Key
     * @param {ApiKeyRequest} apiKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public createApiKeyV1(apiKeyRequest: ApiKeyRequest, options?: any) {
        return ApiKeyApiFp(this.configuration).createApiKeyV1(apiKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Api Key
     * @param {string} keyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public deleteApiKeyV1(keyId: string, options?: any) {
        return ApiKeyApiFp(this.configuration).deleteApiKeyV1(keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Call Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public getCallKeyV1(options?: any) {
        return ApiKeyApiFp(this.configuration).getCallKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Api Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public listApiKeysV1(options?: any) {
        return ApiKeyApiFp(this.configuration).listApiKeysV1(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * BillingApi - axios parameter creator
 * @export
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForBillableProductV1: async (billableProductId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'billableProductId' is not null or undefined
            if (billableProductId === null || billableProductId === undefined) {
                throw new RequiredError('billableProductId','Required parameter billableProductId was null or undefined when calling createCheckoutSessionForBillableProductV1.');
            }
            const localVarPath = `/v1/subscription/billable-products/{billable_product_id}/checkout`
                .replace(`{${"billable_product_id"}}`, encodeURIComponent(String(billableProductId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerSessionSecretV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription/customer-session-secret`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionBillableProductsV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription/billable-products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPortalV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription/portal`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckoutSessionForBillableProductV1(billableProductId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await BillingApiAxiosParamCreator(configuration).createCheckoutSessionForBillableProductV1(billableProductId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerSessionSecretV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await BillingApiAxiosParamCreator(configuration).getCustomerSessionSecretV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionBillableProductsV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Price>>> {
            const localVarAxiosArgs = await BillingApiAxiosParamCreator(configuration).getSubscriptionBillableProductsV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionPortalV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await BillingApiAxiosParamCreator(configuration).getSubscriptionPortalV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionInfo>> {
            const localVarAxiosArgs = await BillingApiAxiosParamCreator(configuration).getSubscriptionV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForBillableProductV1(billableProductId: string, options?: any): AxiosPromise<string> {
            return BillingApiFp(configuration).createCheckoutSessionForBillableProductV1(billableProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerSessionSecretV1(options?: any): AxiosPromise<string> {
            return BillingApiFp(configuration).getCustomerSessionSecretV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionBillableProductsV1(options?: any): AxiosPromise<Array<Price>> {
            return BillingApiFp(configuration).getSubscriptionBillableProductsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPortalV1(options?: any): AxiosPromise<string> {
            return BillingApiFp(configuration).getSubscriptionPortalV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionV1(options?: any): AxiosPromise<SubscriptionInfo> {
            return BillingApiFp(configuration).getSubscriptionV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI {
    /**
     * 
     * @summary Create Checkout Session For Billable Product
     * @param {string} billableProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public createCheckoutSessionForBillableProductV1(billableProductId: string, options?: any) {
        return BillingApiFp(this.configuration).createCheckoutSessionForBillableProductV1(billableProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Customer Session Secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getCustomerSessionSecretV1(options?: any) {
        return BillingApiFp(this.configuration).getCustomerSessionSecretV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Subscription Billable Products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getSubscriptionBillableProductsV1(options?: any) {
        return BillingApiFp(this.configuration).getSubscriptionBillableProductsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Subscription Portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getSubscriptionPortalV1(options?: any) {
        return BillingApiFp(this.configuration).getSubscriptionPortalV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getSubscriptionV1(options?: any) {
        return BillingApiFp(this.configuration).getSubscriptionV1(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ConversationProspectLinkApi - axios parameter creator
 * @export
 */
export const ConversationProspectLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationProspectLinkV1: async (conversationId: string, prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling createConversationProspectLinkV1.');
            }
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling createConversationProspectLinkV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}/prospects/{prospect_id}/links`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationProspectLinkV1: async (conversationId: string, prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling deleteConversationProspectLinkV1.');
            }
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling deleteConversationProspectLinkV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}/prospects/{prospect_id}/links`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsOfProspectsV1: async (prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling listConversationsOfProspectsV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}/conversations`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversationProspectLinkApi - functional programming interface
 * @export
 */
export const ConversationProspectLinkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ConversationProspectLinkApiAxiosParamCreator(configuration).createConversationProspectLinkV1(conversationId, prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ConversationProspectLinkApiAxiosParamCreator(configuration).deleteConversationProspectLinkV1(conversationId, prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConversationsOfProspectsV1(prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConversationOutput>>> {
            const localVarAxiosArgs = await ConversationProspectLinkApiAxiosParamCreator(configuration).listConversationsOfProspectsV1(prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ConversationProspectLinkApi - factory interface
 * @export
 */
export const ConversationProspectLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ConversationProspectLinkApiFp(configuration).createConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ConversationProspectLinkApiFp(configuration).deleteConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsOfProspectsV1(prospectId: string, options?: any): AxiosPromise<Array<ConversationOutput>> {
            return ConversationProspectLinkApiFp(configuration).listConversationsOfProspectsV1(prospectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConversationProspectLinkApi - object-oriented interface
 * @export
 * @class ConversationProspectLinkApi
 * @extends {BaseAPI}
 */
export class ConversationProspectLinkApi extends BaseAPI {
    /**
     * Create a link between a conversation and a prospect
     * @summary Create a link between a conversation and a prospect
     * @param {string} conversationId ID of the conversation
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    public createConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any) {
        return ConversationProspectLinkApiFp(this.configuration).createConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a link between a conversation and a prospect
     * @summary Delete a link between a conversation and a prospect
     * @param {string} conversationId ID of the conversation
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    public deleteConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any) {
        return ConversationProspectLinkApiFp(this.configuration).deleteConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all conversations linked to a specific prospect
     * @summary List all conversations linked to a specific prospect
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    public listConversationsOfProspectsV1(prospectId: string, options?: any) {
        return ConversationProspectLinkApiFp(this.configuration).listConversationsOfProspectsV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ConversationsApi - axios parameter creator
 * @export
 */
export const ConversationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedbackV1: async (conversationId: string, comment: Comment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling addFeedbackV1.');
            }
            // verify required parameter 'comment' is not null or undefined
            if (comment === null || comment === undefined) {
                throw new RequiredError('comment','Required parameter comment was null or undefined when calling addFeedbackV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}/feedback`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof comment !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(comment !== undefined ? comment : {}) : (comment || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationV1: async (conversationInput: ConversationInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationInput' is not null or undefined
            if (conversationInput === null || conversationInput === undefined) {
                throw new RequiredError('conversationInput','Required parameter conversationInput was null or undefined when calling createConversationV1.');
            }
            const localVarPath = `/v1/conversations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof conversationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(conversationInput !== undefined ? conversationInput : {}) : (conversationInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationV1: async (conversationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling deleteConversationV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationV1: async (conversationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling getConversationV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Conversations
         * @summary List All Conversations
         * @param {AppEnumInput} [app] 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsV1: async (app?: AppEnumInput, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/conversations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationV1: async (conversationId: string, conversationInput: ConversationInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling updateConversationV1.');
            }
            // verify required parameter 'conversationInput' is not null or undefined
            if (conversationInput === null || conversationInput === undefined) {
                throw new RequiredError('conversationInput','Required parameter conversationInput was null or undefined when calling updateConversationV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof conversationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(conversationInput !== undefined ? conversationInput : {}) : (conversationInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversationsApi - functional programming interface
 * @export
 */
export const ConversationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFeedbackV1(conversationId: string, comment: Comment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationFeedback>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).addFeedbackV1(conversationId, comment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversationV1(conversationInput: ConversationInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationOutput>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).createConversationV1(conversationInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConversationV1(conversationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).deleteConversationV1(conversationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversationV1(conversationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationOutput>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).getConversationV1(conversationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Conversations
         * @summary List All Conversations
         * @param {AppEnumInput} [app] 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConversationsV1(app?: AppEnumInput, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConversationOutput>>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConversationV1(conversationId: string, conversationInput: ConversationInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationOutput>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).updateConversationV1(conversationId, conversationInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ConversationsApi - factory interface
 * @export
 */
export const ConversationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedbackV1(conversationId: string, comment: Comment, options?: any): AxiosPromise<ConversationFeedback> {
            return ConversationsApiFp(configuration).addFeedbackV1(conversationId, comment, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationV1(conversationInput: ConversationInput, options?: any): AxiosPromise<ConversationOutput> {
            return ConversationsApiFp(configuration).createConversationV1(conversationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationV1(conversationId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ConversationsApiFp(configuration).deleteConversationV1(conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationV1(conversationId: string, options?: any): AxiosPromise<ConversationOutput> {
            return ConversationsApiFp(configuration).getConversationV1(conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Conversations
         * @summary List All Conversations
         * @param {AppEnumInput} [app] 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsV1(app?: AppEnumInput, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): AxiosPromise<Array<ConversationOutput>> {
            return ConversationsApiFp(configuration).listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationV1(conversationId: string, conversationInput: ConversationInput, options?: any): AxiosPromise<ConversationOutput> {
            return ConversationsApiFp(configuration).updateConversationV1(conversationId, conversationInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConversationsApi - object-oriented interface
 * @export
 * @class ConversationsApi
 * @extends {BaseAPI}
 */
export class ConversationsApi extends BaseAPI {
    /**
     * Add Feedback to a Specific Conversation
     * @summary Add Feedback to a Specific Conversation
     * @param {string} conversationId ID of the conversation
     * @param {Comment} comment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public addFeedbackV1(conversationId: string, comment: Comment, options?: any) {
        return ConversationsApiFp(this.configuration).addFeedbackV1(conversationId, comment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a New Conversation
     * @summary Create a New Conversation
     * @param {ConversationInput} conversationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public createConversationV1(conversationInput: ConversationInput, options?: any) {
        return ConversationsApiFp(this.configuration).createConversationV1(conversationInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific Conversation by ID
     * @summary Delete a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public deleteConversationV1(conversationId: string, options?: any) {
        return ConversationsApiFp(this.configuration).deleteConversationV1(conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Conversation by ID
     * @summary Get a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public getConversationV1(conversationId: string, options?: any) {
        return ConversationsApiFp(this.configuration).getConversationV1(conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Conversations
     * @summary List All Conversations
     * @param {AppEnumInput} [app] 
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [updatedAfter] 
     * @param {string} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public listConversationsV1(app?: AppEnumInput, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any) {
        return ConversationsApiFp(this.configuration).listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific Conversation by ID
     * @summary Update a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {ConversationInput} conversationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public updateConversationV1(conversationId: string, conversationInput: ConversationInput, options?: any) {
        return ConversationsApiFp(this.configuration).updateConversationV1(conversationId, conversationInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * DataPlaneApi - axios parameter creator
 * @export
 */
export const DataPlaneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new connection for an AI Agent to start a voice conversation
         * @summary Create Connection
         * @param {string} agentId 
         * @param {ConnectionSource} connectionSource 
         * @param {string} [prospectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection: async (agentId: string, connectionSource: ConnectionSource, prospectId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling createConnection.');
            }
            // verify required parameter 'connectionSource' is not null or undefined
            if (connectionSource === null || connectionSource === undefined) {
                throw new RequiredError('connectionSource','Required parameter connectionSource was null or undefined when calling createConnection.');
            }
            const localVarPath = `/v1/connections`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (agentId !== undefined) {
                localVarQueryParameter['agentId'] = agentId;
            }

            if (prospectId !== undefined) {
                localVarQueryParameter['prospect_id'] = prospectId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof connectionSource !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(connectionSource !== undefined ? connectionSource : {}) : (connectionSource || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the audio stream xml for Plivo to start a voice conversation
         * @summary Get Audio Stream XML For Plivo
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlivoAudioStreamXml: async (connectionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            if (connectionId === null || connectionId === undefined) {
                throw new RequiredError('connectionId','Required parameter connectionId was null or undefined when calling getPlivoAudioStreamXml.');
            }
            const localVarPath = `/v1/connections/{connection_id}/plivo-audio-stream-xml`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List connections
         * @summary Listconnections
         * @param {string} [sourceName] 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections: async (sourceName?: string, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/connections`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (sourceName !== undefined) {
                localVarQueryParameter['sourceName'] = sourceName;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataPlaneApi - functional programming interface
 * @export
 */
export const DataPlaneApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new connection for an AI Agent to start a voice conversation
         * @summary Create Connection
         * @param {string} agentId 
         * @param {ConnectionSource} connectionSource 
         * @param {string} [prospectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnection(agentId: string, connectionSource: ConnectionSource, prospectId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionOutput>> {
            const localVarAxiosArgs = await DataPlaneApiAxiosParamCreator(configuration).createConnection(agentId, connectionSource, prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the audio stream xml for Plivo to start a voice conversation
         * @summary Get Audio Stream XML For Plivo
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlivoAudioStreamXml(connectionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await DataPlaneApiAxiosParamCreator(configuration).getPlivoAudioStreamXml(connectionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List connections
         * @summary Listconnections
         * @param {string} [sourceName] 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnections(sourceName?: string, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConnectionOutput>>> {
            const localVarAxiosArgs = await DataPlaneApiAxiosParamCreator(configuration).listConnections(sourceName, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DataPlaneApi - factory interface
 * @export
 */
export const DataPlaneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new connection for an AI Agent to start a voice conversation
         * @summary Create Connection
         * @param {string} agentId 
         * @param {ConnectionSource} connectionSource 
         * @param {string} [prospectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(agentId: string, connectionSource: ConnectionSource, prospectId?: string, options?: any): AxiosPromise<ConnectionOutput> {
            return DataPlaneApiFp(configuration).createConnection(agentId, connectionSource, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the audio stream xml for Plivo to start a voice conversation
         * @summary Get Audio Stream XML For Plivo
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlivoAudioStreamXml(connectionId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return DataPlaneApiFp(configuration).getPlivoAudioStreamXml(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * List connections
         * @summary Listconnections
         * @param {string} [sourceName] 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections(sourceName?: string, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): AxiosPromise<Array<ConnectionOutput>> {
            return DataPlaneApiFp(configuration).listConnections(sourceName, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataPlaneApi - object-oriented interface
 * @export
 * @class DataPlaneApi
 * @extends {BaseAPI}
 */
export class DataPlaneApi extends BaseAPI {
    /**
     * Create a new connection for an AI Agent to start a voice conversation
     * @summary Create Connection
     * @param {string} agentId 
     * @param {ConnectionSource} connectionSource 
     * @param {string} [prospectId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPlaneApi
     */
    public createConnection(agentId: string, connectionSource: ConnectionSource, prospectId?: string, options?: any) {
        return DataPlaneApiFp(this.configuration).createConnection(agentId, connectionSource, prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the audio stream xml for Plivo to start a voice conversation
     * @summary Get Audio Stream XML For Plivo
     * @param {string} connectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPlaneApi
     */
    public getPlivoAudioStreamXml(connectionId: string, options?: any) {
        return DataPlaneApiFp(this.configuration).getPlivoAudioStreamXml(connectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List connections
     * @summary Listconnections
     * @param {string} [sourceName] 
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [updatedAfter] 
     * @param {string} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPlaneApi
     */
    public listConnections(sourceName?: string, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any) {
        return DataPlaneApiFp(this.configuration).listConnections(sourceName, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete files from Trata account
         * @summary Delete Files
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1: async (fileIds: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileIds' is not null or undefined
            if (fileIds === null || fileIds === undefined) {
                throw new RequiredError('fileIds','Required parameter fileIds was null or undefined when calling deleteFileV1.');
            }
            const localVarPath = `/v1/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (fileIds !== undefined) {
                localVarQueryParameter['file_ids'] = fileIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files 
         * @param {string} [validator] Validator type to use for file validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1: async (files: Array<any>, validator?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'files' is not null or undefined
            if (files === null || files === undefined) {
                throw new RequiredError('files','Required parameter files was null or undefined when calling uploadFileV1.');
            }
            const localVarPath = `/v1/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (validator !== undefined) {
                localVarQueryParameter['validator'] = validator;
            }

            if (files) {
            
                localVarFormParams.append('files', files.join(COLLECTION_FORMATS.csv));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete files from Trata account
         * @summary Delete Files
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileV1(fileIds: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await FilesApiAxiosParamCreator(configuration).deleteFileV1(fileIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files 
         * @param {string} [validator] Validator type to use for file validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileV1(files: Array<any>, validator?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Files>>> {
            const localVarAxiosArgs = await FilesApiAxiosParamCreator(configuration).uploadFileV1(files, validator, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete files from Trata account
         * @summary Delete Files
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1(fileIds: string, options?: any): AxiosPromise<boolean> {
            return FilesApiFp(configuration).deleteFileV1(fileIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files 
         * @param {string} [validator] Validator type to use for file validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1(files: Array<any>, validator?: string, options?: any): AxiosPromise<Array<Files>> {
            return FilesApiFp(configuration).uploadFileV1(files, validator, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * Delete files from Trata account
     * @summary Delete Files
     * @param {string} fileIds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public deleteFileV1(fileIds: string, options?: any) {
        return FilesApiFp(this.configuration).deleteFileV1(fileIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload file to Trata account to use in AI Agents
     * @summary Upload Files
     * @param {Array<any>} files 
     * @param {string} [validator] Validator type to use for file validation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public uploadFileV1(files: Array<any>, validator?: string, options?: any) {
        return FilesApiFp(this.configuration).uploadFileV1(files, validator, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Heart Beat check to check the health of Trata Backend
         * @summary Heart Beat Status Of Trata Backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatusGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Heart Beat check to check the health of Workflow Service
         * @summary Heart Beat Status Of Workflow Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusWorkflowsStatusGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflows/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Heart Beat check to check the health of Trata Backend
         * @summary Heart Beat Status Of Trata Backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusStatusGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await HealthApiAxiosParamCreator(configuration).statusStatusGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Heart Beat check to check the health of Workflow Service
         * @summary Heart Beat Status Of Workflow Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusWorkflowsStatusGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await HealthApiAxiosParamCreator(configuration).statusWorkflowsStatusGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Heart Beat check to check the health of Trata Backend
         * @summary Heart Beat Status Of Trata Backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatusGet(options?: any): AxiosPromise<object> {
            return HealthApiFp(configuration).statusStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Heart Beat check to check the health of Workflow Service
         * @summary Heart Beat Status Of Workflow Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusWorkflowsStatusGet(options?: any): AxiosPromise<object> {
            return HealthApiFp(configuration).statusWorkflowsStatusGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * Heart Beat check to check the health of Trata Backend
     * @summary Heart Beat Status Of Trata Backend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public statusStatusGet(options?: any) {
        return HealthApiFp(this.configuration).statusStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Heart Beat check to check the health of Workflow Service
     * @summary Heart Beat Status Of Workflow Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public statusWorkflowsStatusGet(options?: any) {
        return HealthApiFp(this.configuration).statusWorkflowsStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * HiveApi - axios parameter creator
 * @export
 */
export const HiveApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1: async (hiveContentInput: HiveContentInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveContentInput' is not null or undefined
            if (hiveContentInput === null || hiveContentInput === undefined) {
                throw new RequiredError('hiveContentInput','Required parameter hiveContentInput was null or undefined when calling createHiveV1.');
            }
            const localVarPath = `/v1/hives`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof hiveContentInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(hiveContentInput !== undefined ? hiveContentInput : {}) : (hiveContentInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1: async (hiveId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling deleteHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1: async (hiveId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling getHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Hives
         * @summary List All Hives
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/hives`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1: async (hiveId: string, hiveContentOutput: HiveContentOutput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling updateHiveV1.');
            }
            // verify required parameter 'hiveContentOutput' is not null or undefined
            if (hiveContentOutput === null || hiveContentOutput === undefined) {
                throw new RequiredError('hiveContentOutput','Required parameter hiveContentOutput was null or undefined when calling updateHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof hiveContentOutput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(hiveContentOutput !== undefined ? hiveContentOutput : {}) : (hiveContentOutput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HiveApi - functional programming interface
 * @export
 */
export const HiveApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHiveV1(hiveContentInput: HiveContentInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>> {
            const localVarAxiosArgs = await HiveApiAxiosParamCreator(configuration).createHiveV1(hiveContentInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHiveV1(hiveId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await HiveApiAxiosParamCreator(configuration).deleteHiveV1(hiveId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHiveV1(hiveId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>> {
            const localVarAxiosArgs = await HiveApiAxiosParamCreator(configuration).getHiveV1(hiveId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Hives
         * @summary List All Hives
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHivesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hive>>> {
            const localVarAxiosArgs = await HiveApiAxiosParamCreator(configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHiveV1(hiveId: string, hiveContentOutput: HiveContentOutput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>> {
            const localVarAxiosArgs = await HiveApiAxiosParamCreator(configuration).updateHiveV1(hiveId, hiveContentOutput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HiveApi - factory interface
 * @export
 */
export const HiveApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1(hiveContentInput: HiveContentInput, options?: any): AxiosPromise<Hive> {
            return HiveApiFp(configuration).createHiveV1(hiveContentInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1(hiveId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return HiveApiFp(configuration).deleteHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1(hiveId: string, options?: any): AxiosPromise<Hive> {
            return HiveApiFp(configuration).getHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Hives
         * @summary List All Hives
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): AxiosPromise<Array<Hive>> {
            return HiveApiFp(configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1(hiveId: string, hiveContentOutput: HiveContentOutput, options?: any): AxiosPromise<Hive> {
            return HiveApiFp(configuration).updateHiveV1(hiveId, hiveContentOutput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HiveApi - object-oriented interface
 * @export
 * @class HiveApi
 * @extends {BaseAPI}
 */
export class HiveApi extends BaseAPI {
    /**
     * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
     * @summary Create a New Hive
     * @param {HiveContentInput} hiveContentInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public createHiveV1(hiveContentInput: HiveContentInput, options?: any) {
        return HiveApiFp(this.configuration).createHiveV1(hiveContentInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific Hive by ID
     * @summary Delete a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public deleteHiveV1(hiveId: string, options?: any) {
        return HiveApiFp(this.configuration).deleteHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Hive by ID
     * @summary Get a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public getHiveV1(hiveId: string, options?: any) {
        return HiveApiFp(this.configuration).getHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Hives
     * @summary List All Hives
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [updatedAfter] 
     * @param {string} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public listHivesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any) {
        return HiveApiFp(this.configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific Hive by ID
     * @summary Update a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {HiveContentOutput} hiveContentOutput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public updateHiveV1(hiveId: string, hiveContentOutput: HiveContentOutput, options?: any) {
        return HiveApiFp(this.configuration).updateHiveV1(hiveId, hiveContentOutput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * HiveAgentLinkApi - axios parameter creator
 * @export
 */
export const HiveAgentLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveAgentLinkV1: async (hiveId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling createHiveAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling createHiveAgentLinkV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}/ai-agents/{agent_id}/link`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveAgentLinkV1: async (hiveId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling deleteHiveAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling deleteHiveAgentLinkV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}/ai-agents/{agent_id}/link`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfHiveV1: async (hiveId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling listAgentsOfHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}/ai-agents`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesOfAgentV1: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling listHivesOfAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}/hives`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HiveAgentLinkApi - functional programming interface
 * @export
 */
export const HiveAgentLinkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHiveAgentLinkV1(hiveId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await HiveAgentLinkApiAxiosParamCreator(configuration).createHiveAgentLinkV1(hiveId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHiveAgentLinkV1(hiveId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await HiveAgentLinkApiAxiosParamCreator(configuration).deleteHiveAgentLinkV1(hiveId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAgentsOfHiveV1(hiveId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AIAgentOutput>>> {
            const localVarAxiosArgs = await HiveAgentLinkApiAxiosParamCreator(configuration).listAgentsOfHiveV1(hiveId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHivesOfAgentV1(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hive>>> {
            const localVarAxiosArgs = await HiveAgentLinkApiAxiosParamCreator(configuration).listHivesOfAgentV1(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HiveAgentLinkApi - factory interface
 * @export
 */
export const HiveAgentLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveAgentLinkV1(hiveId: string, agentId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return HiveAgentLinkApiFp(configuration).createHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveAgentLinkV1(hiveId: string, agentId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return HiveAgentLinkApiFp(configuration).deleteHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfHiveV1(hiveId: string, options?: any): AxiosPromise<Array<AIAgentOutput>> {
            return HiveAgentLinkApiFp(configuration).listAgentsOfHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesOfAgentV1(agentId: string, options?: any): AxiosPromise<Array<Hive>> {
            return HiveAgentLinkApiFp(configuration).listHivesOfAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HiveAgentLinkApi - object-oriented interface
 * @export
 * @class HiveAgentLinkApi
 * @extends {BaseAPI}
 */
export class HiveAgentLinkApi extends BaseAPI {
    /**
     * Create a Link Between a Hive and an Agent
     * @summary Create a Link Between a Hive and an Agent
     * @param {string} hiveId ID of the hive
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    public createHiveAgentLinkV1(hiveId: string, agentId: string, options?: any) {
        return HiveAgentLinkApiFp(this.configuration).createHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Link Between a Hive and an Agent
     * @summary Delete a Link Between a Hive and an Agent
     * @param {string} hiveId ID of the hive
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    public deleteHiveAgentLinkV1(hiveId: string, agentId: string, options?: any) {
        return HiveAgentLinkApiFp(this.configuration).deleteHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Agents Linked to a Specific Hive
     * @summary List All Agents Linked to a Specific Hive
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    public listAgentsOfHiveV1(hiveId: string, options?: any) {
        return HiveAgentLinkApiFp(this.configuration).listAgentsOfHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Hives Linked to a Specific Agent
     * @summary List All Hives Linked to a Specific Agent
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    public listHivesOfAgentV1(agentId: string, options?: any) {
        return HiveAgentLinkApiFp(this.configuration).listHivesOfAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * InternalApi - axios parameter creator
 * @export
 */
export const InternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteV1: async (acceptInviteRequest: AcceptInviteRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'acceptInviteRequest' is not null or undefined
            if (acceptInviteRequest === null || acceptInviteRequest === undefined) {
                throw new RequiredError('acceptInviteRequest','Required parameter acceptInviteRequest was null or undefined when calling acceptInviteV1.');
            }
            const localVarPath = `/v1/invites/accept`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof acceptInviteRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(acceptInviteRequest !== undefined ? acceptInviteRequest : {}) : (acceptInviteRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationV1: async (bodyCreateOrganizationV1: BodyCreateOrganizationV1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateOrganizationV1' is not null or undefined
            if (bodyCreateOrganizationV1 === null || bodyCreateOrganizationV1 === undefined) {
                throw new RequiredError('bodyCreateOrganizationV1','Required parameter bodyCreateOrganizationV1 was null or undefined when calling createOrganizationV1.');
            }
            const localVarPath = `/v1/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyCreateOrganizationV1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyCreateOrganizationV1 !== undefined ? bodyCreateOrganizationV1 : {}) : (bodyCreateOrganizationV1 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user
         * @summary Createuser
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserV1: async (userPayload: UserPayload, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPayload' is not null or undefined
            if (userPayload === null || userPayload === undefined) {
                throw new RequiredError('userPayload','Required parameter userPayload was null or undefined when calling createUserV1.');
            }
            const localVarPath = `/v1/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userPayload !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userPayload !== undefined ? userPayload : {}) : (userPayload || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserV1.');
            }
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get customer credits
         * @summary Get Customer Credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCreditsV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/customers/credits`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get customer pricing
         * @summary Get Customer Pricing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerPricingV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/customers/pricing`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getorganizationbranding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBrandingV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organizations/branding`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getuserbyid
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIdV1: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserByIdV1.');
            }
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/invites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput 
         * @param {string} [app] The app to use for the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInviteV1: async (guestInput: GuestInput, app?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guestInput' is not null or undefined
            if (guestInput === null || guestInput === undefined) {
                throw new RequiredError('guestInput','Required parameter guestInput was null or undefined when calling sendInviteV1.');
            }
            const localVarPath = `/v1/invites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof guestInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(guestInput !== undefined ? guestInput : {}) : (guestInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationV1: async (orgId: string, organizationInput: OrganizationInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            if (orgId === null || orgId === undefined) {
                throw new RequiredError('orgId','Required parameter orgId was null or undefined when calling updateOrganizationV1.');
            }
            // verify required parameter 'organizationInput' is not null or undefined
            if (organizationInput === null || organizationInput === undefined) {
                throw new RequiredError('organizationInput','Required parameter organizationInput was null or undefined when calling updateOrganizationV1.');
            }
            const localVarPath = `/v1/organizations/{org_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof organizationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(organizationInput !== undefined ? organizationInput : {}) : (organizationInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId 
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1: async (userId: string, userPayload: UserPayload, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserV1.');
            }
            // verify required parameter 'userPayload' is not null or undefined
            if (userPayload === null || userPayload === undefined) {
                throw new RequiredError('userPayload','Required parameter userPayload was null or undefined when calling updateUserV1.');
            }
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userPayload !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userPayload !== undefined ? userPayload : {}) : (userPayload || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalApi - functional programming interface
 * @export
 */
export const InternalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).acceptInviteV1(acceptInviteRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationV1(bodyCreateOrganizationV1: BodyCreateOrganizationV1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).createOrganizationV1(bodyCreateOrganizationV1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new user
         * @summary Createuser
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserV1(userPayload: UserPayload, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).createUserV1(userPayload, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).deleteOrganizationV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserV1(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).deleteUserV1(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get customer credits
         * @summary Get Customer Credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerCreditsV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Credit>>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).getCustomerCreditsV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get customer pricing
         * @summary Get Customer Pricing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerPricingV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Price>>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).getCustomerPricingV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Getorganizationbranding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationBrandingV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerBranding | object>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).getOrganizationBrandingV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationOutput>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).getOrganizationV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Getuserbyid
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByIdV1(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).getUserByIdV1(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInvitesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuestOutput>>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsersV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).listUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput 
         * @param {string} [app] The app to use for the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendInviteV1(guestInput: GuestInput, app?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuestOutput>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).sendInviteV1(guestInput, app, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationV1(orgId: string, organizationInput: OrganizationInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationOutput>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).updateOrganizationV1(orgId, organizationInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId 
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserV1(userId: string, userPayload: UserPayload, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).updateUserV1(userId, userPayload, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InternalApi - factory interface
 * @export
 */
export const InternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: any): AxiosPromise<User> {
            return InternalApiFp(configuration).acceptInviteV1(acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationV1(bodyCreateOrganizationV1: BodyCreateOrganizationV1, options?: any): AxiosPromise<User> {
            return InternalApiFp(configuration).createOrganizationV1(bodyCreateOrganizationV1, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user
         * @summary Createuser
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserV1(userPayload: UserPayload, options?: any): AxiosPromise<User> {
            return InternalApiFp(configuration).createUserV1(userPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationV1(options?: any): AxiosPromise<BaseResponseInput> {
            return InternalApiFp(configuration).deleteOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1(userId: string, options?: any): AxiosPromise<User> {
            return InternalApiFp(configuration).deleteUserV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get customer credits
         * @summary Get Customer Credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCreditsV1(options?: any): AxiosPromise<Array<Credit>> {
            return InternalApiFp(configuration).getCustomerCreditsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get customer pricing
         * @summary Get Customer Pricing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerPricingV1(options?: any): AxiosPromise<Array<Price>> {
            return InternalApiFp(configuration).getCustomerPricingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getorganizationbranding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBrandingV1(options?: any): AxiosPromise<CustomerBranding | object> {
            return InternalApiFp(configuration).getOrganizationBrandingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationV1(options?: any): AxiosPromise<OrganizationOutput> {
            return InternalApiFp(configuration).getOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getuserbyid
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIdV1(userId: string, options?: any): AxiosPromise<User> {
            return InternalApiFp(configuration).getUserByIdV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): AxiosPromise<Array<GuestOutput>> {
            return InternalApiFp(configuration).listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): AxiosPromise<Array<User>> {
            return InternalApiFp(configuration).listUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput 
         * @param {string} [app] The app to use for the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInviteV1(guestInput: GuestInput, app?: string, options?: any): AxiosPromise<GuestOutput> {
            return InternalApiFp(configuration).sendInviteV1(guestInput, app, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationV1(orgId: string, organizationInput: OrganizationInput, options?: any): AxiosPromise<OrganizationOutput> {
            return InternalApiFp(configuration).updateOrganizationV1(orgId, organizationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId 
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1(userId: string, userPayload: UserPayload, options?: any): AxiosPromise<User> {
            return InternalApiFp(configuration).updateUserV1(userId, userPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
export class InternalApi extends BaseAPI {
    /**
     * Accept invite and add new user to organization
     * @summary Acceptinvite
     * @param {AcceptInviteRequest} acceptInviteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public acceptInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: any) {
        return InternalApiFp(this.configuration).acceptInviteV1(acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new organization and adds the user as the \"ADMIN\" user for the org
     * @summary Createorganization
     * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public createOrganizationV1(bodyCreateOrganizationV1: BodyCreateOrganizationV1, options?: any) {
        return InternalApiFp(this.configuration).createOrganizationV1(bodyCreateOrganizationV1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user
     * @summary Createuser
     * @param {UserPayload} userPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public createUserV1(userPayload: UserPayload, options?: any) {
        return InternalApiFp(this.configuration).createUserV1(userPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deleteorganization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public deleteOrganizationV1(options?: any) {
        return InternalApiFp(this.configuration).deleteOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user
     * @summary Deleteuser
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public deleteUserV1(userId: string, options?: any) {
        return InternalApiFp(this.configuration).deleteUserV1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get customer credits
     * @summary Get Customer Credits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getCustomerCreditsV1(options?: any) {
        return InternalApiFp(this.configuration).getCustomerCreditsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get customer pricing
     * @summary Get Customer Pricing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getCustomerPricingV1(options?: any) {
        return InternalApiFp(this.configuration).getCustomerPricingV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Getorganizationbranding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getOrganizationBrandingV1(options?: any) {
        return InternalApiFp(this.configuration).getOrganizationBrandingV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Getorganization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getOrganizationV1(options?: any) {
        return InternalApiFp(this.configuration).getOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Getuserbyid
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getUserByIdV1(userId: string, options?: any) {
        return InternalApiFp(this.configuration).getUserByIdV1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of all open invites from the organization
     * @summary Listinvites
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [updatedAfter] 
     * @param {string} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public listInvitesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any) {
        return InternalApiFp(this.configuration).listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all users under the user\'s organization
     * @summary Listusers
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [updatedAfter] 
     * @param {string} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public listUsersV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any) {
        return InternalApiFp(this.configuration).listUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a new user to an organization or resend invite to the user if the user is already invited
     * @summary Inviteusers
     * @param {GuestInput} guestInput 
     * @param {string} [app] The app to use for the invite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public sendInviteV1(guestInput: GuestInput, app?: string, options?: any) {
        return InternalApiFp(this.configuration).sendInviteV1(guestInput, app, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updateorganization
     * @param {string} orgId ID of the organization
     * @param {OrganizationInput} organizationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public updateOrganizationV1(orgId: string, organizationInput: OrganizationInput, options?: any) {
        return InternalApiFp(this.configuration).updateOrganizationV1(orgId, organizationInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user details
     * @summary Updateuser
     * @param {string} userId 
     * @param {UserPayload} userPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public updateUserV1(userId: string, userPayload: UserPayload, options?: any) {
        return InternalApiFp(this.configuration).updateUserV1(userId, userPayload, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductV1: async (productInput: ProductInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productInput' is not null or undefined
            if (productInput === null || productInput === undefined) {
                throw new RequiredError('productInput','Required parameter productInput was null or undefined when calling createProductV1.');
            }
            const localVarPath = `/v1/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof productInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(productInput !== undefined ? productInput : {}) : (productInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductV1: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductV1: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfProductV1: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling listAgentsOfProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}/agents`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Products
         * @summary List All Products
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {string} [tags] 
         * @param {string} [productIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, tags?: string, productIds?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (productIds !== undefined) {
                localVarQueryParameter['product_ids'] = productIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductV1: async (productId: string, productInput: ProductInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling updateProductV1.');
            }
            // verify required parameter 'productInput' is not null or undefined
            if (productInput === null || productInput === undefined) {
                throw new RequiredError('productInput','Required parameter productInput was null or undefined when calling updateProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof productInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(productInput !== undefined ? productInput : {}) : (productInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProductV1(productInput: ProductInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOutput>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).createProductV1(productInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductV1(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).deleteProductV1(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductV1(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOutput>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).getProductV1(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAgentsOfProductV1(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AIAgentOutput>>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).listAgentsOfProductV1(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Products
         * @summary List All Products
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {string} [tags] 
         * @param {string} [productIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProductsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, tags?: string, productIds?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductOutput>>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProductV1(productId: string, productInput: ProductInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOutput>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).updateProductV1(productId, productInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductV1(productInput: ProductInput, options?: any): AxiosPromise<ProductOutput> {
            return ProductsApiFp(configuration).createProductV1(productInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductV1(productId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ProductsApiFp(configuration).deleteProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductV1(productId: string, options?: any): AxiosPromise<ProductOutput> {
            return ProductsApiFp(configuration).getProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfProductV1(productId: string, options?: any): AxiosPromise<Array<AIAgentOutput>> {
            return ProductsApiFp(configuration).listAgentsOfProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Products
         * @summary List All Products
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {string} [tags] 
         * @param {string} [productIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, tags?: string, productIds?: string, options?: any): AxiosPromise<Array<ProductOutput>> {
            return ProductsApiFp(configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductV1(productId: string, productInput: ProductInput, options?: any): AxiosPromise<ProductOutput> {
            return ProductsApiFp(configuration).updateProductV1(productId, productInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * Create a New Product
     * @summary Create a New Product
     * @param {ProductInput} productInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public createProductV1(productInput: ProductInput, options?: any) {
        return ProductsApiFp(this.configuration).createProductV1(productInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific Product by ID
     * @summary Delete a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProductV1(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).deleteProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Product by ID
     * @summary Get a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductV1(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).getProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Agents Linked to a Specific Product
     * @summary List All Agents Linked to a Specific Product
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listAgentsOfProductV1(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).listAgentsOfProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Products
     * @summary List All Products
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [updatedAfter] 
     * @param {string} [updatedBefore] 
     * @param {string} [tags] 
     * @param {string} [productIds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listProductsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, tags?: string, productIds?: string, options?: any) {
        return ProductsApiFp(this.configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific Product by ID
     * @summary Update a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {ProductInput} productInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProductV1(productId: string, productInput: ProductInput, options?: any) {
        return ProductsApiFp(this.configuration).updateProductV1(productId, productInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ProspectsApi - axios parameter creator
 * @export
 */
export const ProspectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProspectV1: async (prospectInput: ProspectInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectInput' is not null or undefined
            if (prospectInput === null || prospectInput === undefined) {
                throw new RequiredError('prospectInput','Required parameter prospectInput was null or undefined when calling createProspectV1.');
            }
            const localVarPath = `/v1/prospects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof prospectInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(prospectInput !== undefined ? prospectInput : {}) : (prospectInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProspectV1: async (prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling deleteProspectV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProspectV1: async (prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling getProspectV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Prospects
         * @summary List All Prospects
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProspectsV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/prospects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProspectV1: async (prospectId: string, prospectInput: ProspectInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling updateProspectV1.');
            }
            // verify required parameter 'prospectInput' is not null or undefined
            if (prospectInput === null || prospectInput === undefined) {
                throw new RequiredError('prospectInput','Required parameter prospectInput was null or undefined when calling updateProspectV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof prospectInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(prospectInput !== undefined ? prospectInput : {}) : (prospectInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProspectsApi - functional programming interface
 * @export
 */
export const ProspectsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProspectV1(prospectInput: ProspectInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProspectOutput>> {
            const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(configuration).createProspectV1(prospectInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProspectV1(prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(configuration).deleteProspectV1(prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProspectV1(prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProspectOutput>> {
            const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(configuration).getProspectV1(prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Prospects
         * @summary List All Prospects
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProspectsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProspectOutput>>> {
            const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(configuration).listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProspectV1(prospectId: string, prospectInput: ProspectInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProspectOutput>> {
            const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(configuration).updateProspectV1(prospectId, prospectInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProspectsApi - factory interface
 * @export
 */
export const ProspectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProspectV1(prospectInput: ProspectInput, options?: any): AxiosPromise<ProspectOutput> {
            return ProspectsApiFp(configuration).createProspectV1(prospectInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProspectV1(prospectId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ProspectsApiFp(configuration).deleteProspectV1(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProspectV1(prospectId: string, options?: any): AxiosPromise<ProspectOutput> {
            return ProspectsApiFp(configuration).getProspectV1(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Prospects
         * @summary List All Prospects
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProspectsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): AxiosPromise<Array<ProspectOutput>> {
            return ProspectsApiFp(configuration).listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProspectV1(prospectId: string, prospectInput: ProspectInput, options?: any): AxiosPromise<ProspectOutput> {
            return ProspectsApiFp(configuration).updateProspectV1(prospectId, prospectInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProspectsApi - object-oriented interface
 * @export
 * @class ProspectsApi
 * @extends {BaseAPI}
 */
export class ProspectsApi extends BaseAPI {
    /**
     * Create a New Prospect
     * @summary Create a New Prospect
     * @param {ProspectInput} prospectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public createProspectV1(prospectInput: ProspectInput, options?: any) {
        return ProspectsApiFp(this.configuration).createProspectV1(prospectInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific Prospect by ID
     * @summary Delete a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public deleteProspectV1(prospectId: string, options?: any) {
        return ProspectsApiFp(this.configuration).deleteProspectV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Prospect by ID
     * @summary Get a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public getProspectV1(prospectId: string, options?: any) {
        return ProspectsApiFp(this.configuration).getProspectV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Prospects
     * @summary List All Prospects
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [updatedAfter] 
     * @param {string} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public listProspectsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any) {
        return ProspectsApiFp(this.configuration).listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific Prospect by ID
     * @summary Update a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {ProspectInput} prospectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public updateProspectV1(prospectId: string, prospectInput: ProspectInput, options?: any) {
        return ProspectsApiFp(this.configuration).updateProspectV1(prospectId, prospectInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ResellerCourseAssignmentsApi - axios parameter creator
 * @export
 */
export const ResellerCourseAssignmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign Course To Reseller Customer
         * @param {string} courseId 
         * @param {ResellerCourseAssignment} resellerCourseAssignment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignCourseToResellerCustomerV1ResellersResellerCoursesCourseIdAssignmentPost: async (courseId: string, resellerCourseAssignment: ResellerCourseAssignment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling assignCourseToResellerCustomerV1ResellersResellerCoursesCourseIdAssignmentPost.');
            }
            // verify required parameter 'resellerCourseAssignment' is not null or undefined
            if (resellerCourseAssignment === null || resellerCourseAssignment === undefined) {
                throw new RequiredError('resellerCourseAssignment','Required parameter resellerCourseAssignment was null or undefined when calling assignCourseToResellerCustomerV1ResellersResellerCoursesCourseIdAssignmentPost.');
            }
            const localVarPath = `/v1/resellers/reseller/courses/{course_id}/assignment`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof resellerCourseAssignment !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(resellerCourseAssignment !== undefined ? resellerCourseAssignment : {}) : (resellerCourseAssignment || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerCourseAssignmentsApi - functional programming interface
 * @export
 */
export const ResellerCourseAssignmentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign Course To Reseller Customer
         * @param {string} courseId 
         * @param {ResellerCourseAssignment} resellerCourseAssignment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignCourseToResellerCustomerV1ResellersResellerCoursesCourseIdAssignmentPost(courseId: string, resellerCourseAssignment: ResellerCourseAssignment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ResellerCourseAssignmentsApiAxiosParamCreator(configuration).assignCourseToResellerCustomerV1ResellersResellerCoursesCourseIdAssignmentPost(courseId, resellerCourseAssignment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResellerCourseAssignmentsApi - factory interface
 * @export
 */
export const ResellerCourseAssignmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Assign Course To Reseller Customer
         * @param {string} courseId 
         * @param {ResellerCourseAssignment} resellerCourseAssignment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignCourseToResellerCustomerV1ResellersResellerCoursesCourseIdAssignmentPost(courseId: string, resellerCourseAssignment: ResellerCourseAssignment, options?: any): AxiosPromise<BaseResponseInput> {
            return ResellerCourseAssignmentsApiFp(configuration).assignCourseToResellerCustomerV1ResellersResellerCoursesCourseIdAssignmentPost(courseId, resellerCourseAssignment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerCourseAssignmentsApi - object-oriented interface
 * @export
 * @class ResellerCourseAssignmentsApi
 * @extends {BaseAPI}
 */
export class ResellerCourseAssignmentsApi extends BaseAPI {
    /**
     * 
     * @summary Assign Course To Reseller Customer
     * @param {string} courseId 
     * @param {ResellerCourseAssignment} resellerCourseAssignment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCourseAssignmentsApi
     */
    public assignCourseToResellerCustomerV1ResellersResellerCoursesCourseIdAssignmentPost(courseId: string, resellerCourseAssignment: ResellerCourseAssignment, options?: any) {
        return ResellerCourseAssignmentsApiFp(this.configuration).assignCourseToResellerCustomerV1ResellersResellerCoursesCourseIdAssignmentPost(courseId, resellerCourseAssignment, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ResellerCustomerApi - axios parameter creator
 * @export
 */
export const ResellerCustomerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new customer organization under a reseller organization
         * @summary Create Customer V1
         * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerOrganizationV1: async (bodyCreateCustomerOrganizationV1: BodyCreateCustomerOrganizationV1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateCustomerOrganizationV1' is not null or undefined
            if (bodyCreateCustomerOrganizationV1 === null || bodyCreateCustomerOrganizationV1 === undefined) {
                throw new RequiredError('bodyCreateCustomerOrganizationV1','Required parameter bodyCreateCustomerOrganizationV1 was null or undefined when calling createCustomerOrganizationV1.');
            }
            const localVarPath = `/v1/resellers/customers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyCreateCustomerOrganizationV1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyCreateCustomerOrganizationV1 !== undefined ? bodyCreateCustomerOrganizationV1 : {}) : (bodyCreateCustomerOrganizationV1 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a reseller\'s customer and all associated data
         * @summary Delete Customer V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerCustomerV1: async (customerOrgId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling deleteResellerCustomerV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the basic credentials of a customer organization under a reseller organization.
         * @summary Get Customer Basic Credentials V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerBasicCredentialsV1: async (customerOrgId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling getCustomerBasicCredentialsV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/basic_credentials`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
         * @summary Get Customer Credentials V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCredentialsV1: async (customerOrgId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling getCustomerCredentialsV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/credentials`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get reseller customer by id
         * @summary Get Reseller Customer By Id V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerByIdV1: async (customerOrgId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling getResellerCustomerByIdV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List reseller customers with prices, users and credits
         * @summary List Reseller Customers V1
         * @param {string} [searchQuery] Search query
         * @param {boolean} [expandPrices] Whether to expand the prices
         * @param {boolean} [expandUsers] Whether to expand the users
         * @param {boolean} [expandCredits] Whether to expand the credits
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerCustomersV1: async (searchQuery?: string, expandPrices?: boolean, expandUsers?: boolean, expandCredits?: boolean, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/customers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchQuery !== undefined) {
                localVarQueryParameter['search_query'] = searchQuery;
            }

            if (expandPrices !== undefined) {
                localVarQueryParameter['expand_prices'] = expandPrices;
            }

            if (expandUsers !== undefined) {
                localVarQueryParameter['expand_users'] = expandUsers;
            }

            if (expandCredits !== undefined) {
                localVarQueryParameter['expand_credits'] = expandCredits;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a customer organization under a reseller organization
         * @summary Update Customer V1
         * @param {string} customerOrgId 
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerOrganizationV1: async (customerOrgId: string, organizationInput: OrganizationInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling updateCustomerOrganizationV1.');
            }
            // verify required parameter 'organizationInput' is not null or undefined
            if (organizationInput === null || organizationInput === undefined) {
                throw new RequiredError('organizationInput','Required parameter organizationInput was null or undefined when calling updateCustomerOrganizationV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof organizationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(organizationInput !== undefined ? organizationInput : {}) : (organizationInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerCustomerApi - functional programming interface
 * @export
 */
export const ResellerCustomerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new customer organization under a reseller organization
         * @summary Create Customer V1
         * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1: BodyCreateCustomerOrganizationV1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ResellerCustomerApiAxiosParamCreator(configuration).createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a reseller\'s customer and all associated data
         * @summary Delete Customer V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResellerCustomerV1(customerOrgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ResellerCustomerApiAxiosParamCreator(configuration).deleteResellerCustomerV1(customerOrgId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the basic credentials of a customer organization under a reseller organization.
         * @summary Get Customer Basic Credentials V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerBasicCredentialsV1(customerOrgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasicCredentials>> {
            const localVarAxiosArgs = await ResellerCustomerApiAxiosParamCreator(configuration).getCustomerBasicCredentialsV1(customerOrgId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
         * @summary Get Customer Credentials V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerCredentialsV1(customerOrgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await ResellerCustomerApiAxiosParamCreator(configuration).getCustomerCredentialsV1(customerOrgId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get reseller customer by id
         * @summary Get Reseller Customer By Id V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerCustomerByIdV1(customerOrgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgUsersPriceCredits>> {
            const localVarAxiosArgs = await ResellerCustomerApiAxiosParamCreator(configuration).getResellerCustomerByIdV1(customerOrgId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List reseller customers with prices, users and credits
         * @summary List Reseller Customers V1
         * @param {string} [searchQuery] Search query
         * @param {boolean} [expandPrices] Whether to expand the prices
         * @param {boolean} [expandUsers] Whether to expand the users
         * @param {boolean} [expandCredits] Whether to expand the credits
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResellerCustomersV1(searchQuery?: string, expandPrices?: boolean, expandUsers?: boolean, expandCredits?: boolean, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrgUsersPriceCredits>>> {
            const localVarAxiosArgs = await ResellerCustomerApiAxiosParamCreator(configuration).listResellerCustomersV1(searchQuery, expandPrices, expandUsers, expandCredits, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a customer organization under a reseller organization
         * @summary Update Customer V1
         * @param {string} customerOrgId 
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomerOrganizationV1(customerOrgId: string, organizationInput: OrganizationInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationOutput>> {
            const localVarAxiosArgs = await ResellerCustomerApiAxiosParamCreator(configuration).updateCustomerOrganizationV1(customerOrgId, organizationInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResellerCustomerApi - factory interface
 * @export
 */
export const ResellerCustomerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a new customer organization under a reseller organization
         * @summary Create Customer V1
         * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1: BodyCreateCustomerOrganizationV1, options?: any): AxiosPromise<BaseResponseInput> {
            return ResellerCustomerApiFp(configuration).createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a reseller\'s customer and all associated data
         * @summary Delete Customer V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerCustomerV1(customerOrgId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ResellerCustomerApiFp(configuration).deleteResellerCustomerV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the basic credentials of a customer organization under a reseller organization.
         * @summary Get Customer Basic Credentials V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerBasicCredentialsV1(customerOrgId: string, options?: any): AxiosPromise<BasicCredentials> {
            return ResellerCustomerApiFp(configuration).getCustomerBasicCredentialsV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
         * @summary Get Customer Credentials V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCredentialsV1(customerOrgId: string, options?: any): AxiosPromise<string> {
            return ResellerCustomerApiFp(configuration).getCustomerCredentialsV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get reseller customer by id
         * @summary Get Reseller Customer By Id V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerByIdV1(customerOrgId: string, options?: any): AxiosPromise<OrgUsersPriceCredits> {
            return ResellerCustomerApiFp(configuration).getResellerCustomerByIdV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * List reseller customers with prices, users and credits
         * @summary List Reseller Customers V1
         * @param {string} [searchQuery] Search query
         * @param {boolean} [expandPrices] Whether to expand the prices
         * @param {boolean} [expandUsers] Whether to expand the users
         * @param {boolean} [expandCredits] Whether to expand the credits
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerCustomersV1(searchQuery?: string, expandPrices?: boolean, expandUsers?: boolean, expandCredits?: boolean, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): AxiosPromise<Array<OrgUsersPriceCredits>> {
            return ResellerCustomerApiFp(configuration).listResellerCustomersV1(searchQuery, expandPrices, expandUsers, expandCredits, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a customer organization under a reseller organization
         * @summary Update Customer V1
         * @param {string} customerOrgId 
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerOrganizationV1(customerOrgId: string, organizationInput: OrganizationInput, options?: any): AxiosPromise<OrganizationOutput> {
            return ResellerCustomerApiFp(configuration).updateCustomerOrganizationV1(customerOrgId, organizationInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerCustomerApi - object-oriented interface
 * @export
 * @class ResellerCustomerApi
 * @extends {BaseAPI}
 */
export class ResellerCustomerApi extends BaseAPI {
    /**
     * Creates a new customer organization under a reseller organization
     * @summary Create Customer V1
     * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    public createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1: BodyCreateCustomerOrganizationV1, options?: any) {
        return ResellerCustomerApiFp(this.configuration).createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a reseller\'s customer and all associated data
     * @summary Delete Customer V1
     * @param {string} customerOrgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    public deleteResellerCustomerV1(customerOrgId: string, options?: any) {
        return ResellerCustomerApiFp(this.configuration).deleteResellerCustomerV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the basic credentials of a customer organization under a reseller organization.
     * @summary Get Customer Basic Credentials V1
     * @param {string} customerOrgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    public getCustomerBasicCredentialsV1(customerOrgId: string, options?: any) {
        return ResellerCustomerApiFp(this.configuration).getCustomerBasicCredentialsV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
     * @summary Get Customer Credentials V1
     * @param {string} customerOrgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    public getCustomerCredentialsV1(customerOrgId: string, options?: any) {
        return ResellerCustomerApiFp(this.configuration).getCustomerCredentialsV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get reseller customer by id
     * @summary Get Reseller Customer By Id V1
     * @param {string} customerOrgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    public getResellerCustomerByIdV1(customerOrgId: string, options?: any) {
        return ResellerCustomerApiFp(this.configuration).getResellerCustomerByIdV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List reseller customers with prices, users and credits
     * @summary List Reseller Customers V1
     * @param {string} [searchQuery] Search query
     * @param {boolean} [expandPrices] Whether to expand the prices
     * @param {boolean} [expandUsers] Whether to expand the users
     * @param {boolean} [expandCredits] Whether to expand the credits
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [updatedAfter] 
     * @param {string} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    public listResellerCustomersV1(searchQuery?: string, expandPrices?: boolean, expandUsers?: boolean, expandCredits?: boolean, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any) {
        return ResellerCustomerApiFp(this.configuration).listResellerCustomersV1(searchQuery, expandPrices, expandUsers, expandCredits, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a customer organization under a reseller organization
     * @summary Update Customer V1
     * @param {string} customerOrgId 
     * @param {OrganizationInput} organizationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    public updateCustomerOrganizationV1(customerOrgId: string, organizationInput: OrganizationInput, options?: any) {
        return ResellerCustomerApiFp(this.configuration).updateCustomerOrganizationV1(customerOrgId, organizationInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ResellerCustomerAuditLogsApi - axios parameter creator
 * @export
 */
export const ResellerCustomerAuditLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Reseller Customer Audit Logs
         * @param {string} customerOrgId 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet: async (customerOrgId: string, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/audit-logs`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerCustomerAuditLogsApi - functional programming interface
 * @export
 */
export const ResellerCustomerAuditLogsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Reseller Customer Audit Logs
         * @param {string} customerOrgId 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId: string, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await ResellerCustomerAuditLogsApiAxiosParamCreator(configuration).getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResellerCustomerAuditLogsApi - factory interface
 * @export
 */
export const ResellerCustomerAuditLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get Reseller Customer Audit Logs
         * @param {string} customerOrgId 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId: string, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return ResellerCustomerAuditLogsApiFp(configuration).getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerCustomerAuditLogsApi - object-oriented interface
 * @export
 * @class ResellerCustomerAuditLogsApi
 * @extends {BaseAPI}
 */
export class ResellerCustomerAuditLogsApi extends BaseAPI {
    /**
     * 
     * @summary Get Reseller Customer Audit Logs
     * @param {string} customerOrgId 
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [updatedAfter] 
     * @param {string} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerAuditLogsApi
     */
    public getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId: string, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any) {
        return ResellerCustomerAuditLogsApiFp(this.configuration).getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ResellerCustomerCheckoutApi - axios parameter creator
 * @export
 */
export const ResellerCustomerCheckoutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a checkout session for a reseller customer
         * @summary Create Checkout Session For Reseller Customer
         * @param {string} customerOrgId 
         * @param {string} priceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForResellerCustomerV1: async (customerOrgId: string, priceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling createCheckoutSessionForResellerCustomerV1.');
            }
            // verify required parameter 'priceId' is not null or undefined
            if (priceId === null || priceId === undefined) {
                throw new RequiredError('priceId','Required parameter priceId was null or undefined when calling createCheckoutSessionForResellerCustomerV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/pricing/{price_id}/checkout`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"price_id"}}`, encodeURIComponent(String(priceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerCustomerCheckoutApi - functional programming interface
 * @export
 */
export const ResellerCustomerCheckoutApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a checkout session for a reseller customer
         * @summary Create Checkout Session For Reseller Customer
         * @param {string} customerOrgId 
         * @param {string} priceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckoutSessionForResellerCustomerV1(customerOrgId: string, priceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await ResellerCustomerCheckoutApiAxiosParamCreator(configuration).createCheckoutSessionForResellerCustomerV1(customerOrgId, priceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResellerCustomerCheckoutApi - factory interface
 * @export
 */
export const ResellerCustomerCheckoutApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a checkout session for a reseller customer
         * @summary Create Checkout Session For Reseller Customer
         * @param {string} customerOrgId 
         * @param {string} priceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForResellerCustomerV1(customerOrgId: string, priceId: string, options?: any): AxiosPromise<string> {
            return ResellerCustomerCheckoutApiFp(configuration).createCheckoutSessionForResellerCustomerV1(customerOrgId, priceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerCustomerCheckoutApi - object-oriented interface
 * @export
 * @class ResellerCustomerCheckoutApi
 * @extends {BaseAPI}
 */
export class ResellerCustomerCheckoutApi extends BaseAPI {
    /**
     * Create a checkout session for a reseller customer
     * @summary Create Checkout Session For Reseller Customer
     * @param {string} customerOrgId 
     * @param {string} priceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerCheckoutApi
     */
    public createCheckoutSessionForResellerCustomerV1(customerOrgId: string, priceId: string, options?: any) {
        return ResellerCustomerCheckoutApiFp(this.configuration).createCheckoutSessionForResellerCustomerV1(customerOrgId, priceId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ResellerCustomerDefaultPricingApi - axios parameter creator
 * @export
 */
export const ResellerCustomerDefaultPricingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the default pricing for all customers under the reseller organization
         * @summary Get Customer Default Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerDefaultPricingV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/customers/pricing/default`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update customer default pricing
         * @summary Update Customer Default Pricing V1
         * @param {string} priceId 
         * @param {PricingRequest} pricingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerDefaultPricingV1: async (priceId: string, pricingRequest: PricingRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'priceId' is not null or undefined
            if (priceId === null || priceId === undefined) {
                throw new RequiredError('priceId','Required parameter priceId was null or undefined when calling updateCustomerDefaultPricingV1.');
            }
            // verify required parameter 'pricingRequest' is not null or undefined
            if (pricingRequest === null || pricingRequest === undefined) {
                throw new RequiredError('pricingRequest','Required parameter pricingRequest was null or undefined when calling updateCustomerDefaultPricingV1.');
            }
            const localVarPath = `/v1/resellers/customers/pricing/default/{price_id}`
                .replace(`{${"price_id"}}`, encodeURIComponent(String(priceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof pricingRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(pricingRequest !== undefined ? pricingRequest : {}) : (pricingRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerCustomerDefaultPricingApi - functional programming interface
 * @export
 */
export const ResellerCustomerDefaultPricingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get the default pricing for all customers under the reseller organization
         * @summary Get Customer Default Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerDefaultPricingV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Price>>> {
            const localVarAxiosArgs = await ResellerCustomerDefaultPricingApiAxiosParamCreator(configuration).getCustomerDefaultPricingV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update customer default pricing
         * @summary Update Customer Default Pricing V1
         * @param {string} priceId 
         * @param {PricingRequest} pricingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomerDefaultPricingV1(priceId: string, pricingRequest: PricingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Price>> {
            const localVarAxiosArgs = await ResellerCustomerDefaultPricingApiAxiosParamCreator(configuration).updateCustomerDefaultPricingV1(priceId, pricingRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResellerCustomerDefaultPricingApi - factory interface
 * @export
 */
export const ResellerCustomerDefaultPricingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get the default pricing for all customers under the reseller organization
         * @summary Get Customer Default Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerDefaultPricingV1(options?: any): AxiosPromise<Array<Price>> {
            return ResellerCustomerDefaultPricingApiFp(configuration).getCustomerDefaultPricingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Update customer default pricing
         * @summary Update Customer Default Pricing V1
         * @param {string} priceId 
         * @param {PricingRequest} pricingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerDefaultPricingV1(priceId: string, pricingRequest: PricingRequest, options?: any): AxiosPromise<Price> {
            return ResellerCustomerDefaultPricingApiFp(configuration).updateCustomerDefaultPricingV1(priceId, pricingRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerCustomerDefaultPricingApi - object-oriented interface
 * @export
 * @class ResellerCustomerDefaultPricingApi
 * @extends {BaseAPI}
 */
export class ResellerCustomerDefaultPricingApi extends BaseAPI {
    /**
     * Get the default pricing for all customers under the reseller organization
     * @summary Get Customer Default Pricing V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerDefaultPricingApi
     */
    public getCustomerDefaultPricingV1(options?: any) {
        return ResellerCustomerDefaultPricingApiFp(this.configuration).getCustomerDefaultPricingV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update customer default pricing
     * @summary Update Customer Default Pricing V1
     * @param {string} priceId 
     * @param {PricingRequest} pricingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerDefaultPricingApi
     */
    public updateCustomerDefaultPricingV1(priceId: string, pricingRequest: PricingRequest, options?: any) {
        return ResellerCustomerDefaultPricingApiFp(this.configuration).updateCustomerDefaultPricingV1(priceId, pricingRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ResellerCustomerPortalApi - axios parameter creator
 * @export
 */
export const ResellerCustomerPortalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a customer portal for a reseller customer
         * @summary Create Customer Portal For Reseller Customer
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPortalForResellerCustomerV1: async (customerOrgId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling createCustomerPortalForResellerCustomerV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/portal`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerCustomerPortalApi - functional programming interface
 * @export
 */
export const ResellerCustomerPortalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a customer portal for a reseller customer
         * @summary Create Customer Portal For Reseller Customer
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomerPortalForResellerCustomerV1(customerOrgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await ResellerCustomerPortalApiAxiosParamCreator(configuration).createCustomerPortalForResellerCustomerV1(customerOrgId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResellerCustomerPortalApi - factory interface
 * @export
 */
export const ResellerCustomerPortalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a customer portal for a reseller customer
         * @summary Create Customer Portal For Reseller Customer
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPortalForResellerCustomerV1(customerOrgId: string, options?: any): AxiosPromise<string> {
            return ResellerCustomerPortalApiFp(configuration).createCustomerPortalForResellerCustomerV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerCustomerPortalApi - object-oriented interface
 * @export
 * @class ResellerCustomerPortalApi
 * @extends {BaseAPI}
 */
export class ResellerCustomerPortalApi extends BaseAPI {
    /**
     * Create a customer portal for a reseller customer
     * @summary Create Customer Portal For Reseller Customer
     * @param {string} customerOrgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerPortalApi
     */
    public createCustomerPortalForResellerCustomerV1(customerOrgId: string, options?: any) {
        return ResellerCustomerPortalApiFp(this.configuration).createCustomerPortalForResellerCustomerV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ResellerCustomerPricingApi - axios parameter creator
 * @export
 */
export const ResellerCustomerPricingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Override pricing for customer
         * @summary Create Customer Pricing V1
         * @param {string} customerOrgId 
         * @param {PricingRequest} pricingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPricingV1: async (customerOrgId: string, pricingRequest: PricingRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling createCustomerPricingV1.');
            }
            // verify required parameter 'pricingRequest' is not null or undefined
            if (pricingRequest === null || pricingRequest === undefined) {
                throw new RequiredError('pricingRequest','Required parameter pricingRequest was null or undefined when calling createCustomerPricingV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/pricing`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof pricingRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(pricingRequest !== undefined ? pricingRequest : {}) : (pricingRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get resellers customer credits
         * @summary Get Reseller Customer Credits V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerCreditsV1: async (customerOrgId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling getResellerCustomerCreditsV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/credits`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get resellers customer pricing
         * @summary Get Reseller Customer Pricing V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerPricingV1: async (customerOrgId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling getResellerCustomerPricingV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/pricing`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update customer pricing
         * @summary Update Customer Pricing V1
         * @param {string} customerOrgId 
         * @param {string} priceId 
         * @param {PricingRequest} pricingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerPricingV1: async (customerOrgId: string, priceId: string, pricingRequest: PricingRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling updateCustomerPricingV1.');
            }
            // verify required parameter 'priceId' is not null or undefined
            if (priceId === null || priceId === undefined) {
                throw new RequiredError('priceId','Required parameter priceId was null or undefined when calling updateCustomerPricingV1.');
            }
            // verify required parameter 'pricingRequest' is not null or undefined
            if (pricingRequest === null || pricingRequest === undefined) {
                throw new RequiredError('pricingRequest','Required parameter pricingRequest was null or undefined when calling updateCustomerPricingV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/pricing/{price_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"price_id"}}`, encodeURIComponent(String(priceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof pricingRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(pricingRequest !== undefined ? pricingRequest : {}) : (pricingRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerCustomerPricingApi - functional programming interface
 * @export
 */
export const ResellerCustomerPricingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Override pricing for customer
         * @summary Create Customer Pricing V1
         * @param {string} customerOrgId 
         * @param {PricingRequest} pricingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomerPricingV1(customerOrgId: string, pricingRequest: PricingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Price>> {
            const localVarAxiosArgs = await ResellerCustomerPricingApiAxiosParamCreator(configuration).createCustomerPricingV1(customerOrgId, pricingRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get resellers customer credits
         * @summary Get Reseller Customer Credits V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerCustomerCreditsV1(customerOrgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Credit>>> {
            const localVarAxiosArgs = await ResellerCustomerPricingApiAxiosParamCreator(configuration).getResellerCustomerCreditsV1(customerOrgId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get resellers customer pricing
         * @summary Get Reseller Customer Pricing V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerCustomerPricingV1(customerOrgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Price>>> {
            const localVarAxiosArgs = await ResellerCustomerPricingApiAxiosParamCreator(configuration).getResellerCustomerPricingV1(customerOrgId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update customer pricing
         * @summary Update Customer Pricing V1
         * @param {string} customerOrgId 
         * @param {string} priceId 
         * @param {PricingRequest} pricingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomerPricingV1(customerOrgId: string, priceId: string, pricingRequest: PricingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Price>> {
            const localVarAxiosArgs = await ResellerCustomerPricingApiAxiosParamCreator(configuration).updateCustomerPricingV1(customerOrgId, priceId, pricingRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResellerCustomerPricingApi - factory interface
 * @export
 */
export const ResellerCustomerPricingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Override pricing for customer
         * @summary Create Customer Pricing V1
         * @param {string} customerOrgId 
         * @param {PricingRequest} pricingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPricingV1(customerOrgId: string, pricingRequest: PricingRequest, options?: any): AxiosPromise<Price> {
            return ResellerCustomerPricingApiFp(configuration).createCustomerPricingV1(customerOrgId, pricingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get resellers customer credits
         * @summary Get Reseller Customer Credits V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerCreditsV1(customerOrgId: string, options?: any): AxiosPromise<Array<Credit>> {
            return ResellerCustomerPricingApiFp(configuration).getResellerCustomerCreditsV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get resellers customer pricing
         * @summary Get Reseller Customer Pricing V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerPricingV1(customerOrgId: string, options?: any): AxiosPromise<Array<Price>> {
            return ResellerCustomerPricingApiFp(configuration).getResellerCustomerPricingV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update customer pricing
         * @summary Update Customer Pricing V1
         * @param {string} customerOrgId 
         * @param {string} priceId 
         * @param {PricingRequest} pricingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerPricingV1(customerOrgId: string, priceId: string, pricingRequest: PricingRequest, options?: any): AxiosPromise<Price> {
            return ResellerCustomerPricingApiFp(configuration).updateCustomerPricingV1(customerOrgId, priceId, pricingRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerCustomerPricingApi - object-oriented interface
 * @export
 * @class ResellerCustomerPricingApi
 * @extends {BaseAPI}
 */
export class ResellerCustomerPricingApi extends BaseAPI {
    /**
     * Override pricing for customer
     * @summary Create Customer Pricing V1
     * @param {string} customerOrgId 
     * @param {PricingRequest} pricingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerPricingApi
     */
    public createCustomerPricingV1(customerOrgId: string, pricingRequest: PricingRequest, options?: any) {
        return ResellerCustomerPricingApiFp(this.configuration).createCustomerPricingV1(customerOrgId, pricingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get resellers customer credits
     * @summary Get Reseller Customer Credits V1
     * @param {string} customerOrgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerPricingApi
     */
    public getResellerCustomerCreditsV1(customerOrgId: string, options?: any) {
        return ResellerCustomerPricingApiFp(this.configuration).getResellerCustomerCreditsV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get resellers customer pricing
     * @summary Get Reseller Customer Pricing V1
     * @param {string} customerOrgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerPricingApi
     */
    public getResellerCustomerPricingV1(customerOrgId: string, options?: any) {
        return ResellerCustomerPricingApiFp(this.configuration).getResellerCustomerPricingV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update customer pricing
     * @summary Update Customer Pricing V1
     * @param {string} customerOrgId 
     * @param {string} priceId 
     * @param {PricingRequest} pricingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerPricingApi
     */
    public updateCustomerPricingV1(customerOrgId: string, priceId: string, pricingRequest: PricingRequest, options?: any) {
        return ResellerCustomerPricingApiFp(this.configuration).updateCustomerPricingV1(customerOrgId, priceId, pricingRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ResellerCustomerUserApi - axios parameter creator
 * @export
 */
export const ResellerCustomerUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete reseller customer user
         * @summary Delete Reseller Customer User V1
         * @param {string} customerOrgId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerCustomerUserV1: async (customerOrgId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling deleteResellerCustomerUserV1.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteResellerCustomerUserV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/users/{user_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get resellers customer users and invites by id
         * @summary Get Reseller Customer User And Invites V1
         * @param {string} customerOrgId 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerUserAndInvitesV1: async (customerOrgId: string, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling getResellerCustomerUserAndInvitesV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/users_and_invites`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get resellers customer user by id
         * @summary Get Reseller Customer User By Id V1
         * @param {string} customerOrgId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerUserByIdV1: async (customerOrgId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling getResellerCustomerUserByIdV1.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getResellerCustomerUserByIdV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/users/{user_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all invites for a customer organization
         * @summary List Customer Invites V1
         * @param {string} customerOrgId 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomerInvitesV1: async (customerOrgId: string, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling listCustomerInvitesV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/invites`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List resellers customer users
         * @summary List Reseller Customer Users V1
         * @param {string} customerOrgId 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerCustomerUsersV1: async (customerOrgId: string, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling listResellerCustomerUsersV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/users`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke an invite for a customer organization
         * @summary Revoke Customer Invite V1
         * @param {string} customerOrgId 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCustomerInviteV1: async (customerOrgId: string, email: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling revokeCustomerInviteV1.');
            }
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling revokeCustomerInviteV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/invites/{email}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send invite to a user on behalf of a customer organization
         * @summary Invite Customer Users V1
         * @param {string} customerOrgId 
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCustomerUserInviteV1: async (customerOrgId: string, guestInput: GuestInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling sendCustomerUserInviteV1.');
            }
            // verify required parameter 'guestInput' is not null or undefined
            if (guestInput === null || guestInput === undefined) {
                throw new RequiredError('guestInput','Required parameter guestInput was null or undefined when calling sendCustomerUserInviteV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/invites`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof guestInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(guestInput !== undefined ? guestInput : {}) : (guestInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update reseller customer user
         * @summary Update Reseller Customer User V1
         * @param {string} customerOrgId 
         * @param {string} userId 
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerCustomerUserV1: async (customerOrgId: string, userId: string, updateUserRequest: UpdateUserRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling updateResellerCustomerUserV1.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateResellerCustomerUserV1.');
            }
            // verify required parameter 'updateUserRequest' is not null or undefined
            if (updateUserRequest === null || updateUserRequest === undefined) {
                throw new RequiredError('updateUserRequest','Required parameter updateUserRequest was null or undefined when calling updateResellerCustomerUserV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/users/{user_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateUserRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateUserRequest !== undefined ? updateUserRequest : {}) : (updateUserRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerCustomerUserApi - functional programming interface
 * @export
 */
export const ResellerCustomerUserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete reseller customer user
         * @summary Delete Reseller Customer User V1
         * @param {string} customerOrgId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResellerCustomerUserV1(customerOrgId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ResellerCustomerUserApiAxiosParamCreator(configuration).deleteResellerCustomerUserV1(customerOrgId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get resellers customer users and invites by id
         * @summary Get Reseller Customer User And Invites V1
         * @param {string} customerOrgId 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerCustomerUserAndInvitesV1(customerOrgId: string, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await ResellerCustomerUserApiAxiosParamCreator(configuration).getResellerCustomerUserAndInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get resellers customer user by id
         * @summary Get Reseller Customer User By Id V1
         * @param {string} customerOrgId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerCustomerUserByIdV1(customerOrgId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await ResellerCustomerUserApiAxiosParamCreator(configuration).getResellerCustomerUserByIdV1(customerOrgId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all invites for a customer organization
         * @summary List Customer Invites V1
         * @param {string} customerOrgId 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCustomerInvitesV1(customerOrgId: string, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuestOutput>>> {
            const localVarAxiosArgs = await ResellerCustomerUserApiAxiosParamCreator(configuration).listCustomerInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List resellers customer users
         * @summary List Reseller Customer Users V1
         * @param {string} customerOrgId 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResellerCustomerUsersV1(customerOrgId: string, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await ResellerCustomerUserApiAxiosParamCreator(configuration).listResellerCustomerUsersV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Revoke an invite for a customer organization
         * @summary Revoke Customer Invite V1
         * @param {string} customerOrgId 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeCustomerInviteV1(customerOrgId: string, email: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ResellerCustomerUserApiAxiosParamCreator(configuration).revokeCustomerInviteV1(customerOrgId, email, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Send invite to a user on behalf of a customer organization
         * @summary Invite Customer Users V1
         * @param {string} customerOrgId 
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendCustomerUserInviteV1(customerOrgId: string, guestInput: GuestInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ResellerCustomerUserApiAxiosParamCreator(configuration).sendCustomerUserInviteV1(customerOrgId, guestInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update reseller customer user
         * @summary Update Reseller Customer User V1
         * @param {string} customerOrgId 
         * @param {string} userId 
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResellerCustomerUserV1(customerOrgId: string, userId: string, updateUserRequest: UpdateUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await ResellerCustomerUserApiAxiosParamCreator(configuration).updateResellerCustomerUserV1(customerOrgId, userId, updateUserRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResellerCustomerUserApi - factory interface
 * @export
 */
export const ResellerCustomerUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete reseller customer user
         * @summary Delete Reseller Customer User V1
         * @param {string} customerOrgId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerCustomerUserV1(customerOrgId: string, userId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ResellerCustomerUserApiFp(configuration).deleteResellerCustomerUserV1(customerOrgId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get resellers customer users and invites by id
         * @summary Get Reseller Customer User And Invites V1
         * @param {string} customerOrgId 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerUserAndInvitesV1(customerOrgId: string, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): AxiosPromise<Array<User>> {
            return ResellerCustomerUserApiFp(configuration).getResellerCustomerUserAndInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Get resellers customer user by id
         * @summary Get Reseller Customer User By Id V1
         * @param {string} customerOrgId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerUserByIdV1(customerOrgId: string, userId: string, options?: any): AxiosPromise<User> {
            return ResellerCustomerUserApiFp(configuration).getResellerCustomerUserByIdV1(customerOrgId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all invites for a customer organization
         * @summary List Customer Invites V1
         * @param {string} customerOrgId 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomerInvitesV1(customerOrgId: string, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): AxiosPromise<Array<GuestOutput>> {
            return ResellerCustomerUserApiFp(configuration).listCustomerInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * List resellers customer users
         * @summary List Reseller Customer Users V1
         * @param {string} customerOrgId 
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerCustomerUsersV1(customerOrgId: string, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): AxiosPromise<Array<User>> {
            return ResellerCustomerUserApiFp(configuration).listResellerCustomerUsersV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke an invite for a customer organization
         * @summary Revoke Customer Invite V1
         * @param {string} customerOrgId 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCustomerInviteV1(customerOrgId: string, email: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ResellerCustomerUserApiFp(configuration).revokeCustomerInviteV1(customerOrgId, email, options).then((request) => request(axios, basePath));
        },
        /**
         * Send invite to a user on behalf of a customer organization
         * @summary Invite Customer Users V1
         * @param {string} customerOrgId 
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCustomerUserInviteV1(customerOrgId: string, guestInput: GuestInput, options?: any): AxiosPromise<BaseResponseInput> {
            return ResellerCustomerUserApiFp(configuration).sendCustomerUserInviteV1(customerOrgId, guestInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update reseller customer user
         * @summary Update Reseller Customer User V1
         * @param {string} customerOrgId 
         * @param {string} userId 
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerCustomerUserV1(customerOrgId: string, userId: string, updateUserRequest: UpdateUserRequest, options?: any): AxiosPromise<User> {
            return ResellerCustomerUserApiFp(configuration).updateResellerCustomerUserV1(customerOrgId, userId, updateUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerCustomerUserApi - object-oriented interface
 * @export
 * @class ResellerCustomerUserApi
 * @extends {BaseAPI}
 */
export class ResellerCustomerUserApi extends BaseAPI {
    /**
     * Delete reseller customer user
     * @summary Delete Reseller Customer User V1
     * @param {string} customerOrgId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    public deleteResellerCustomerUserV1(customerOrgId: string, userId: string, options?: any) {
        return ResellerCustomerUserApiFp(this.configuration).deleteResellerCustomerUserV1(customerOrgId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get resellers customer users and invites by id
     * @summary Get Reseller Customer User And Invites V1
     * @param {string} customerOrgId 
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [updatedAfter] 
     * @param {string} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    public getResellerCustomerUserAndInvitesV1(customerOrgId: string, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any) {
        return ResellerCustomerUserApiFp(this.configuration).getResellerCustomerUserAndInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get resellers customer user by id
     * @summary Get Reseller Customer User By Id V1
     * @param {string} customerOrgId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    public getResellerCustomerUserByIdV1(customerOrgId: string, userId: string, options?: any) {
        return ResellerCustomerUserApiFp(this.configuration).getResellerCustomerUserByIdV1(customerOrgId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all invites for a customer organization
     * @summary List Customer Invites V1
     * @param {string} customerOrgId 
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [updatedAfter] 
     * @param {string} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    public listCustomerInvitesV1(customerOrgId: string, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any) {
        return ResellerCustomerUserApiFp(this.configuration).listCustomerInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List resellers customer users
     * @summary List Reseller Customer Users V1
     * @param {string} customerOrgId 
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [updatedAfter] 
     * @param {string} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    public listResellerCustomerUsersV1(customerOrgId: string, searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any) {
        return ResellerCustomerUserApiFp(this.configuration).listResellerCustomerUsersV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke an invite for a customer organization
     * @summary Revoke Customer Invite V1
     * @param {string} customerOrgId 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    public revokeCustomerInviteV1(customerOrgId: string, email: string, options?: any) {
        return ResellerCustomerUserApiFp(this.configuration).revokeCustomerInviteV1(customerOrgId, email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send invite to a user on behalf of a customer organization
     * @summary Invite Customer Users V1
     * @param {string} customerOrgId 
     * @param {GuestInput} guestInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    public sendCustomerUserInviteV1(customerOrgId: string, guestInput: GuestInput, options?: any) {
        return ResellerCustomerUserApiFp(this.configuration).sendCustomerUserInviteV1(customerOrgId, guestInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update reseller customer user
     * @summary Update Reseller Customer User V1
     * @param {string} customerOrgId 
     * @param {string} userId 
     * @param {UpdateUserRequest} updateUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    public updateResellerCustomerUserV1(customerOrgId: string, userId: string, updateUserRequest: UpdateUserRequest, options?: any) {
        return ResellerCustomerUserApiFp(this.configuration).updateResellerCustomerUserV1(customerOrgId, userId, updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ResellerFilesApi - axios parameter creator
 * @export
 */
export const ResellerFilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete files from Trata reseller account
         * @summary Delete Files
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerFilesV1: async (fileIds: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileIds' is not null or undefined
            if (fileIds === null || fileIds === undefined) {
                throw new RequiredError('fileIds','Required parameter fileIds was null or undefined when calling deleteResellerFilesV1.');
            }
            const localVarPath = `/v1/resellers/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (fileIds !== undefined) {
                localVarQueryParameter['file_ids'] = fileIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadResellerFilesV1: async (files: Array<any>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'files' is not null or undefined
            if (files === null || files === undefined) {
                throw new RequiredError('files','Required parameter files was null or undefined when calling uploadResellerFilesV1.');
            }
            const localVarPath = `/v1/resellers/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (files) {
            
                localVarFormParams.append('files', files.join(COLLECTION_FORMATS.csv));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerFilesApi - functional programming interface
 * @export
 */
export const ResellerFilesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete files from Trata reseller account
         * @summary Delete Files
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResellerFilesV1(fileIds: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await ResellerFilesApiAxiosParamCreator(configuration).deleteResellerFilesV1(fileIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadResellerFilesV1(files: Array<any>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Files>>> {
            const localVarAxiosArgs = await ResellerFilesApiAxiosParamCreator(configuration).uploadResellerFilesV1(files, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResellerFilesApi - factory interface
 * @export
 */
export const ResellerFilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete files from Trata reseller account
         * @summary Delete Files
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerFilesV1(fileIds: string, options?: any): AxiosPromise<boolean> {
            return ResellerFilesApiFp(configuration).deleteResellerFilesV1(fileIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadResellerFilesV1(files: Array<any>, options?: any): AxiosPromise<Array<Files>> {
            return ResellerFilesApiFp(configuration).uploadResellerFilesV1(files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerFilesApi - object-oriented interface
 * @export
 * @class ResellerFilesApi
 * @extends {BaseAPI}
 */
export class ResellerFilesApi extends BaseAPI {
    /**
     * Delete files from Trata reseller account
     * @summary Delete Files
     * @param {string} fileIds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerFilesApi
     */
    public deleteResellerFilesV1(fileIds: string, options?: any) {
        return ResellerFilesApiFp(this.configuration).deleteResellerFilesV1(fileIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload file to Trata account to use in AI Agents
     * @summary Upload Files
     * @param {Array<any>} files 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerFilesApi
     */
    public uploadResellerFilesV1(files: Array<any>, options?: any) {
        return ResellerFilesApiFp(this.configuration).uploadResellerFilesV1(files, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ResellerMetricsApi - axios parameter creator
 * @export
 */
export const ResellerMetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get analytics data for Reseller
         * @summary Get Reseller Metrics
         * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerMetricsV1: async (resellerBatchMetricsRequests: ResellerBatchMetricsRequests, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resellerBatchMetricsRequests' is not null or undefined
            if (resellerBatchMetricsRequests === null || resellerBatchMetricsRequests === undefined) {
                throw new RequiredError('resellerBatchMetricsRequests','Required parameter resellerBatchMetricsRequests was null or undefined when calling getResellerMetricsV1.');
            }
            const localVarPath = `/v1/resellers/metrics`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof resellerBatchMetricsRequests !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(resellerBatchMetricsRequests !== undefined ? resellerBatchMetricsRequests : {}) : (resellerBatchMetricsRequests || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerMetricsApi - functional programming interface
 * @export
 */
export const ResellerMetricsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get analytics data for Reseller
         * @summary Get Reseller Metrics
         * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerMetricsV1(resellerBatchMetricsRequests: ResellerBatchMetricsRequests, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchMetricsResponseInput>> {
            const localVarAxiosArgs = await ResellerMetricsApiAxiosParamCreator(configuration).getResellerMetricsV1(resellerBatchMetricsRequests, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResellerMetricsApi - factory interface
 * @export
 */
export const ResellerMetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get analytics data for Reseller
         * @summary Get Reseller Metrics
         * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerMetricsV1(resellerBatchMetricsRequests: ResellerBatchMetricsRequests, options?: any): AxiosPromise<BatchMetricsResponseInput> {
            return ResellerMetricsApiFp(configuration).getResellerMetricsV1(resellerBatchMetricsRequests, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerMetricsApi - object-oriented interface
 * @export
 * @class ResellerMetricsApi
 * @extends {BaseAPI}
 */
export class ResellerMetricsApi extends BaseAPI {
    /**
     * Get analytics data for Reseller
     * @summary Get Reseller Metrics
     * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerMetricsApi
     */
    public getResellerMetricsV1(resellerBatchMetricsRequests: ResellerBatchMetricsRequests, options?: any) {
        return ResellerMetricsApiFp(this.configuration).getResellerMetricsV1(resellerBatchMetricsRequests, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ResellerOrganizationApi - axios parameter creator
 * @export
 */
export const ResellerOrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
         * @summary Create Reseller Organization V1
         * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResellerOrganizationV1: async (bodyCreateResellerOrganizationV1: BodyCreateResellerOrganizationV1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateResellerOrganizationV1' is not null or undefined
            if (bodyCreateResellerOrganizationV1 === null || bodyCreateResellerOrganizationV1 === undefined) {
                throw new RequiredError('bodyCreateResellerOrganizationV1','Required parameter bodyCreateResellerOrganizationV1 was null or undefined when calling createResellerOrganizationV1.');
            }
            const localVarPath = `/v1/resellers/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyCreateResellerOrganizationV1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyCreateResellerOrganizationV1 !== undefined ? bodyCreateResellerOrganizationV1 : {}) : (bodyCreateResellerOrganizationV1 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a reseller organization
         * @summary Delete Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerOrganizationV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a reseller organization by id
         * @summary Get Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerOrganizationV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a reseller organization
         * @summary Update Reseller Organization V1
         * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerOrganizationV1: async (updateResellerOrganizationRequest: UpdateResellerOrganizationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateResellerOrganizationRequest' is not null or undefined
            if (updateResellerOrganizationRequest === null || updateResellerOrganizationRequest === undefined) {
                throw new RequiredError('updateResellerOrganizationRequest','Required parameter updateResellerOrganizationRequest was null or undefined when calling updateResellerOrganizationV1.');
            }
            const localVarPath = `/v1/resellers/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateResellerOrganizationRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateResellerOrganizationRequest !== undefined ? updateResellerOrganizationRequest : {}) : (updateResellerOrganizationRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerOrganizationApi - functional programming interface
 * @export
 */
export const ResellerOrganizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
         * @summary Create Reseller Organization V1
         * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResellerOrganizationV1(bodyCreateResellerOrganizationV1: BodyCreateResellerOrganizationV1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await ResellerOrganizationApiAxiosParamCreator(configuration).createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a reseller organization
         * @summary Delete Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResellerOrganizationV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ResellerOrganizationApiAxiosParamCreator(configuration).deleteResellerOrganizationV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a reseller organization by id
         * @summary Get Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerOrganizationV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgWithUsers>> {
            const localVarAxiosArgs = await ResellerOrganizationApiAxiosParamCreator(configuration).getResellerOrganizationV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a reseller organization
         * @summary Update Reseller Organization V1
         * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResellerOrganizationV1(updateResellerOrganizationRequest: UpdateResellerOrganizationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationOutput>> {
            const localVarAxiosArgs = await ResellerOrganizationApiAxiosParamCreator(configuration).updateResellerOrganizationV1(updateResellerOrganizationRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResellerOrganizationApi - factory interface
 * @export
 */
export const ResellerOrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
         * @summary Create Reseller Organization V1
         * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResellerOrganizationV1(bodyCreateResellerOrganizationV1: BodyCreateResellerOrganizationV1, options?: any): AxiosPromise<User> {
            return ResellerOrganizationApiFp(configuration).createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a reseller organization
         * @summary Delete Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerOrganizationV1(options?: any): AxiosPromise<BaseResponseInput> {
            return ResellerOrganizationApiFp(configuration).deleteResellerOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a reseller organization by id
         * @summary Get Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerOrganizationV1(options?: any): AxiosPromise<OrgWithUsers> {
            return ResellerOrganizationApiFp(configuration).getResellerOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a reseller organization
         * @summary Update Reseller Organization V1
         * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerOrganizationV1(updateResellerOrganizationRequest: UpdateResellerOrganizationRequest, options?: any): AxiosPromise<OrganizationOutput> {
            return ResellerOrganizationApiFp(configuration).updateResellerOrganizationV1(updateResellerOrganizationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerOrganizationApi - object-oriented interface
 * @export
 * @class ResellerOrganizationApi
 * @extends {BaseAPI}
 */
export class ResellerOrganizationApi extends BaseAPI {
    /**
     * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
     * @summary Create Reseller Organization V1
     * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerOrganizationApi
     */
    public createResellerOrganizationV1(bodyCreateResellerOrganizationV1: BodyCreateResellerOrganizationV1, options?: any) {
        return ResellerOrganizationApiFp(this.configuration).createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a reseller organization
     * @summary Delete Reseller Organization V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerOrganizationApi
     */
    public deleteResellerOrganizationV1(options?: any) {
        return ResellerOrganizationApiFp(this.configuration).deleteResellerOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a reseller organization by id
     * @summary Get Reseller Organization V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerOrganizationApi
     */
    public getResellerOrganizationV1(options?: any) {
        return ResellerOrganizationApiFp(this.configuration).getResellerOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a reseller organization
     * @summary Update Reseller Organization V1
     * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerOrganizationApi
     */
    public updateResellerOrganizationV1(updateResellerOrganizationRequest: UpdateResellerOrganizationRequest, options?: any) {
        return ResellerOrganizationApiFp(this.configuration).updateResellerOrganizationV1(updateResellerOrganizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ResellerPricingApi - axios parameter creator
 * @export
 */
export const ResellerPricingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new account link to the reseller organization
         * @summary Add Stripe Account Link To Reseller Org
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addStripeAccountLinkToResellerOrgV1: async (code: string, state: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling addStripeAccountLinkToResellerOrgV1.');
            }
            // verify required parameter 'state' is not null or undefined
            if (state === null || state === undefined) {
                throw new RequiredError('state','Required parameter state was null or undefined when calling addStripeAccountLinkToResellerOrgV1.');
            }
            const localVarPath = `/v1/resellers/stripe-account/link`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new account link URL for the reseller
         * @summary Create Stripe Account Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStripeAccountLinkV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/stripe-account/connect-link`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stripe account details
         * @summary Get Stripe Account Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripeAccountDetailsV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/stripe-account`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disconnect reseller stripe account connection
         * @summary Revoke Stripe Connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeDisconnectV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/stripe-account`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerPricingApi - functional programming interface
 * @export
 */
export const ResellerPricingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new account link to the reseller organization
         * @summary Add Stripe Account Link To Reseller Org
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addStripeAccountLinkToResellerOrgV1(code: string, state: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ResellerPricingApiAxiosParamCreator(configuration).addStripeAccountLinkToResellerOrgV1(code, state, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new account link URL for the reseller
         * @summary Create Stripe Account Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStripeAccountLinkV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await ResellerPricingApiAxiosParamCreator(configuration).createStripeAccountLinkV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get stripe account details
         * @summary Get Stripe Account Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStripeAccountDetailsV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResellerPaymentAccountDetails>> {
            const localVarAxiosArgs = await ResellerPricingApiAxiosParamCreator(configuration).getStripeAccountDetailsV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Disconnect reseller stripe account connection
         * @summary Revoke Stripe Connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeDisconnectV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await ResellerPricingApiAxiosParamCreator(configuration).stripeDisconnectV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResellerPricingApi - factory interface
 * @export
 */
export const ResellerPricingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adds a new account link to the reseller organization
         * @summary Add Stripe Account Link To Reseller Org
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addStripeAccountLinkToResellerOrgV1(code: string, state: string, options?: any): AxiosPromise<BaseResponseInput> {
            return ResellerPricingApiFp(configuration).addStripeAccountLinkToResellerOrgV1(code, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new account link URL for the reseller
         * @summary Create Stripe Account Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStripeAccountLinkV1(options?: any): AxiosPromise<string> {
            return ResellerPricingApiFp(configuration).createStripeAccountLinkV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get stripe account details
         * @summary Get Stripe Account Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripeAccountDetailsV1(options?: any): AxiosPromise<ResellerPaymentAccountDetails> {
            return ResellerPricingApiFp(configuration).getStripeAccountDetailsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Disconnect reseller stripe account connection
         * @summary Revoke Stripe Connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeDisconnectV1(options?: any): AxiosPromise<BaseResponseInput> {
            return ResellerPricingApiFp(configuration).stripeDisconnectV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerPricingApi - object-oriented interface
 * @export
 * @class ResellerPricingApi
 * @extends {BaseAPI}
 */
export class ResellerPricingApi extends BaseAPI {
    /**
     * Adds a new account link to the reseller organization
     * @summary Add Stripe Account Link To Reseller Org
     * @param {string} code 
     * @param {string} state 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerPricingApi
     */
    public addStripeAccountLinkToResellerOrgV1(code: string, state: string, options?: any) {
        return ResellerPricingApiFp(this.configuration).addStripeAccountLinkToResellerOrgV1(code, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new account link URL for the reseller
     * @summary Create Stripe Account Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerPricingApi
     */
    public createStripeAccountLinkV1(options?: any) {
        return ResellerPricingApiFp(this.configuration).createStripeAccountLinkV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stripe account details
     * @summary Get Stripe Account Details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerPricingApi
     */
    public getStripeAccountDetailsV1(options?: any) {
        return ResellerPricingApiFp(this.configuration).getStripeAccountDetailsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disconnect reseller stripe account connection
     * @summary Revoke Stripe Connection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerPricingApi
     */
    public stripeDisconnectV1(options?: any) {
        return ResellerPricingApiFp(this.configuration).stripeDisconnectV1(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ResellerSettingsApi - axios parameter creator
 * @export
 */
export const ResellerSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add Reseller settings
         * @summary Organization Settings V1
         * @param {OrganizationSettings} organizationSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResellerSettingsV1: async (organizationSettings: OrganizationSettings, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSettings' is not null or undefined
            if (organizationSettings === null || organizationSettings === undefined) {
                throw new RequiredError('organizationSettings','Required parameter organizationSettings was null or undefined when calling addResellerSettingsV1.');
            }
            const localVarPath = `/v1/resellers/settings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof organizationSettings !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(organizationSettings !== undefined ? organizationSettings : {}) : (organizationSettings || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization settings
         * @summary Get Organization Settings V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSettingsV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/settings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update organization settings
         * @summary Organization Settings Update V1
         * @param {OrganizationSettings} organizationSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerSettingsV1: async (organizationSettings: OrganizationSettings, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSettings' is not null or undefined
            if (organizationSettings === null || organizationSettings === undefined) {
                throw new RequiredError('organizationSettings','Required parameter organizationSettings was null or undefined when calling updateResellerSettingsV1.');
            }
            const localVarPath = `/v1/resellers/settings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof organizationSettings !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(organizationSettings !== undefined ? organizationSettings : {}) : (organizationSettings || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerSettingsApi - functional programming interface
 * @export
 */
export const ResellerSettingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add Reseller settings
         * @summary Organization Settings V1
         * @param {OrganizationSettings} organizationSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addResellerSettingsV1(organizationSettings: OrganizationSettings, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSettings>> {
            const localVarAxiosArgs = await ResellerSettingsApiAxiosParamCreator(configuration).addResellerSettingsV1(organizationSettings, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get organization settings
         * @summary Get Organization Settings V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationSettingsV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSettings>> {
            const localVarAxiosArgs = await ResellerSettingsApiAxiosParamCreator(configuration).getOrganizationSettingsV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update organization settings
         * @summary Organization Settings Update V1
         * @param {OrganizationSettings} organizationSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResellerSettingsV1(organizationSettings: OrganizationSettings, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSettings>> {
            const localVarAxiosArgs = await ResellerSettingsApiAxiosParamCreator(configuration).updateResellerSettingsV1(organizationSettings, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResellerSettingsApi - factory interface
 * @export
 */
export const ResellerSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Add Reseller settings
         * @summary Organization Settings V1
         * @param {OrganizationSettings} organizationSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResellerSettingsV1(organizationSettings: OrganizationSettings, options?: any): AxiosPromise<OrganizationSettings> {
            return ResellerSettingsApiFp(configuration).addResellerSettingsV1(organizationSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization settings
         * @summary Get Organization Settings V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSettingsV1(options?: any): AxiosPromise<OrganizationSettings> {
            return ResellerSettingsApiFp(configuration).getOrganizationSettingsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Update organization settings
         * @summary Organization Settings Update V1
         * @param {OrganizationSettings} organizationSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerSettingsV1(organizationSettings: OrganizationSettings, options?: any): AxiosPromise<OrganizationSettings> {
            return ResellerSettingsApiFp(configuration).updateResellerSettingsV1(organizationSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerSettingsApi - object-oriented interface
 * @export
 * @class ResellerSettingsApi
 * @extends {BaseAPI}
 */
export class ResellerSettingsApi extends BaseAPI {
    /**
     * Add Reseller settings
     * @summary Organization Settings V1
     * @param {OrganizationSettings} organizationSettings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerSettingsApi
     */
    public addResellerSettingsV1(organizationSettings: OrganizationSettings, options?: any) {
        return ResellerSettingsApiFp(this.configuration).addResellerSettingsV1(organizationSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization settings
     * @summary Get Organization Settings V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerSettingsApi
     */
    public getOrganizationSettingsV1(options?: any) {
        return ResellerSettingsApiFp(this.configuration).getOrganizationSettingsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update organization settings
     * @summary Organization Settings Update V1
     * @param {OrganizationSettings} organizationSettings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerSettingsApi
     */
    public updateResellerSettingsV1(organizationSettings: OrganizationSettings, options?: any) {
        return ResellerSettingsApiFp(this.configuration).updateResellerSettingsV1(organizationSettings, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ResellerUserApi - axios parameter creator
 * @export
 */
export const ResellerUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Accept Invite V1
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptResellerUserInviteV1: async (acceptInviteRequest: AcceptInviteRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'acceptInviteRequest' is not null or undefined
            if (acceptInviteRequest === null || acceptInviteRequest === undefined) {
                throw new RequiredError('acceptInviteRequest','Required parameter acceptInviteRequest was null or undefined when calling acceptResellerUserInviteV1.');
            }
            const localVarPath = `/v1/resellers/invites/accept`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof acceptInviteRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(acceptInviteRequest !== undefined ? acceptInviteRequest : {}) : (acceptInviteRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user
         * @summary Delete Reseller User V1
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerUserV1: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteResellerUserV1.');
            }
            const localVarPath = `/v1/resellers/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Reseller User By Id V1
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerUserByIdV1: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getResellerUserByIdV1.');
            }
            const localVarPath = `/v1/resellers/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of all open invites from the organization
         * @summary List Reseller User Invites V1
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUserInvitesV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/invites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all users under the user\'s organization
         * @summary List Reseller Users V1
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUsersV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Invite Users V1
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendResellerUserInviteV1: async (guestInput: GuestInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guestInput' is not null or undefined
            if (guestInput === null || guestInput === undefined) {
                throw new RequiredError('guestInput','Required parameter guestInput was null or undefined when calling sendResellerUserInviteV1.');
            }
            const localVarPath = `/v1/resellers/invites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof guestInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(guestInput !== undefined ? guestInput : {}) : (guestInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user details
         * @summary Update Reseller User V1
         * @param {string} userId 
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerUserV1: async (userId: string, userPayload: UserPayload, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateResellerUserV1.');
            }
            // verify required parameter 'userPayload' is not null or undefined
            if (userPayload === null || userPayload === undefined) {
                throw new RequiredError('userPayload','Required parameter userPayload was null or undefined when calling updateResellerUserV1.');
            }
            const localVarPath = `/v1/resellers/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userPayload !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userPayload !== undefined ? userPayload : {}) : (userPayload || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerUserApi - functional programming interface
 * @export
 */
export const ResellerUserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Accept Invite V1
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptResellerUserInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await ResellerUserApiAxiosParamCreator(configuration).acceptResellerUserInviteV1(acceptInviteRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a user
         * @summary Delete Reseller User V1
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResellerUserV1(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await ResellerUserApiAxiosParamCreator(configuration).deleteResellerUserV1(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Reseller User By Id V1
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerUserByIdV1(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await ResellerUserApiAxiosParamCreator(configuration).getResellerUserByIdV1(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List of all open invites from the organization
         * @summary List Reseller User Invites V1
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResellerUserInvitesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuestOutput>>> {
            const localVarAxiosArgs = await ResellerUserApiAxiosParamCreator(configuration).listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all users under the user\'s organization
         * @summary List Reseller Users V1
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResellerUsersV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await ResellerUserApiAxiosParamCreator(configuration).listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Invite Users V1
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendResellerUserInviteV1(guestInput: GuestInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuestOutput>> {
            const localVarAxiosArgs = await ResellerUserApiAxiosParamCreator(configuration).sendResellerUserInviteV1(guestInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update user details
         * @summary Update Reseller User V1
         * @param {string} userId 
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResellerUserV1(userId: string, userPayload: UserPayload, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await ResellerUserApiAxiosParamCreator(configuration).updateResellerUserV1(userId, userPayload, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResellerUserApi - factory interface
 * @export
 */
export const ResellerUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Accept Invite V1
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptResellerUserInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: any): AxiosPromise<User> {
            return ResellerUserApiFp(configuration).acceptResellerUserInviteV1(acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user
         * @summary Delete Reseller User V1
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerUserV1(userId: string, options?: any): AxiosPromise<User> {
            return ResellerUserApiFp(configuration).deleteResellerUserV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Reseller User By Id V1
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerUserByIdV1(userId: string, options?: any): AxiosPromise<User> {
            return ResellerUserApiFp(configuration).getResellerUserByIdV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List of all open invites from the organization
         * @summary List Reseller User Invites V1
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUserInvitesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): AxiosPromise<Array<GuestOutput>> {
            return ResellerUserApiFp(configuration).listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all users under the user\'s organization
         * @summary List Reseller Users V1
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUsersV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): AxiosPromise<Array<User>> {
            return ResellerUserApiFp(configuration).listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Invite Users V1
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendResellerUserInviteV1(guestInput: GuestInput, options?: any): AxiosPromise<GuestOutput> {
            return ResellerUserApiFp(configuration).sendResellerUserInviteV1(guestInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user details
         * @summary Update Reseller User V1
         * @param {string} userId 
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerUserV1(userId: string, userPayload: UserPayload, options?: any): AxiosPromise<User> {
            return ResellerUserApiFp(configuration).updateResellerUserV1(userId, userPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerUserApi - object-oriented interface
 * @export
 * @class ResellerUserApi
 * @extends {BaseAPI}
 */
export class ResellerUserApi extends BaseAPI {
    /**
     * Accept invite and add new user to organization
     * @summary Accept Invite V1
     * @param {AcceptInviteRequest} acceptInviteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    public acceptResellerUserInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: any) {
        return ResellerUserApiFp(this.configuration).acceptResellerUserInviteV1(acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user
     * @summary Delete Reseller User V1
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    public deleteResellerUserV1(userId: string, options?: any) {
        return ResellerUserApiFp(this.configuration).deleteResellerUserV1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Reseller User By Id V1
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    public getResellerUserByIdV1(userId: string, options?: any) {
        return ResellerUserApiFp(this.configuration).getResellerUserByIdV1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of all open invites from the organization
     * @summary List Reseller User Invites V1
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [updatedAfter] 
     * @param {string} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    public listResellerUserInvitesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any) {
        return ResellerUserApiFp(this.configuration).listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all users under the user\'s organization
     * @summary List Reseller Users V1
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [updatedAfter] 
     * @param {string} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    public listResellerUsersV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any) {
        return ResellerUserApiFp(this.configuration).listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a new user to an organization or resend invite to the user if the user is already invited
     * @summary Invite Users V1
     * @param {GuestInput} guestInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    public sendResellerUserInviteV1(guestInput: GuestInput, options?: any) {
        return ResellerUserApiFp(this.configuration).sendResellerUserInviteV1(guestInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user details
     * @summary Update Reseller User V1
     * @param {string} userId 
     * @param {UserPayload} userPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    public updateResellerUserV1(userId: string, userPayload: UserPayload, options?: any) {
        return ResellerUserApiFp(this.configuration).updateResellerUserV1(userId, userPayload, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SparrApi - axios parameter creator
 * @export
 */
export const SparrApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a module attempt for a user
         * @summary Add Module Attempt
         * @param {string} moduleId 
         * @param {UserModuleAttemptCore} userModuleAttemptCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addModuleAttemptV1: async (moduleId: string, userModuleAttemptCore: UserModuleAttemptCore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'moduleId' is not null or undefined
            if (moduleId === null || moduleId === undefined) {
                throw new RequiredError('moduleId','Required parameter moduleId was null or undefined when calling addModuleAttemptV1.');
            }
            // verify required parameter 'userModuleAttemptCore' is not null or undefined
            if (userModuleAttemptCore === null || userModuleAttemptCore === undefined) {
                throw new RequiredError('userModuleAttemptCore','Required parameter userModuleAttemptCore was null or undefined when calling addModuleAttemptV1.');
            }
            const localVarPath = `/v1/sparr/courses/modules/{module_id}/attempts`
                .replace(`{${"module_id"}}`, encodeURIComponent(String(moduleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userModuleAttemptCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userModuleAttemptCore !== undefined ? userModuleAttemptCore : {}) : (userModuleAttemptCore || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign a course to a user
         * @summary Assign Course
         * @param {string} courseId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignCourseV1: async (courseId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling assignCourseV1.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling assignCourseV1.');
            }
            const localVarPath = `/v1/sparr/courses/{course_id}/assign/{user_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a checkout session for a price
         * @summary Create Checkout Session For Price
         * @param {string} priceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForPriceV1: async (priceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'priceId' is not null or undefined
            if (priceId === null || priceId === undefined) {
                throw new RequiredError('priceId','Required parameter priceId was null or undefined when calling createCheckoutSessionForPriceV1.');
            }
            const localVarPath = `/v1/sparr/pricing/{price_id}/checkout`
                .replace(`{${"price_id"}}`, encodeURIComponent(String(priceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseV1: async (courseRequest: CourseRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseRequest' is not null or undefined
            if (courseRequest === null || courseRequest === undefined) {
                throw new RequiredError('courseRequest','Required parameter courseRequest was null or undefined when calling createCourseV1.');
            }
            const localVarPath = `/v1/sparr/courses/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof courseRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(courseRequest !== undefined ? courseRequest : {}) : (courseRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a customer portal for customer
         * @summary Create Customer Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPortalV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/customers/portal`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new feedback
         * @summary Create Feedback
         * @param {FeedbackCore} feedbackCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedbackV1: async (feedbackCore: FeedbackCore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackCore' is not null or undefined
            if (feedbackCore === null || feedbackCore === undefined) {
                throw new RequiredError('feedbackCore','Required parameter feedbackCore was null or undefined when calling createFeedbackV1.');
            }
            const localVarPath = `/v1/sparr/feedbacks/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof feedbackCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(feedbackCore !== undefined ? feedbackCore : {}) : (feedbackCore || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonaV1: async (personaCore: PersonaCore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaCore' is not null or undefined
            if (personaCore === null || personaCore === undefined) {
                throw new RequiredError('personaCore','Required parameter personaCore was null or undefined when calling createPersonaV1.');
            }
            const localVarPath = `/v1/sparr/personas/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof personaCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(personaCore !== undefined ? personaCore : {}) : (personaCore || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {ScenarioCore} scenarioCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenarioV1: async (scenarioCore: ScenarioCore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioCore' is not null or undefined
            if (scenarioCore === null || scenarioCore === undefined) {
                throw new RequiredError('scenarioCore','Required parameter scenarioCore was null or undefined when calling createScenarioV1.');
            }
            const localVarPath = `/v1/sparr/scenarios/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof scenarioCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(scenarioCore !== undefined ? scenarioCore : {}) : (scenarioCore || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseV1: async (courseId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling deleteCourseV1.');
            }
            const localVarPath = `/v1/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a feedback
         * @summary Delete Feedback
         * @param {string} feedbackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedbackV1: async (feedbackId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackId' is not null or undefined
            if (feedbackId === null || feedbackId === undefined) {
                throw new RequiredError('feedbackId','Required parameter feedbackId was null or undefined when calling deleteFeedbackV1.');
            }
            const localVarPath = `/v1/sparr/feedbacks/{feedback_id}`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonaV1: async (personaId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            if (personaId === null || personaId === undefined) {
                throw new RequiredError('personaId','Required parameter personaId was null or undefined when calling deletePersonaV1.');
            }
            const localVarPath = `/v1/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioV1: async (scenarioId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            if (scenarioId === null || scenarioId === undefined) {
                throw new RequiredError('scenarioId','Required parameter scenarioId was null or undefined when calling deleteScenarioV1.');
            }
            const localVarPath = `/v1/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseV1: async (courseId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling getCourseV1.');
            }
            const localVarPath = `/v1/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get credits
         * @summary Get Credits V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditsV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/credits`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific feedback by ID
         * @summary Get Feedback
         * @param {string} feedbackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedbackV1: async (feedbackId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackId' is not null or undefined
            if (feedbackId === null || feedbackId === undefined) {
                throw new RequiredError('feedbackId','Required parameter feedbackId was null or undefined when calling getFeedbackV1.');
            }
            const localVarPath = `/v1/sparr/feedbacks/{feedback_id}`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get metrics for a given batch of metrics requests
         * @summary Get Metrics
         * @param {SparrModelsAnalyticsBatchMetricsRequests} sparrModelsAnalyticsBatchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1: async (sparrModelsAnalyticsBatchMetricsRequests: SparrModelsAnalyticsBatchMetricsRequests, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sparrModelsAnalyticsBatchMetricsRequests' is not null or undefined
            if (sparrModelsAnalyticsBatchMetricsRequests === null || sparrModelsAnalyticsBatchMetricsRequests === undefined) {
                throw new RequiredError('sparrModelsAnalyticsBatchMetricsRequests','Required parameter sparrModelsAnalyticsBatchMetricsRequests was null or undefined when calling getMetricsV1.');
            }
            const localVarPath = `/v1/sparr/feedbacks/metrics`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof sparrModelsAnalyticsBatchMetricsRequests !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(sparrModelsAnalyticsBatchMetricsRequests !== undefined ? sparrModelsAnalyticsBatchMetricsRequests : {}) : (sparrModelsAnalyticsBatchMetricsRequests || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific persona by ID
         * @summary Get Persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaV1: async (personaId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            if (personaId === null || personaId === undefined) {
                throw new RequiredError('personaId','Required parameter personaId was null or undefined when calling getPersonaV1.');
            }
            const localVarPath = `/v1/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pricing
         * @summary Get Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/pricing`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific scenario by ID
         * @summary Get Scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioV1: async (scenarioId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            if (scenarioId === null || scenarioId === undefined) {
                throw new RequiredError('scenarioId','Required parameter scenarioId was null or undefined when calling getScenarioV1.');
            }
            const localVarPath = `/v1/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search personas by name, title and company
         * @summary Get User Stats
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStatsV1: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserStatsV1.');
            }
            const localVarPath = `/v1/sparr/user_stats/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLinkedinPersonaV1: async (linkedinUrl: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'linkedinUrl' is not null or undefined
            if (linkedinUrl === null || linkedinUrl === undefined) {
                throw new RequiredError('linkedinUrl','Required parameter linkedinUrl was null or undefined when calling importLinkedinPersonaV1.');
            }
            const localVarPath = `/v1/sparr/personas/import-linkedin`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (linkedinUrl !== undefined) {
                localVarQueryParameter['linkedin_url'] = linkedinUrl;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoursesV1: async (skip?: number, limit?: number, status?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/courses/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all feedbacks
         * @summary Get Feedbacks
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string} [fromDate] Start date for filtering feedbacks
         * @param {string} [toDate] End date for filtering feedbacks
         * @param {string} [userFilter] User filter for filtering feedbacks. Comma separated list of user ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeedbacksV1: async (skip?: number, limit?: number, fromDate?: string, toDate?: string, userFilter?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/feedbacks/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = toDate;
            }

            if (userFilter !== undefined) {
                localVarQueryParameter['user_filter'] = userFilter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all personas
         * @summary Get Personas
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonasV1: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/personas/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all scenarios
         * @summary Get Scenarios
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenariosV1: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/scenarios/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all course assignments for a user with analytics
         * @summary Get User Assignments
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAssignmentsV1: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling listUserAssignmentsV1.');
            }
            const localVarPath = `/v1/sparr/courses/users/{user_id}/assignments`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all module attempts with module information for a user in a specific course
         * @summary Get User Course Attempts
         * @param {string} courseId 
         * @param {string} userId 
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCourseAttemptsV1: async (courseId: string, userId: string, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling listUserCourseAttemptsV1.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling listUserCourseAttemptsV1.');
            }
            const localVarPath = `/v1/sparr/courses/{course_id}/attempts/users/{user_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all module attempts for a user
         * @summary Get User Module Attempts
         * @param {string} moduleId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserModuleAttemptsV1: async (moduleId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'moduleId' is not null or undefined
            if (moduleId === null || moduleId === undefined) {
                throw new RequiredError('moduleId','Required parameter moduleId was null or undefined when calling listUserModuleAttemptsV1.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling listUserModuleAttemptsV1.');
            }
            const localVarPath = `/v1/sparr/courses/modules/{module_id}/attempts/{user_id}`
                .replace(`{${"module_id"}}`, encodeURIComponent(String(moduleId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke a course from a user
         * @summary Revoke Course
         * @param {string} courseId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCourseV1: async (courseId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling revokeCourseV1.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling revokeCourseV1.');
            }
            const localVarPath = `/v1/sparr/courses/{course_id}/assign/{user_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonasV1: async (query: string, page?: number, size?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling searchPersonasV1.');
            }
            const localVarPath = `/v1/sparr/personas/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenariosV1: async (query: string, page?: number, size?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling searchScenariosV1.');
            }
            const localVarPath = `/v1/sparr/scenarios/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Heart Beat check to check the health of Sparr Service
         * @summary Heart Beat Status Of Sparr Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusSparrStatusGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/sparr/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update course completion status
         * @summary Update Course Completion Status
         * @param {string} courseId 
         * @param {string} userId 
         * @param {CourseCompletionStatus} completionStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseCompletionStatusV1: async (courseId: string, userId: string, completionStatus: CourseCompletionStatus, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling updateCourseCompletionStatusV1.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateCourseCompletionStatusV1.');
            }
            // verify required parameter 'completionStatus' is not null or undefined
            if (completionStatus === null || completionStatus === undefined) {
                throw new RequiredError('completionStatus','Required parameter completionStatus was null or undefined when calling updateCourseCompletionStatusV1.');
            }
            const localVarPath = `/v1/sparr/courses/{course_id}/assign/{user_id}/status`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (completionStatus !== undefined) {
                localVarQueryParameter['completionStatus'] = completionStatus;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId 
         * @param {CourseUpdateRequest} courseUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseV1: async (courseId: string, courseUpdateRequest: CourseUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling updateCourseV1.');
            }
            // verify required parameter 'courseUpdateRequest' is not null or undefined
            if (courseUpdateRequest === null || courseUpdateRequest === undefined) {
                throw new RequiredError('courseUpdateRequest','Required parameter courseUpdateRequest was null or undefined when calling updateCourseV1.');
            }
            const localVarPath = `/v1/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof courseUpdateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(courseUpdateRequest !== undefined ? courseUpdateRequest : {}) : (courseUpdateRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a feedback
         * @summary Update Feedback
         * @param {string} feedbackId 
         * @param {FeedbackCore} feedbackCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedbackV1: async (feedbackId: string, feedbackCore: FeedbackCore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackId' is not null or undefined
            if (feedbackId === null || feedbackId === undefined) {
                throw new RequiredError('feedbackId','Required parameter feedbackId was null or undefined when calling updateFeedbackV1.');
            }
            // verify required parameter 'feedbackCore' is not null or undefined
            if (feedbackCore === null || feedbackCore === undefined) {
                throw new RequiredError('feedbackCore','Required parameter feedbackCore was null or undefined when calling updateFeedbackV1.');
            }
            const localVarPath = `/v1/sparr/feedbacks/{feedback_id}`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof feedbackCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(feedbackCore !== undefined ? feedbackCore : {}) : (feedbackCore || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId 
         * @param {PersonaCore} personaCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonaV1: async (personaId: string, personaCore: PersonaCore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            if (personaId === null || personaId === undefined) {
                throw new RequiredError('personaId','Required parameter personaId was null or undefined when calling updatePersonaV1.');
            }
            // verify required parameter 'personaCore' is not null or undefined
            if (personaCore === null || personaCore === undefined) {
                throw new RequiredError('personaCore','Required parameter personaCore was null or undefined when calling updatePersonaV1.');
            }
            const localVarPath = `/v1/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof personaCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(personaCore !== undefined ? personaCore : {}) : (personaCore || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId 
         * @param {ScenarioCore} scenarioCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenarioV1: async (scenarioId: string, scenarioCore: ScenarioCore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            if (scenarioId === null || scenarioId === undefined) {
                throw new RequiredError('scenarioId','Required parameter scenarioId was null or undefined when calling updateScenarioV1.');
            }
            // verify required parameter 'scenarioCore' is not null or undefined
            if (scenarioCore === null || scenarioCore === undefined) {
                throw new RequiredError('scenarioCore','Required parameter scenarioCore was null or undefined when calling updateScenarioV1.');
            }
            const localVarPath = `/v1/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof scenarioCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(scenarioCore !== undefined ? scenarioCore : {}) : (scenarioCore || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SparrApi - functional programming interface
 * @export
 */
export const SparrApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add a module attempt for a user
         * @summary Add Module Attempt
         * @param {string} moduleId 
         * @param {UserModuleAttemptCore} userModuleAttemptCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addModuleAttemptV1(moduleId: string, userModuleAttemptCore: UserModuleAttemptCore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModuleAttempt>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).addModuleAttemptV1(moduleId, userModuleAttemptCore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Assign a course to a user
         * @summary Assign Course
         * @param {string} courseId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignCourseV1(courseId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCourseAssignment>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).assignCourseV1(courseId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a checkout session for a price
         * @summary Create Checkout Session For Price
         * @param {string} priceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckoutSessionForPriceV1(priceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).createCheckoutSessionForPriceV1(priceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCourseV1(courseRequest: CourseRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseResponse>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).createCourseV1(courseRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a customer portal for customer
         * @summary Create Customer Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomerPortalV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).createCustomerPortalV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new feedback
         * @summary Create Feedback
         * @param {FeedbackCore} feedbackCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeedbackV1(feedbackCore: FeedbackCore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Feedback>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).createFeedbackV1(feedbackCore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPersonaV1(personaCore: PersonaCore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).createPersonaV1(personaCore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {ScenarioCore} scenarioCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScenarioV1(scenarioCore: ScenarioCore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).createScenarioV1(scenarioCore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCourseV1(courseId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).deleteCourseV1(courseId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a feedback
         * @summary Delete Feedback
         * @param {string} feedbackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFeedbackV1(feedbackId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).deleteFeedbackV1(feedbackId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePersonaV1(personaId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).deletePersonaV1(personaId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScenarioV1(scenarioId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).deleteScenarioV1(scenarioId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseV1(courseId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseResponse>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).getCourseV1(courseId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get credits
         * @summary Get Credits V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCreditsV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Credit>>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).getCreditsV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a specific feedback by ID
         * @summary Get Feedback
         * @param {string} feedbackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeedbackV1(feedbackId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Feedback>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).getFeedbackV1(feedbackId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get metrics for a given batch of metrics requests
         * @summary Get Metrics
         * @param {SparrModelsAnalyticsBatchMetricsRequests} sparrModelsAnalyticsBatchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests: SparrModelsAnalyticsBatchMetricsRequests, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsAnalyticsBatchMetricsResponse>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a specific persona by ID
         * @summary Get Persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonaV1(personaId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).getPersonaV1(personaId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get pricing
         * @summary Get Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricingV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Price>>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).getPricingV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a specific scenario by ID
         * @summary Get Scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenarioV1(scenarioId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).getScenarioV1(scenarioId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Search personas by name, title and company
         * @summary Get User Stats
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserStatsV1(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStats>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).getUserStatsV1(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importLinkedinPersonaV1(linkedinUrl: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).importLinkedinPersonaV1(linkedinUrl, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCoursesV1(skip?: number, limit?: number, status?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseResponse>>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).listCoursesV1(skip, limit, status, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get all feedbacks
         * @summary Get Feedbacks
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string} [fromDate] Start date for filtering feedbacks
         * @param {string} [toDate] End date for filtering feedbacks
         * @param {string} [userFilter] User filter for filtering feedbacks. Comma separated list of user ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFeedbacksV1(skip?: number, limit?: number, fromDate?: string, toDate?: string, userFilter?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Feedback>>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).listFeedbacksV1(skip, limit, fromDate, toDate, userFilter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get all personas
         * @summary Get Personas
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPersonasV1(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Persona>>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).listPersonasV1(skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve all scenarios
         * @summary Get Scenarios
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScenariosV1(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Scenario>>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).listScenariosV1(skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get all course assignments for a user with analytics
         * @summary Get User Assignments
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserAssignmentsV1(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserCourseAssignmentAnalyticsResponse>>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).listUserAssignmentsV1(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get all module attempts with module information for a user in a specific course
         * @summary Get User Course Attempts
         * @param {string} courseId 
         * @param {string} userId 
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserCourseAttemptsV1(courseId: string, userId: string, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserModuleAttemptResponse>>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).listUserCourseAttemptsV1(courseId, userId, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get all module attempts for a user
         * @summary Get User Module Attempts
         * @param {string} moduleId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserModuleAttemptsV1(moduleId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserModuleAttemptResponse>>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).listUserModuleAttemptsV1(moduleId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Revoke a course from a user
         * @summary Revoke Course
         * @param {string} courseId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeCourseV1(courseId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).revokeCourseV1(courseId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPersonasV1(query: string, page?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaSearchResponse>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).searchPersonasV1(query, page, size, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchScenariosV1(query: string, page?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioSearchResponse>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).searchScenariosV1(query, page, size, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Heart Beat check to check the health of Sparr Service
         * @summary Heart Beat Status Of Sparr Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusSparrStatusGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).statusSparrStatusGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update course completion status
         * @summary Update Course Completion Status
         * @param {string} courseId 
         * @param {string} userId 
         * @param {CourseCompletionStatus} completionStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCourseCompletionStatusV1(courseId: string, userId: string, completionStatus: CourseCompletionStatus, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCourseAssignment>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).updateCourseCompletionStatusV1(courseId, userId, completionStatus, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId 
         * @param {CourseUpdateRequest} courseUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCourseV1(courseId: string, courseUpdateRequest: CourseUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseResponse>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).updateCourseV1(courseId, courseUpdateRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a feedback
         * @summary Update Feedback
         * @param {string} feedbackId 
         * @param {FeedbackCore} feedbackCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeedbackV1(feedbackId: string, feedbackCore: FeedbackCore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Feedback>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).updateFeedbackV1(feedbackId, feedbackCore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId 
         * @param {PersonaCore} personaCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePersonaV1(personaId: string, personaCore: PersonaCore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).updatePersonaV1(personaId, personaCore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId 
         * @param {ScenarioCore} scenarioCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScenarioV1(scenarioId: string, scenarioCore: ScenarioCore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await SparrApiAxiosParamCreator(configuration).updateScenarioV1(scenarioId, scenarioCore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SparrApi - factory interface
 * @export
 */
export const SparrApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Add a module attempt for a user
         * @summary Add Module Attempt
         * @param {string} moduleId 
         * @param {UserModuleAttemptCore} userModuleAttemptCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addModuleAttemptV1(moduleId: string, userModuleAttemptCore: UserModuleAttemptCore, options?: any): AxiosPromise<UserModuleAttempt> {
            return SparrApiFp(configuration).addModuleAttemptV1(moduleId, userModuleAttemptCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign a course to a user
         * @summary Assign Course
         * @param {string} courseId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignCourseV1(courseId: string, userId: string, options?: any): AxiosPromise<UserCourseAssignment> {
            return SparrApiFp(configuration).assignCourseV1(courseId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a checkout session for a price
         * @summary Create Checkout Session For Price
         * @param {string} priceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForPriceV1(priceId: string, options?: any): AxiosPromise<string> {
            return SparrApiFp(configuration).createCheckoutSessionForPriceV1(priceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseV1(courseRequest: CourseRequest, options?: any): AxiosPromise<CourseResponse> {
            return SparrApiFp(configuration).createCourseV1(courseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a customer portal for customer
         * @summary Create Customer Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPortalV1(options?: any): AxiosPromise<string> {
            return SparrApiFp(configuration).createCustomerPortalV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new feedback
         * @summary Create Feedback
         * @param {FeedbackCore} feedbackCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedbackV1(feedbackCore: FeedbackCore, options?: any): AxiosPromise<Feedback> {
            return SparrApiFp(configuration).createFeedbackV1(feedbackCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonaV1(personaCore: PersonaCore, options?: any): AxiosPromise<Persona> {
            return SparrApiFp(configuration).createPersonaV1(personaCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {ScenarioCore} scenarioCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenarioV1(scenarioCore: ScenarioCore, options?: any): AxiosPromise<Scenario> {
            return SparrApiFp(configuration).createScenarioV1(scenarioCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseV1(courseId: string, options?: any): AxiosPromise<SparrModelsBaseBaseResponse> {
            return SparrApiFp(configuration).deleteCourseV1(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a feedback
         * @summary Delete Feedback
         * @param {string} feedbackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedbackV1(feedbackId: string, options?: any): AxiosPromise<SparrModelsBaseBaseResponse> {
            return SparrApiFp(configuration).deleteFeedbackV1(feedbackId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonaV1(personaId: string, options?: any): AxiosPromise<SparrModelsBaseBaseResponse> {
            return SparrApiFp(configuration).deletePersonaV1(personaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioV1(scenarioId: string, options?: any): AxiosPromise<SparrModelsBaseBaseResponse> {
            return SparrApiFp(configuration).deleteScenarioV1(scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseV1(courseId: string, options?: any): AxiosPromise<CourseResponse> {
            return SparrApiFp(configuration).getCourseV1(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get credits
         * @summary Get Credits V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditsV1(options?: any): AxiosPromise<Array<Credit>> {
            return SparrApiFp(configuration).getCreditsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific feedback by ID
         * @summary Get Feedback
         * @param {string} feedbackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedbackV1(feedbackId: string, options?: any): AxiosPromise<Feedback> {
            return SparrApiFp(configuration).getFeedbackV1(feedbackId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get metrics for a given batch of metrics requests
         * @summary Get Metrics
         * @param {SparrModelsAnalyticsBatchMetricsRequests} sparrModelsAnalyticsBatchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests: SparrModelsAnalyticsBatchMetricsRequests, options?: any): AxiosPromise<SparrModelsAnalyticsBatchMetricsResponse> {
            return SparrApiFp(configuration).getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific persona by ID
         * @summary Get Persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaV1(personaId: string, options?: any): AxiosPromise<Persona> {
            return SparrApiFp(configuration).getPersonaV1(personaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pricing
         * @summary Get Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingV1(options?: any): AxiosPromise<Array<Price>> {
            return SparrApiFp(configuration).getPricingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific scenario by ID
         * @summary Get Scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioV1(scenarioId: string, options?: any): AxiosPromise<Scenario> {
            return SparrApiFp(configuration).getScenarioV1(scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search personas by name, title and company
         * @summary Get User Stats
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStatsV1(userId: string, options?: any): AxiosPromise<UserStats> {
            return SparrApiFp(configuration).getUserStatsV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLinkedinPersonaV1(linkedinUrl: string, options?: any): AxiosPromise<Persona> {
            return SparrApiFp(configuration).importLinkedinPersonaV1(linkedinUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoursesV1(skip?: number, limit?: number, status?: string, options?: any): AxiosPromise<Array<CourseResponse>> {
            return SparrApiFp(configuration).listCoursesV1(skip, limit, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all feedbacks
         * @summary Get Feedbacks
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string} [fromDate] Start date for filtering feedbacks
         * @param {string} [toDate] End date for filtering feedbacks
         * @param {string} [userFilter] User filter for filtering feedbacks. Comma separated list of user ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeedbacksV1(skip?: number, limit?: number, fromDate?: string, toDate?: string, userFilter?: string, options?: any): AxiosPromise<Array<Feedback>> {
            return SparrApiFp(configuration).listFeedbacksV1(skip, limit, fromDate, toDate, userFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all personas
         * @summary Get Personas
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonasV1(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Persona>> {
            return SparrApiFp(configuration).listPersonasV1(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all scenarios
         * @summary Get Scenarios
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenariosV1(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Scenario>> {
            return SparrApiFp(configuration).listScenariosV1(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all course assignments for a user with analytics
         * @summary Get User Assignments
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAssignmentsV1(userId: string, options?: any): AxiosPromise<Array<UserCourseAssignmentAnalyticsResponse>> {
            return SparrApiFp(configuration).listUserAssignmentsV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all module attempts with module information for a user in a specific course
         * @summary Get User Course Attempts
         * @param {string} courseId 
         * @param {string} userId 
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCourseAttemptsV1(courseId: string, userId: string, skip?: number, limit?: number, options?: any): AxiosPromise<Array<UserModuleAttemptResponse>> {
            return SparrApiFp(configuration).listUserCourseAttemptsV1(courseId, userId, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all module attempts for a user
         * @summary Get User Module Attempts
         * @param {string} moduleId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserModuleAttemptsV1(moduleId: string, userId: string, options?: any): AxiosPromise<Array<UserModuleAttemptResponse>> {
            return SparrApiFp(configuration).listUserModuleAttemptsV1(moduleId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke a course from a user
         * @summary Revoke Course
         * @param {string} courseId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCourseV1(courseId: string, userId: string, options?: any): AxiosPromise<SparrModelsBaseBaseResponse> {
            return SparrApiFp(configuration).revokeCourseV1(courseId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonasV1(query: string, page?: number, size?: number, options?: any): AxiosPromise<PersonaSearchResponse> {
            return SparrApiFp(configuration).searchPersonasV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenariosV1(query: string, page?: number, size?: number, options?: any): AxiosPromise<ScenarioSearchResponse> {
            return SparrApiFp(configuration).searchScenariosV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Heart Beat check to check the health of Sparr Service
         * @summary Heart Beat Status Of Sparr Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusSparrStatusGet(options?: any): AxiosPromise<object> {
            return SparrApiFp(configuration).statusSparrStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update course completion status
         * @summary Update Course Completion Status
         * @param {string} courseId 
         * @param {string} userId 
         * @param {CourseCompletionStatus} completionStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseCompletionStatusV1(courseId: string, userId: string, completionStatus: CourseCompletionStatus, options?: any): AxiosPromise<UserCourseAssignment> {
            return SparrApiFp(configuration).updateCourseCompletionStatusV1(courseId, userId, completionStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId 
         * @param {CourseUpdateRequest} courseUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseV1(courseId: string, courseUpdateRequest: CourseUpdateRequest, options?: any): AxiosPromise<CourseResponse> {
            return SparrApiFp(configuration).updateCourseV1(courseId, courseUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a feedback
         * @summary Update Feedback
         * @param {string} feedbackId 
         * @param {FeedbackCore} feedbackCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedbackV1(feedbackId: string, feedbackCore: FeedbackCore, options?: any): AxiosPromise<Feedback> {
            return SparrApiFp(configuration).updateFeedbackV1(feedbackId, feedbackCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId 
         * @param {PersonaCore} personaCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonaV1(personaId: string, personaCore: PersonaCore, options?: any): AxiosPromise<Persona> {
            return SparrApiFp(configuration).updatePersonaV1(personaId, personaCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId 
         * @param {ScenarioCore} scenarioCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenarioV1(scenarioId: string, scenarioCore: ScenarioCore, options?: any): AxiosPromise<Scenario> {
            return SparrApiFp(configuration).updateScenarioV1(scenarioId, scenarioCore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SparrApi - object-oriented interface
 * @export
 * @class SparrApi
 * @extends {BaseAPI}
 */
export class SparrApi extends BaseAPI {
    /**
     * Add a module attempt for a user
     * @summary Add Module Attempt
     * @param {string} moduleId 
     * @param {UserModuleAttemptCore} userModuleAttemptCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public addModuleAttemptV1(moduleId: string, userModuleAttemptCore: UserModuleAttemptCore, options?: any) {
        return SparrApiFp(this.configuration).addModuleAttemptV1(moduleId, userModuleAttemptCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign a course to a user
     * @summary Assign Course
     * @param {string} courseId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public assignCourseV1(courseId: string, userId: string, options?: any) {
        return SparrApiFp(this.configuration).assignCourseV1(courseId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a checkout session for a price
     * @summary Create Checkout Session For Price
     * @param {string} priceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public createCheckoutSessionForPriceV1(priceId: string, options?: any) {
        return SparrApiFp(this.configuration).createCheckoutSessionForPriceV1(priceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new course
     * @summary Create Course
     * @param {CourseRequest} courseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public createCourseV1(courseRequest: CourseRequest, options?: any) {
        return SparrApiFp(this.configuration).createCourseV1(courseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a customer portal for customer
     * @summary Create Customer Portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public createCustomerPortalV1(options?: any) {
        return SparrApiFp(this.configuration).createCustomerPortalV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new feedback
     * @summary Create Feedback
     * @param {FeedbackCore} feedbackCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public createFeedbackV1(feedbackCore: FeedbackCore, options?: any) {
        return SparrApiFp(this.configuration).createFeedbackV1(feedbackCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new persona
     * @summary Create Persona
     * @param {PersonaCore} personaCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public createPersonaV1(personaCore: PersonaCore, options?: any) {
        return SparrApiFp(this.configuration).createPersonaV1(personaCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new scenario
     * @summary Create Scenario
     * @param {ScenarioCore} scenarioCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public createScenarioV1(scenarioCore: ScenarioCore, options?: any) {
        return SparrApiFp(this.configuration).createScenarioV1(scenarioCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a course
     * @summary Delete Course
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public deleteCourseV1(courseId: string, options?: any) {
        return SparrApiFp(this.configuration).deleteCourseV1(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a feedback
     * @summary Delete Feedback
     * @param {string} feedbackId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public deleteFeedbackV1(feedbackId: string, options?: any) {
        return SparrApiFp(this.configuration).deleteFeedbackV1(feedbackId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a persona
     * @summary Delete Persona
     * @param {string} personaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public deletePersonaV1(personaId: string, options?: any) {
        return SparrApiFp(this.configuration).deletePersonaV1(personaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a scenario
     * @summary Delete Scenario
     * @param {string} scenarioId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public deleteScenarioV1(scenarioId: string, options?: any) {
        return SparrApiFp(this.configuration).deleteScenarioV1(scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific course by ID
     * @summary Get Course
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getCourseV1(courseId: string, options?: any) {
        return SparrApiFp(this.configuration).getCourseV1(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get credits
     * @summary Get Credits V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getCreditsV1(options?: any) {
        return SparrApiFp(this.configuration).getCreditsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific feedback by ID
     * @summary Get Feedback
     * @param {string} feedbackId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getFeedbackV1(feedbackId: string, options?: any) {
        return SparrApiFp(this.configuration).getFeedbackV1(feedbackId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get metrics for a given batch of metrics requests
     * @summary Get Metrics
     * @param {SparrModelsAnalyticsBatchMetricsRequests} sparrModelsAnalyticsBatchMetricsRequests 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests: SparrModelsAnalyticsBatchMetricsRequests, options?: any) {
        return SparrApiFp(this.configuration).getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific persona by ID
     * @summary Get Persona
     * @param {string} personaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getPersonaV1(personaId: string, options?: any) {
        return SparrApiFp(this.configuration).getPersonaV1(personaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pricing
     * @summary Get Pricing V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getPricingV1(options?: any) {
        return SparrApiFp(this.configuration).getPricingV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific scenario by ID
     * @summary Get Scenario
     * @param {string} scenarioId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getScenarioV1(scenarioId: string, options?: any) {
        return SparrApiFp(this.configuration).getScenarioV1(scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search personas by name, title and company
     * @summary Get User Stats
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getUserStatsV1(userId: string, options?: any) {
        return SparrApiFp(this.configuration).getUserStatsV1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import a persona from LinkedIn URL
     * @summary Import Linkedin Persona
     * @param {string} linkedinUrl 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public importLinkedinPersonaV1(linkedinUrl: string, options?: any) {
        return SparrApiFp(this.configuration).importLinkedinPersonaV1(linkedinUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all courses including reseller assignments
     * @summary Get Courses
     * @param {number} [skip] Skip for pagination
     * @param {number} [limit] Limit for pagination
     * @param {string} [status] Filter by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public listCoursesV1(skip?: number, limit?: number, status?: string, options?: any) {
        return SparrApiFp(this.configuration).listCoursesV1(skip, limit, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all feedbacks
     * @summary Get Feedbacks
     * @param {number} [skip] Skip for pagination
     * @param {number} [limit] Limit for pagination
     * @param {string} [fromDate] Start date for filtering feedbacks
     * @param {string} [toDate] End date for filtering feedbacks
     * @param {string} [userFilter] User filter for filtering feedbacks. Comma separated list of user ids.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public listFeedbacksV1(skip?: number, limit?: number, fromDate?: string, toDate?: string, userFilter?: string, options?: any) {
        return SparrApiFp(this.configuration).listFeedbacksV1(skip, limit, fromDate, toDate, userFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all personas
     * @summary Get Personas
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public listPersonasV1(skip?: number, limit?: number, options?: any) {
        return SparrApiFp(this.configuration).listPersonasV1(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all scenarios
     * @summary Get Scenarios
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public listScenariosV1(skip?: number, limit?: number, options?: any) {
        return SparrApiFp(this.configuration).listScenariosV1(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all course assignments for a user with analytics
     * @summary Get User Assignments
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public listUserAssignmentsV1(userId: string, options?: any) {
        return SparrApiFp(this.configuration).listUserAssignmentsV1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all module attempts with module information for a user in a specific course
     * @summary Get User Course Attempts
     * @param {string} courseId 
     * @param {string} userId 
     * @param {number} [skip] Skip for pagination
     * @param {number} [limit] Limit for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public listUserCourseAttemptsV1(courseId: string, userId: string, skip?: number, limit?: number, options?: any) {
        return SparrApiFp(this.configuration).listUserCourseAttemptsV1(courseId, userId, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all module attempts for a user
     * @summary Get User Module Attempts
     * @param {string} moduleId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public listUserModuleAttemptsV1(moduleId: string, userId: string, options?: any) {
        return SparrApiFp(this.configuration).listUserModuleAttemptsV1(moduleId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke a course from a user
     * @summary Revoke Course
     * @param {string} courseId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public revokeCourseV1(courseId: string, userId: string, options?: any) {
        return SparrApiFp(this.configuration).revokeCourseV1(courseId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search personas by name, title and company
     * @summary Search Personas
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public searchPersonasV1(query: string, page?: number, size?: number, options?: any) {
        return SparrApiFp(this.configuration).searchPersonasV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search scenarios by name and description
     * @summary Search Scenarios
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public searchScenariosV1(query: string, page?: number, size?: number, options?: any) {
        return SparrApiFp(this.configuration).searchScenariosV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Heart Beat check to check the health of Sparr Service
     * @summary Heart Beat Status Of Sparr Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public statusSparrStatusGet(options?: any) {
        return SparrApiFp(this.configuration).statusSparrStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update course completion status
     * @summary Update Course Completion Status
     * @param {string} courseId 
     * @param {string} userId 
     * @param {CourseCompletionStatus} completionStatus 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public updateCourseCompletionStatusV1(courseId: string, userId: string, completionStatus: CourseCompletionStatus, options?: any) {
        return SparrApiFp(this.configuration).updateCourseCompletionStatusV1(courseId, userId, completionStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a course
     * @summary Update Course
     * @param {string} courseId 
     * @param {CourseUpdateRequest} courseUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public updateCourseV1(courseId: string, courseUpdateRequest: CourseUpdateRequest, options?: any) {
        return SparrApiFp(this.configuration).updateCourseV1(courseId, courseUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a feedback
     * @summary Update Feedback
     * @param {string} feedbackId 
     * @param {FeedbackCore} feedbackCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public updateFeedbackV1(feedbackId: string, feedbackCore: FeedbackCore, options?: any) {
        return SparrApiFp(this.configuration).updateFeedbackV1(feedbackId, feedbackCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a persona
     * @summary Update Persona
     * @param {string} personaId 
     * @param {PersonaCore} personaCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public updatePersonaV1(personaId: string, personaCore: PersonaCore, options?: any) {
        return SparrApiFp(this.configuration).updatePersonaV1(personaId, personaCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a scenario
     * @summary Update Scenario
     * @param {string} scenarioId 
     * @param {ScenarioCore} scenarioCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public updateScenarioV1(scenarioId: string, scenarioCore: ScenarioCore, options?: any) {
        return SparrApiFp(this.configuration).updateScenarioV1(scenarioId, scenarioCore, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SparringApi - axios parameter creator
 * @export
 */
export const SparringApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a virtual prospect
         * @summary Create Virtual Prospect
         * @param {VirtualProspectInput} virtualProspectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualProspectV1SparrVirtualProspectsPost: async (virtualProspectInput: VirtualProspectInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualProspectInput' is not null or undefined
            if (virtualProspectInput === null || virtualProspectInput === undefined) {
                throw new RequiredError('virtualProspectInput','Required parameter virtualProspectInput was null or undefined when calling createVirtualProspectV1SparrVirtualProspectsPost.');
            }
            const localVarPath = `/v1/sparr/virtual-prospects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof virtualProspectInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(virtualProspectInput !== undefined ? virtualProspectInput : {}) : (virtualProspectInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a virtual prospect
         * @summary Delete Virtual Prospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete: async (prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete.');
            }
            const localVarPath = `/v1/sparr/virtual-prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get sparring stats from Trata AI like call count, prospect count, etc.
         * @summary Get Sparring Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSparringStatsV1SparrSparringStatsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/sparring-stats`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get virtual prospect associated with an agent
         * @summary Get Virtual Prospect by Agent ID
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet.');
            }
            const localVarPath = `/v1/sparr/agent/{agent_id}/virtual-prospect`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a virtual prospect
         * @summary Get Virtual Prospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectV1SparrVirtualProspectsProspectIdGet: async (prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling getVirtualProspectV1SparrVirtualProspectsProspectIdGet.');
            }
            const localVarPath = `/v1/sparr/virtual-prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Link a virtual prospect to an agent
         * @summary Link Virtual Prospect to Agent
         * @param {string} prospectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost: async (prospectId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost.');
            }
            const localVarPath = `/v1/sparr/virtual-prospects/{prospect_id}/agent/{agent_id}/link`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all virtual prospects
         * @summary List Virtual Prospects
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualProspectsV1SparrVirtualProspectsGet: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/virtual-prospects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a virtual prospect
         * @summary Update Virtual Prospect
         * @param {string} prospectId 
         * @param {VirtualProspectInput} virtualProspectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVirtualProspectV1SparrVirtualProspectsProspectIdPut: async (prospectId: string, virtualProspectInput: VirtualProspectInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling updateVirtualProspectV1SparrVirtualProspectsProspectIdPut.');
            }
            // verify required parameter 'virtualProspectInput' is not null or undefined
            if (virtualProspectInput === null || virtualProspectInput === undefined) {
                throw new RequiredError('virtualProspectInput','Required parameter virtualProspectInput was null or undefined when calling updateVirtualProspectV1SparrVirtualProspectsProspectIdPut.');
            }
            const localVarPath = `/v1/sparr/virtual-prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof virtualProspectInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(virtualProspectInput !== undefined ? virtualProspectInput : {}) : (virtualProspectInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SparringApi - functional programming interface
 * @export
 */
export const SparringApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a virtual prospect
         * @summary Create Virtual Prospect
         * @param {VirtualProspectInput} virtualProspectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput: VirtualProspectInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualProspectOutput>> {
            const localVarAxiosArgs = await SparringApiAxiosParamCreator(configuration).createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a virtual prospect
         * @summary Delete Virtual Prospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await SparringApiAxiosParamCreator(configuration).deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get sparring stats from Trata AI like call count, prospect count, etc.
         * @summary Get Sparring Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSparringStatsV1SparrSparringStatsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrStatsResponse>> {
            const localVarAxiosArgs = await SparringApiAxiosParamCreator(configuration).getSparringStatsV1SparrSparringStatsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get virtual prospect associated with an agent
         * @summary Get Virtual Prospect by Agent ID
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VirtualProspectOutput>>> {
            const localVarAxiosArgs = await SparringApiAxiosParamCreator(configuration).getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a virtual prospect
         * @summary Get Virtual Prospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualProspectOutput>> {
            const localVarAxiosArgs = await SparringApiAxiosParamCreator(configuration).getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Link a virtual prospect to an agent
         * @summary Link Virtual Prospect to Agent
         * @param {string} prospectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualProspectAIAgentLink>> {
            const localVarAxiosArgs = await SparringApiAxiosParamCreator(configuration).linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all virtual prospects
         * @summary List Virtual Prospects
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVirtualProspectsV1SparrVirtualProspectsGet(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VirtualProspectOutput>>> {
            const localVarAxiosArgs = await SparringApiAxiosParamCreator(configuration).listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a virtual prospect
         * @summary Update Virtual Prospect
         * @param {string} prospectId 
         * @param {VirtualProspectInput} virtualProspectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId: string, virtualProspectInput: VirtualProspectInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualProspectOutput>> {
            const localVarAxiosArgs = await SparringApiAxiosParamCreator(configuration).updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SparringApi - factory interface
 * @export
 */
export const SparringApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a virtual prospect
         * @summary Create Virtual Prospect
         * @param {VirtualProspectInput} virtualProspectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput: VirtualProspectInput, options?: any): AxiosPromise<VirtualProspectOutput> {
            return SparringApiFp(configuration).createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a virtual prospect
         * @summary Delete Virtual Prospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return SparringApiFp(configuration).deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get sparring stats from Trata AI like call count, prospect count, etc.
         * @summary Get Sparring Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSparringStatsV1SparrSparringStatsGet(options?: any): AxiosPromise<SparrStatsResponse> {
            return SparringApiFp(configuration).getSparringStatsV1SparrSparringStatsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get virtual prospect associated with an agent
         * @summary Get Virtual Prospect by Agent ID
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId: string, options?: any): AxiosPromise<Array<VirtualProspectOutput>> {
            return SparringApiFp(configuration).getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a virtual prospect
         * @summary Get Virtual Prospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId: string, options?: any): AxiosPromise<VirtualProspectOutput> {
            return SparringApiFp(configuration).getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Link a virtual prospect to an agent
         * @summary Link Virtual Prospect to Agent
         * @param {string} prospectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId: string, agentId: string, options?: any): AxiosPromise<VirtualProspectAIAgentLink> {
            return SparringApiFp(configuration).linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all virtual prospects
         * @summary List Virtual Prospects
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualProspectsV1SparrVirtualProspectsGet(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any): AxiosPromise<Array<VirtualProspectOutput>> {
            return SparringApiFp(configuration).listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a virtual prospect
         * @summary Update Virtual Prospect
         * @param {string} prospectId 
         * @param {VirtualProspectInput} virtualProspectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId: string, virtualProspectInput: VirtualProspectInput, options?: any): AxiosPromise<VirtualProspectOutput> {
            return SparringApiFp(configuration).updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SparringApi - object-oriented interface
 * @export
 * @class SparringApi
 * @extends {BaseAPI}
 */
export class SparringApi extends BaseAPI {
    /**
     * Create a virtual prospect
     * @summary Create Virtual Prospect
     * @param {VirtualProspectInput} virtualProspectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput: VirtualProspectInput, options?: any) {
        return SparringApiFp(this.configuration).createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a virtual prospect
     * @summary Delete Virtual Prospect
     * @param {string} prospectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId: string, options?: any) {
        return SparringApiFp(this.configuration).deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get sparring stats from Trata AI like call count, prospect count, etc.
     * @summary Get Sparring Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public getSparringStatsV1SparrSparringStatsGet(options?: any) {
        return SparringApiFp(this.configuration).getSparringStatsV1SparrSparringStatsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get virtual prospect associated with an agent
     * @summary Get Virtual Prospect by Agent ID
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId: string, options?: any) {
        return SparringApiFp(this.configuration).getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a virtual prospect
     * @summary Get Virtual Prospect
     * @param {string} prospectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId: string, options?: any) {
        return SparringApiFp(this.configuration).getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Link a virtual prospect to an agent
     * @summary Link Virtual Prospect to Agent
     * @param {string} prospectId 
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId: string, agentId: string, options?: any) {
        return SparringApiFp(this.configuration).linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all virtual prospects
     * @summary List Virtual Prospects
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [updatedAfter] 
     * @param {string} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public listVirtualProspectsV1SparrVirtualProspectsGet(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, options?: any) {
        return SparringApiFp(this.configuration).listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a virtual prospect
     * @summary Update Virtual Prospect
     * @param {string} prospectId 
     * @param {VirtualProspectInput} virtualProspectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId: string, virtualProspectInput: VirtualProspectInput, options?: any) {
        return SparringApiFp(this.configuration).updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TelephonyApi - axios parameter creator
 * @export
 */
export const TelephonyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Agent Phones
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentPhonesV1: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling getAgentPhonesV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}/phones`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Link Phone To Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPhoneToAgentV1: async (phoneId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'phoneId' is not null or undefined
            if (phoneId === null || phoneId === undefined) {
                throw new RequiredError('phoneId','Required parameter phoneId was null or undefined when calling linkPhoneToAgentV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling linkPhoneToAgentV1.');
            }
            const localVarPath = `/v1/telephony/phones/{phone_id}/ai-agents/{agent_id}/link`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Available Phones
         * @param {string} countryCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailablePhonesV1: async (countryCode: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryCode' is not null or undefined
            if (countryCode === null || countryCode === undefined) {
                throw new RequiredError('countryCode','Required parameter countryCode was null or undefined when calling listAvailablePhonesV1.');
            }
            const localVarPath = `/v1/telephony/countries/{country_code}/available-phones`
                .replace(`{${"country_code"}}`, encodeURIComponent(String(countryCode)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Purchased Phones
         * @param {string} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPurchasedPhonesV1: async (countryCode?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/telephony/phones`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedCountriesV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/telephony/countries`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePhoneV1: async (numberPurchaseRequest: NumberPurchaseRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'numberPurchaseRequest' is not null or undefined
            if (numberPurchaseRequest === null || numberPurchaseRequest === undefined) {
                throw new RequiredError('numberPurchaseRequest','Required parameter numberPurchaseRequest was null or undefined when calling purchasePhoneV1.');
            }
            const localVarPath = `/v1/telephony/phones`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof numberPurchaseRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(numberPurchaseRequest !== undefined ? numberPurchaseRequest : {}) : (numberPurchaseRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Release Phone
         * @param {string} phoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePhoneV1: async (phoneId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'phoneId' is not null or undefined
            if (phoneId === null || phoneId === undefined) {
                throw new RequiredError('phoneId','Required parameter phoneId was null or undefined when calling releasePhoneV1.');
            }
            const localVarPath = `/v1/telephony/phones/{phone_id}`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlink Phone From Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPhoneFromAgentV1: async (phoneId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'phoneId' is not null or undefined
            if (phoneId === null || phoneId === undefined) {
                throw new RequiredError('phoneId','Required parameter phoneId was null or undefined when calling unlinkPhoneFromAgentV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling unlinkPhoneFromAgentV1.');
            }
            const localVarPath = `/v1/telephony/phones/{phone_id}/ai-agents/{agent_id}/link`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TelephonyApi - functional programming interface
 * @export
 */
export const TelephonyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Agent Phones
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgentPhonesV1(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TelephoneNumber>>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).getAgentPhonesV1(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Link Phone To Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkPhoneToAgentV1(phoneId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).linkPhoneToAgentV1(phoneId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Available Phones
         * @param {string} countryCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAvailablePhonesV1(countryCode: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AvailablePhoneNumber>>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).listAvailablePhonesV1(countryCode, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Purchased Phones
         * @param {string} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPurchasedPhonesV1(countryCode?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TelephoneNumber>>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).listPurchasedPhonesV1(countryCode, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSupportedCountriesV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CountryInfo>>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).listSupportedCountriesV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchasePhoneV1(numberPurchaseRequest: NumberPurchaseRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TelephoneNumber>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).purchasePhoneV1(numberPurchaseRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Release Phone
         * @param {string} phoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async releasePhoneV1(phoneId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).releasePhoneV1(phoneId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Unlink Phone From Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkPhoneFromAgentV1(phoneId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).unlinkPhoneFromAgentV1(phoneId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TelephonyApi - factory interface
 * @export
 */
export const TelephonyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get Agent Phones
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentPhonesV1(agentId: string, options?: any): AxiosPromise<Array<TelephoneNumber>> {
            return TelephonyApiFp(configuration).getAgentPhonesV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Link Phone To Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPhoneToAgentV1(phoneId: string, agentId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return TelephonyApiFp(configuration).linkPhoneToAgentV1(phoneId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Available Phones
         * @param {string} countryCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailablePhonesV1(countryCode: string, options?: any): AxiosPromise<Array<AvailablePhoneNumber>> {
            return TelephonyApiFp(configuration).listAvailablePhonesV1(countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Purchased Phones
         * @param {string} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPurchasedPhonesV1(countryCode?: string, options?: any): AxiosPromise<Array<TelephoneNumber>> {
            return TelephonyApiFp(configuration).listPurchasedPhonesV1(countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedCountriesV1(options?: any): AxiosPromise<Array<CountryInfo>> {
            return TelephonyApiFp(configuration).listSupportedCountriesV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePhoneV1(numberPurchaseRequest: NumberPurchaseRequest, options?: any): AxiosPromise<TelephoneNumber> {
            return TelephonyApiFp(configuration).purchasePhoneV1(numberPurchaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Release Phone
         * @param {string} phoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePhoneV1(phoneId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return TelephonyApiFp(configuration).releasePhoneV1(phoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlink Phone From Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPhoneFromAgentV1(phoneId: string, agentId: string, options?: any): AxiosPromise<BaseResponseInput> {
            return TelephonyApiFp(configuration).unlinkPhoneFromAgentV1(phoneId, agentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TelephonyApi - object-oriented interface
 * @export
 * @class TelephonyApi
 * @extends {BaseAPI}
 */
export class TelephonyApi extends BaseAPI {
    /**
     * 
     * @summary Get Agent Phones
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public getAgentPhonesV1(agentId: string, options?: any) {
        return TelephonyApiFp(this.configuration).getAgentPhonesV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Link Phone To Agent
     * @param {string} phoneId 
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public linkPhoneToAgentV1(phoneId: string, agentId: string, options?: any) {
        return TelephonyApiFp(this.configuration).linkPhoneToAgentV1(phoneId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Available Phones
     * @param {string} countryCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public listAvailablePhonesV1(countryCode: string, options?: any) {
        return TelephonyApiFp(this.configuration).listAvailablePhonesV1(countryCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Purchased Phones
     * @param {string} [countryCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public listPurchasedPhonesV1(countryCode?: string, options?: any) {
        return TelephonyApiFp(this.configuration).listPurchasedPhonesV1(countryCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Supported Countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public listSupportedCountriesV1(options?: any) {
        return TelephonyApiFp(this.configuration).listSupportedCountriesV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purchase Phone
     * @param {NumberPurchaseRequest} numberPurchaseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public purchasePhoneV1(numberPurchaseRequest: NumberPurchaseRequest, options?: any) {
        return TelephonyApiFp(this.configuration).purchasePhoneV1(numberPurchaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Release Phone
     * @param {string} phoneId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public releasePhoneV1(phoneId: string, options?: any) {
        return TelephonyApiFp(this.configuration).releasePhoneV1(phoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlink Phone From Agent
     * @param {string} phoneId 
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public unlinkPhoneFromAgentV1(phoneId: string, agentId: string, options?: any) {
        return TelephonyApiFp(this.configuration).unlinkPhoneFromAgentV1(phoneId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UIApi - axios parameter creator
 * @export
 */
export const UIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Action Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionTemplatesV1: async (language?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ui/action-templates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Products
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {string} [tags] 
         * @param {string} [productIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsDetailedV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, tags?: string, productIds?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ui/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = updatedBefore;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (productIds !== undefined) {
                localVarQueryParameter['product_ids'] = productIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Prompt Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptTemplatesV1: async (language?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ui/prompt-templates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Role Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleTemplatesV1: async (language?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ui/role-templates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UIApi - functional programming interface
 * @export
 */
export const UIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Action Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActionTemplatesV1(language?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActionInput>>> {
            const localVarAxiosArgs = await UIApiAxiosParamCreator(configuration).listActionTemplatesV1(language, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Products
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {string} [tags] 
         * @param {string} [productIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProductsDetailedV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, tags?: string, productIds?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductWithAgents>>> {
            const localVarAxiosArgs = await UIApiAxiosParamCreator(configuration).listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Prompt Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPromptTemplatesV1(language?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: PromptTemplate; }>> {
            const localVarAxiosArgs = await UIApiAxiosParamCreator(configuration).listPromptTemplatesV1(language, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Role Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoleTemplatesV1(language?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleTemplate>>> {
            const localVarAxiosArgs = await UIApiAxiosParamCreator(configuration).listRoleTemplatesV1(language, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UIApi - factory interface
 * @export
 */
export const UIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary List Action Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionTemplatesV1(language?: string, options?: any): AxiosPromise<Array<ActionInput>> {
            return UIApiFp(configuration).listActionTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Products
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [updatedAfter] 
         * @param {string} [updatedBefore] 
         * @param {string} [tags] 
         * @param {string} [productIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsDetailedV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, tags?: string, productIds?: string, options?: any): AxiosPromise<Array<ProductWithAgents>> {
            return UIApiFp(configuration).listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Prompt Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptTemplatesV1(language?: string, options?: any): AxiosPromise<{ [key: string]: PromptTemplate; }> {
            return UIApiFp(configuration).listPromptTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Role Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleTemplatesV1(language?: string, options?: any): AxiosPromise<Array<RoleTemplate>> {
            return UIApiFp(configuration).listRoleTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UIApi - object-oriented interface
 * @export
 * @class UIApi
 * @extends {BaseAPI}
 */
export class UIApi extends BaseAPI {
    /**
     * 
     * @summary List Action Templates
     * @param {string} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    public listActionTemplatesV1(language?: string, options?: any) {
        return UIApiFp(this.configuration).listActionTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Products
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [updatedAfter] 
     * @param {string} [updatedBefore] 
     * @param {string} [tags] 
     * @param {string} [productIds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    public listProductsDetailedV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, updatedAfter?: string, updatedBefore?: string, tags?: string, productIds?: string, options?: any) {
        return UIApiFp(this.configuration).listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Prompt Templates
     * @param {string} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    public listPromptTemplatesV1(language?: string, options?: any) {
        return UIApiFp(this.configuration).listPromptTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Role Templates
     * @param {string} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    public listRoleTemplatesV1(language?: string, options?: any) {
        return UIApiFp(this.configuration).listRoleTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * VoiceModelsApi - axios parameter creator
 * @export
 */
export const VoiceModelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get List Of Voices Available For Sparr
         * @summary Get List Of Voices Available For Sparr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSparrVoiceModelsV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr-voice-models`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get List Of Voices Available For Conversations
         * @summary Get List Of Voices Available For Conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceModelsV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/voice-models`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoiceModelsApi - functional programming interface
 * @export
 */
export const VoiceModelsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get List Of Voices Available For Sparr
         * @summary Get List Of Voices Available For Sparr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSparrVoiceModelsV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VoiceModel>>> {
            const localVarAxiosArgs = await VoiceModelsApiAxiosParamCreator(configuration).listSparrVoiceModelsV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get List Of Voices Available For Conversations
         * @summary Get List Of Voices Available For Conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVoiceModelsV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VoiceModel>>> {
            const localVarAxiosArgs = await VoiceModelsApiAxiosParamCreator(configuration).listVoiceModelsV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VoiceModelsApi - factory interface
 * @export
 */
export const VoiceModelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get List Of Voices Available For Sparr
         * @summary Get List Of Voices Available For Sparr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSparrVoiceModelsV1(options?: any): AxiosPromise<Array<VoiceModel>> {
            return VoiceModelsApiFp(configuration).listSparrVoiceModelsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get List Of Voices Available For Conversations
         * @summary Get List Of Voices Available For Conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceModelsV1(options?: any): AxiosPromise<Array<VoiceModel>> {
            return VoiceModelsApiFp(configuration).listVoiceModelsV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VoiceModelsApi - object-oriented interface
 * @export
 * @class VoiceModelsApi
 * @extends {BaseAPI}
 */
export class VoiceModelsApi extends BaseAPI {
    /**
     * Get List Of Voices Available For Sparr
     * @summary Get List Of Voices Available For Sparr
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceModelsApi
     */
    public listSparrVoiceModelsV1(options?: any) {
        return VoiceModelsApiFp(this.configuration).listSparrVoiceModelsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get List Of Voices Available For Conversations
     * @summary Get List Of Voices Available For Conversations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceModelsApi
     */
    public listVoiceModelsV1(options?: any) {
        return VoiceModelsApiFp(this.configuration).listVoiceModelsV1(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WorkflowsApi - axios parameter creator
 * @export
 */
export const WorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Workflow
         * @param {WorkflowCore} workflowCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowV1WorkflowsPost: async (workflowCore: WorkflowCore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowCore' is not null or undefined
            if (workflowCore === null || workflowCore === undefined) {
                throw new RequiredError('workflowCore','Required parameter workflowCore was null or undefined when calling createWorkflowV1WorkflowsPost.');
            }
            const localVarPath = `/v1/workflows/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof workflowCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(workflowCore !== undefined ? workflowCore : {}) : (workflowCore || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowV1WorkflowsWorkflowIdDelete: async (workflowId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling deleteWorkflowV1WorkflowsWorkflowIdDelete.');
            }
            const localVarPath = `/v1/workflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowV1WorkflowsWorkflowIdGet: async (workflowId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling readWorkflowV1WorkflowsWorkflowIdGet.');
            }
            const localVarPath = `/v1/workflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Workflows
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {AgenticWorkflowAdkModelsWorkflowAppEnum} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowsV1WorkflowsGet: async (skip?: number, limit?: number, app?: AgenticWorkflowAdkModelsWorkflowAppEnum, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/workflows/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger Workflow Step
         * @param {string} workflowId 
         * @param {string} stepId 
         * @param {WorkflowStepTriggerRequest} workflowStepTriggerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost: async (workflowId: string, stepId: string, workflowStepTriggerRequest: WorkflowStepTriggerRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost.');
            }
            // verify required parameter 'stepId' is not null or undefined
            if (stepId === null || stepId === undefined) {
                throw new RequiredError('stepId','Required parameter stepId was null or undefined when calling triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost.');
            }
            // verify required parameter 'workflowStepTriggerRequest' is not null or undefined
            if (workflowStepTriggerRequest === null || workflowStepTriggerRequest === undefined) {
                throw new RequiredError('workflowStepTriggerRequest','Required parameter workflowStepTriggerRequest was null or undefined when calling triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost.');
            }
            const localVarPath = `/v1/workflows/{workflow_id}/step/{step_id}/trigger`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)))
                .replace(`{${"step_id"}}`, encodeURIComponent(String(stepId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof workflowStepTriggerRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(workflowStepTriggerRequest !== undefined ? workflowStepTriggerRequest : {}) : (workflowStepTriggerRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Workflow
         * @param {string} workflowId 
         * @param {WorkflowCore} workflowCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowV1WorkflowsWorkflowIdPut: async (workflowId: string, workflowCore: WorkflowCore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling updateWorkflowV1WorkflowsWorkflowIdPut.');
            }
            // verify required parameter 'workflowCore' is not null or undefined
            if (workflowCore === null || workflowCore === undefined) {
                throw new RequiredError('workflowCore','Required parameter workflowCore was null or undefined when calling updateWorkflowV1WorkflowsWorkflowIdPut.');
            }
            const localVarPath = `/v1/workflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof workflowCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(workflowCore !== undefined ? workflowCore : {}) : (workflowCore || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload File
         * @param {string} workflowId 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1WorkflowsWorkflowIdFilePost: async (workflowId: string, file: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling uploadFileV1WorkflowsWorkflowIdFilePost.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling uploadFileV1WorkflowsWorkflowIdFilePost.');
            }
            const localVarPath = `/v1/workflows/{workflow_id}/file`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsApi - functional programming interface
 * @export
 */
export const WorkflowsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Workflow
         * @param {WorkflowCore} workflowCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflowV1WorkflowsPost(workflowCore: WorkflowCore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await WorkflowsApiAxiosParamCreator(configuration).createWorkflowV1WorkflowsPost(workflowCore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await WorkflowsApiAxiosParamCreator(configuration).deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Read Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readWorkflowV1WorkflowsWorkflowIdGet(workflowId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await WorkflowsApiAxiosParamCreator(configuration).readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Read Workflows
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {AgenticWorkflowAdkModelsWorkflowAppEnum} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readWorkflowsV1WorkflowsGet(skip?: number, limit?: number, app?: AgenticWorkflowAdkModelsWorkflowAppEnum, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workflow>>> {
            const localVarAxiosArgs = await WorkflowsApiAxiosParamCreator(configuration).readWorkflowsV1WorkflowsGet(skip, limit, app, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Trigger Workflow Step
         * @param {string} workflowId 
         * @param {string} stepId 
         * @param {WorkflowStepTriggerRequest} workflowStepTriggerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId: string, stepId: string, workflowStepTriggerRequest: WorkflowStepTriggerRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowStepTriggerResponse>> {
            const localVarAxiosArgs = await WorkflowsApiAxiosParamCreator(configuration).triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update Workflow
         * @param {string} workflowId 
         * @param {WorkflowCore} workflowCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkflowV1WorkflowsWorkflowIdPut(workflowId: string, workflowCore: WorkflowCore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await WorkflowsApiAxiosParamCreator(configuration).updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Upload File
         * @param {string} workflowId 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileV1WorkflowsWorkflowIdFilePost(workflowId: string, file: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadFileResponse>> {
            const localVarAxiosArgs = await WorkflowsApiAxiosParamCreator(configuration).uploadFileV1WorkflowsWorkflowIdFilePost(workflowId, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkflowsApi - factory interface
 * @export
 */
export const WorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create Workflow
         * @param {WorkflowCore} workflowCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowV1WorkflowsPost(workflowCore: WorkflowCore, options?: any): AxiosPromise<Workflow> {
            return WorkflowsApiFp(configuration).createWorkflowV1WorkflowsPost(workflowCore, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId: string, options?: any): AxiosPromise<AgenticWorkflowModelsBaseBaseResponse> {
            return WorkflowsApiFp(configuration).deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowV1WorkflowsWorkflowIdGet(workflowId: string, options?: any): AxiosPromise<Workflow> {
            return WorkflowsApiFp(configuration).readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Workflows
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {AgenticWorkflowAdkModelsWorkflowAppEnum} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowsV1WorkflowsGet(skip?: number, limit?: number, app?: AgenticWorkflowAdkModelsWorkflowAppEnum, options?: any): AxiosPromise<Array<Workflow>> {
            return WorkflowsApiFp(configuration).readWorkflowsV1WorkflowsGet(skip, limit, app, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger Workflow Step
         * @param {string} workflowId 
         * @param {string} stepId 
         * @param {WorkflowStepTriggerRequest} workflowStepTriggerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId: string, stepId: string, workflowStepTriggerRequest: WorkflowStepTriggerRequest, options?: any): AxiosPromise<WorkflowStepTriggerResponse> {
            return WorkflowsApiFp(configuration).triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Workflow
         * @param {string} workflowId 
         * @param {WorkflowCore} workflowCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowV1WorkflowsWorkflowIdPut(workflowId: string, workflowCore: WorkflowCore, options?: any): AxiosPromise<Workflow> {
            return WorkflowsApiFp(configuration).updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload File
         * @param {string} workflowId 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1WorkflowsWorkflowIdFilePost(workflowId: string, file: any, options?: any): AxiosPromise<UploadFileResponse> {
            return WorkflowsApiFp(configuration).uploadFileV1WorkflowsWorkflowIdFilePost(workflowId, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsApi
 * @extends {BaseAPI}
 */
export class WorkflowsApi extends BaseAPI {
    /**
     * 
     * @summary Create Workflow
     * @param {WorkflowCore} workflowCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public createWorkflowV1WorkflowsPost(workflowCore: WorkflowCore, options?: any) {
        return WorkflowsApiFp(this.configuration).createWorkflowV1WorkflowsPost(workflowCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Workflow
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId: string, options?: any) {
        return WorkflowsApiFp(this.configuration).deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Workflow
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public readWorkflowV1WorkflowsWorkflowIdGet(workflowId: string, options?: any) {
        return WorkflowsApiFp(this.configuration).readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Workflows
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {AgenticWorkflowAdkModelsWorkflowAppEnum} [app] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public readWorkflowsV1WorkflowsGet(skip?: number, limit?: number, app?: AgenticWorkflowAdkModelsWorkflowAppEnum, options?: any) {
        return WorkflowsApiFp(this.configuration).readWorkflowsV1WorkflowsGet(skip, limit, app, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger Workflow Step
     * @param {string} workflowId 
     * @param {string} stepId 
     * @param {WorkflowStepTriggerRequest} workflowStepTriggerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId: string, stepId: string, workflowStepTriggerRequest: WorkflowStepTriggerRequest, options?: any) {
        return WorkflowsApiFp(this.configuration).triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Workflow
     * @param {string} workflowId 
     * @param {WorkflowCore} workflowCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public updateWorkflowV1WorkflowsWorkflowIdPut(workflowId: string, workflowCore: WorkflowCore, options?: any) {
        return WorkflowsApiFp(this.configuration).updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload File
     * @param {string} workflowId 
     * @param {any} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public uploadFileV1WorkflowsWorkflowIdFilePost(workflowId: string, file: any, options?: any) {
        return WorkflowsApiFp(this.configuration).uploadFileV1WorkflowsWorkflowIdFilePost(workflowId, file, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WorkflowsApiHubspotApi - axios parameter creator
 * @export
 */
export const WorkflowsApiHubspotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Handle Hubspot Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/workflows/api/hubspot/webhook`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsApiHubspotApi - functional programming interface
 * @export
 */
export const WorkflowsApiHubspotApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Handle Hubspot Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await WorkflowsApiHubspotApiAxiosParamCreator(configuration).handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkflowsApiHubspotApi - factory interface
 * @export
 */
export const WorkflowsApiHubspotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Handle Hubspot Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options?: any): AxiosPromise<AgenticWorkflowModelsBaseBaseResponse> {
            return WorkflowsApiHubspotApiFp(configuration).handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsApiHubspotApi - object-oriented interface
 * @export
 * @class WorkflowsApiHubspotApi
 * @extends {BaseAPI}
 */
export class WorkflowsApiHubspotApi extends BaseAPI {
    /**
     * 
     * @summary Handle Hubspot Webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApiHubspotApi
     */
    public handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options?: any) {
        return WorkflowsApiHubspotApiFp(this.configuration).handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WorkflowsAppsApi - axios parameter creator
 * @export
 */
export const WorkflowsAppsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create App
         * @param {AppEntity} appEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAppV1WorkflowsAppsPost: async (appEntity: AppEntity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appEntity' is not null or undefined
            if (appEntity === null || appEntity === undefined) {
                throw new RequiredError('appEntity','Required parameter appEntity was null or undefined when calling createAppV1WorkflowsAppsPost.');
            }
            const localVarPath = `/v1/workflows/apps/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof appEntity !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(appEntity !== undefined ? appEntity : {}) : (appEntity || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete App
         * @param {string} appId 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppV1WorkflowsAppsAppIdDelete: async (appId: string, version?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling deleteAppV1WorkflowsAppsAppIdDelete.');
            }
            const localVarPath = `/v1/workflows/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Connections By App Id
         * @param {string} appId 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet: async (appId: string, version: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet.');
            }
            const localVarPath = `/v1/workflows/apps/{app_id}/versions/{version}/connections`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read App
         * @param {string} appId 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppV1WorkflowsAppsAppIdGet: async (appId: string, version?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling readAppV1WorkflowsAppsAppIdGet.');
            }
            const localVarPath = `/v1/workflows/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Apps
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppsV1WorkflowsAppsGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/workflows/apps/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update App
         * @param {string} appId 
         * @param {AppEntity} appEntity 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppV1WorkflowsAppsAppIdPut: async (appId: string, appEntity: AppEntity, version?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling updateAppV1WorkflowsAppsAppIdPut.');
            }
            // verify required parameter 'appEntity' is not null or undefined
            if (appEntity === null || appEntity === undefined) {
                throw new RequiredError('appEntity','Required parameter appEntity was null or undefined when calling updateAppV1WorkflowsAppsAppIdPut.');
            }
            const localVarPath = `/v1/workflows/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof appEntity !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(appEntity !== undefined ? appEntity : {}) : (appEntity || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsAppsApi - functional programming interface
 * @export
 */
export const WorkflowsAppsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create App
         * @param {AppEntity} appEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAppV1WorkflowsAppsPost(appEntity: AppEntity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppResponse>> {
            const localVarAxiosArgs = await WorkflowsAppsApiAxiosParamCreator(configuration).createAppV1WorkflowsAppsPost(appEntity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete App
         * @param {string} appId 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAppV1WorkflowsAppsAppIdDelete(appId: string, version?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await WorkflowsAppsApiAxiosParamCreator(configuration).deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Connections By App Id
         * @param {string} appId 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId: string, version: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConnectionCore>>> {
            const localVarAxiosArgs = await WorkflowsAppsApiAxiosParamCreator(configuration).getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Read App
         * @param {string} appId 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readAppV1WorkflowsAppsAppIdGet(appId: string, version?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppResponse>> {
            const localVarAxiosArgs = await WorkflowsAppsApiAxiosParamCreator(configuration).readAppV1WorkflowsAppsAppIdGet(appId, version, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Read Apps
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readAppsV1WorkflowsAppsGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AppResponse>>> {
            const localVarAxiosArgs = await WorkflowsAppsApiAxiosParamCreator(configuration).readAppsV1WorkflowsAppsGet(skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update App
         * @param {string} appId 
         * @param {AppEntity} appEntity 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAppV1WorkflowsAppsAppIdPut(appId: string, appEntity: AppEntity, version?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppResponse>> {
            const localVarAxiosArgs = await WorkflowsAppsApiAxiosParamCreator(configuration).updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkflowsAppsApi - factory interface
 * @export
 */
export const WorkflowsAppsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create App
         * @param {AppEntity} appEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAppV1WorkflowsAppsPost(appEntity: AppEntity, options?: any): AxiosPromise<AppResponse> {
            return WorkflowsAppsApiFp(configuration).createAppV1WorkflowsAppsPost(appEntity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete App
         * @param {string} appId 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppV1WorkflowsAppsAppIdDelete(appId: string, version?: string, options?: any): AxiosPromise<AgenticWorkflowModelsBaseBaseResponse> {
            return WorkflowsAppsApiFp(configuration).deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Connections By App Id
         * @param {string} appId 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId: string, version: string, options?: any): AxiosPromise<Array<ConnectionCore>> {
            return WorkflowsAppsApiFp(configuration).getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read App
         * @param {string} appId 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppV1WorkflowsAppsAppIdGet(appId: string, version?: string, options?: any): AxiosPromise<AppResponse> {
            return WorkflowsAppsApiFp(configuration).readAppV1WorkflowsAppsAppIdGet(appId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Apps
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppsV1WorkflowsAppsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<AppResponse>> {
            return WorkflowsAppsApiFp(configuration).readAppsV1WorkflowsAppsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update App
         * @param {string} appId 
         * @param {AppEntity} appEntity 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppV1WorkflowsAppsAppIdPut(appId: string, appEntity: AppEntity, version?: string, options?: any): AxiosPromise<AppResponse> {
            return WorkflowsAppsApiFp(configuration).updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsAppsApi - object-oriented interface
 * @export
 * @class WorkflowsAppsApi
 * @extends {BaseAPI}
 */
export class WorkflowsAppsApi extends BaseAPI {
    /**
     * 
     * @summary Create App
     * @param {AppEntity} appEntity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    public createAppV1WorkflowsAppsPost(appEntity: AppEntity, options?: any) {
        return WorkflowsAppsApiFp(this.configuration).createAppV1WorkflowsAppsPost(appEntity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete App
     * @param {string} appId 
     * @param {string} [version] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    public deleteAppV1WorkflowsAppsAppIdDelete(appId: string, version?: string, options?: any) {
        return WorkflowsAppsApiFp(this.configuration).deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Connections By App Id
     * @param {string} appId 
     * @param {string} version 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    public getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId: string, version: string, options?: any) {
        return WorkflowsAppsApiFp(this.configuration).getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read App
     * @param {string} appId 
     * @param {string} [version] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    public readAppV1WorkflowsAppsAppIdGet(appId: string, version?: string, options?: any) {
        return WorkflowsAppsApiFp(this.configuration).readAppV1WorkflowsAppsAppIdGet(appId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Apps
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    public readAppsV1WorkflowsAppsGet(skip?: number, limit?: number, options?: any) {
        return WorkflowsAppsApiFp(this.configuration).readAppsV1WorkflowsAppsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update App
     * @param {string} appId 
     * @param {AppEntity} appEntity 
     * @param {string} [version] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    public updateAppV1WorkflowsAppsAppIdPut(appId: string, appEntity: AppEntity, version?: string, options?: any) {
        return WorkflowsAppsApiFp(this.configuration).updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WorkflowsConnectionsApi - axios parameter creator
 * @export
 */
export const WorkflowsConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Connection
         * @param {ConnectionCore} connectionCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectionV1WorkflowsConnectionsPost: async (connectionCore: ConnectionCore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionCore' is not null or undefined
            if (connectionCore === null || connectionCore === undefined) {
                throw new RequiredError('connectionCore','Required parameter connectionCore was null or undefined when calling createConnectionV1WorkflowsConnectionsPost.');
            }
            const localVarPath = `/v1/workflows/connections/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof connectionCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(connectionCore !== undefined ? connectionCore : {}) : (connectionCore || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectionV1WorkflowsConnectionsConnectionIdDelete: async (connectionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            if (connectionId === null || connectionId === undefined) {
                throw new RequiredError('connectionId','Required parameter connectionId was null or undefined when calling deleteConnectionV1WorkflowsConnectionsConnectionIdDelete.');
            }
            const localVarPath = `/v1/workflows/connections/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionV1WorkflowsConnectionsConnectionIdGet: async (connectionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            if (connectionId === null || connectionId === undefined) {
                throw new RequiredError('connectionId','Required parameter connectionId was null or undefined when calling readConnectionV1WorkflowsConnectionsConnectionIdGet.');
            }
            const localVarPath = `/v1/workflows/connections/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Connections
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionsV1WorkflowsConnectionsGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/workflows/connections/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Connection
         * @param {string} connectionId 
         * @param {ConnectionCore} connectionCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnectionV1WorkflowsConnectionsConnectionIdPut: async (connectionId: string, connectionCore: ConnectionCore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            if (connectionId === null || connectionId === undefined) {
                throw new RequiredError('connectionId','Required parameter connectionId was null or undefined when calling updateConnectionV1WorkflowsConnectionsConnectionIdPut.');
            }
            // verify required parameter 'connectionCore' is not null or undefined
            if (connectionCore === null || connectionCore === undefined) {
                throw new RequiredError('connectionCore','Required parameter connectionCore was null or undefined when calling updateConnectionV1WorkflowsConnectionsConnectionIdPut.');
            }
            const localVarPath = `/v1/workflows/connections/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof connectionCore !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(connectionCore !== undefined ? connectionCore : {}) : (connectionCore || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsConnectionsApi - functional programming interface
 * @export
 */
export const WorkflowsConnectionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Connection
         * @param {ConnectionCore} connectionCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnectionV1WorkflowsConnectionsPost(connectionCore: ConnectionCore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowDbModelsConnection>> {
            const localVarAxiosArgs = await WorkflowsConnectionsApiAxiosParamCreator(configuration).createConnectionV1WorkflowsConnectionsPost(connectionCore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await WorkflowsConnectionsApiAxiosParamCreator(configuration).deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Read Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowDbModelsConnection>> {
            const localVarAxiosArgs = await WorkflowsConnectionsApiAxiosParamCreator(configuration).readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Read Connections
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readConnectionsV1WorkflowsConnectionsGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AgenticWorkflowDbModelsConnection>>> {
            const localVarAxiosArgs = await WorkflowsConnectionsApiAxiosParamCreator(configuration).readConnectionsV1WorkflowsConnectionsGet(skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update Connection
         * @param {string} connectionId 
         * @param {ConnectionCore} connectionCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId: string, connectionCore: ConnectionCore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowDbModelsConnection>> {
            const localVarAxiosArgs = await WorkflowsConnectionsApiAxiosParamCreator(configuration).updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkflowsConnectionsApi - factory interface
 * @export
 */
export const WorkflowsConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create Connection
         * @param {ConnectionCore} connectionCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectionV1WorkflowsConnectionsPost(connectionCore: ConnectionCore, options?: any): AxiosPromise<AgenticWorkflowDbModelsConnection> {
            return WorkflowsConnectionsApiFp(configuration).createConnectionV1WorkflowsConnectionsPost(connectionCore, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId: string, options?: any): AxiosPromise<AgenticWorkflowModelsBaseBaseResponse> {
            return WorkflowsConnectionsApiFp(configuration).deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId: string, options?: any): AxiosPromise<AgenticWorkflowDbModelsConnection> {
            return WorkflowsConnectionsApiFp(configuration).readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Connections
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionsV1WorkflowsConnectionsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<AgenticWorkflowDbModelsConnection>> {
            return WorkflowsConnectionsApiFp(configuration).readConnectionsV1WorkflowsConnectionsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Connection
         * @param {string} connectionId 
         * @param {ConnectionCore} connectionCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId: string, connectionCore: ConnectionCore, options?: any): AxiosPromise<AgenticWorkflowDbModelsConnection> {
            return WorkflowsConnectionsApiFp(configuration).updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsConnectionsApi - object-oriented interface
 * @export
 * @class WorkflowsConnectionsApi
 * @extends {BaseAPI}
 */
export class WorkflowsConnectionsApi extends BaseAPI {
    /**
     * 
     * @summary Create Connection
     * @param {ConnectionCore} connectionCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    public createConnectionV1WorkflowsConnectionsPost(connectionCore: ConnectionCore, options?: any) {
        return WorkflowsConnectionsApiFp(this.configuration).createConnectionV1WorkflowsConnectionsPost(connectionCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Connection
     * @param {string} connectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    public deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId: string, options?: any) {
        return WorkflowsConnectionsApiFp(this.configuration).deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Connection
     * @param {string} connectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    public readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId: string, options?: any) {
        return WorkflowsConnectionsApiFp(this.configuration).readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Connections
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    public readConnectionsV1WorkflowsConnectionsGet(skip?: number, limit?: number, options?: any) {
        return WorkflowsConnectionsApiFp(this.configuration).readConnectionsV1WorkflowsConnectionsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Connection
     * @param {string} connectionId 
     * @param {ConnectionCore} connectionCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    public updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId: string, connectionCore: ConnectionCore, options?: any) {
        return WorkflowsConnectionsApiFp(this.configuration).updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WorkflowsExecutionsApi - axios parameter creator
 * @export
 */
export const WorkflowsExecutionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Execute a workflow. This is an Sync call. This returns the status of the workflow
         * @summary Execute Workflow
         * @param {string} workflowId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost: async (workflowId: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost.');
            }
            const localVarPath = `/v1/workflows/executions/{workflow_id}/execute`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status of a workflow given the run id
         * @summary Get Workflow Status
         * @param {string} runId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet: async (runId: string, workflowId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet.');
            }
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet.');
            }
            const localVarPath = `/v1/workflows/executions/{workflow_id}/runs/{run_id}`
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)))
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Workflow Runs
         * @param {string} workflowId 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet: async (workflowId: string, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet.');
            }
            const localVarPath = `/v1/workflows/executions/{workflow_id}/runs`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger a workflow execution. This is an Async call. This returns a workflow id which can be queried to get the status of the workflow
         * @summary Trigger Workflow
         * @param {string} workflowId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost: async (workflowId: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost.');
            }
            const localVarPath = `/v1/workflows/executions/{workflow_id}/trigger`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsExecutionsApi - functional programming interface
 * @export
 */
export const WorkflowsExecutionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Execute a workflow. This is an Sync call. This returns the status of the workflow
         * @summary Execute Workflow
         * @param {string} workflowId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowExecution>> {
            const localVarAxiosArgs = await WorkflowsExecutionsApiAxiosParamCreator(configuration).executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the status of a workflow given the run id
         * @summary Get Workflow Status
         * @param {string} runId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId: string, workflowId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowExecution>> {
            const localVarAxiosArgs = await WorkflowsExecutionsApiAxiosParamCreator(configuration).getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Workflow Runs
         * @param {string} workflowId 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId: string, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowExecution>>> {
            const localVarAxiosArgs = await WorkflowsExecutionsApiAxiosParamCreator(configuration).listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Trigger a workflow execution. This is an Async call. This returns a workflow id which can be queried to get the status of the workflow
         * @summary Trigger Workflow
         * @param {string} workflowId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowExecution>> {
            const localVarAxiosArgs = await WorkflowsExecutionsApiAxiosParamCreator(configuration).triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkflowsExecutionsApi - factory interface
 * @export
 */
export const WorkflowsExecutionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Execute a workflow. This is an Sync call. This returns the status of the workflow
         * @summary Execute Workflow
         * @param {string} workflowId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId: string, body: object, options?: any): AxiosPromise<WorkflowExecution> {
            return WorkflowsExecutionsApiFp(configuration).executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status of a workflow given the run id
         * @summary Get Workflow Status
         * @param {string} runId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId: string, workflowId: string, options?: any): AxiosPromise<WorkflowExecution> {
            return WorkflowsExecutionsApiFp(configuration).getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Workflow Runs
         * @param {string} workflowId 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId: string, skip?: number, limit?: number, options?: any): AxiosPromise<Array<WorkflowExecution>> {
            return WorkflowsExecutionsApiFp(configuration).listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger a workflow execution. This is an Async call. This returns a workflow id which can be queried to get the status of the workflow
         * @summary Trigger Workflow
         * @param {string} workflowId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId: string, body: object, options?: any): AxiosPromise<WorkflowExecution> {
            return WorkflowsExecutionsApiFp(configuration).triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsExecutionsApi - object-oriented interface
 * @export
 * @class WorkflowsExecutionsApi
 * @extends {BaseAPI}
 */
export class WorkflowsExecutionsApi extends BaseAPI {
    /**
     * Execute a workflow. This is an Sync call. This returns the status of the workflow
     * @summary Execute Workflow
     * @param {string} workflowId 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsExecutionsApi
     */
    public executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId: string, body: object, options?: any) {
        return WorkflowsExecutionsApiFp(this.configuration).executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the status of a workflow given the run id
     * @summary Get Workflow Status
     * @param {string} runId 
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsExecutionsApi
     */
    public getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId: string, workflowId: string, options?: any) {
        return WorkflowsExecutionsApiFp(this.configuration).getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Workflow Runs
     * @param {string} workflowId 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsExecutionsApi
     */
    public listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId: string, skip?: number, limit?: number, options?: any) {
        return WorkflowsExecutionsApiFp(this.configuration).listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger a workflow execution. This is an Async call. This returns a workflow id which can be queried to get the status of the workflow
     * @summary Trigger Workflow
     * @param {string} workflowId 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsExecutionsApi
     */
    public triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId: string, body: object, options?: any) {
        return WorkflowsExecutionsApiFp(this.configuration).triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WorkflowsSubWorkflowsApi - axios parameter creator
 * @export
 */
export const WorkflowsSubWorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all sub workflows which can be invoked for a given workflow step
         * @summary Get Sub Workflows
         * @param {WorkflowStepInput} workflowStepInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost: async (workflowStepInput: WorkflowStepInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowStepInput' is not null or undefined
            if (workflowStepInput === null || workflowStepInput === undefined) {
                throw new RequiredError('workflowStepInput','Required parameter workflowStepInput was null or undefined when calling getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost.');
            }
            const localVarPath = `/v1/workflows/steps/sub_workflows`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof workflowStepInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(workflowStepInput !== undefined ? workflowStepInput : {}) : (workflowStepInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsSubWorkflowsApi - functional programming interface
 * @export
 */
export const WorkflowsSubWorkflowsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns all sub workflows which can be invoked for a given workflow step
         * @summary Get Sub Workflows
         * @param {WorkflowStepInput} workflowStepInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput: WorkflowStepInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workflow>>> {
            const localVarAxiosArgs = await WorkflowsSubWorkflowsApiAxiosParamCreator(configuration).getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkflowsSubWorkflowsApi - factory interface
 * @export
 */
export const WorkflowsSubWorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns all sub workflows which can be invoked for a given workflow step
         * @summary Get Sub Workflows
         * @param {WorkflowStepInput} workflowStepInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput: WorkflowStepInput, options?: any): AxiosPromise<Array<Workflow>> {
            return WorkflowsSubWorkflowsApiFp(configuration).getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsSubWorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsSubWorkflowsApi
 * @extends {BaseAPI}
 */
export class WorkflowsSubWorkflowsApi extends BaseAPI {
    /**
     * Returns all sub workflows which can be invoked for a given workflow step
     * @summary Get Sub Workflows
     * @param {WorkflowStepInput} workflowStepInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsSubWorkflowsApi
     */
    public getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput: WorkflowStepInput, options?: any) {
        return WorkflowsSubWorkflowsApiFp(this.configuration).getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options).then((request) => request(this.axios, this.basePath));
    }

}


