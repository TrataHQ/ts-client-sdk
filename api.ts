/* tslint:disable */
/* eslint-disable */
/**
 * Trata AI API
 * Human like conversation to answer calls, drive engagement, automate follow-ups & schedule bookings 24/7  with end to end integrations ensuring you never miss a sales enquiry.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AIAgentInput
 */
export interface AIAgentInput {
    /**
     * Name of the AI agent
     * @type {string}
     * @memberof AIAgentInput
     */
    'name': string;
    /**
     * Image URL for the AI agent
     * @type {string}
     * @memberof AIAgentInput
     */
    'imageUrl': string;
    /**
     * 
     * @type {Mission}
     * @memberof AIAgentInput
     */
    'mission'?: Mission | null;
    /**
     * 
     * @type {Status}
     * @memberof AIAgentInput
     */
    'status': Status;
    /**
     * Role of the AI agent in the company
     * @type {string}
     * @memberof AIAgentInput
     */
    'role': string;
    /**
     * Description of the role of the AI agent
     * @type {string}
     * @memberof AIAgentInput
     */
    'roleDescription': string;
    /**
     * Timezone of the AI agent used for scheduling meetings
     * @type {string}
     * @memberof AIAgentInput
     */
    'timezone': string;
    /**
     * 
     * @type {VoiceInput}
     * @memberof AIAgentInput
     */
    'voice'?: VoiceInput | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AIAgentInput
     */
    'boostedKeywords'?: Array<string> | null;
    /**
     * 
     * @type {AppEnumInput}
     * @memberof AIAgentInput
     */
    'app'?: AppEnumInput | null;
    /**
     * 
     * @type {ConversationEvaluationMetrics}
     * @memberof AIAgentInput
     */
    'evaluationMetrics'?: ConversationEvaluationMetrics | null;
}


/**
 * AI agent configured by businesses
 * @export
 * @interface AIAgentOutput
 */
export interface AIAgentOutput {
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    'orgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {Mission}
     * @memberof AIAgentOutput
     */
    'mission'?: Mission | null;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    'roleDescription'?: string;
    /**
     * 
     * @type {Transcriber}
     * @memberof AIAgentOutput
     */
    'transcriber'?: Transcriber | null;
    /**
     * 
     * @type {IntelligenceProvider}
     * @memberof AIAgentOutput
     */
    'intelligenceProvider'?: IntelligenceProvider | null;
    /**
     * 
     * @type {VoiceOutput}
     * @memberof AIAgentOutput
     */
    'voice'?: VoiceOutput | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AIAgentOutput
     */
    'boostedKeywords'?: Array<string> | null;
    /**
     * 
     * @type {AppEnumOutput}
     * @memberof AIAgentOutput
     */
    'app'?: AppEnumOutput | null;
    /**
     * 
     * @type {ConversationEvaluationMetrics}
     * @memberof AIAgentOutput
     */
    'evaluationMetrics'?: ConversationEvaluationMetrics | null;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    'timezone'?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    'updatedAt'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const Accent = {
    American: 'American',
    Indian: 'Indian',
    Australian: 'Australian',
    British: 'British',
    Hindi: 'Hindi',
    MiddleEastern: 'Middle Eastern'
} as const;

export type Accent = typeof Accent[keyof typeof Accent];


/**
 * 
 * @export
 * @interface AcceptInviteRequest
 */
export interface AcceptInviteRequest {
    /**
     * 
     * @type {string}
     * @memberof AcceptInviteRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AcceptInviteRequest
     */
    'password'?: string | null;
}
/**
 * 
 * @export
 * @interface ActionInput
 */
export interface ActionInput {
    /**
     * Name of the action
     * @type {string}
     * @memberof ActionInput
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ActionInput
     */
    'description'?: string | null;
    /**
     * Parameters for the action. It should be a JSON schema object
     * @type {{ [key: string]: any; }}
     * @memberof ActionInput
     */
    'parameters': { [key: string]: any; };
    /**
     * 
     * @type {Endpoint}
     * @memberof ActionInput
     */
    'endpoint': Endpoint;
    /**
     * 
     * @type {string}
     * @memberof ActionInput
     */
    'userWaitingText'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionInput
     */
    'userSuccessText'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionInput
     */
    'userErrorText'?: string | null;
    /**
     * 
     * @type {ActionInvocationTrigger}
     * @memberof ActionInput
     */
    'invocationTrigger': ActionInvocationTrigger;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ActionInvocationTrigger = {
    UserQuery: 'user_query',
    WebhookConversationStart: 'webhook.conversation_start',
    WebhookConversationEnd: 'webhook.conversation_end'
} as const;

export type ActionInvocationTrigger = typeof ActionInvocationTrigger[keyof typeof ActionInvocationTrigger];


/**
 * Action entity to store the actions which can be performed by ai agents
 * @export
 * @interface ActionOutput
 */
export interface ActionOutput {
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    'orgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    'description'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ActionOutput
     */
    'parameters'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ActionOutput
     */
    'endpoint'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    'invocationTrigger'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    'userWaitingText'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    'userSuccessText'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    'userErrorText'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Adaptability = {
    OpenToChange: 'open to change',
    Resistant: 'resistant',
    Indifferent: 'indifferent'
} as const;

export type Adaptability = typeof Adaptability[keyof typeof Adaptability];


/**
 * 
 * @export
 * @interface Adaptability1
 */
export interface Adaptability1 {
}
/**
 * 
 * @export
 * @interface Adaptability2
 */
export interface Adaptability2 {
}
/**
 * 
 * @export
 * @interface AddressInput
 */
export interface AddressInput {
    /**
     * Address line 1
     * @type {string}
     * @memberof AddressInput
     */
    'line1': string;
    /**
     * 
     * @type {string}
     * @memberof AddressInput
     */
    'line2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressInput
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressInput
     */
    'state'?: string | null;
    /**
     * Country
     * @type {string}
     * @memberof AddressInput
     */
    'country': string;
}
/**
 * 
 * @export
 * @interface AddressOutput
 */
export interface AddressOutput {
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    'line1': string;
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    'line2': string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    'city': string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    'state': string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    'country': string | null;
}
/**
 * 
 * @export
 * @interface AgentConfig
 */
export interface AgentConfig {
    /**
     * 
     * @type {TranscriberConfig}
     * @memberof AgentConfig
     */
    'transcriber': TranscriberConfig;
    /**
     * 
     * @type {IntelligenceProviderConfig}
     * @memberof AgentConfig
     */
    'intelligenceProvider': IntelligenceProviderConfig;
    /**
     * 
     * @type {SynthesizerConfig}
     * @memberof AgentConfig
     */
    'synthesizer': SynthesizerConfig;
    /**
     * 
     * @type {EmbeddingsModelConfig}
     * @memberof AgentConfig
     */
    'embeddingsModelConfig': EmbeddingsModelConfig;
    /**
     * 
     * @type {HiveStorageConfig}
     * @memberof AgentConfig
     */
    'hiveStorageConfig': HiveStorageConfig;
    /**
     * 
     * @type {FillersConfig}
     * @memberof AgentConfig
     */
    'fillersConfig'?: FillersConfig | null;
}


/**
 * 
 * @export
 * @interface AgenticWorkflowActionEndpoint
 */
export interface AgenticWorkflowActionEndpoint {
    /**
     * Agentic workflow id
     * @type {string}
     * @memberof AgenticWorkflowActionEndpoint
     */
    'workflowId': string;
}
/**
 * Enum which stores the list of apps which are used to create the conversation
 * @export
 * @enum {string}
 */

export const AgenticWorkflowAdkModelsWorkflowAppEnum = {
    Trata: 'TRATA',
    TrataSparr: 'TRATA_SPARR'
} as const;

export type AgenticWorkflowAdkModelsWorkflowAppEnum = typeof AgenticWorkflowAdkModelsWorkflowAppEnum[keyof typeof AgenticWorkflowAdkModelsWorkflowAppEnum];


/**
 * Connection represents an instance of an app with specific credentials and configuration
 * @export
 * @interface AgenticWorkflowDbModelsConnection
 */
export interface AgenticWorkflowDbModelsConnection {
    /**
     * The user who created.
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    'createdBy'?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    'createdAt'?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    'updatedBy'?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    'updatedAt'?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    'orgId'?: string;
    /**
     * The name of the connection
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    'name'?: string;
    /**
     * The unique identifier of the app
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    'appId'?: string;
    /**
     * The version of the app
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    'appVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    'description'?: string | null;
    /**
     * 
     * @type {Credentials}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    'credentials': Credentials;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    'connectionMetaData'?: { [key: string]: any; } | null;
    /**
     * The unique identifier of the connection
     * @type {string}
     * @memberof AgenticWorkflowDbModelsConnection
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface AgenticWorkflowModelsBaseBaseResponse
 */
export interface AgenticWorkflowModelsBaseBaseResponse {
    /**
     * The message of the response
     * @type {string}
     * @memberof AgenticWorkflowModelsBaseBaseResponse
     */
    'message'?: string;
    /**
     * The status of the response
     * @type {string}
     * @memberof AgenticWorkflowModelsBaseBaseResponse
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface AgentsInner
 */
export interface AgentsInner {
    /**
     * 
     * @type {string}
     * @memberof AgentsInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentsInner
     */
    'orgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentsInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentsInner
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {Mission}
     * @memberof AgentsInner
     */
    'mission'?: Mission;
    /**
     * 
     * @type {string}
     * @memberof AgentsInner
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentsInner
     */
    'roleDescription'?: string;
    /**
     * 
     * @type {Transcriber}
     * @memberof AgentsInner
     */
    'transcriber'?: Transcriber;
    /**
     * 
     * @type {IntelligenceProvider}
     * @memberof AgentsInner
     */
    'intelligenceProvider'?: IntelligenceProvider;
    /**
     * 
     * @type {VoiceOutput}
     * @memberof AgentsInner
     */
    'voice'?: VoiceOutput;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgentsInner
     */
    'boostedKeywords'?: Array<string> | null;
    /**
     * 
     * @type {AppEnumOutput}
     * @memberof AgentsInner
     */
    'app'?: AppEnumOutput;
    /**
     * 
     * @type {ConversationEvaluationMetrics}
     * @memberof AgentsInner
     */
    'evaluationMetrics'?: ConversationEvaluationMetrics;
    /**
     * 
     * @type {string}
     * @memberof AgentsInner
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentsInner
     */
    'timezone'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentsInner
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentsInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentsInner
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentsInner
     */
    'updatedAt'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AggregationFormulaInput = {
    Count: 'COUNT',
    Sum: 'SUM',
    Median: 'MEDIAN'
} as const;

export type AggregationFormulaInput = typeof AggregationFormulaInput[keyof typeof AggregationFormulaInput];


/**
 * 
 * @export
 * @enum {string}
 */

export const AggregationFormulaOutput = {
    Count: 'COUNT',
    Sum: 'SUM',
    Avg: 'AVG',
    Min: 'MIN',
    Max: 'MAX',
    Median: 'MEDIAN'
} as const;

export type AggregationFormulaOutput = typeof AggregationFormulaOutput[keyof typeof AggregationFormulaOutput];


/**
 * 
 * @export
 * @enum {string}
 */

export const AggregationPeriod = {
    Monthly: 'MONTHLY',
    Weekly: 'WEEKLY',
    Daily: 'DAILY'
} as const;

export type AggregationPeriod = typeof AggregationPeriod[keyof typeof AggregationPeriod];


/**
 * 
 * @export
 * @interface Aiwhatcanbeimproved
 */
export interface Aiwhatcanbeimproved {
}
/**
 * 
 * @export
 * @interface Aiwhatwentwell
 */
export interface Aiwhatwentwell {
}
/**
 * 
 * @export
 * @interface AnalyticsModelInput
 */
export interface AnalyticsModelInput {
    /**
     * 
     * @type {SparrModelsAnalyticsConversationAnalyticsModel}
     * @memberof AnalyticsModelInput
     */
    'conversation_analytics': SparrModelsAnalyticsConversationAnalyticsModel;
    /**
     * 
     * @type {GoalAnalyticsModelInput}
     * @memberof AnalyticsModelInput
     */
    'goals_analytics': GoalAnalyticsModelInput;
    /**
     * 
     * @type {CoachAnalyticsModel}
     * @memberof AnalyticsModelInput
     */
    'coach_analytics': CoachAnalyticsModel;
    /**
     * 
     * @type {SystemMetricsInput}
     * @memberof AnalyticsModelInput
     */
    'system_metrics'?: SystemMetricsInput | null;
    /**
     * 
     * @type {{ [key: string]: AnalyticsModelInputWeightedScoresValue; }}
     * @memberof AnalyticsModelInput
     */
    'weighted_scores'?: { [key: string]: AnalyticsModelInputWeightedScoresValue; } | null;
    /**
     * 
     * @type {Array<TrackerAnalyticsModel>}
     * @memberof AnalyticsModelInput
     */
    'tracker_analytics'?: Array<TrackerAnalyticsModel> | null;
}
/**
 * 
 * @export
 * @interface AnalyticsModelInputWeightedScoresValue
 */
export interface AnalyticsModelInputWeightedScoresValue {
}
/**
 * 
 * @export
 * @interface AnalyticsModelOutput
 */
export interface AnalyticsModelOutput {
    /**
     * 
     * @type {SparrModelsAnalyticsConversationAnalyticsModel}
     * @memberof AnalyticsModelOutput
     */
    'conversation_analytics': SparrModelsAnalyticsConversationAnalyticsModel;
    /**
     * 
     * @type {GoalAnalyticsModelOutput}
     * @memberof AnalyticsModelOutput
     */
    'goals_analytics': GoalAnalyticsModelOutput;
    /**
     * 
     * @type {CoachAnalyticsModel}
     * @memberof AnalyticsModelOutput
     */
    'coach_analytics': CoachAnalyticsModel;
    /**
     * 
     * @type {SystemMetricsOutput}
     * @memberof AnalyticsModelOutput
     */
    'system_metrics'?: SystemMetricsOutput | null;
    /**
     * 
     * @type {{ [key: string]: AnalyticsModelInputWeightedScoresValue; }}
     * @memberof AnalyticsModelOutput
     */
    'weighted_scores'?: { [key: string]: AnalyticsModelInputWeightedScoresValue; } | null;
    /**
     * 
     * @type {Array<TrackerAnalyticsModel>}
     * @memberof AnalyticsModelOutput
     */
    'tracker_analytics'?: Array<TrackerAnalyticsModel> | null;
}
/**
 * Simplified analytics request for single date range
 * @export
 * @interface AnalyticsRequest
 */
export interface AnalyticsRequest {
    /**
     * Start date for the analytics range
     * @type {string}
     * @memberof AnalyticsRequest
     */
    'startDate': string;
    /**
     * End date for the analytics range
     * @type {string}
     * @memberof AnalyticsRequest
     */
    'endDate': string;
    /**
     * List of metrics to retrieve
     * @type {Array<MetricRequest>}
     * @memberof AnalyticsRequest
     */
    'metrics': Array<MetricRequest>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AnalyticsRequest
     */
    'userIds'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AnalyticsRequest
     */
    'scenarioIds'?: Array<string> | null;
}
/**
 * Simplified analytics response
 * @export
 * @interface AnalyticsResponse
 */
export interface AnalyticsResponse {
    /**
     * Start date of the analytics range
     * @type {string}
     * @memberof AnalyticsResponse
     */
    'startDate': string;
    /**
     * End date of the analytics range
     * @type {string}
     * @memberof AnalyticsResponse
     */
    'endDate': string;
    /**
     * List of aggregated metric values
     * @type {Array<MetricDataPoint>}
     * @memberof AnalyticsResponse
     */
    'metrics': Array<MetricDataPoint>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AnalyticsResponse
     */
    'userIds'?: Array<string> | null;
}
/**
 * API key authentication configuration
 * @export
 * @interface ApiKeyAuth
 */
export interface ApiKeyAuth {
    /**
     * The type of authentication
     * @type {string}
     * @memberof ApiKeyAuth
     */
    'authType'?: string;
}
/**
 * 
 * @export
 * @interface ApiKeyCredentials
 */
export interface ApiKeyCredentials {
    /**
     * Credential type identifier
     * @type {string}
     * @memberof ApiKeyCredentials
     */
    'credentialsType'?: string;
    /**
     * The API key for the app
     * @type {string}
     * @memberof ApiKeyCredentials
     */
    'apiKey': string;
}
/**
 * 
 * @export
 * @interface ApiKeyRequest
 */
export interface ApiKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiKeyRequest
     */
    'key_type'?: ApiKeyRequestKeyTypeEnum | null;
}

export const ApiKeyRequestKeyTypeEnum = {
    ApiKey: 'api_key',
    CallKey: 'call_key'
} as const;

export type ApiKeyRequestKeyTypeEnum = typeof ApiKeyRequestKeyTypeEnum[keyof typeof ApiKeyRequestKeyTypeEnum];

/**
 * App represents an integration that can be connected to perform actions and triggers
 * @export
 * @interface App
 */
export interface App {
    /**
     * The user who created.
     * @type {string}
     * @memberof App
     */
    'createdBy'?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof App
     */
    'createdAt'?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof App
     */
    'updatedBy'?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof App
     */
    'updatedAt'?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof App
     */
    'orgId'?: string;
    /**
     * The name of the app
     * @type {string}
     * @memberof App
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof App
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof App
     */
    'endpointUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof App
     */
    'logoUrl'?: string | null;
    /**
     * Authentication configuration for the app
     * @type {Array<AuthInner>}
     * @memberof App
     */
    'auth': Array<AuthInner>;
    /**
     * The version of the app
     * @type {string}
     * @memberof App
     */
    'version'?: string;
    /**
     * The unique identifier of the app
     * @type {string}
     * @memberof App
     */
    'id'?: string;
}
/**
 * AppAction represents an action that can be performed by an app
 * @export
 * @interface AppAction
 */
export interface AppAction {
    /**
     * The user who created.
     * @type {string}
     * @memberof AppAction
     */
    'createdBy'?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof AppAction
     */
    'createdAt'?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof AppAction
     */
    'updatedBy'?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof AppAction
     */
    'updatedAt'?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof AppAction
     */
    'orgId'?: string;
    /**
     * 
     * @type {AppActionType}
     * @memberof AppAction
     */
    'actionType': AppActionType;
    /**
     * The name of the step. This name should be unique within the app
     * @type {string}
     * @memberof AppAction
     */
    'name'?: string;
    /**
     * The description of the step
     * @type {string}
     * @memberof AppAction
     */
    'description'?: string;
    /**
     * JSON Schema for the step data
     * @type {{ [key: string]: any; }}
     * @memberof AppAction
     */
    'dataSchema': { [key: string]: any; };
    /**
     * JSON Schema for the UI representation
     * @type {{ [key: string]: any; }}
     * @memberof AppAction
     */
    'uiSchema': { [key: string]: any; };
    /**
     * 
     * @type {UiNodeType}
     * @memberof AppAction
     */
    'uiNodeType': UiNodeType;
    /**
     * The ID of the app that this action belongs to
     * @type {string}
     * @memberof AppAction
     */
    'appId': string;
    /**
     * The version of the app that this action belongs to
     * @type {string}
     * @memberof AppAction
     */
    'appVersion': string;
    /**
     * The unique identifier of the app action
     * @type {string}
     * @memberof AppAction
     */
    'id'?: string;
}


/**
 * App Action Model
 * @export
 * @interface AppActionEntity
 */
export interface AppActionEntity {
    /**
     * 
     * @type {AppActionType}
     * @memberof AppActionEntity
     */
    'actionType': AppActionType;
    /**
     * The name of the step. This name should be unique within the app
     * @type {string}
     * @memberof AppActionEntity
     */
    'name'?: string;
    /**
     * The description of the step
     * @type {string}
     * @memberof AppActionEntity
     */
    'description'?: string;
    /**
     * JSON Schema for the step data
     * @type {{ [key: string]: any; }}
     * @memberof AppActionEntity
     */
    'dataSchema': { [key: string]: any; };
    /**
     * JSON Schema for the UI representation
     * @type {{ [key: string]: any; }}
     * @memberof AppActionEntity
     */
    'uiSchema': { [key: string]: any; };
    /**
     * 
     * @type {UiNodeType}
     * @memberof AppActionEntity
     */
    'uiNodeType': UiNodeType;
}


/**
 * Enum for step types
 * @export
 * @enum {string}
 */

export const AppActionType = {
    Trigger: 'TRIGGER',
    Action: 'ACTION'
} as const;

export type AppActionType = typeof AppActionType[keyof typeof AppActionType];


/**
 * App DTO Model filled by user
 * @export
 * @interface AppEntity
 */
export interface AppEntity {
    /**
     * The name of the app
     * @type {string}
     * @memberof AppEntity
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppEntity
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AppEntity
     */
    'endpointUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AppEntity
     */
    'logoUrl'?: string | null;
    /**
     * Authentication configuration for the app
     * @type {Array<AuthInner>}
     * @memberof AppEntity
     */
    'auth': Array<AuthInner>;
    /**
     * The version of the app
     * @type {string}
     * @memberof AppEntity
     */
    'version'?: string;
    /**
     * Array of available actions with their configurations
     * @type {Array<AppActionEntity>}
     * @memberof AppEntity
     */
    'actions': Array<AppActionEntity>;
}
/**
 * Enum which stores the list of apps which are used to create the conversation
 * @export
 * @enum {string}
 */

export const AppEnumInput = {
    Trata: 'TRATA',
    TrataSparr: 'TRATA_SPARR',
    TrataSparrV1: 'TRATA_SPARR_V1'
} as const;

export type AppEnumInput = typeof AppEnumInput[keyof typeof AppEnumInput];


/**
 * Enum which stores the list of apps which are used to create the conversation
 * @export
 * @enum {string}
 */

export const AppEnumOutput = {
    Trata: 'TRATA',
    TrataSparr: 'TRATA_SPARR',
    TrataSparrV1: 'TRATA_SPARR_V1'
} as const;

export type AppEnumOutput = typeof AppEnumOutput[keyof typeof AppEnumOutput];


/**
 * 
 * @export
 * @interface AppResponse
 */
export interface AppResponse {
    /**
     * 
     * @type {App}
     * @memberof AppResponse
     */
    'app': App;
    /**
     * 
     * @type {Array<AppAction>}
     * @memberof AppResponse
     */
    'actions': Array<AppAction>;
}
/**
 * Audit log details of the business
 * @export
 * @interface AuditLog
 */
export interface AuditLog {
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'orgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'action'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface AuthInner
 */
export interface AuthInner {
    /**
     * The type of authentication
     * @type {string}
     * @memberof AuthInner
     */
    'authType'?: string;
    /**
     * The client ID for the OAuth app
     * @type {string}
     * @memberof AuthInner
     */
    'clientId': string;
    /**
     * The client secret for the OAuth app
     * @type {string}
     * @memberof AuthInner
     */
    'clientSecret': string;
    /**
     * The redirect URI for the OAuth app
     * @type {string}
     * @memberof AuthInner
     */
    'redirectUri': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthInner
     */
    'scopes'?: Array<string> | null;
    /**
     * The authorization URL for the OAuth app
     * @type {string}
     * @memberof AuthInner
     */
    'authUrl': string;
    /**
     * The token URL for the OAuth app
     * @type {string}
     * @memberof AuthInner
     */
    'tokenUrl': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AuthRole = {
    Owner: 'Owner',
    Admin: 'Admin',
    Member: 'Member'
} as const;

export type AuthRole = typeof AuthRole[keyof typeof AuthRole];


/**
 * 
 * @export
 * @interface AvailablePhoneNumber
 */
export interface AvailablePhoneNumber {
    /**
     * 
     * @type {string}
     * @memberof AvailablePhoneNumber
     */
    'phoneNumber': string;
    /**
     * 
     * @type {string}
     * @memberof AvailablePhoneNumber
     */
    'countryCode': string;
    /**
     * 
     * @type {string}
     * @memberof AvailablePhoneNumber
     */
    'locality': string | null;
    /**
     * 
     * @type {string}
     * @memberof AvailablePhoneNumber
     */
    'region': string | null;
}
/**
 * 
 * @export
 * @interface BaseResponseInput
 */
export interface BaseResponseInput {
    /**
     * Address line 1
     * @type {string}
     * @memberof BaseResponseInput
     */
    'message': string;
}
/**
 * Basic authentication configuration
 * @export
 * @interface BasicAuth
 */
export interface BasicAuth {
    /**
     * The type of authentication
     * @type {string}
     * @memberof BasicAuth
     */
    'authType'?: string;
}
/**
 * 
 * @export
 * @interface BasicAuthCredentials
 */
export interface BasicAuthCredentials {
    /**
     * Credential type identifier
     * @type {string}
     * @memberof BasicAuthCredentials
     */
    'credentialsType'?: string;
    /**
     * The username for the app
     * @type {string}
     * @memberof BasicAuthCredentials
     */
    'username': string;
    /**
     * The password for the app
     * @type {string}
     * @memberof BasicAuthCredentials
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface BasicCredentials
 */
export interface BasicCredentials {
    /**
     * Email of the user
     * @type {string}
     * @memberof BasicCredentials
     */
    'email': string;
    /**
     * Password of the user
     * @type {string}
     * @memberof BasicCredentials
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface BatchMetricsRequestsInput
 */
export interface BatchMetricsRequestsInput {
    /**
     * 
     * @type {Array<MetricsRequestInput>}
     * @memberof BatchMetricsRequestsInput
     */
    'requests': Array<MetricsRequestInput>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BatchMetricsRequestsInput
     */
    'orgIds'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface BatchMetricsResponseInput
 */
export interface BatchMetricsResponseInput {
    /**
     * 
     * @type {Array<MetricsResponseInput>}
     * @memberof BatchMetricsResponseInput
     */
    'responses': Array<MetricsResponseInput>;
}
/**
 * 
 * @export
 * @interface BodyCreateCustomerOrganizationV1
 */
export interface BodyCreateCustomerOrganizationV1 {
    /**
     * 
     * @type {OrganizationInput}
     * @memberof BodyCreateCustomerOrganizationV1
     */
    'customer_org': OrganizationInput;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateCustomerOrganizationV1
     */
    'adminUserName': string;
}
/**
 * 
 * @export
 * @interface BodyCreateOrganizationV1
 */
export interface BodyCreateOrganizationV1 {
    /**
     * 
     * @type {OrganizationInput}
     * @memberof BodyCreateOrganizationV1
     */
    'org': OrganizationInput;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateOrganizationV1
     */
    'adminUserName': string;
}
/**
 * 
 * @export
 * @interface BodyCreateResellerOrganizationV1
 */
export interface BodyCreateResellerOrganizationV1 {
    /**
     * 
     * @type {OrganizationInput}
     * @memberof BodyCreateResellerOrganizationV1
     */
    'org': OrganizationInput;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateResellerOrganizationV1
     */
    'adminUserName': string;
}
/**
 * Model for call recording data from telephony providers
 * @export
 * @interface CallRecording
 */
export interface CallRecording {
    /**
     * URI to access the recording content
     * @type {string}
     * @memberof CallRecording
     */
    'contentUri': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CallSentiment = {
    Positive: 'positive',
    Negative: 'negative',
    Neutral: 'neutral'
} as const;

export type CallSentiment = typeof CallSentiment[keyof typeof CallSentiment];


/**
 * 
 * @export
 * @enum {string}
 */

export const CallType = {
    Inbound: 'inbound',
    Outbound: 'outbound',
    SalesInbound: 'sales_inbound',
    SalesOutbound: 'sales_outbound',
    ServiceInbound: 'service_inbound',
    ServiceOutbound: 'service_outbound',
    InPersonInbound: 'in_person_inbound',
    InPersonOutbound: 'in_person_outbound'
} as const;

export type CallType = typeof CallType[keyof typeof CallType];


/**
 * 
 * @export
 * @enum {string}
 */

export const ChangeAssignmentOperation = {
    Assign: 'assign',
    Remove: 'remove'
} as const;

export type ChangeAssignmentOperation = typeof ChangeAssignmentOperation[keyof typeof ChangeAssignmentOperation];


/**
 * 
 * @export
 * @interface ChangeAssignmentRequest
 */
export interface ChangeAssignmentRequest {
    /**
     * 
     * @type {ChangeAssignmentOperation}
     * @memberof ChangeAssignmentRequest
     */
    'operation': ChangeAssignmentOperation;
    /**
     * 
     * @type {Courses}
     * @memberof ChangeAssignmentRequest
     */
    'courses': Courses;
    /**
     * 
     * @type {Customers}
     * @memberof ChangeAssignmentRequest
     */
    'customers': Customers;
}


/**
 * 
 * @export
 * @interface CoachAnalyticsModel
 */
export interface CoachAnalyticsModel {
    /**
     * 
     * @type {Array<string>}
     * @memberof CoachAnalyticsModel
     */
    'coaching_points'?: Array<string> | null;
}
/**
 * Combined response model that includes evaluator and its optional components
 * @export
 * @interface CombinedEvaluatorResponse
 */
export interface CombinedEvaluatorResponse {
    /**
     * 
     * @type {Evaluator}
     * @memberof CombinedEvaluatorResponse
     */
    'evaluator': Evaluator;
    /**
     * 
     * @type {SparrDbModelsGoal}
     * @memberof CombinedEvaluatorResponse
     */
    'goals'?: SparrDbModelsGoal | null;
    /**
     * 
     * @type {Tracker}
     * @memberof CombinedEvaluatorResponse
     */
    'tracker'?: Tracker | null;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * Notes or comments to record
     * @type {string}
     * @memberof Comment
     */
    'comment': string;
    /**
     * Star rating to record
     * @type {number}
     * @memberof Comment
     */
    'rating': number;
}
/**
 * 
 * @export
 * @interface CommunicationStyle
 */
export interface CommunicationStyle {
}
/**
 * 
 * @export
 * @interface CommunicationStyle1
 */
export interface CommunicationStyle1 {
}
/**
 * Condition Model for branching/looping logic
 * @export
 * @interface Condition
 */
export interface Condition {
    /**
     * Condition expression to evaluate
     * @type {string}
     * @memberof Condition
     */
    'when': string;
    /**
     * Next step ID if condition is true
     * @type {string}
     * @memberof Condition
     */
    'stepId': string;
}
/**
 * Core Connection Model
 * @export
 * @interface ConnectionCore
 */
export interface ConnectionCore {
    /**
     * The name of the connection
     * @type {string}
     * @memberof ConnectionCore
     */
    'name'?: string;
    /**
     * The unique identifier of the app
     * @type {string}
     * @memberof ConnectionCore
     */
    'appId'?: string;
    /**
     * The version of the app
     * @type {string}
     * @memberof ConnectionCore
     */
    'appVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionCore
     */
    'description'?: string | null;
    /**
     * 
     * @type {Credentials}
     * @memberof ConnectionCore
     */
    'credentials': Credentials;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ConnectionCore
     */
    'connectionMetaData'?: { [key: string]: any; } | null;
}
/**
 * This represents the connection between the user and the assistant
 * @export
 * @interface ConnectionOutput
 */
export interface ConnectionOutput {
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    'orgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    'sourceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    'sourceId'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ConnectionOutput
     */
    'sourceProps'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    'agentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    'prospectId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionOutput
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ConnectionSource
 */
export interface ConnectionSource {
    /**
     * Name of the source
     * @type {string}
     * @memberof ConnectionSource
     */
    'sourceName'?: ConnectionSourceSourceNameEnum;
    /**
     * Unique identifier for the source
     * @type {string}
     * @memberof ConnectionSource
     */
    'sourceId': string;
    /**
     * Extra properties of source
     * @type {{ [key: string]: any; }}
     * @memberof ConnectionSource
     */
    'sourceProps': { [key: string]: any; };
}

export const ConnectionSourceSourceNameEnum = {
    Twilio: 'TWILIO',
    Plivo: 'PLIVO',
    Browser: 'BROWSER'
} as const;

export type ConnectionSourceSourceNameEnum = typeof ConnectionSourceSourceNameEnum[keyof typeof ConnectionSourceSourceNameEnum];

/**
 * Expected output of the post conversation task
 * @export
 * @interface ConversationAnalyticsModelInput
 */
export interface ConversationAnalyticsModelInput {
    /**
     * 
     * @type {string}
     * @memberof ConversationAnalyticsModelInput
     */
    'summary': string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConversationAnalyticsModelInput
     */
    'action_items': Array<string> | null;
    /**
     * If the user has given consent to store the audio of the conversation. Unless the user explicitly says yes, this should be false.
     * @type {boolean}
     * @memberof ConversationAnalyticsModelInput
     */
    'is_audio_consent_given': boolean;
    /**
     * 
     * @type {string}
     * @memberof ConversationAnalyticsModelInput
     */
    'email_address_of_caller': string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationAnalyticsModelInput
     */
    'name_of_caller': string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationAnalyticsModelInput
     */
    'phone_number_of_caller': string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationAnalyticsModelInput
     */
    'address_of_caller': string | null;
    /**
     * 
     * @type {CallSentiment}
     * @memberof ConversationAnalyticsModelInput
     */
    'sentiment_of_caller': CallSentiment;
    /**
     * 
     * @type {ProspectStatus}
     * @memberof ConversationAnalyticsModelInput
     */
    'prospectStatus': ProspectStatus | null;
}


/**
 * 
 * @export
 * @interface ConversationEndEvent
 */
export interface ConversationEndEvent {
    /**
     * 
     * @type {string}
     * @memberof ConversationEndEvent
     */
    'timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof ConversationEndEvent
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationEndEvent
     */
    'event_name': string;
    /**
     * 
     * @type {ConversationEndEventPayload}
     * @memberof ConversationEndEvent
     */
    'payload'?: ConversationEndEventPayload;
}
/**
 * 
 * @export
 * @interface ConversationEndEventPayload
 */
export interface ConversationEndEventPayload {
    /**
     * 
     * @type {ConversationOutput}
     * @memberof ConversationEndEventPayload
     */
    'conversation': ConversationOutput;
}
/**
 * Model which stores the evaluation metrics for the conversation
 * @export
 * @interface ConversationEvaluation
 */
export interface ConversationEvaluation {
    /**
     * 
     * @type {string}
     * @memberof ConversationEvaluation
     */
    'aiEvaluationSummary': string | null;
    /**
     * 
     * @type {Array<ConversationEvaluationData>}
     * @memberof ConversationEvaluation
     */
    'aiEvaluations': Array<ConversationEvaluationData>;
    /**
     * 
     * @type {Aiwhatwentwell}
     * @memberof ConversationEvaluation
     */
    'aiWhatWentWell': Aiwhatwentwell | null;
    /**
     * 
     * @type {Aiwhatcanbeimproved}
     * @memberof ConversationEvaluation
     */
    'aiWhatCanBeImproved': Aiwhatcanbeimproved | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationEvaluation
     */
    'humanEvaluationSummary': string | null;
    /**
     * 
     * @type {Array<ConversationEvaluationData>}
     * @memberof ConversationEvaluation
     */
    'humanEvaluations': Array<ConversationEvaluationData> | null;
    /**
     * 
     * @type {Humanwhatwentwell}
     * @memberof ConversationEvaluation
     */
    'humanWhatWentWell': Humanwhatwentwell | null;
    /**
     * 
     * @type {Humanwhatcanbeimproved}
     * @memberof ConversationEvaluation
     */
    'humanWhatCanBeImproved': Humanwhatcanbeimproved | null;
}
/**
 * Model which stores the result of the evaluation metric for a conversation
 * @export
 * @interface ConversationEvaluationData
 */
export interface ConversationEvaluationData {
    /**
     * Name of the evaluation metric
     * @type {string}
     * @memberof ConversationEvaluationData
     */
    'name'?: string;
    /**
     * Description about the evaluation metric
     * @type {string}
     * @memberof ConversationEvaluationData
     */
    'description'?: string;
    /**
     * Value of the evaluation metric
     * @type {string}
     * @memberof ConversationEvaluationData
     */
    'value'?: string;
}
/**
 * Model which stores the details of each evaluation metric
 * @export
 * @interface ConversationEvaluationMetric
 */
export interface ConversationEvaluationMetric {
    /**
     * Name of the evaluation metric
     * @type {string}
     * @memberof ConversationEvaluationMetric
     */
    'name'?: string;
    /**
     * Description about the evaluation metric
     * @type {string}
     * @memberof ConversationEvaluationMetric
     */
    'description'?: string;
}
/**
 * Model which stores all the evaluation metrics which is used to evaluate the conversation
 * @export
 * @interface ConversationEvaluationMetrics
 */
export interface ConversationEvaluationMetrics {
    /**
     * 
     * @type {Array<ConversationEvaluationMetric>}
     * @memberof ConversationEvaluationMetrics
     */
    'qualitativeMetrics': Array<ConversationEvaluationMetric> | null;
    /**
     * 
     * @type {Array<ConversationEvaluationMetric>}
     * @memberof ConversationEvaluationMetrics
     */
    'quantitativeMetrics': Array<ConversationEvaluationMetric> | null;
}
/**
 * Any feedback added to the conversation by business is managed here.
 * @export
 * @interface ConversationFeedback
 */
export interface ConversationFeedback {
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    'orgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    'conversationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    'feedback'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConversationFeedback
     */
    'rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ConversationInput
 */
export interface ConversationInput {
    /**
     * Source from where the conversation originated. This can be device id, phone number, etc.
     * @type {string}
     * @memberof ConversationInput
     */
    'source': string;
    /**
     * 
     * @type {ConversationSourceType}
     * @memberof ConversationInput
     */
    'sourceType': ConversationSourceType;
    /**
     * AI agent which handled the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    'agentId': string;
    /**
     * 
     * @type {AppEnumInput}
     * @memberof ConversationInput
     */
    'app'?: AppEnumInput | null;
    /**
     * 
     * @type {Array<DialogLine>}
     * @memberof ConversationInput
     */
    'transcriptText'?: Array<DialogLine> | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationInput
     */
    'transcriptSummary'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationInput
     */
    'transcriptRecordingUrl'?: string | null;
    /**
     * Start time of the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    'timestampStart': string;
    /**
     * 
     * @type {string}
     * @memberof ConversationInput
     */
    'timestampEnd'?: string | null;
    /**
     * 
     * @type {ConversationAnalyticsModelInput}
     * @memberof ConversationInput
     */
    'conversationAnalytics'?: ConversationAnalyticsModelInput | null;
    /**
     * 
     * @type {Array<Comment>}
     * @memberof ConversationInput
     */
    'adminComments'?: Array<Comment> | null;
    /**
     * 
     * @type {ConversationStatsModel}
     * @memberof ConversationInput
     */
    'conversationStats'?: ConversationStatsModel | null;
    /**
     * 
     * @type {ConversationEvaluation}
     * @memberof ConversationInput
     */
    'evaluation'?: ConversationEvaluation | null;
}


/**
 * Any conversation happening between the end user and assistant is stored in this table
 * @export
 * @interface ConversationOutput
 */
export interface ConversationOutput {
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    'orgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    'prospectId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    'source'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    'sourceType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    'aiAgentId'?: string;
    /**
     * 
     * @type {Array<DialogLine>}
     * @memberof ConversationOutput
     */
    'transcriptText'?: Array<DialogLine> | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    'transcriptSummary'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    'transcriptRecordingUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    'timestampStart'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    'timestampEnd'?: string | null;
    /**
     * 
     * @type {ConversationAnalyticsModelInput}
     * @memberof ConversationOutput
     */
    'conversationAnalytics'?: ConversationAnalyticsModelInput | null;
    /**
     * 
     * @type {ConversationStatsModel}
     * @memberof ConversationOutput
     */
    'conversationStats'?: ConversationStatsModel | null;
    /**
     * 
     * @type {AppEnumOutput}
     * @memberof ConversationOutput
     */
    'app'?: AppEnumOutput | null;
    /**
     * 
     * @type {ConversationEvaluation}
     * @memberof ConversationOutput
     */
    'evaluation'?: ConversationEvaluation | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    'updatedAt'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ConversationSourceType = {
    Browser: 'BROWSER',
    Twilio: 'TWILIO',
    Plivo: 'PLIVO'
} as const;

export type ConversationSourceType = typeof ConversationSourceType[keyof typeof ConversationSourceType];


/**
 * 
 * @export
 * @interface ConversationStartEvent
 */
export interface ConversationStartEvent {
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEvent
     */
    'timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEvent
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEvent
     */
    'event_name': string;
    /**
     * 
     * @type {ConversationStartEventPayload}
     * @memberof ConversationStartEvent
     */
    'payload'?: ConversationStartEventPayload;
}
/**
 * 
 * @export
 * @interface ConversationStartEventPayload
 */
export interface ConversationStartEventPayload {
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEventPayload
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEventPayload
     */
    'connection_id': string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEventPayload
     */
    'conversation_id': string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEventPayload
     */
    'ai_agent_id': string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEventPayload
     */
    'org_id': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ConversationStartEventPayload
     */
    'caller_id': { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface ConversationStatsModel
 */
export interface ConversationStatsModel {
    /**
     * Total number of dialogs in the conversation
     * @type {number}
     * @memberof ConversationStatsModel
     */
    'total_dialog': number;
    /**
     * Ratio of Agent dialogs to total dialogs
     * @type {number}
     * @memberof ConversationStatsModel
     */
    'agent_dialog_ratio': number;
    /**
     * Ratio of User dialogs to total dialogs
     * @type {number}
     * @memberof ConversationStatsModel
     */
    'user_dialog_ratio': number;
}
/**
 * 
 * @export
 * @interface CountryInfo
 */
export interface CountryInfo {
    /**
     * 
     * @type {string}
     * @memberof CountryInfo
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof CountryInfo
     */
    'name': string;
}
/**
 * Course represents a course that can be used in a scenario
 * @export
 * @interface Course
 */
export interface Course {
    /**
     * The user who created.
     * @type {string}
     * @memberof Course
     */
    'createdBy'?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof Course
     */
    'createdAt'?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof Course
     */
    'updatedBy'?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof Course
     */
    'updatedAt'?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof Course
     */
    'orgId'?: string;
    /**
     * The name of the course
     * @type {string}
     * @memberof Course
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'photoUrl'?: string | null;
    /**
     * The description of the course
     * @type {string}
     * @memberof Course
     */
    'description': string;
    /**
     * The status of the course
     * @type {string}
     * @memberof Course
     */
    'status': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Course
     */
    'tags'?: Array<string> | null;
    /**
     * The unique identifier of the course
     * @type {string}
     * @memberof Course
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CourseAssignmentStatus = {
    Assigned: 'assigned',
    Unassigned: 'unassigned'
} as const;

export type CourseAssignmentStatus = typeof CourseAssignmentStatus[keyof typeof CourseAssignmentStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const CourseCompletionStatus = {
    NotStarted: 'NOT_STARTED',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED'
} as const;

export type CourseCompletionStatus = typeof CourseCompletionStatus[keyof typeof CourseCompletionStatus];


/**
 * 
 * @export
 * @interface CourseCore
 */
export interface CourseCore {
    /**
     * The name of the course
     * @type {string}
     * @memberof CourseCore
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CourseCore
     */
    'photoUrl'?: string | null;
    /**
     * The description of the course
     * @type {string}
     * @memberof CourseCore
     */
    'description': string;
    /**
     * The status of the course
     * @type {string}
     * @memberof CourseCore
     */
    'status': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CourseCore
     */
    'tags'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CourseRequest
 */
export interface CourseRequest {
    /**
     * 
     * @type {CourseCore}
     * @memberof CourseRequest
     */
    'course': CourseCore;
    /**
     * 
     * @type {Array<ModuleCore>}
     * @memberof CourseRequest
     */
    'modules': Array<ModuleCore>;
}
/**
 * 
 * @export
 * @interface CourseResponse
 */
export interface CourseResponse {
    /**
     * 
     * @type {Course}
     * @memberof CourseResponse
     */
    'course': Course;
    /**
     * 
     * @type {Array<Module>}
     * @memberof CourseResponse
     */
    'modules': Array<Module>;
}
/**
 * 
 * @export
 * @interface CourseUpdateRequest
 */
export interface CourseUpdateRequest {
    /**
     * 
     * @type {CourseCore}
     * @memberof CourseUpdateRequest
     */
    'course': CourseCore;
    /**
     * 
     * @type {Array<ModuleUpdateRequest>}
     * @memberof CourseUpdateRequest
     */
    'modules': Array<ModuleUpdateRequest>;
}
/**
 * 
 * @export
 * @interface CourseWithAssignmentStatus
 */
export interface CourseWithAssignmentStatus {
    /**
     * 
     * @type {Course}
     * @memberof CourseWithAssignmentStatus
     */
    'course': Course;
    /**
     * 
     * @type {CourseAssignmentStatus}
     * @memberof CourseWithAssignmentStatus
     */
    'status'?: CourseAssignmentStatus;
}


/**
 * Either \'all\' or a list of course IDs
 * @export
 * @interface Courses
 */
export interface Courses {
}
/**
 * 
 * @export
 * @interface CreateScenarioRequest
 */
export interface CreateScenarioRequest {
    /**
     * The name of the scenario
     * @type {string}
     * @memberof CreateScenarioRequest
     */
    'name': string;
    /**
     * The description of the scenario
     * @type {string}
     * @memberof CreateScenarioRequest
     */
    'description': string;
    /**
     * The objections to be handled for the scenario
     * @type {Array<Objection>}
     * @memberof CreateScenarioRequest
     */
    'objections'?: Array<Objection>;
    /**
     * 
     * @type {CallType}
     * @memberof CreateScenarioRequest
     */
    'callType'?: CallType | null;
    /**
     * 
     * @type {FamiliarityLevel}
     * @memberof CreateScenarioRequest
     */
    'familiarityLevel'?: FamiliarityLevel;
    /**
     * The goals to be achieved for the scenario
     * @type {Array<GoalInput>}
     * @memberof CreateScenarioRequest
     */
    'goals'?: Array<GoalInput>;
    /**
     * The playbook to be followed for the scenario
     * @type {Array<Step>}
     * @memberof CreateScenarioRequest
     */
    'playbook'?: Array<Step>;
    /**
     * Whether the scenario is inherited from the parent scenario
     * @type {boolean}
     * @memberof CreateScenarioRequest
     */
    'isInherited'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateScenarioRequest
     */
    'evaluatorId'?: string | null;
    /**
     * 
     * @type {EvaluatorRequest}
     * @memberof CreateScenarioRequest
     */
    'evaluator'?: EvaluatorRequest | null;
    /**
     * The status of the scenario
     * @type {string}
     * @memberof CreateScenarioRequest
     */
    'status'?: string;
}


/**
 * OAuth or API key authentication configuration
 * @export
 * @interface Credentials
 */
export interface Credentials {
    /**
     * Credential type identifier
     * @type {string}
     * @memberof Credentials
     */
    'credentialsType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    'code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    'accessToken'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    'refreshToken'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    'expiresAt'?: string | null;
    /**
     * The API key for the app
     * @type {string}
     * @memberof Credentials
     */
    'apiKey': string;
    /**
     * The username for the app
     * @type {string}
     * @memberof Credentials
     */
    'username': string;
    /**
     * The password for the app
     * @type {string}
     * @memberof Credentials
     */
    'password': string;
}
/**
 * Credits details of the business
 * @export
 * @interface Credit
 */
export interface Credit {
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'orgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'creditTypeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'totalAvailable'?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'consumed'?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'durationStart'?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    'durationEnd'?: string;
}
/**
 * Enum for the type of credit
 * @export
 * @enum {string}
 */

export const CreditTypeEnum = {
    PhoneNumbers: 'phone_numbers',
    CallSeconds: 'call_seconds',
    CallHours: 'call_hours',
    Emails: 'emails',
    LinkedInScraping: 'linked_in_scraping',
    Courses: 'courses',
    RecordingAndTranscription: 'recording_and_transcription',
    Users: 'users',
    AdvancedIntelligence: 'advanced_intelligence',
    RolePlayCustomization: 'role_play_customization'
} as const;

export type CreditTypeEnum = typeof CreditTypeEnum[keyof typeof CreditTypeEnum];


/**
 * 
 * @export
 * @interface CustomerBranding
 */
export interface CustomerBranding {
    /**
     * 
     * @type {string}
     * @memberof CustomerBranding
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomerBranding
     */
    'brandColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomerBranding
     */
    'buttonColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomerBranding
     */
    'secondaryColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomerBranding
     */
    'textColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomerBranding
     */
    'favicon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomerBranding
     */
    'faviconUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomerBranding
     */
    'logo'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomerBranding
     */
    'logoUrl'?: string | null;
}
/**
 * Either \'all\' or a list of customer IDs
 * @export
 * @interface Customers
 */
export interface Customers {
}
/**
 * 
 * @export
 * @interface DecisionMakingStyle
 */
export interface DecisionMakingStyle {
}
/**
 * 
 * @export
 * @interface DecisionMakingStyle1
 */
export interface DecisionMakingStyle1 {
}
/**
 * 
 * @export
 * @interface DialogLine
 */
export interface DialogLine {
    /**
     * 
     * @type {string}
     * @memberof DialogLine
     */
    'speaker': DialogLineSpeakerEnum;
    /**
     * 
     * @type {string}
     * @memberof DialogLine
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof DialogLine
     */
    'timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof DialogLine
     */
    'message_id': string;
}

export const DialogLineSpeakerEnum = {
    User: 'USER',
    Ai: 'AI',
    Tool: 'TOOL',
    AiToolRequest: 'AI - TOOL REQUEST'
} as const;

export type DialogLineSpeakerEnum = typeof DialogLineSpeakerEnum[keyof typeof DialogLineSpeakerEnum];

/**
 * 
 * @export
 * @interface DialogWordWithTimestamp
 */
export interface DialogWordWithTimestamp {
    /**
     * 
     * @type {string}
     * @memberof DialogWordWithTimestamp
     */
    'word': string;
    /**
     * 
     * @type {number}
     * @memberof DialogWordWithTimestamp
     */
    'start_at_milliseconds': number;
    /**
     * 
     * @type {number}
     * @memberof DialogWordWithTimestamp
     */
    'end_at_milliseconds': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EmbeddingsModelConfig = {
    CustomPropsDimensionLength1536maxInputToken8192ModelNameTextEmbeddingsOpenaiModelProviderOpenai: '{\"CustomProps\":{\"dimension_length\":1536,\"max_input_token\":8192},\"ModelName\":\"text-embeddings-openai\",\"ModelProvider\":\"openai\"}',
    CustomPropsModelNameTextEmbeddingsGeminiModelProviderGoogle: '{\"CustomProps\":{},\"ModelName\":\"text-embeddings-gemini\",\"ModelProvider\":\"google\"}',
    CustomPropsDimensionLength768maxInputToken8192modelKwargsDeviceCputrustRemoteCodeTrueModelNameNomicAiNomicEmbedTextV1ModelProviderHuggingface: '{\"CustomProps\":{\"dimension_length\":768,\"max_input_token\":8192,\"model_kwargs\":{\"device\":\"cpu\",\"trust_remote_code\":true}},\"ModelName\":\"nomic-ai/nomic-embed-text-v1\",\"ModelProvider\":\"huggingface\"}',
    CustomPropsDimensionLength1024maxInputToken512ModelNameIntfloatE5LargeModelProviderHuggingface: '{\"CustomProps\":{\"dimension_length\":1024,\"max_input_token\":512},\"ModelName\":\"intfloat/e5-large\",\"ModelProvider\":\"huggingface\"}',
    CustomPropsDimensionLength384maxInputToken256ModelNameSentenceTransformersAllMiniLmL6V2ModelProviderHuggingface: '{\"CustomProps\":{\"dimension_length\":384,\"max_input_token\":256},\"ModelName\":\"sentence-transformers/all-MiniLM-L6-v2\",\"ModelProvider\":\"huggingface\"}'
} as const;

export type EmbeddingsModelConfig = typeof EmbeddingsModelConfig[keyof typeof EmbeddingsModelConfig];


/**
 * Endpoint for the action
 * @export
 * @interface Endpoint
 */
export interface Endpoint {
    /**
     * Action endpoint URL
     * @type {string}
     * @memberof Endpoint
     */
    'url': string;
    /**
     * Method to be used for invoking the endpoint
     * @type {string}
     * @memberof Endpoint
     */
    'method'?: EndpointMethodEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Endpoint
     */
    'headers'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Endpoint
     */
    'payload'?: { [key: string]: any; } | null;
    /**
     * Module where the action is defined
     * @type {string}
     * @memberof Endpoint
     */
    'module': string;
    /**
     * Function to be called inside the module
     * @type {string}
     * @memberof Endpoint
     */
    'function': string;
    /**
     * Agentic workflow id
     * @type {string}
     * @memberof Endpoint
     */
    'workflowId': string;
}

export const EndpointMethodEnum = {
    Get: 'GET',
    Post: 'POST'
} as const;

export type EndpointMethodEnum = typeof EndpointMethodEnum[keyof typeof EndpointMethodEnum];

/**
 * 
 * @export
 * @interface EngagementLevel
 */
export interface EngagementLevel {
}
/**
 * 
 * @export
 * @interface EngagementLevel1
 */
export interface EngagementLevel1 {
}
/**
 * Mapping table between entities and their tags (simple string tags)
 * @export
 * @interface EntityTag
 */
export interface EntityTag {
    /**
     * The user who created.
     * @type {string}
     * @memberof EntityTag
     */
    'createdBy'?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof EntityTag
     */
    'createdAt'?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof EntityTag
     */
    'updatedBy'?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof EntityTag
     */
    'updatedAt'?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof EntityTag
     */
    'orgId'?: string;
    /**
     * The unique identifier of the entity tag
     * @type {string}
     * @memberof EntityTag
     */
    'id'?: string;
    /**
     * Type of entity being tagged (e.g., scenario, persona, course, evaluator)
     * @type {string}
     * @memberof EntityTag
     */
    'entityType'?: string;
    /**
     * ID of the entity being tagged
     * @type {string}
     * @memberof EntityTag
     */
    'entityId'?: string;
    /**
     * Name of the tag
     * @type {string}
     * @memberof EntityTag
     */
    'tagName'?: string;
}
/**
 * Model which stores the result of the evaluation metric for a conversation
 * @export
 * @interface EvaluationInput
 */
export interface EvaluationInput {
    /**
     * 
     * @type {string}
     * @memberof EvaluationInput
     */
    'evaluation_result'?: string | null;
    /**
     * 
     * @type {RubricScore}
     * @memberof EvaluationInput
     */
    'rubric_score'?: RubricScore | null;
}
/**
 * Model which stores the result of the evaluation metric for a conversation
 * @export
 * @interface EvaluationOutput
 */
export interface EvaluationOutput {
    /**
     * 
     * @type {string}
     * @memberof EvaluationOutput
     */
    'evaluation_result'?: string | null;
    /**
     * 
     * @type {RubricScore}
     * @memberof EvaluationOutput
     */
    'rubric_score'?: RubricScore | null;
}
/**
 * 
 * @export
 * @interface Evaluator
 */
export interface Evaluator {
    /**
     * The user who created.
     * @type {string}
     * @memberof Evaluator
     */
    'createdBy'?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof Evaluator
     */
    'createdAt'?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof Evaluator
     */
    'updatedBy'?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof Evaluator
     */
    'updatedAt'?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof Evaluator
     */
    'orgId'?: string;
    /**
     * The name of the evaluator
     * @type {string}
     * @memberof Evaluator
     */
    'name': string;
    /**
     * The description of the evaluator
     * @type {string}
     * @memberof Evaluator
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Evaluator
     */
    'goals_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Evaluator
     */
    'tracker_id'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Evaluator
     */
    'generator_source'?: Array<string> | null;
    /**
     * The status of the evaluator
     * @type {string}
     * @memberof Evaluator
     */
    'status'?: string;
    /**
     * The unique identifier of the evaluator
     * @type {string}
     * @memberof Evaluator
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface EvaluatorCore
 */
export interface EvaluatorCore {
    /**
     * The name of the evaluator
     * @type {string}
     * @memberof EvaluatorCore
     */
    'name': string;
    /**
     * The description of the evaluator
     * @type {string}
     * @memberof EvaluatorCore
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof EvaluatorCore
     */
    'goals_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EvaluatorCore
     */
    'tracker_id'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof EvaluatorCore
     */
    'generator_source'?: Array<string> | null;
    /**
     * The status of the evaluator
     * @type {string}
     * @memberof EvaluatorCore
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface EvaluatorRequest
 */
export interface EvaluatorRequest {
    /**
     * The name of the evaluator
     * @type {string}
     * @memberof EvaluatorRequest
     */
    'name': string;
    /**
     * The description of the evaluator
     * @type {string}
     * @memberof EvaluatorRequest
     */
    'description': string;
    /**
     * 
     * @type {GoalCoreInput}
     * @memberof EvaluatorRequest
     */
    'goals': GoalCoreInput;
}
/**
 * Response model for evaluator with goals
 * @export
 * @interface EvaluatorResponse
 */
export interface EvaluatorResponse {
    /**
     * The ID of the evaluator
     * @type {string}
     * @memberof EvaluatorResponse
     */
    'id': string;
    /**
     * The name of the evaluator
     * @type {string}
     * @memberof EvaluatorResponse
     */
    'name': string;
    /**
     * The description of the evaluator
     * @type {string}
     * @memberof EvaluatorResponse
     */
    'description': string;
    /**
     * 
     * @type {GoalCoreOutput}
     * @memberof EvaluatorResponse
     */
    'goals'?: GoalCoreOutput | null;
    /**
     * 
     * @type {string}
     * @memberof EvaluatorResponse
     */
    'goals_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EvaluatorResponse
     */
    'tracker_id'?: string | null;
    /**
     * The status of the evaluator
     * @type {string}
     * @memberof EvaluatorResponse
     */
    'status': string;
    /**
     * The organization ID
     * @type {string}
     * @memberof EvaluatorResponse
     */
    'orgId': string;
    /**
     * The user who created the evaluator
     * @type {string}
     * @memberof EvaluatorResponse
     */
    'createdBy': string;
    /**
     * The creation timestamp
     * @type {string}
     * @memberof EvaluatorResponse
     */
    'createdAt': string;
    /**
     * The user who last updated the evaluator
     * @type {string}
     * @memberof EvaluatorResponse
     */
    'updatedBy': string;
    /**
     * The last update timestamp
     * @type {string}
     * @memberof EvaluatorResponse
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface Excitementlevel
 */
export interface Excitementlevel {
}
/**
 * 
 * @export
 * @interface ExternalReference
 */
export interface ExternalReference {
    /**
     * External service provider name
     * @type {string}
     * @memberof ExternalReference
     */
    'providerName': string;
    /**
     * External service identifier
     * @type {string}
     * @memberof ExternalReference
     */
    'id': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ExternalReference
     */
    'providerProps'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface ExternalServiceProviderInput
 */
export interface ExternalServiceProviderInput {
    /**
     * External service provider name
     * @type {string}
     * @memberof ExternalServiceProviderInput
     */
    'providerName': string;
    /**
     * External service identifier
     * @type {string}
     * @memberof ExternalServiceProviderInput
     */
    'id': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ExternalServiceProviderInput
     */
    'providerProps': { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface ExternalServiceProviderOutput
 */
export interface ExternalServiceProviderOutput {
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceProviderOutput
     */
    'providerName': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceProviderOutput
     */
    'id': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ExternalServiceProviderOutput
     */
    'providerProps': { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FamiliarityLevel = {
    Cold: 'cold',
    Warm: 'warm',
    Hot: 'hot'
} as const;

export type FamiliarityLevel = typeof FamiliarityLevel[keyof typeof FamiliarityLevel];


/**
 * Feedback represents a feedback that can be given to a persona
 * @export
 * @interface Feedback
 */
export interface Feedback {
    /**
     * The user who created.
     * @type {string}
     * @memberof Feedback
     */
    'createdBy'?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof Feedback
     */
    'createdAt'?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof Feedback
     */
    'updatedBy'?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof Feedback
     */
    'updatedAt'?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof Feedback
     */
    'orgId'?: string;
    /**
     * The ID of the user who made the call
     * @type {string}
     * @memberof Feedback
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'userName': string | null;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'userProfilePictureUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'aiAgentId': string | null;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'scenarioId': string | null;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'scenarioName': string | null;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'personaId': string | null;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'personaName': string | null;
    /**
     * The start timestamp of the conversation
     * @type {string}
     * @memberof Feedback
     */
    'startTimestamp': string;
    /**
     * The end timestamp of the conversation
     * @type {string}
     * @memberof Feedback
     */
    'endTimestamp': string;
    /**
     * The time in seconds when sparring started
     * @type {number}
     * @memberof Feedback
     */
    'startSparringAt'?: number;
    /**
     * The time in seconds when sparring ended
     * @type {number}
     * @memberof Feedback
     */
    'endSparringAt'?: number;
    /**
     * The top insights from the conversation
     * @type {Array<string>}
     * @memberof Feedback
     */
    'topInsights': Array<string>;
    /**
     * The URL of the recording of the conversation
     * @type {string}
     * @memberof Feedback
     */
    'recordingUrl': string;
    /**
     * The transcript of the conversation
     * @type {Array<SparrDialogLine>}
     * @memberof Feedback
     */
    'transcript': Array<SparrDialogLine>;
    /**
     * 
     * @type {Array<SparrDialogLine>}
     * @memberof Feedback
     */
    'completeTranscript'?: Array<SparrDialogLine> | null;
    /**
     * 
     * @type {Array<SparrDialogLineWithTimestamp>}
     * @memberof Feedback
     */
    'transcriptWithTimestamp'?: Array<SparrDialogLineWithTimestamp> | null;
    /**
     * 
     * @type {AnalyticsModelOutput}
     * @memberof Feedback
     */
    'analytics': AnalyticsModelOutput;
    /**
     * The overall score of the conversation out of 100 based on the weightage of each goal
     * @type {number}
     * @memberof Feedback
     */
    'overallScore': number;
    /**
     * The status of the feedback
     * @type {string}
     * @memberof Feedback
     */
    'status'?: string;
    /**
     * The environment where the feedback was given - Only two possible values (sparr or live)
     * @type {string}
     * @memberof Feedback
     */
    'environment'?: string;
    /**
     * The unique identifier of the feedback
     * @type {string}
     * @memberof Feedback
     */
    'id'?: string;
    /**
     * The version of the feedback
     * @type {number}
     * @memberof Feedback
     */
    'version'?: number;
    /**
     * 
     * @type {FeedbackProps}
     * @memberof Feedback
     */
    'feedbackProps': FeedbackProps | null;
}
/**
 * 
 * @export
 * @interface FeedbackCommentCore
 */
export interface FeedbackCommentCore {
    /**
     * The ID of the feedback
     * @type {string}
     * @memberof FeedbackCommentCore
     */
    'feedbackId': string;
    /**
     * 
     * @type {Array<FeedbackCommentThreadInput>}
     * @memberof FeedbackCommentCore
     */
    'comments': Array<FeedbackCommentThreadInput>;
    /**
     * The status of the feedback comment
     * @type {string}
     * @memberof FeedbackCommentCore
     */
    'status'?: string;
}
/**
 * The comment on the feedback
 * @export
 * @interface FeedbackCommentInput
 */
export interface FeedbackCommentInput {
    /**
     * The ID of the user who made the comment
     * @type {string}
     * @memberof FeedbackCommentInput
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof FeedbackCommentInput
     */
    'userName': string | null;
    /**
     * 
     * @type {string}
     * @memberof FeedbackCommentInput
     */
    'userProfilePictureUrl'?: string | null;
    /**
     * The comment from the user
     * @type {string}
     * @memberof FeedbackCommentInput
     */
    'comment': string;
    /**
     * The order of the comment in the thread
     * @type {number}
     * @memberof FeedbackCommentInput
     */
    'order'?: number;
}
/**
 * The comment thread on the feedback
 * @export
 * @interface FeedbackCommentThreadInput
 */
export interface FeedbackCommentThreadInput {
    /**
     * 
     * @type {TimestampRange}
     * @memberof FeedbackCommentThreadInput
     */
    'timestampRange': TimestampRange;
    /**
     * The comments on the feedback
     * @type {Array<FeedbackCommentInput>}
     * @memberof FeedbackCommentThreadInput
     */
    'comments': Array<FeedbackCommentInput>;
}
/**
 * The comment thread on the feedback
 * @export
 * @interface FeedbackCommentThreadOutput
 */
export interface FeedbackCommentThreadOutput {
    /**
     * 
     * @type {TimestampRange}
     * @memberof FeedbackCommentThreadOutput
     */
    'timestampRange': TimestampRange;
    /**
     * The comments on the feedback
     * @type {Array<SparrModelsFeedbackFeedbackComment>}
     * @memberof FeedbackCommentThreadOutput
     */
    'comments': Array<SparrModelsFeedbackFeedbackComment>;
}
/**
 * 
 * @export
 * @interface FeedbackCore
 */
export interface FeedbackCore {
    /**
     * The ID of the user who made the call
     * @type {string}
     * @memberof FeedbackCore
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof FeedbackCore
     */
    'userName': string | null;
    /**
     * 
     * @type {string}
     * @memberof FeedbackCore
     */
    'userProfilePictureUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FeedbackCore
     */
    'aiAgentId': string | null;
    /**
     * 
     * @type {string}
     * @memberof FeedbackCore
     */
    'scenarioId': string | null;
    /**
     * 
     * @type {string}
     * @memberof FeedbackCore
     */
    'scenarioName': string | null;
    /**
     * 
     * @type {string}
     * @memberof FeedbackCore
     */
    'personaId': string | null;
    /**
     * 
     * @type {string}
     * @memberof FeedbackCore
     */
    'personaName': string | null;
    /**
     * The start timestamp of the conversation
     * @type {string}
     * @memberof FeedbackCore
     */
    'startTimestamp': string;
    /**
     * The end timestamp of the conversation
     * @type {string}
     * @memberof FeedbackCore
     */
    'endTimestamp': string;
    /**
     * The time in seconds when sparring started
     * @type {number}
     * @memberof FeedbackCore
     */
    'startSparringAt'?: number;
    /**
     * The time in seconds when sparring ended
     * @type {number}
     * @memberof FeedbackCore
     */
    'endSparringAt'?: number;
    /**
     * The top insights from the conversation
     * @type {Array<string>}
     * @memberof FeedbackCore
     */
    'topInsights': Array<string>;
    /**
     * The URL of the recording of the conversation
     * @type {string}
     * @memberof FeedbackCore
     */
    'recordingUrl': string;
    /**
     * The transcript of the conversation
     * @type {Array<SparrDialogLine>}
     * @memberof FeedbackCore
     */
    'transcript': Array<SparrDialogLine>;
    /**
     * 
     * @type {Array<SparrDialogLine>}
     * @memberof FeedbackCore
     */
    'completeTranscript'?: Array<SparrDialogLine> | null;
    /**
     * 
     * @type {Array<SparrDialogLineWithTimestamp>}
     * @memberof FeedbackCore
     */
    'transcriptWithTimestamp'?: Array<SparrDialogLineWithTimestamp> | null;
    /**
     * 
     * @type {AnalyticsModelInput}
     * @memberof FeedbackCore
     */
    'analytics': AnalyticsModelInput;
    /**
     * The overall score of the conversation out of 100 based on the weightage of each goal
     * @type {number}
     * @memberof FeedbackCore
     */
    'overallScore': number;
    /**
     * The status of the feedback
     * @type {string}
     * @memberof FeedbackCore
     */
    'status'?: string;
    /**
     * The environment where the feedback was given - Only two possible values (sparr or live)
     * @type {string}
     * @memberof FeedbackCore
     */
    'environment'?: string;
}
/**
 * The properties of the feedback
 * @export
 * @interface FeedbackProps
 */
export interface FeedbackProps {
    /**
     * 
     * @type {LiveFeedbackProps}
     * @memberof FeedbackProps
     */
    'live_feedback_props'?: LiveFeedbackProps | null;
    /**
     * The properties of the sparring feedback
     * @type {object}
     * @memberof FeedbackProps
     */
    'sparr_feedback_props'?: object;
}
/**
 * Stores the map of file id with respective file URL in storage manager
 * @export
 * @interface Files
 */
export interface Files {
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    'orgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    'fileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    'fileUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface FillerWords
 */
export interface FillerWords {
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof FillerWords
     */
    'words': { [key: string]: number; } | null;
    /**
     * 
     * @type {number}
     * @memberof FillerWords
     */
    'total': number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FillersConfig = {
    ModelProviderDecisionTree: '{\"ModelProvider\":\"decision_tree\"}',
    ModelProviderNaiveBayes: '{\"ModelProvider\":\"naive_bayes\"}',
    ModelProviderRandom: '{\"ModelProvider\":\"random\"}'
} as const;

export type FillersConfig = typeof FillersConfig[keyof typeof FillersConfig];


/**
 * 
 * @export
 * @enum {string}
 */

export const FilterOperator = {
    Eq: 'eq',
    Neq: 'neq',
    In: 'in',
    Nin: 'nin',
    And: 'and',
    Or: 'or',
    Gte: 'gte',
    Lte: 'lte',
    Lt: 'lt'
} as const;

export type FilterOperator = typeof FilterOperator[keyof typeof FilterOperator];


/**
 * 
 * @export
 * @interface FlexibleGenerationRequest
 */
export interface FlexibleGenerationRequest {
    /**
     * Name for the generated evaluator
     * @type {string}
     * @memberof FlexibleGenerationRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FlexibleGenerationRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof FlexibleGenerationRequest
     */
    'file_ids'?: Array<string> | null;
    /**
     * 
     * @type {GoalCoreInput}
     * @memberof FlexibleGenerationRequest
     */
    'goals_core'?: GoalCoreInput | null;
    /**
     * 
     * @type {TrackerCore}
     * @memberof FlexibleGenerationRequest
     */
    'tracker_core'?: TrackerCore | null;
}
/**
 * 
 * @export
 * @interface FrustrationTolerance
 */
export interface FrustrationTolerance {
}
/**
 * 
 * @export
 * @interface FrustrationTolerance1
 */
export interface FrustrationTolerance1 {
}
/**
 * Request model for generating feedback from call recording and user
 * @export
 * @interface GenerateFeedbackRequest
 */
export interface GenerateFeedbackRequest {
    /**
     * 
     * @type {CallRecording}
     * @memberof GenerateFeedbackRequest
     */
    'call_recording': CallRecording;
    /**
     * 
     * @type {UserData}
     * @memberof GenerateFeedbackRequest
     */
    'user': UserData;
    /**
     * 
     * @type {string}
     * @memberof GenerateFeedbackRequest
     */
    'idempotency_key'?: string | null;
}
/**
 * 
 * @export
 * @interface GoalAnalyticsModelInput
 */
export interface GoalAnalyticsModelInput {
    /**
     * 
     * @type {Array<GoalCategoryResponseInput>}
     * @memberof GoalAnalyticsModelInput
     */
    'goals_v1'?: Array<GoalCategoryResponseInput> | null;
    /**
     * 
     * @type {number}
     * @memberof GoalAnalyticsModelInput
     */
    'overall_score'?: number | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof GoalAnalyticsModelInput
     */
    'goals'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface GoalAnalyticsModelOutput
 */
export interface GoalAnalyticsModelOutput {
    /**
     * 
     * @type {Array<GoalCategoryResponseOutput>}
     * @memberof GoalAnalyticsModelOutput
     */
    'goals_v1'?: Array<GoalCategoryResponseOutput> | null;
    /**
     * 
     * @type {number}
     * @memberof GoalAnalyticsModelOutput
     */
    'overall_score'?: number | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof GoalAnalyticsModelOutput
     */
    'goals'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface GoalCategoryResponseInput
 */
export interface GoalCategoryResponseInput {
    /**
     * 
     * @type {Array<GoalEvaluationResultInput>}
     * @memberof GoalCategoryResponseInput
     */
    'skills_goals'?: Array<GoalEvaluationResultInput> | null;
    /**
     * 
     * @type {Array<GoalEvaluationResultInput>}
     * @memberof GoalCategoryResponseInput
     */
    'process_goals'?: Array<GoalEvaluationResultInput> | null;
    /**
     * 
     * @type {Array<GoalEvaluationResultInput>}
     * @memberof GoalCategoryResponseInput
     */
    'communication_goals'?: Array<GoalEvaluationResultInput> | null;
}
/**
 * 
 * @export
 * @interface GoalCategoryResponseOutput
 */
export interface GoalCategoryResponseOutput {
    /**
     * 
     * @type {Array<GoalEvaluationResultOutput>}
     * @memberof GoalCategoryResponseOutput
     */
    'skills_goals'?: Array<GoalEvaluationResultOutput> | null;
    /**
     * 
     * @type {Array<GoalEvaluationResultOutput>}
     * @memberof GoalCategoryResponseOutput
     */
    'process_goals'?: Array<GoalEvaluationResultOutput> | null;
    /**
     * 
     * @type {Array<GoalEvaluationResultOutput>}
     * @memberof GoalCategoryResponseOutput
     */
    'communication_goals'?: Array<GoalEvaluationResultOutput> | null;
}
/**
 * 
 * @export
 * @interface GoalCoreInput
 */
export interface GoalCoreInput {
    /**
     * The name of the goals collection
     * @type {string}
     * @memberof GoalCoreInput
     */
    'name': string;
    /**
     * The description of the goals collection
     * @type {string}
     * @memberof GoalCoreInput
     */
    'description': string;
    /**
     * 
     * @type {Array<GoalInput>}
     * @memberof GoalCoreInput
     */
    'process_goals'?: Array<GoalInput> | null;
    /**
     * 
     * @type {Array<GoalInput>}
     * @memberof GoalCoreInput
     */
    'skills_goals'?: Array<GoalInput> | null;
    /**
     * 
     * @type {Array<GoalInput>}
     * @memberof GoalCoreInput
     */
    'communication_goals'?: Array<GoalInput> | null;
    /**
     * The status of the goals collection
     * @type {string}
     * @memberof GoalCoreInput
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GoalCoreOutput
 */
export interface GoalCoreOutput {
    /**
     * The name of the goals collection
     * @type {string}
     * @memberof GoalCoreOutput
     */
    'name': string;
    /**
     * The description of the goals collection
     * @type {string}
     * @memberof GoalCoreOutput
     */
    'description': string;
    /**
     * 
     * @type {Array<SparrModelsScenarioGoal>}
     * @memberof GoalCoreOutput
     */
    'process_goals'?: Array<SparrModelsScenarioGoal> | null;
    /**
     * 
     * @type {Array<SparrModelsScenarioGoal>}
     * @memberof GoalCoreOutput
     */
    'skills_goals'?: Array<SparrModelsScenarioGoal> | null;
    /**
     * 
     * @type {Array<SparrModelsScenarioGoal>}
     * @memberof GoalCoreOutput
     */
    'communication_goals'?: Array<SparrModelsScenarioGoal> | null;
    /**
     * The status of the goals collection
     * @type {string}
     * @memberof GoalCoreOutput
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GoalEvaluationResultInput
 */
export interface GoalEvaluationResultInput {
    /**
     * Name of the goal
     * @type {string}
     * @memberof GoalEvaluationResultInput
     */
    'name': string;
    /**
     * 
     * @type {EvaluationInput}
     * @memberof GoalEvaluationResultInput
     */
    'evaluation_result'?: EvaluationInput | null;
    /**
     * 
     * @type {number}
     * @memberof GoalEvaluationResultInput
     */
    'score'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GoalEvaluationResultInput
     */
    'weighted_score'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GoalEvaluationResultInput
     */
    'weights'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof GoalEvaluationResultInput
     */
    'evidence'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface GoalEvaluationResultOutput
 */
export interface GoalEvaluationResultOutput {
    /**
     * Name of the goal
     * @type {string}
     * @memberof GoalEvaluationResultOutput
     */
    'name': string;
    /**
     * 
     * @type {EvaluationOutput}
     * @memberof GoalEvaluationResultOutput
     */
    'evaluation_result'?: EvaluationOutput | null;
    /**
     * 
     * @type {number}
     * @memberof GoalEvaluationResultOutput
     */
    'score'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GoalEvaluationResultOutput
     */
    'weighted_score'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GoalEvaluationResultOutput
     */
    'weights'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof GoalEvaluationResultOutput
     */
    'evidence'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface GoalInput
 */
export interface GoalInput {
    /**
     * The name of the goal
     * @type {string}
     * @memberof GoalInput
     */
    'name': string;
    /**
     * The description of the goal
     * @type {string}
     * @memberof GoalInput
     */
    'description': string;
    /**
     * The weightage of the goal in percentage
     * @type {number}
     * @memberof GoalInput
     */
    'weightage': number;
}
/**
 * 
 * @export
 * @interface GoalsSearchResponse
 */
export interface GoalsSearchResponse {
    /**
     * 
     * @type {Array<SparrDbModelsGoal>}
     * @memberof GoalsSearchResponse
     */
    'items': Array<SparrDbModelsGoal>;
    /**
     * 
     * @type {number}
     * @memberof GoalsSearchResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof GoalsSearchResponse
     */
    'pages': number;
    /**
     * 
     * @type {number}
     * @memberof GoalsSearchResponse
     */
    'current_page': number;
    /**
     * 
     * @type {number}
     * @memberof GoalsSearchResponse
     */
    'page_size': number;
}
/**
 * Guest users who are not verified by Trata yet
 * @export
 * @interface GuestInput
 */
export interface GuestInput {
    /**
     * 
     * @type {string}
     * @memberof GuestInput
     */
    'email': string;
    /**
     * 
     * @type {Role}
     * @memberof GuestInput
     */
    'role': Role;
}


/**
 * Guest users who are not verified by Trata yet. They will not be able to use Trata until they are verified.
 * @export
 * @interface GuestOutput
 */
export interface GuestOutput {
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    'orgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    'role'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GuestOutput
     */
    'isEmailVerified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    'last_sent_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    'guestInviteCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GuestOutput
     */
    'sent_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * Reference to all business knowledge base will be stored in Hive
 * @export
 * @interface Hive
 */
export interface Hive {
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    'orgId'?: string;
    /**
     * 
     * @type {HiveContentOutput}
     * @memberof Hive
     */
    'content': HiveContentOutput;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface HiveContentInput
 */
export interface HiveContentInput {
    /**
     * 
     * @type {HiveType}
     * @memberof HiveContentInput
     */
    'hiveType': HiveType;
    /**
     * 
     * @type {string}
     * @memberof HiveContentInput
     */
    'url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof HiveContentInput
     */
    'file_ids'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof HiveContentInput
     */
    'hiveProps'?: { [key: string]: any; } | null;
}


/**
 * 
 * @export
 * @interface HiveContentOutput
 */
export interface HiveContentOutput {
    /**
     * 
     * @type {HiveType}
     * @memberof HiveContentOutput
     */
    'hiveType': HiveType;
    /**
     * 
     * @type {string}
     * @memberof HiveContentOutput
     */
    'url'?: string | null;
    /**
     * 
     * @type {Array<Files>}
     * @memberof HiveContentOutput
     */
    'files'?: Array<Files> | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof HiveContentOutput
     */
    'hiveProps'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof HiveContentOutput
     */
    'internalProps'?: { [key: string]: any; } | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const HiveStorageConfig = {
    CloudProviderGoogleCustomProps: '{\"CloudProvider\":\"google\",\"CustomProps\":{}}',
    CloudProviderAwsCustomProps: '{\"CloudProvider\":\"aws\",\"CustomProps\":{}}'
} as const;

export type HiveStorageConfig = typeof HiveStorageConfig[keyof typeof HiveStorageConfig];


/**
 * 
 * @export
 * @enum {string}
 */

export const HiveType = {
    Website: 'WEBSITE',
    GoogleDocs: 'GOOGLE_DOCS',
    Docs: 'DOCS',
    Transcripts: 'TRANSCRIPTS'
} as const;

export type HiveType = typeof HiveType[keyof typeof HiveType];


/**
 * 
 * @export
 * @interface HttpActionEndpoint
 */
export interface HttpActionEndpoint {
    /**
     * Action endpoint URL
     * @type {string}
     * @memberof HttpActionEndpoint
     */
    'url': string;
    /**
     * Method to be used for invoking the endpoint
     * @type {string}
     * @memberof HttpActionEndpoint
     */
    'method'?: HttpActionEndpointMethodEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof HttpActionEndpoint
     */
    'headers'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof HttpActionEndpoint
     */
    'payload'?: { [key: string]: any; } | null;
}

export const HttpActionEndpointMethodEnum = {
    Get: 'GET',
    Post: 'POST'
} as const;

export type HttpActionEndpointMethodEnum = typeof HttpActionEndpointMethodEnum[keyof typeof HttpActionEndpointMethodEnum];

/**
 * 
 * @export
 * @interface Humanwhatcanbeimproved
 */
export interface Humanwhatcanbeimproved {
}
/**
 * 
 * @export
 * @interface Humanwhatwentwell
 */
export interface Humanwhatwentwell {
}
/**
 * 
 * @export
 * @interface IntelligenceProvider
 */
export interface IntelligenceProvider {
    /**
     * 
     * @type {string}
     * @memberof IntelligenceProvider
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IntelligenceProvider
     */
    'model'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof IntelligenceProvider
     */
    'providerProps'?: { [key: string]: any; } | null;
}
/**
 * Enum class representing intelligence provider
 * @export
 * @enum {string}
 */

export const IntelligenceProviderConfig = {
    CustomPropsModelNameGpt4o20240806ModelProviderOpenai: '{\"CustomProps\":{},\"ModelName\":\"gpt-4o-2024-08-06\",\"ModelProvider\":\"openai\"}',
    CustomPropsModelNameGpt4oRealtimePreviewModelProviderOpenaiRealtime: '{\"CustomProps\":{},\"ModelName\":\"gpt-4o-realtime-preview\",\"ModelProvider\":\"openai-realtime\"}',
    CustomPropsModelNameLlama3170bVersatileModelProviderGroq: '{\"CustomProps\":{},\"ModelName\":\"llama-3.1-70b-versatile\",\"ModelProvider\":\"groq\"}',
    CustomPropsModelNameClaude3Haiku20240307ModelProviderAnthropic: '{\"CustomProps\":{},\"ModelName\":\"claude-3-haiku-20240307\",\"ModelProvider\":\"anthropic\"}',
    CustomPropsModelNameGemini15Flash001ModelProviderGoogle: '{\"CustomProps\":{},\"ModelName\":\"gemini-1.5-flash-001\",\"ModelProvider\":\"google\"}',
    CustomPropsModelNameMistralaiMixtral8x7BInstructV01ModelProviderTogetherAi: '{\"CustomProps\":{},\"ModelName\":\"mistralai/Mixtral-8x7B-Instruct-v0.1\",\"ModelProvider\":\"together-ai\"}',
    CustomPropsModelNameMetaLlamaMetaLlama3170BInstructTurboModelProviderTogetherAi: '{\"CustomProps\":{},\"ModelName\":\"meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo\",\"ModelProvider\":\"together-ai\"}',
    CustomPropsModelNameGoogleGemma7bModelProviderHuggingface: '{\"CustomProps\":{},\"ModelName\":\"google/gemma-7b\",\"ModelProvider\":\"huggingface\"}',
    CustomPropsModelNameMetaLlamaMetaLlama318BInstructModelProviderHuggingface: '{\"CustomProps\":{},\"ModelName\":\"meta-llama/Meta-Llama-3.1-8B-Instruct\",\"ModelProvider\":\"huggingface\"}',
    CustomPropsModelNameMistralaiMistral7BInstructV03ModelProviderHuggingface: '{\"CustomProps\":{},\"ModelName\":\"mistralai/Mistral-7B-Instruct-v0.3\",\"ModelProvider\":\"huggingface\"}',
    CustomPropsModelNameMetaLlama38bInstructV10ModelProviderBedrock: '{\"CustomProps\":{},\"ModelName\":\"meta.llama3-8b-instruct-v1:0\",\"ModelProvider\":\"bedrock\"}'
} as const;

export type IntelligenceProviderConfig = typeof IntelligenceProviderConfig[keyof typeof IntelligenceProviderConfig];


/**
 * 
 * @export
 * @enum {string}
 */

export const InteractionTone = {
    Professional: 'professional',
    Casual: 'casual',
    Friendly: 'friendly',
    Authoritative: 'authoritative'
} as const;

export type InteractionTone = typeof InteractionTone[keyof typeof InteractionTone];


/**
 * Internal action endpoint to be used for calling the action inside the module. Not used by external users
 * @export
 * @interface InternalActionEndpoint
 */
export interface InternalActionEndpoint {
    /**
     * Module where the action is defined
     * @type {string}
     * @memberof InternalActionEndpoint
     */
    'module': string;
    /**
     * Function to be called inside the module
     * @type {string}
     * @memberof InternalActionEndpoint
     */
    'function': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Language = {
    English: 'English',
    Spanish: 'Spanish',
    Hindi: 'Hindi'
} as const;

export type Language = typeof Language[keyof typeof Language];


/**
 * 
 * @export
 * @interface LanguageAccentCombo
 */
export interface LanguageAccentCombo {
    /**
     * 
     * @type {Language}
     * @memberof LanguageAccentCombo
     */
    'language': Language;
    /**
     * 
     * @type {Accent}
     * @memberof LanguageAccentCombo
     */
    'accent': Accent;
}


/**
 * The properties of the live feedback
 * @export
 * @interface LiveFeedbackProps
 */
export interface LiveFeedbackProps {
    /**
     * 
     * @type {string}
     * @memberof LiveFeedbackProps
     */
    'speaker_label': string | null;
    /**
     * 
     * @type {string}
     * @memberof LiveFeedbackProps
     */
    'contact_name': string | null;
    /**
     * Whether the conversation was guessed by the scenario
     * @type {boolean}
     * @memberof LiveFeedbackProps
     */
    'is_scenario_ai_guessed'?: boolean;
    /**
     * Whether the conversation was guessed by the speaker label
     * @type {boolean}
     * @memberof LiveFeedbackProps
     */
    'is_speaker_label_ai_guessed'?: boolean;
}
/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * 
 * @export
 * @interface LongestMonologue
 */
export interface LongestMonologue {
    /**
     * 
     * @type {string}
     * @memberof LongestMonologue
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof LongestMonologue
     */
    'start_at_seconds': number;
    /**
     * 
     * @type {number}
     * @memberof LongestMonologue
     */
    'end_at_seconds': number;
    /**
     * 
     * @type {number}
     * @memberof LongestMonologue
     */
    'duration': number;
}
/**
 * Simple metric data point with alias and value
 * @export
 * @interface MetricDataPoint
 */
export interface MetricDataPoint {
    /**
     * Metric alias name
     * @type {string}
     * @memberof MetricDataPoint
     */
    'alias': string;
    /**
     * 
     * @type {number}
     * @memberof MetricDataPoint
     */
    'value': number | null;
    /**
     * 
     * @type {AggregationFormulaOutput}
     * @memberof MetricDataPoint
     */
    'aggregation': AggregationFormulaOutput;
}


/**
 * Pydantic-compatible filter model for metrics requests
 * @export
 * @interface MetricFilter
 */
export interface MetricFilter {
    /**
     * Field name to filter on
     * @type {string}
     * @memberof MetricFilter
     */
    'field': string;
    /**
     * 
     * @type {FilterOperator}
     * @memberof MetricFilter
     */
    'operator': FilterOperator;
    /**
     * 
     * @type {Value}
     * @memberof MetricFilter
     */
    'value': Value;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const MetricNameInput = {
    Calls: 'CALLS',
    CallDuration: 'CALL_DURATION',
    SparrCalls: 'SPARR_CALLS',
    SparrCallDuration: 'SPARR_CALL_DURATION',
    AppointmentScheduled: 'APPOINTMENT_SCHEDULED',
    CreditsConsumed: 'CREDITS_CONSUMED',
    CreditsConsumedPhoneNumbers: 'CREDITS_CONSUMED_PHONE_NUMBERS',
    CreditsConsumedCallSeconds: 'CREDITS_CONSUMED_CALL_SECONDS',
    CreditsConsumedEmails: 'CREDITS_CONSUMED_EMAILS',
    CreditsConsumedLeadGeneration: 'CREDITS_CONSUMED_LEAD_GENERATION',
    CreditsConsumedLinkedInScraping: 'CREDITS_CONSUMED_LINKED_IN_SCRAPING',
    CreditsConsumedCourses: 'CREDITS_CONSUMED_COURSES',
    CreditsTotal: 'CREDITS_TOTAL',
    CreditsTotalPhoneNumbers: 'CREDITS_TOTAL_PHONE_NUMBERS',
    CreditsTotalCallSeconds: 'CREDITS_TOTAL_CALL_SECONDS',
    CreditsTotalEmails: 'CREDITS_TOTAL_EMAILS',
    CreditsTotalLeadGeneration: 'CREDITS_TOTAL_LEAD_GENERATION',
    CreditsTotalLinkedInScraping: 'CREDITS_TOTAL_LINKED_IN_SCRAPING',
    CreditsTotalCourses: 'CREDITS_TOTAL_COURSES',
    CreditBurnRate: 'CREDIT_BURN_RATE',
    CreditBurnRatePhoneNumbers: 'CREDIT_BURN_RATE_PHONE_NUMBERS',
    CreditBurnRateCallSeconds: 'CREDIT_BURN_RATE_CALL_SECONDS',
    CreditBurnRateEmails: 'CREDIT_BURN_RATE_EMAILS',
    CreditBurnRateLeadGeneration: 'CREDIT_BURN_RATE_LEAD_GENERATION',
    CreditBurnRateLinkedInScraping: 'CREDIT_BURN_RATE_LINKED_IN_SCRAPING',
    CreditBurnRateCourses: 'CREDIT_BURN_RATE_COURSES',
    TotalRevenue: 'TOTAL_REVENUE',
    Profit: 'PROFIT',
    RevenueBySubscription: 'REVENUE_BY_SUBSCRIPTION',
    RevenueByAddOns: 'REVENUE_BY_ADD_ONS',
    MonthlyRecurringRevenue: 'MONTHLY_RECURRING_REVENUE',
    OneTimeRevenue: 'ONE_TIME_REVENUE',
    ActiveSubscriptions: 'ACTIVE_SUBSCRIPTIONS',
    NumberOfActivePayingCustomers: 'NUMBER_OF_ACTIVE_PAYING_CUSTOMERS',
    AverageRevenuePerActivePayingCustomer: 'AVERAGE_REVENUE_PER_ACTIVE_PAYING_CUSTOMER',
    TotalHoursConsumed: 'TOTAL_HOURS_CONSUMED',
    Prospects: 'PROSPECTS',
    Interested: 'INTERESTED',
    NotInterested: 'NOT_INTERESTED',
    NewCustomers: 'NEW_CUSTOMERS'
} as const;

export type MetricNameInput = typeof MetricNameInput[keyof typeof MetricNameInput];


/**
 * Simple metric request with column name, aggregation, and alias
 * @export
 * @interface MetricRequest
 */
export interface MetricRequest {
    /**
     * 
     * @type {SparrModelsAnalyticsMetricName}
     * @memberof MetricRequest
     */
    'name': SparrModelsAnalyticsMetricName;
    /**
     * 
     * @type {SparrModelsAnalyticsAggregationFormula}
     * @memberof MetricRequest
     */
    'aggregation': SparrModelsAnalyticsAggregationFormula;
    /**
     * Response alias name for the metric
     * @type {string}
     * @memberof MetricRequest
     */
    'alias': string;
}


/**
 * 
 * @export
 * @interface MetricResponseDataPointInput
 */
export interface MetricResponseDataPointInput {
    /**
     * Timestamp of the data point
     * @type {string}
     * @memberof MetricResponseDataPointInput
     */
    'timestamp': string;
    /**
     * Value which will be a string representation of integer or floating number
     * @type {string}
     * @memberof MetricResponseDataPointInput
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface MetricsRequestInput
 */
export interface MetricsRequestInput {
    /**
     * Unique identifier for the metric request. This can be helped to co-relate the request and response
     * @type {string}
     * @memberof MetricsRequestInput
     */
    'id': string;
    /**
     * 
     * @type {MetricNameInput}
     * @memberof MetricsRequestInput
     */
    'name': MetricNameInput;
    /**
     * Start date to get metric request
     * @type {string}
     * @memberof MetricsRequestInput
     */
    'fromDate': string;
    /**
     * End date until get metric request
     * @type {string}
     * @memberof MetricsRequestInput
     */
    'toDate': string;
    /**
     * 
     * @type {AggregationPeriod}
     * @memberof MetricsRequestInput
     */
    'aggregationPeriod': AggregationPeriod;
    /**
     * 
     * @type {AggregationFormulaInput}
     * @memberof MetricsRequestInput
     */
    'aggregationFormula': AggregationFormulaInput;
}


/**
 * 
 * @export
 * @interface MetricsResponseInput
 */
export interface MetricsResponseInput {
    /**
     * Unique identifier for the metric response. This will help co-relate the request and response
     * @type {string}
     * @memberof MetricsResponseInput
     */
    'id': string;
    /**
     * 
     * @type {MetricNameInput}
     * @memberof MetricsResponseInput
     */
    'name': MetricNameInput;
    /**
     * List of data points for the metric response
     * @type {Array<MetricResponseDataPointInput>}
     * @memberof MetricsResponseInput
     */
    'datapoints': Array<MetricResponseDataPointInput>;
}


/**
 * 
 * @export
 * @interface Mission
 */
export interface Mission {
    /**
     * 
     * @type {string}
     * @memberof Mission
     */
    'prompt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Mission
     */
    'objective'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Mission
     */
    'greeting': string | null;
    /**
     * 
     * @type {Array<Sequence>}
     * @memberof Mission
     */
    'sequence'?: Array<Sequence> | null;
    /**
     * 
     * @type {string}
     * @memberof Mission
     */
    'farewell'?: string | null;
}
/**
 * FileUpload represents information about uploaded files in the system
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * The user who created.
     * @type {string}
     * @memberof ModelFile
     */
    'createdBy'?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof ModelFile
     */
    'createdAt'?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof ModelFile
     */
    'updatedBy'?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof ModelFile
     */
    'updatedAt'?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof ModelFile
     */
    'orgId'?: string;
    /**
     * The original name of the uploaded file
     * @type {string}
     * @memberof ModelFile
     */
    'filename': string;
    /**
     * The signed storage URL where the file is stored.
     * @type {string}
     * @memberof ModelFile
     */
    'file_url': string;
    /**
     * The unique identifier of the file
     * @type {string}
     * @memberof ModelFile
     */
    'id'?: string;
}
/**
 * Module represents a module that can be used in a course
 * @export
 * @interface Module
 */
export interface Module {
    /**
     * The user who created.
     * @type {string}
     * @memberof Module
     */
    'createdBy'?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof Module
     */
    'createdAt'?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof Module
     */
    'updatedBy'?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof Module
     */
    'updatedAt'?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof Module
     */
    'orgId'?: string;
    /**
     * The name of the module
     * @type {string}
     * @memberof Module
     */
    'name': string;
    /**
     * The description of the module
     * @type {string}
     * @memberof Module
     */
    'description': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Module
     */
    'tags'?: Array<string> | null;
    /**
     * The difficulty level of the module
     * @type {string}
     * @memberof Module
     */
    'difficultyLevel': string;
    /**
     * The ID of the persona
     * @type {string}
     * @memberof Module
     */
    'personaId': string;
    /**
     * 
     * @type {string}
     * @memberof Module
     */
    'personaName': string | null;
    /**
     * The ID of the scenario
     * @type {string}
     * @memberof Module
     */
    'scenarioId': string;
    /**
     * 
     * @type {string}
     * @memberof Module
     */
    'scenarioName': string | null;
    /**
     * The expected completion score of the module out of 100
     * @type {number}
     * @memberof Module
     */
    'passingScorePercentage': number;
    /**
     * The unique identifier of the module
     * @type {string}
     * @memberof Module
     */
    'id'?: string;
    /**
     * The ID of the course
     * @type {string}
     * @memberof Module
     */
    'courseId': string;
    /**
     * 
     * @type {string}
     * @memberof Module
     */
    'courseName': string | null;
    /**
     * The order of the module in the course
     * @type {number}
     * @memberof Module
     */
    'moduleOrder': number;
}
/**
 * 
 * @export
 * @interface ModuleAnalytics
 */
export interface ModuleAnalytics {
    /**
     * 
     * @type {Module}
     * @memberof ModuleAnalytics
     */
    'module': Module;
    /**
     * The number of attempts
     * @type {number}
     * @memberof ModuleAnalytics
     */
    'numberOfAttempts': number;
    /**
     * 
     * @type {ModuleAttemptStatus}
     * @memberof ModuleAnalytics
     */
    'lastAttemptStatus': ModuleAttemptStatus;
    /**
     * Whether the module is completed
     * @type {boolean}
     * @memberof ModuleAnalytics
     */
    'isModuleCompleted': boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ModuleAttemptStatus = {
    Passed: 'PASSED',
    Failed: 'FAILED',
    NotAttempted: 'NOT_ATTEMPTED'
} as const;

export type ModuleAttemptStatus = typeof ModuleAttemptStatus[keyof typeof ModuleAttemptStatus];


/**
 * 
 * @export
 * @interface ModuleCore
 */
export interface ModuleCore {
    /**
     * The name of the module
     * @type {string}
     * @memberof ModuleCore
     */
    'name': string;
    /**
     * The description of the module
     * @type {string}
     * @memberof ModuleCore
     */
    'description': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleCore
     */
    'tags'?: Array<string> | null;
    /**
     * The difficulty level of the module
     * @type {string}
     * @memberof ModuleCore
     */
    'difficultyLevel': string;
    /**
     * The ID of the persona
     * @type {string}
     * @memberof ModuleCore
     */
    'personaId': string;
    /**
     * 
     * @type {string}
     * @memberof ModuleCore
     */
    'personaName': string | null;
    /**
     * The ID of the scenario
     * @type {string}
     * @memberof ModuleCore
     */
    'scenarioId': string;
    /**
     * 
     * @type {string}
     * @memberof ModuleCore
     */
    'scenarioName': string | null;
    /**
     * The expected completion score of the module out of 100
     * @type {number}
     * @memberof ModuleCore
     */
    'passingScorePercentage': number;
}
/**
 * 
 * @export
 * @interface ModuleUpdateRequest
 */
export interface ModuleUpdateRequest {
    /**
     * The name of the module
     * @type {string}
     * @memberof ModuleUpdateRequest
     */
    'name': string;
    /**
     * The description of the module
     * @type {string}
     * @memberof ModuleUpdateRequest
     */
    'description': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleUpdateRequest
     */
    'tags'?: Array<string> | null;
    /**
     * The difficulty level of the module
     * @type {string}
     * @memberof ModuleUpdateRequest
     */
    'difficultyLevel': string;
    /**
     * The ID of the persona
     * @type {string}
     * @memberof ModuleUpdateRequest
     */
    'personaId': string;
    /**
     * 
     * @type {string}
     * @memberof ModuleUpdateRequest
     */
    'personaName': string | null;
    /**
     * The ID of the scenario
     * @type {string}
     * @memberof ModuleUpdateRequest
     */
    'scenarioId': string;
    /**
     * 
     * @type {string}
     * @memberof ModuleUpdateRequest
     */
    'scenarioName': string | null;
    /**
     * The expected completion score of the module out of 100
     * @type {number}
     * @memberof ModuleUpdateRequest
     */
    'passingScorePercentage': number;
    /**
     * 
     * @type {string}
     * @memberof ModuleUpdateRequest
     */
    'id'?: string | null;
}
/**
 * 
 * @export
 * @interface NegotiationStyle
 */
export interface NegotiationStyle {
}
/**
 * 
 * @export
 * @interface NegotiationStyle1
 */
export interface NegotiationStyle1 {
}
/**
 * Defines how to determine the next step
 * @export
 * @interface NextStepResolver
 */
export interface NextStepResolver {
    /**
     * 
     * @type {Array<Condition>}
     * @memberof NextStepResolver
     */
    'conditions'?: Array<Condition> | null;
    /**
     * 
     * @type {string}
     * @memberof NextStepResolver
     */
    'nextStepId'?: string | null;
}
/**
 * No authentication configuration
 * @export
 * @interface NoAuth
 */
export interface NoAuth {
    /**
     * The type of authentication
     * @type {string}
     * @memberof NoAuth
     */
    'authType'?: string;
}
/**
 * 
 * @export
 * @interface NoAuthCredentials
 */
export interface NoAuthCredentials {
    /**
     * Credential type identifier
     * @type {string}
     * @memberof NoAuthCredentials
     */
    'credentialsType'?: string;
}
/**
 * 
 * @export
 * @interface NumberPurchaseRequest
 */
export interface NumberPurchaseRequest {
    /**
     * 
     * @type {string}
     * @memberof NumberPurchaseRequest
     */
    'countryCode': string;
    /**
     * 
     * @type {string}
     * @memberof NumberPurchaseRequest
     */
    'phoneNumber': string;
}
/**
 * OAuth authentication configuration
 * @export
 * @interface OAuth
 */
export interface OAuth {
    /**
     * The type of authentication
     * @type {string}
     * @memberof OAuth
     */
    'authType'?: string;
    /**
     * The client ID for the OAuth app
     * @type {string}
     * @memberof OAuth
     */
    'clientId': string;
    /**
     * The client secret for the OAuth app
     * @type {string}
     * @memberof OAuth
     */
    'clientSecret': string;
    /**
     * The redirect URI for the OAuth app
     * @type {string}
     * @memberof OAuth
     */
    'redirectUri': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OAuth
     */
    'scopes'?: Array<string> | null;
    /**
     * The authorization URL for the OAuth app
     * @type {string}
     * @memberof OAuth
     */
    'authUrl': string;
    /**
     * The token URL for the OAuth app
     * @type {string}
     * @memberof OAuth
     */
    'tokenUrl': string;
}
/**
 * 
 * @export
 * @interface OAuthCredentials
 */
export interface OAuthCredentials {
    /**
     * Credential type identifier
     * @type {string}
     * @memberof OAuthCredentials
     */
    'credentialsType'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthCredentials
     */
    'code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OAuthCredentials
     */
    'accessToken'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OAuthCredentials
     */
    'refreshToken'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OAuthCredentials
     */
    'expiresAt'?: string | null;
}
/**
 * 
 * @export
 * @interface Objection
 */
export interface Objection {
    /**
     * The objection to be handled
     * @type {string}
     * @memberof Objection
     */
    'objection': string;
    /**
     * The rebuttal to the objection
     * @type {string}
     * @memberof Objection
     */
    'rebuttal': string;
}
/**
 * 
 * @export
 * @interface OrgUsersPriceCredits
 */
export interface OrgUsersPriceCredits {
    /**
     * 
     * @type {OrganizationOutput}
     * @memberof OrgUsersPriceCredits
     */
    'organization': OrganizationOutput;
    /**
     * 
     * @type {Array<User>}
     * @memberof OrgUsersPriceCredits
     */
    'users': Array<User>;
    /**
     * 
     * @type {Array<Price>}
     * @memberof OrgUsersPriceCredits
     */
    'prices'?: Array<Price> | null;
    /**
     * 
     * @type {Array<Credit>}
     * @memberof OrgUsersPriceCredits
     */
    'credits'?: Array<Credit> | null;
    /**
     * 
     * @type {string}
     * @memberof OrgUsersPriceCredits
     */
    'resellerAdminUserCredentials'?: string | null;
}
/**
 * 
 * @export
 * @interface OrgWithCourseAssignment
 */
export interface OrgWithCourseAssignment {
    /**
     * 
     * @type {OrganizationOutput}
     * @memberof OrgWithCourseAssignment
     */
    'organization': OrganizationOutput;
    /**
     * 
     * @type {CourseAssignmentStatus}
     * @memberof OrgWithCourseAssignment
     */
    'status'?: CourseAssignmentStatus;
}


/**
 * 
 * @export
 * @interface OrgWithUsers
 */
export interface OrgWithUsers {
    /**
     * 
     * @type {OrganizationOutput}
     * @memberof OrgWithUsers
     */
    'organization': OrganizationOutput;
    /**
     * 
     * @type {Array<User>}
     * @memberof OrgWithUsers
     */
    'users': Array<User>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OrganizationInitializationStatus = {
    Pending: 'PENDING',
    Completed: 'COMPLETED',
    Failed: 'FAILED'
} as const;

export type OrganizationInitializationStatus = typeof OrganizationInitializationStatus[keyof typeof OrganizationInitializationStatus];


/**
 * Organization represents the business using Trata and all users are associated to this business entity
 * @export
 * @interface OrganizationInput
 */
export interface OrganizationInput {
    /**
     * Name of the organization
     * @type {string}
     * @memberof OrganizationInput
     */
    'name': string;
    /**
     * 
     * @type {AddressInput}
     * @memberof OrganizationInput
     */
    'address'?: AddressInput | null;
    /**
     * 
     * @type {TaxDetailsInput}
     * @memberof OrganizationInput
     */
    'tax'?: TaxDetailsInput | null;
    /**
     * 
     * @type {Array<ExternalServiceProviderInput>}
     * @memberof OrganizationInput
     */
    'externalReferenceIds'?: Array<ExternalServiceProviderInput> | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationInput
     */
    'billingEmailAddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationInput
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {AgentConfig}
     * @memberof OrganizationInput
     */
    'agentConfig'?: AgentConfig | null;
    /**
     * 
     * @type {AppEnumInput}
     * @memberof OrganizationInput
     */
    'app'?: AppEnumInput | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationInput
     */
    'orgType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationInput
     */
    'additionalInfo'?: string | null;
}


/**
 * Organization represents the business using Trata and all users are associated to this business entity
 * @export
 * @interface OrganizationOutput
 */
export interface OrganizationOutput {
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    'name'?: string;
    /**
     * 
     * @type {AgentConfig}
     * @memberof OrganizationOutput
     */
    'config': AgentConfig;
    /**
     * 
     * @type {AddressOutput}
     * @memberof OrganizationOutput
     */
    'address': AddressOutput | null;
    /**
     * 
     * @type {TaxDetailsOutput}
     * @memberof OrganizationOutput
     */
    'tax': TaxDetailsOutput | null;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationOutput
     */
    'isActiveSubscription'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    'billingEmailAddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {Array<ExternalServiceProviderOutput>}
     * @memberof OrganizationOutput
     */
    'externalReferenceIds': Array<ExternalServiceProviderOutput> | null;
    /**
     * 
     * @type {OrganizationInitializationStatus}
     * @memberof OrganizationOutput
     */
    'isInitialized'?: OrganizationInitializationStatus;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OrganizationOutput
     */
    'internalProps': { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OrganizationOutput
     */
    'adminProps': { [key: string]: any; } | null;
    /**
     * If the Organization is created by reseller, this field will have the reseller org id as the parent organization id
     * @type {string}
     * @memberof OrganizationOutput
     */
    'parentOrgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    'orgType'?: string | null;
    /**
     * 
     * @type {AppEnumOutput}
     * @memberof OrganizationOutput
     */
    'app'?: AppEnumOutput;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    'additionalInfo'?: string | null;
}


/**
 * 
 * @export
 * @interface OrganizationSettings
 */
export interface OrganizationSettings {
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    'domain'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    'brandColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    'buttonColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    'secondaryColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    'textColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    'favicon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    'faviconUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    'logo'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    'logoUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface PatienceLevel
 */
export interface PatienceLevel {
}
/**
 * 
 * @export
 * @interface PatienceLevel1
 */
export interface PatienceLevel1 {
}
/**
 * Persona represents a persona that can be used in a scenario
 * @export
 * @interface Persona
 */
export interface Persona {
    /**
     * The user who created.
     * @type {string}
     * @memberof Persona
     */
    'createdBy'?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof Persona
     */
    'createdAt'?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof Persona
     */
    'updatedBy'?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof Persona
     */
    'updatedAt'?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof Persona
     */
    'orgId'?: string;
    /**
     * The name of the persona
     * @type {string}
     * @memberof Persona
     */
    'name': string;
    /**
     * The title of the persona
     * @type {string}
     * @memberof Persona
     */
    'title': string;
    /**
     * The context of the persona
     * @type {string}
     * @memberof Persona
     */
    'context': string;
    /**
     * 
     * @type {SparrVoiceOutput}
     * @memberof Persona
     */
    'voice': SparrVoiceOutput;
    /**
     * 
     * @type {SparrDemeanorOutput}
     * @memberof Persona
     */
    'demeanor': SparrDemeanorOutput;
    /**
     * The additional background of the persona
     * @type {string}
     * @memberof Persona
     */
    'additionalBackground': string;
    /**
     * The work history of the persona
     * @type {Array<SparrWorkDetails>}
     * @memberof Persona
     */
    'workHistory': Array<SparrWorkDetails>;
    /**
     * The LinkedIn URL of the persona
     * @type {string}
     * @memberof Persona
     */
    'linkedInUrl': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'twitterUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'blogUrl': string | null;
    /**
     * Whether the persona is inherited from the parent persona
     * @type {boolean}
     * @memberof Persona
     */
    'isInherited'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'profilePictureUrl': string | null;
    /**
     * The communication style of the persona
     * @type {string}
     * @memberof Persona
     */
    'communicationStyle'?: string;
    /**
     * The status of the persona
     * @type {string}
     * @memberof Persona
     */
    'status'?: string;
    /**
     * The unique identifier of the persona
     * @type {string}
     * @memberof Persona
     */
    'id'?: string;
    /**
     * The version of the persona
     * @type {number}
     * @memberof Persona
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface PersonaAttributesAndTraits
 */
export interface PersonaAttributesAndTraits {
    /**
     * 
     * @type {PatienceLevel}
     * @memberof PersonaAttributesAndTraits
     */
    'patience_level'?: PatienceLevel | null;
    /**
     * 
     * @type {DecisionMakingStyle}
     * @memberof PersonaAttributesAndTraits
     */
    'decision_making_style'?: DecisionMakingStyle | null;
    /**
     * 
     * @type {CommunicationStyle}
     * @memberof PersonaAttributesAndTraits
     */
    'communication_style'?: CommunicationStyle | null;
    /**
     * 
     * @type {Adaptability1}
     * @memberof PersonaAttributesAndTraits
     */
    'adaptability'?: Adaptability1 | null;
    /**
     * 
     * @type {FrustrationTolerance}
     * @memberof PersonaAttributesAndTraits
     */
    'frustration_tolerance'?: FrustrationTolerance | null;
    /**
     * 
     * @type {EngagementLevel}
     * @memberof PersonaAttributesAndTraits
     */
    'engagement_level'?: EngagementLevel | null;
    /**
     * 
     * @type {PreferredTone}
     * @memberof PersonaAttributesAndTraits
     */
    'preferred_tone'?: PreferredTone | null;
    /**
     * 
     * @type {NegotiationStyle}
     * @memberof PersonaAttributesAndTraits
     */
    'negotiation_style'?: NegotiationStyle | null;
}
/**
 * 
 * @export
 * @interface PersonaCore
 */
export interface PersonaCore {
    /**
     * The name of the persona
     * @type {string}
     * @memberof PersonaCore
     */
    'name': string;
    /**
     * The title of the persona
     * @type {string}
     * @memberof PersonaCore
     */
    'title': string;
    /**
     * The context of the persona
     * @type {string}
     * @memberof PersonaCore
     */
    'context': string;
    /**
     * 
     * @type {SparrVoiceInput}
     * @memberof PersonaCore
     */
    'voice': SparrVoiceInput;
    /**
     * 
     * @type {SparrDemeanorInput}
     * @memberof PersonaCore
     */
    'demeanor': SparrDemeanorInput;
    /**
     * The additional background of the persona
     * @type {string}
     * @memberof PersonaCore
     */
    'additionalBackground': string;
    /**
     * The work history of the persona
     * @type {Array<SparrWorkDetails>}
     * @memberof PersonaCore
     */
    'workHistory': Array<SparrWorkDetails>;
    /**
     * The LinkedIn URL of the persona
     * @type {string}
     * @memberof PersonaCore
     */
    'linkedInUrl': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaCore
     */
    'twitterUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaCore
     */
    'blogUrl': string | null;
    /**
     * Whether the persona is inherited from the parent persona
     * @type {boolean}
     * @memberof PersonaCore
     */
    'isInherited'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PersonaCore
     */
    'profilePictureUrl': string | null;
    /**
     * The communication style of the persona
     * @type {string}
     * @memberof PersonaCore
     */
    'communicationStyle'?: string;
    /**
     * The status of the persona
     * @type {string}
     * @memberof PersonaCore
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface PersonaSearchResponse
 */
export interface PersonaSearchResponse {
    /**
     * 
     * @type {Array<Persona>}
     * @memberof PersonaSearchResponse
     */
    'items': Array<Persona>;
    /**
     * 
     * @type {number}
     * @memberof PersonaSearchResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PersonaSearchResponse
     */
    'pages': number;
    /**
     * 
     * @type {number}
     * @memberof PersonaSearchResponse
     */
    'current_page': number;
    /**
     * 
     * @type {number}
     * @memberof PersonaSearchResponse
     */
    'page_size': number;
}
/**
 * 
 * @export
 * @interface PreferredTone
 */
export interface PreferredTone {
}
/**
 * 
 * @export
 * @interface PreferredTone1
 */
export interface PreferredTone1 {
}
/**
 * Price tier details of the business
 * @export
 * @interface Price
 */
export interface Price {
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'parentOrgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'orgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'priceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Price
     */
    'isDefault'?: boolean | null;
    /**
     * Currency of the price, e.g. USD, INR, EUR, GBP, etc.
     * @type {string}
     * @memberof Price
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'stripePriceId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'stripeProductId'?: string | null;
    /**
     * 
     * @type {PriceInterval}
     * @memberof Price
     */
    'priceInterval'?: PriceInterval | null;
    /**
     * 
     * @type {Array<PriceItem>}
     * @memberof Price
     */
    'priceItems'?: Array<PriceItem> | null;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'updatedAt'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PriceInterval = {
    OneTime: 'one_time',
    Monthly: 'monthly',
    Quarterly: 'quarterly',
    Yearly: 'yearly'
} as const;

export type PriceInterval = typeof PriceInterval[keyof typeof PriceInterval];


/**
 * Price item details for a price tier
 * @export
 * @interface PriceItem
 */
export interface PriceItem {
    /**
     * Name of the price item
     * @type {string}
     * @memberof PriceItem
     */
    'name'?: string;
    /**
     * Description of the price item
     * @type {string}
     * @memberof PriceItem
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof PriceItem
     */
    'quantity'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PriceItem
     */
    'pricePerQuantity'?: number | null;
    /**
     * 
     * @type {CreditTypeEnum}
     * @memberof PriceItem
     */
    'creditType'?: CreditTypeEnum;
}


/**
 * 
 * @export
 * @interface PricingRequest
 */
export interface PricingRequest {
    /**
     * Price name
     * @type {string}
     * @memberof PricingRequest
     */
    'priceName': string;
    /**
     * Description
     * @type {string}
     * @memberof PricingRequest
     */
    'description': string;
    /**
     * Currency
     * @type {string}
     * @memberof PricingRequest
     */
    'currency': string;
    /**
     * 
     * @type {PriceInterval}
     * @memberof PricingRequest
     */
    'priceInterval': PriceInterval;
    /**
     * 
     * @type {Array<PriceItem>}
     * @memberof PricingRequest
     */
    'priceItems'?: Array<PriceItem> | null;
}


/**
 * 
 * @export
 * @interface ProductInput
 */
export interface ProductInput {
    /**
     * Product is active or not
     * @type {boolean}
     * @memberof ProductInput
     */
    'active': boolean;
    /**
     * Default price of the product this is represented in the lowest currency denomination. Eg: 1000 for $10
     * @type {number}
     * @memberof ProductInput
     */
    'defaultPrice': number;
    /**
     * Currency of the product
     * @type {string}
     * @memberof ProductInput
     */
    'currency': ProductInputCurrencyEnum;
    /**
     * Description of the product
     * @type {string}
     * @memberof ProductInput
     */
    'description': string;
    /**
     * Name of the product
     * @type {string}
     * @memberof ProductInput
     */
    'name': string;
    /**
     * Product is shippable or not. Service is not shippable
     * @type {boolean}
     * @memberof ProductInput
     */
    'shippable'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductInput
     */
    'features'?: Array<string> | null;
    /**
     * Product requires appointment scheduling or not
     * @type {boolean}
     * @memberof ProductInput
     */
    'scheduleAppointment'?: boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ProductInput
     */
    'props'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof ProductInput
     */
    'tags'?: Set<string> | null;
    /**
     * 
     * @type {Status}
     * @memberof ProductInput
     */
    'status': Status;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductInput
     */
    'agentIds'?: Array<string> | null;
}

export const ProductInputCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Bov: 'BOV',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Che: 'CHE',
    Chf: 'CHF',
    Chw: 'CHW',
    Clf: 'CLF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Cou: 'COU',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mru: 'MRU',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Mxv: 'MXV',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sle: 'SLE',
    Sll: 'SLL',
    Sos: 'SOS',
    Srd: 'SRD',
    Ssp: 'SSP',
    Stn: 'STN',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Usn: 'USN',
    Uyi: 'UYI',
    Uyu: 'UYU',
    Uyw: 'UYW',
    Uzs: 'UZS',
    Ved: 'VED',
    Ves: 'VES',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xof: 'XOF',
    Xpf: 'XPF',
    Xsu: 'XSU',
    Xua: 'XUA',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwl: 'ZWL'
} as const;

export type ProductInputCurrencyEnum = typeof ProductInputCurrencyEnum[keyof typeof ProductInputCurrencyEnum];

/**
 * Product and services offered by the business
 * @export
 * @interface ProductOutput
 */
export interface ProductOutput {
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    'orgId'?: string;
    /**
     * Product is active or not
     * @type {boolean}
     * @memberof ProductOutput
     */
    'active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ProductOutput
     */
    'defaultPrice'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    'description'?: string | null;
    /**
     * Name of the product
     * @type {string}
     * @memberof ProductOutput
     */
    'name'?: string;
    /**
     * Product is shippable or not. Service is not shippable
     * @type {boolean}
     * @memberof ProductOutput
     */
    'shippable'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductOutput
     */
    'features'?: Array<string> | null;
    /**
     * Product requires appointment scheduling or not
     * @type {boolean}
     * @memberof ProductOutput
     */
    'scheduleAppointment'?: boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ProductOutput
     */
    'props'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof ProductOutput
     */
    'tags'?: Set<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ProductWithAgents
 */
export interface ProductWithAgents {
    /**
     * 
     * @type {ProductOutput}
     * @memberof ProductWithAgents
     */
    'product': ProductOutput;
    /**
     * 
     * @type {Array<AgentsInner>}
     * @memberof ProductWithAgents
     */
    'agents'?: Array<AgentsInner>;
}
/**
 * 
 * @export
 * @interface PromptTemplate
 */
export interface PromptTemplate {
    /**
     * 
     * @type {string}
     * @memberof PromptTemplate
     */
    'prompt': string;
    /**
     * 
     * @type {Array<Sequence>}
     * @memberof PromptTemplate
     */
    'sequences': Array<Sequence>;
    /**
     * 
     * @type {string}
     * @memberof PromptTemplate
     */
    'role': string;
    /**
     * 
     * @type {string}
     * @memberof PromptTemplate
     */
    'roleDescription': string;
    /**
     * 
     * @type {string}
     * @memberof PromptTemplate
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ProspectInput
 */
export interface ProspectInput {
    /**
     * 
     * @type {string}
     * @memberof ProspectInput
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectInput
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectInput
     */
    'phoneNumber'?: string | null;
    /**
     * 
     * @type {Array<ExternalReference>}
     * @memberof ProspectInput
     */
    'externalReference'?: Array<ExternalReference> | null;
    /**
     * 
     * @type {ProspectStatus}
     * @memberof ProspectInput
     */
    'status': ProspectStatus;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ProspectInput
     */
    'prospectProps'?: { [key: string]: any; } | null;
}


/**
 * Prospects are the potential customers for business
 * @export
 * @interface ProspectOutput
 */
export interface ProspectOutput {
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    'orgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    'phoneNumber'?: string | null;
    /**
     * 
     * @type {Array<ExternalReference>}
     * @memberof ProspectOutput
     */
    'externalReference': Array<ExternalReference> | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    'status': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ProspectOutput
     */
    'prospectProps': { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ProspectStatus = {
    New: 'NEW',
    GeneralEnquiry: 'GENERAL_ENQUIRY',
    ScheduledCallbackWithBot: 'SCHEDULED_CALLBACK_WITH_BOT',
    ScheduledAppointmentWithPerson: 'SCHEDULED_APPOINTMENT_WITH_PERSON',
    ScheduledAppointmentForService: 'SCHEDULED_APPOINTMENT_FOR_SERVICE',
    NotInterested: 'NOT_INTERESTED',
    ProductOrderPlaced: 'PRODUCT_ORDER_PLACED',
    ServiceOrderPlaced: 'SERVICE_ORDER_PLACED'
} as const;

export type ProspectStatus = typeof ProspectStatus[keyof typeof ProspectStatus];


/**
 * 
 * @export
 * @interface ResellerBatchMetricsRequests
 */
export interface ResellerBatchMetricsRequests {
    /**
     * 
     * @type {Array<string>}
     * @memberof ResellerBatchMetricsRequests
     */
    'organizations'?: Array<string> | null;
    /**
     * 
     * @type {Array<MetricsRequestInput>}
     * @memberof ResellerBatchMetricsRequests
     */
    'requests': Array<MetricsRequestInput>;
}
/**
 * 
 * @export
 * @interface ResellerPaymentAccountDetails
 */
export interface ResellerPaymentAccountDetails {
    /**
     * 
     * @type {string}
     * @memberof ResellerPaymentAccountDetails
     */
    'businessName': string | null;
}
/**
 * 
 * @export
 * @interface ResponseGetorganizationbrandingv1
 */
export interface ResponseGetorganizationbrandingv1 {
    /**
     * 
     * @type {string}
     * @memberof ResponseGetorganizationbrandingv1
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetorganizationbrandingv1
     */
    'brandColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetorganizationbrandingv1
     */
    'buttonColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetorganizationbrandingv1
     */
    'secondaryColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetorganizationbrandingv1
     */
    'textColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetorganizationbrandingv1
     */
    'favicon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetorganizationbrandingv1
     */
    'faviconUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetorganizationbrandingv1
     */
    'logo'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetorganizationbrandingv1
     */
    'logoUrl'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Role = {
    Admin: 'ADMIN',
    ReadOnly: 'READ_ONLY',
    Owner: 'OWNER',
    ResellerAdmin: 'RESELLER_ADMIN'
} as const;

export type Role = typeof Role[keyof typeof Role];


/**
 * 
 * @export
 * @interface RoleTemplate
 */
export interface RoleTemplate {
    /**
     * 
     * @type {string}
     * @memberof RoleTemplate
     */
    'roleName': string;
    /**
     * 
     * @type {string}
     * @memberof RoleTemplate
     */
    'roleDescription': string;
}
/**
 * Rubric levels for consistent scoring
 * @export
 * @enum {string}
 */

export const RubricLevel = {
    NotDemonstrated: 'NOT_DEMONSTRATED',
    Beginning: 'BEGINNING',
    Developing: 'DEVELOPING',
    Competent: 'COMPETENT',
    Advanced: 'ADVANCED',
    Mastery: 'MASTERY',
    InsufficientData: 'INSUFFICIENT_DATA'
} as const;

export type RubricLevel = typeof RubricLevel[keyof typeof RubricLevel];


/**
 * Detailed rubric-based scoring for precision and consistency
 * @export
 * @interface RubricScore
 */
export interface RubricScore {
    /**
     * 
     * @type {RubricLevel}
     * @memberof RubricScore
     */
    'level': RubricLevel;
    /**
     * Confidence in the rubric level assessment (0.0 = low confidence, 1.0 = high confidence)
     * @type {number}
     * @memberof RubricScore
     */
    'confidence'?: number;
    /**
     * Fine-tuning adjustment within the rubric level (-0.5 to +0.5)
     * @type {number}
     * @memberof RubricScore
     */
    'fine_tune'?: number;
    /**
     * Cite the exact user dialogue(s) that support your assessment. Explain briefly how these align with the evaluation criteria. If there are improvement opportunities that can help meet the goals more effectively, include a concise coaching tip. Keep the explanation focused and to the point.
     * @type {Array<string>}
     * @memberof RubricScore
     */
    'evidence'?: Array<string>;
}


/**
 * 
 * @export
 * @interface Rudenesslevel
 */
export interface Rudenesslevel {
}
/**
 * Scenario represents a sequence of steps that can be performed by an app
 * @export
 * @interface Scenario
 */
export interface Scenario {
    /**
     * The user who created.
     * @type {string}
     * @memberof Scenario
     */
    'createdBy'?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof Scenario
     */
    'createdAt'?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof Scenario
     */
    'updatedBy'?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof Scenario
     */
    'updatedAt'?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof Scenario
     */
    'orgId'?: string;
    /**
     * The name of the scenario
     * @type {string}
     * @memberof Scenario
     */
    'name': string;
    /**
     * The description of the scenario
     * @type {string}
     * @memberof Scenario
     */
    'description': string;
    /**
     * The objections to be handled for the scenario
     * @type {Array<Objection>}
     * @memberof Scenario
     */
    'objections': Array<Objection>;
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'callType'?: string | null;
    /**
     * The familiarity level for this scenario
     * @type {string}
     * @memberof Scenario
     */
    'familiarityLevel'?: string;
    /**
     * The goals to be achieved for the scenario
     * @type {Array<SparrModelsScenarioGoal>}
     * @memberof Scenario
     */
    'goals'?: Array<SparrModelsScenarioGoal>;
    /**
     * The playbook to be followed for the scenario
     * @type {Array<Step>}
     * @memberof Scenario
     */
    'playbook': Array<Step>;
    /**
     * Whether the scenario is inherited from the parent scenario
     * @type {boolean}
     * @memberof Scenario
     */
    'isInherited'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'evaluatorId'?: string | null;
    /**
     * The status of the scenario
     * @type {string}
     * @memberof Scenario
     */
    'status'?: string;
    /**
     * The unique identifier of the scenario
     * @type {string}
     * @memberof Scenario
     */
    'id'?: string;
    /**
     * The version of the scenario
     * @type {number}
     * @memberof Scenario
     */
    'version'?: number;
}
/**
 * Response model for scenario including evaluator with goals
 * @export
 * @interface ScenarioResponse
 */
export interface ScenarioResponse {
    /**
     * The unique identifier of the scenario
     * @type {string}
     * @memberof ScenarioResponse
     */
    'id': string;
    /**
     * The version of the scenario
     * @type {number}
     * @memberof ScenarioResponse
     */
    'version': number;
    /**
     * The name of the scenario
     * @type {string}
     * @memberof ScenarioResponse
     */
    'name': string;
    /**
     * The description of the scenario
     * @type {string}
     * @memberof ScenarioResponse
     */
    'description': string;
    /**
     * The objections to be handled for the scenario
     * @type {Array<Objection>}
     * @memberof ScenarioResponse
     */
    'objections': Array<Objection>;
    /**
     * 
     * @type {CallType}
     * @memberof ScenarioResponse
     */
    'callType': CallType | null;
    /**
     * 
     * @type {FamiliarityLevel}
     * @memberof ScenarioResponse
     */
    'familiarityLevel': FamiliarityLevel;
    /**
     * The goals to be achieved for the scenario
     * @type {Array<SparrModelsScenarioGoal>}
     * @memberof ScenarioResponse
     */
    'goals': Array<SparrModelsScenarioGoal>;
    /**
     * The playbook to be followed for the scenario
     * @type {Array<Step>}
     * @memberof ScenarioResponse
     */
    'playbook': Array<Step>;
    /**
     * Whether the scenario is inherited from the parent scenario
     * @type {boolean}
     * @memberof ScenarioResponse
     */
    'isInherited': boolean;
    /**
     * 
     * @type {string}
     * @memberof ScenarioResponse
     */
    'evaluatorId': string | null;
    /**
     * 
     * @type {EvaluatorResponse}
     * @memberof ScenarioResponse
     */
    'evaluator'?: EvaluatorResponse | null;
    /**
     * The status of the scenario
     * @type {string}
     * @memberof ScenarioResponse
     */
    'status': string;
    /**
     * The organization ID
     * @type {string}
     * @memberof ScenarioResponse
     */
    'orgId': string;
    /**
     * The user who created the scenario
     * @type {string}
     * @memberof ScenarioResponse
     */
    'createdBy': string;
    /**
     * The creation timestamp
     * @type {string}
     * @memberof ScenarioResponse
     */
    'createdAt': string;
    /**
     * The user who last updated the scenario
     * @type {string}
     * @memberof ScenarioResponse
     */
    'updatedBy': string;
    /**
     * The last update timestamp
     * @type {string}
     * @memberof ScenarioResponse
     */
    'updatedAt': string;
}


/**
 * 
 * @export
 * @interface ScenarioSearchResponse
 */
export interface ScenarioSearchResponse {
    /**
     * 
     * @type {Array<Scenario>}
     * @memberof ScenarioSearchResponse
     */
    'items': Array<Scenario>;
    /**
     * 
     * @type {number}
     * @memberof ScenarioSearchResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof ScenarioSearchResponse
     */
    'pages': number;
    /**
     * 
     * @type {number}
     * @memberof ScenarioSearchResponse
     */
    'current_page': number;
    /**
     * 
     * @type {number}
     * @memberof ScenarioSearchResponse
     */
    'page_size': number;
}
/**
 * 
 * @export
 * @interface Sequence
 */
export interface Sequence {
    /**
     * Name of the stage
     * @type {string}
     * @memberof Sequence
     */
    'stageName': string;
    /**
     * Description of the stage
     * @type {string}
     * @memberof Sequence
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Sequence
     */
    'otherNotes'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SortOrder = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortOrder = typeof SortOrder[keyof typeof SortOrder];


/**
 * 
 * @export
 * @enum {string}
 */

export const SparrAdaptability = {
    OpenToChange: 'open to change',
    Resistant: 'resistant',
    Indifferent: 'indifferent'
} as const;

export type SparrAdaptability = typeof SparrAdaptability[keyof typeof SparrAdaptability];


/**
 * 
 * @export
 * @enum {string}
 */

export const SparrCommunicationStyle = {
    Direct: 'direct',
    Indirect: 'indirect',
    Verbose: 'verbose',
    Brief: 'brief'
} as const;

export type SparrCommunicationStyle = typeof SparrCommunicationStyle[keyof typeof SparrCommunicationStyle];


/**
 * FeedbackComment represents a comment on a feedback
 * @export
 * @interface SparrDbModelsFeedbackComment
 */
export interface SparrDbModelsFeedbackComment {
    /**
     * The user who created.
     * @type {string}
     * @memberof SparrDbModelsFeedbackComment
     */
    'createdBy'?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof SparrDbModelsFeedbackComment
     */
    'createdAt'?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof SparrDbModelsFeedbackComment
     */
    'updatedBy'?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof SparrDbModelsFeedbackComment
     */
    'updatedAt'?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof SparrDbModelsFeedbackComment
     */
    'orgId'?: string;
    /**
     * The ID of the feedback
     * @type {string}
     * @memberof SparrDbModelsFeedbackComment
     */
    'feedbackId': string;
    /**
     * 
     * @type {Array<FeedbackCommentThreadOutput>}
     * @memberof SparrDbModelsFeedbackComment
     */
    'comments': Array<FeedbackCommentThreadOutput>;
    /**
     * The status of the feedback comment
     * @type {string}
     * @memberof SparrDbModelsFeedbackComment
     */
    'status'?: string;
    /**
     * The unique identifier of the feedback comment
     * @type {string}
     * @memberof SparrDbModelsFeedbackComment
     */
    'id'?: string;
}
/**
 * Goal represents a collection of goals with weightages
 * @export
 * @interface SparrDbModelsGoal
 */
export interface SparrDbModelsGoal {
    /**
     * The user who created.
     * @type {string}
     * @memberof SparrDbModelsGoal
     */
    'createdBy'?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof SparrDbModelsGoal
     */
    'createdAt'?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof SparrDbModelsGoal
     */
    'updatedBy'?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof SparrDbModelsGoal
     */
    'updatedAt'?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof SparrDbModelsGoal
     */
    'orgId'?: string;
    /**
     * The name of the goals collection
     * @type {string}
     * @memberof SparrDbModelsGoal
     */
    'name': string;
    /**
     * The description of the goals collection
     * @type {string}
     * @memberof SparrDbModelsGoal
     */
    'description': string;
    /**
     * 
     * @type {Array<SparrModelsScenarioGoal>}
     * @memberof SparrDbModelsGoal
     */
    'process_goals'?: Array<SparrModelsScenarioGoal> | null;
    /**
     * 
     * @type {Array<SparrModelsScenarioGoal>}
     * @memberof SparrDbModelsGoal
     */
    'skills_goals'?: Array<SparrModelsScenarioGoal> | null;
    /**
     * 
     * @type {Array<SparrModelsScenarioGoal>}
     * @memberof SparrDbModelsGoal
     */
    'communication_goals'?: Array<SparrModelsScenarioGoal> | null;
    /**
     * The status of the goals collection
     * @type {string}
     * @memberof SparrDbModelsGoal
     */
    'status'?: string;
    /**
     * The unique identifier of the goals collection
     * @type {string}
     * @memberof SparrDbModelsGoal
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SparrDecisionMakingStyle = {
    Logical: 'logical',
    Emotional: 'emotional',
    Impulsive: 'impulsive',
    Hesitant: 'hesitant'
} as const;

export type SparrDecisionMakingStyle = typeof SparrDecisionMakingStyle[keyof typeof SparrDecisionMakingStyle];


/**
 * 
 * @export
 * @interface SparrDemeanorInput
 */
export interface SparrDemeanorInput {
    /**
     * 
     * @type {SparrPersonaAttributesAndTraits}
     * @memberof SparrDemeanorInput
     */
    'personaTraits'?: SparrPersonaAttributesAndTraits | null;
    /**
     * 
     * @type {Excitementlevel}
     * @memberof SparrDemeanorInput
     */
    'excitementLevel'?: Excitementlevel | null;
    /**
     * 
     * @type {Rudenesslevel}
     * @memberof SparrDemeanorInput
     */
    'rudenessLevel'?: Rudenesslevel | null;
}
/**
 * 
 * @export
 * @interface SparrDemeanorOutput
 */
export interface SparrDemeanorOutput {
    /**
     * 
     * @type {SparrPersonaAttributesAndTraits}
     * @memberof SparrDemeanorOutput
     */
    'personaTraits'?: SparrPersonaAttributesAndTraits | null;
    /**
     * 
     * @type {Excitementlevel}
     * @memberof SparrDemeanorOutput
     */
    'excitementLevel'?: Excitementlevel | null;
    /**
     * 
     * @type {Rudenesslevel}
     * @memberof SparrDemeanorOutput
     */
    'rudenessLevel'?: Rudenesslevel | null;
}
/**
 * 
 * @export
 * @interface SparrDialogLine
 */
export interface SparrDialogLine {
    /**
     * 
     * @type {string}
     * @memberof SparrDialogLine
     */
    'speaker': string;
    /**
     * 
     * @type {string}
     * @memberof SparrDialogLine
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof SparrDialogLine
     */
    'timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof SparrDialogLine
     */
    'message_id': string;
}
/**
 * 
 * @export
 * @interface SparrDialogLineWithSentiment
 */
export interface SparrDialogLineWithSentiment {
    /**
     * 
     * @type {string}
     * @memberof SparrDialogLineWithSentiment
     */
    'speaker': string;
    /**
     * 
     * @type {string}
     * @memberof SparrDialogLineWithSentiment
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof SparrDialogLineWithSentiment
     */
    'start_at_seconds': number;
    /**
     * 
     * @type {number}
     * @memberof SparrDialogLineWithSentiment
     */
    'end_at_seconds': number;
    /**
     * 
     * @type {string}
     * @memberof SparrDialogLineWithSentiment
     */
    'sentiment': SparrDialogLineWithSentimentSentimentEnum;
    /**
     * 
     * @type {number}
     * @memberof SparrDialogLineWithSentiment
     */
    'sentiment_score': number;
    /**
     * 
     * @type {string}
     * @memberof SparrDialogLineWithSentiment
     */
    'id': string;
}

export const SparrDialogLineWithSentimentSentimentEnum = {
    Positive: 'POSITIVE',
    Negative: 'NEGATIVE',
    Neutral: 'NEUTRAL'
} as const;

export type SparrDialogLineWithSentimentSentimentEnum = typeof SparrDialogLineWithSentimentSentimentEnum[keyof typeof SparrDialogLineWithSentimentSentimentEnum];

/**
 * 
 * @export
 * @interface SparrDialogLineWithTimestamp
 */
export interface SparrDialogLineWithTimestamp {
    /**
     * 
     * @type {string}
     * @memberof SparrDialogLineWithTimestamp
     */
    'speaker': string;
    /**
     * 
     * @type {string}
     * @memberof SparrDialogLineWithTimestamp
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof SparrDialogLineWithTimestamp
     */
    'message_id': string;
    /**
     * 
     * @type {number}
     * @memberof SparrDialogLineWithTimestamp
     */
    'start_at_milliseconds': number;
    /**
     * 
     * @type {number}
     * @memberof SparrDialogLineWithTimestamp
     */
    'end_at_milliseconds': number;
    /**
     * 
     * @type {Array<DialogWordWithTimestamp>}
     * @memberof SparrDialogLineWithTimestamp
     */
    'words': Array<DialogWordWithTimestamp>;
    /**
     * 
     * @type {string}
     * @memberof SparrDialogLineWithTimestamp
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SparrEngagementLevel = {
    HighlyEngaged: 'highly engaged',
    Distracted: 'distracted',
    Uninterested: 'uninterested'
} as const;

export type SparrEngagementLevel = typeof SparrEngagementLevel[keyof typeof SparrEngagementLevel];


/**
 * 
 * @export
 * @enum {string}
 */

export const SparrExcitementLevel = {
    Neutral: 'neutral',
    Interested: 'interested',
    Excited: 'excited',
    Overjoyed: 'overjoyed',
    Euphoric: 'euphoric'
} as const;

export type SparrExcitementLevel = typeof SparrExcitementLevel[keyof typeof SparrExcitementLevel];


/**
 * 
 * @export
 * @enum {string}
 */

export const SparrFrustrationTolerance = {
    Neutral: 'neutral',
    QuickToAnger: 'quick to anger',
    Understanding: 'understanding'
} as const;

export type SparrFrustrationTolerance = typeof SparrFrustrationTolerance[keyof typeof SparrFrustrationTolerance];


/**
 * 
 * @export
 * @enum {string}
 */

export const SparrInteractionTone = {
    Casual: 'casual',
    Professional: 'professional',
    Friendly: 'friendly',
    Authoritative: 'authoritative'
} as const;

export type SparrInteractionTone = typeof SparrInteractionTone[keyof typeof SparrInteractionTone];


/**
 * 
 * @export
 * @interface SparrLanguageAccentCombo
 */
export interface SparrLanguageAccentCombo {
    /**
     * 
     * @type {SparrVoiceLanguage}
     * @memberof SparrLanguageAccentCombo
     */
    'language': SparrVoiceLanguage;
    /**
     * 
     * @type {SparrVoiceAccent}
     * @memberof SparrLanguageAccentCombo
     */
    'accent': SparrVoiceAccent;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SparrModelsAnalyticsAggregationFormula = {
    Count: 'COUNT',
    Sum: 'SUM',
    Avg: 'AVG',
    Min: 'MIN',
    Max: 'MAX',
    Median: 'MEDIAN'
} as const;

export type SparrModelsAnalyticsAggregationFormula = typeof SparrModelsAnalyticsAggregationFormula[keyof typeof SparrModelsAnalyticsAggregationFormula];


/**
 * 
 * @export
 * @interface SparrModelsAnalyticsBatchMetricsRequests
 */
export interface SparrModelsAnalyticsBatchMetricsRequests {
    /**
     * 
     * @type {Array<SparrModelsAnalyticsMetricsRequest>}
     * @memberof SparrModelsAnalyticsBatchMetricsRequests
     */
    'requests': Array<SparrModelsAnalyticsMetricsRequest>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SparrModelsAnalyticsBatchMetricsRequests
     */
    'userIds'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface SparrModelsAnalyticsBatchMetricsResponse
 */
export interface SparrModelsAnalyticsBatchMetricsResponse {
    /**
     * 
     * @type {Array<SparrModelsAnalyticsMetricsResponse>}
     * @memberof SparrModelsAnalyticsBatchMetricsResponse
     */
    'responses': Array<SparrModelsAnalyticsMetricsResponse>;
}
/**
 * Expected output of the post conversation task
 * @export
 * @interface SparrModelsAnalyticsConversationAnalyticsModel
 */
export interface SparrModelsAnalyticsConversationAnalyticsModel {
    /**
     * 
     * @type {string}
     * @memberof SparrModelsAnalyticsConversationAnalyticsModel
     */
    'evaluation_summary': string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof SparrModelsAnalyticsConversationAnalyticsModel
     */
    'top_insights': Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof SparrModelsAnalyticsConversationAnalyticsModel
     */
    'what_went_well': Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof SparrModelsAnalyticsConversationAnalyticsModel
     */
    'what_can_be_improved': Array<string> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SparrModelsAnalyticsMetricName = {
    Calls: 'CALLS',
    CallCount: 'callCount',
    CallDuration: 'CALL_DURATION',
    TalkRatio: 'TALK_RATIO',
    AverageFillerWordsCount: 'AVERAGE_FILLER_WORDS_COUNT',
    AverageOverallScore: 'AVERAGE_OVERALL_SCORE',
    AverageLongestMonologue: 'AVERAGE_LONGEST_MONOLOGUE',
    AverageModulesCompleted: 'AVERAGE_MODULES_COMPLETED',
    AverageActiveDays: 'AVERAGE_ACTIVE_DAYS',
    AverageScore: 'AVERAGE_SCORE',
    ProcessAdherenceScore: 'processAdherenceScore',
    SkillsScore: 'skillsScore',
    CommunicationScore: 'communicationScore',
    UserTalkingRatio: 'userTalkingRatio',
    FillerWords: 'fillerWords',
    OverallScore: 'overallScore',
    ModulesCompleted: 'modulesCompleted',
    CallDuration2: 'callDuration',
    LongestMonologue: 'longestMonologue',
    Winrate: 'winrate',
    ActiveDays: 'activeDays'
} as const;

export type SparrModelsAnalyticsMetricName = typeof SparrModelsAnalyticsMetricName[keyof typeof SparrModelsAnalyticsMetricName];


/**
 * 
 * @export
 * @interface SparrModelsAnalyticsMetricResponseDataPoint
 */
export interface SparrModelsAnalyticsMetricResponseDataPoint {
    /**
     * Timestamp of the data point
     * @type {string}
     * @memberof SparrModelsAnalyticsMetricResponseDataPoint
     */
    'timestamp': string;
    /**
     * Value which will be a string representation of integer or floating number
     * @type {string}
     * @memberof SparrModelsAnalyticsMetricResponseDataPoint
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof SparrModelsAnalyticsMetricResponseDataPoint
     */
    'weight'?: string | null;
}
/**
 * 
 * @export
 * @interface SparrModelsAnalyticsMetricsRequest
 */
export interface SparrModelsAnalyticsMetricsRequest {
    /**
     * Unique identifier for the metric request. This can be helped to co-relate the request and response
     * @type {string}
     * @memberof SparrModelsAnalyticsMetricsRequest
     */
    'id': string;
    /**
     * 
     * @type {SparrModelsAnalyticsMetricName}
     * @memberof SparrModelsAnalyticsMetricsRequest
     */
    'name': SparrModelsAnalyticsMetricName;
    /**
     * Start date to get metric request
     * @type {string}
     * @memberof SparrModelsAnalyticsMetricsRequest
     */
    'fromDate': string;
    /**
     * End date until get metric request
     * @type {string}
     * @memberof SparrModelsAnalyticsMetricsRequest
     */
    'toDate': string;
    /**
     * 
     * @type {AggregationPeriod}
     * @memberof SparrModelsAnalyticsMetricsRequest
     */
    'aggregationPeriod': AggregationPeriod;
    /**
     * 
     * @type {SparrModelsAnalyticsAggregationFormula}
     * @memberof SparrModelsAnalyticsMetricsRequest
     */
    'aggregationFormula': SparrModelsAnalyticsAggregationFormula;
    /**
     * 
     * @type {Array<MetricFilter>}
     * @memberof SparrModelsAnalyticsMetricsRequest
     */
    'filter'?: Array<MetricFilter> | null;
}


/**
 * 
 * @export
 * @interface SparrModelsAnalyticsMetricsResponse
 */
export interface SparrModelsAnalyticsMetricsResponse {
    /**
     * Unique identifier for the metric response. This will help co-relate the request and response
     * @type {string}
     * @memberof SparrModelsAnalyticsMetricsResponse
     */
    'id': string;
    /**
     * 
     * @type {SparrModelsAnalyticsMetricName}
     * @memberof SparrModelsAnalyticsMetricsResponse
     */
    'name': SparrModelsAnalyticsMetricName;
    /**
     * List of data points for the metric response
     * @type {Array<SparrModelsAnalyticsMetricResponseDataPoint>}
     * @memberof SparrModelsAnalyticsMetricsResponse
     */
    'datapoints': Array<SparrModelsAnalyticsMetricResponseDataPoint>;
}


/**
 * 
 * @export
 * @interface SparrModelsBaseBaseResponse
 */
export interface SparrModelsBaseBaseResponse {
    /**
     * The message of the response
     * @type {string}
     * @memberof SparrModelsBaseBaseResponse
     */
    'message'?: string;
    /**
     * The status of the response
     * @type {string}
     * @memberof SparrModelsBaseBaseResponse
     */
    'status'?: string;
}
/**
 * The comment on the feedback
 * @export
 * @interface SparrModelsFeedbackFeedbackComment
 */
export interface SparrModelsFeedbackFeedbackComment {
    /**
     * The ID of the user who made the comment
     * @type {string}
     * @memberof SparrModelsFeedbackFeedbackComment
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof SparrModelsFeedbackFeedbackComment
     */
    'userName': string | null;
    /**
     * 
     * @type {string}
     * @memberof SparrModelsFeedbackFeedbackComment
     */
    'userProfilePictureUrl'?: string | null;
    /**
     * The comment from the user
     * @type {string}
     * @memberof SparrModelsFeedbackFeedbackComment
     */
    'comment': string;
    /**
     * The order of the comment in the thread
     * @type {number}
     * @memberof SparrModelsFeedbackFeedbackComment
     */
    'order'?: number;
}
/**
 * 
 * @export
 * @interface SparrModelsScenarioGoal
 */
export interface SparrModelsScenarioGoal {
    /**
     * The name of the goal
     * @type {string}
     * @memberof SparrModelsScenarioGoal
     */
    'name': string;
    /**
     * The description of the goal
     * @type {string}
     * @memberof SparrModelsScenarioGoal
     */
    'description': string;
    /**
     * The weightage of the goal in percentage
     * @type {number}
     * @memberof SparrModelsScenarioGoal
     */
    'weightage': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SparrNegotiationStyle = {
    HardBargainer: 'hard bargainer',
    FriendlyNegotiator: 'friendly negotiator',
    NonNegotiator: 'non-negotiator'
} as const;

export type SparrNegotiationStyle = typeof SparrNegotiationStyle[keyof typeof SparrNegotiationStyle];


/**
 * 
 * @export
 * @enum {string}
 */

export const SparrPatienceLevel = {
    Neutral: 'neutral',
    VeryPatient: 'very patient',
    Impatient: 'impatient'
} as const;

export type SparrPatienceLevel = typeof SparrPatienceLevel[keyof typeof SparrPatienceLevel];


/**
 * 
 * @export
 * @interface SparrPersonaAttributesAndTraits
 */
export interface SparrPersonaAttributesAndTraits {
    /**
     * 
     * @type {PatienceLevel1}
     * @memberof SparrPersonaAttributesAndTraits
     */
    'patience_level'?: PatienceLevel1 | null;
    /**
     * 
     * @type {DecisionMakingStyle1}
     * @memberof SparrPersonaAttributesAndTraits
     */
    'decision_making_style'?: DecisionMakingStyle1 | null;
    /**
     * 
     * @type {CommunicationStyle1}
     * @memberof SparrPersonaAttributesAndTraits
     */
    'communication_style'?: CommunicationStyle1 | null;
    /**
     * 
     * @type {Adaptability2}
     * @memberof SparrPersonaAttributesAndTraits
     */
    'adaptability'?: Adaptability2 | null;
    /**
     * 
     * @type {FrustrationTolerance1}
     * @memberof SparrPersonaAttributesAndTraits
     */
    'frustration_tolerance'?: FrustrationTolerance1 | null;
    /**
     * 
     * @type {EngagementLevel1}
     * @memberof SparrPersonaAttributesAndTraits
     */
    'engagement_level'?: EngagementLevel1 | null;
    /**
     * 
     * @type {PreferredTone1}
     * @memberof SparrPersonaAttributesAndTraits
     */
    'preferred_tone'?: PreferredTone1 | null;
    /**
     * 
     * @type {NegotiationStyle1}
     * @memberof SparrPersonaAttributesAndTraits
     */
    'negotiation_style'?: NegotiationStyle1 | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SparrRudenessLevel = {
    Courteous: 'courteous',
    Direct: 'direct',
    Irritable: 'irritable',
    Aggressive: 'aggressive',
    Toxic: 'toxic'
} as const;

export type SparrRudenessLevel = typeof SparrRudenessLevel[keyof typeof SparrRudenessLevel];


/**
 * 
 * @export
 * @interface SparrStatsData
 */
export interface SparrStatsData {
    /**
     * 
     * @type {number}
     * @memberof SparrStatsData
     */
    'no_of_calls': number;
    /**
     * 
     * @type {number}
     * @memberof SparrStatsData
     */
    'average_call_duration': number;
    /**
     * 
     * @type {number}
     * @memberof SparrStatsData
     */
    'average_dialogs': number;
    /**
     * 
     * @type {number}
     * @memberof SparrStatsData
     */
    'average_agent_dialog_ratio': number;
    /**
     * 
     * @type {number}
     * @memberof SparrStatsData
     */
    'average_user_dialog_ratio': number;
}
/**
 * 
 * @export
 * @interface SparrStatsResponse
 */
export interface SparrStatsResponse {
    /**
     * 
     * @type {SparrStatsData}
     * @memberof SparrStatsResponse
     */
    'response': SparrStatsData;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SparrVoiceAccent = {
    American: 'American',
    Indian: 'Indian',
    Australian: 'Australian',
    British: 'British',
    Hindi: 'Hindi',
    MiddleEastern: 'Middle Eastern'
} as const;

export type SparrVoiceAccent = typeof SparrVoiceAccent[keyof typeof SparrVoiceAccent];


/**
 * 
 * @export
 * @interface SparrVoiceInput
 */
export interface SparrVoiceInput {
    /**
     * 
     * @type {SparrLanguageAccentCombo}
     * @memberof SparrVoiceInput
     */
    'languageAccent': SparrLanguageAccentCombo;
    /**
     * 
     * @type {string}
     * @memberof SparrVoiceInput
     */
    'modelId': string;
    /**
     * 
     * @type {string}
     * @memberof SparrVoiceInput
     */
    'playbackSpeed'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SparrVoiceInput
     */
    'backgroundNoise'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SparrVoiceLanguage = {
    English: 'English',
    Spanish: 'Spanish',
    Hindi: 'Hindi'
} as const;

export type SparrVoiceLanguage = typeof SparrVoiceLanguage[keyof typeof SparrVoiceLanguage];


/**
 * 
 * @export
 * @interface SparrVoiceOutput
 */
export interface SparrVoiceOutput {
    /**
     * 
     * @type {SparrLanguageAccentCombo}
     * @memberof SparrVoiceOutput
     */
    'languageAccent': SparrLanguageAccentCombo;
    /**
     * 
     * @type {string}
     * @memberof SparrVoiceOutput
     */
    'modelId': string;
    /**
     * 
     * @type {string}
     * @memberof SparrVoiceOutput
     */
    'playbackSpeed'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SparrVoiceOutput
     */
    'backgroundNoise'?: boolean;
}
/**
 * 
 * @export
 * @interface SparrWorkDetails
 */
export interface SparrWorkDetails {
    /**
     * 
     * @type {string}
     * @memberof SparrWorkDetails
     */
    'companyName': string | null;
    /**
     * 
     * @type {string}
     * @memberof SparrWorkDetails
     */
    'jobTitle': string | null;
    /**
     * 
     * @type {string}
     * @memberof SparrWorkDetails
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof SparrWorkDetails
     */
    'startDate': string | null;
    /**
     * 
     * @type {string}
     * @memberof SparrWorkDetails
     */
    'endDate': string | null;
}
/**
 * 
 * @export
 * @interface Sparrv1EvaluateFeedbackRequest
 */
export interface Sparrv1EvaluateFeedbackRequest {
    /**
     * 
     * @type {string}
     * @memberof Sparrv1EvaluateFeedbackRequest
     */
    'thread_id': string;
    /**
     * 
     * @type {string}
     * @memberof Sparrv1EvaluateFeedbackRequest
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Sparrv1EvaluateFeedbackRequest
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Sparrv1EvaluateFeedbackRequest
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof Sparrv1EvaluateFeedbackRequest
     */
    'recording_url': string;
    /**
     * 
     * @type {string}
     * @memberof Sparrv1EvaluateFeedbackRequest
     */
    'contact_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Sparrv1EvaluateFeedbackRequest
     */
    'speaker_label'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Sparrv1EvaluateFeedbackRequest
     */
    'start_timestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Sparrv1EvaluateFeedbackRequest
     */
    'end_timestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Sparrv1EvaluateFeedbackRequest
     */
    'feedback_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Sparrv1EvaluateFeedbackRequest
     */
    'scenario_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Sparrv1EvaluateFeedbackRequest
     */
    'persona_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Sparrv1EvaluateFeedbackRequest
     */
    'transcript'?: string | null;
}
/**
 * 
 * @export
 * @interface StatsData
 */
export interface StatsData {
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    'no_of_prospects': number;
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    'appointment_scheduled': number;
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    'unqualified': number;
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    'average_call_duration': number;
}
/**
 * 
 * @export
 * @interface StatsResponse
 */
export interface StatsResponse {
    /**
     * 
     * @type {StatsData}
     * @memberof StatsResponse
     */
    'response': StatsData;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Status = {
    Active: 'active',
    Inactive: 'inactive',
    Pending: 'pending',
    Archived: 'archived'
} as const;

export type Status = typeof Status[keyof typeof Status];


/**
 * 
 * @export
 * @interface Step
 */
export interface Step {
    /**
     * The name of the step
     * @type {string}
     * @memberof Step
     */
    'name': string;
    /**
     * The description of the step
     * @type {string}
     * @memberof Step
     */
    'description': string;
}
/**
 * Subscription details of the business
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'parentOrgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'orgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'subscriptionTypeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'planName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'priceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'stripeSubscriptionId'?: string;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    'billingCycleStartDate'?: number;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'nextRenewalDate'?: string;
}
/**
 * Subscription details of the business
 * @export
 * @interface SubscriptionInfo
 */
export interface SubscriptionInfo {
    /**
     * 
     * @type {Subscription}
     * @memberof SubscriptionInfo
     */
    'subscription'?: Subscription | null;
    /**
     * 
     * @type {Array<Credit>}
     * @memberof SubscriptionInfo
     */
    'credits'?: Array<Credit> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SynthesizerConfig = {
    CustomPropsModelNameAuraModelProviderDeepgram: '{\"CustomProps\":{},\"ModelName\":\"aura\",\"ModelProvider\":\"Deepgram\"}',
    CustomPropsModelNameTts1ModelProviderOpenAi: '{\"CustomProps\":{},\"ModelName\":\"tts-1\",\"ModelProvider\":\"OpenAI\"}',
    CustomPropsModelNameModelProviderOpenVoice: '{\"CustomProps\":{},\"ModelName\":\"\",\"ModelProvider\":\"OpenVoice\"}',
    CustomPropsCanStreamInputTrueModelNameModelProviderElevenlabs: '{\"CustomProps\":{\"can_stream_input\":true},\"ModelName\":\"\",\"ModelProvider\":\"Elevenlabs\"}',
    CustomPropsCanStreamInputTrueModelNameSonicEnglishModelProviderCartesia: '{\"CustomProps\":{\"can_stream_input\":true},\"ModelName\":\"sonic-english\",\"ModelProvider\":\"Cartesia\"}',
    CustomPropsCanStreamInputTrueModelNameMistModelProviderRime: '{\"CustomProps\":{\"can_stream_input\":true},\"ModelName\":\"mist\",\"ModelProvider\":\"Rime\"}'
} as const;

export type SynthesizerConfig = typeof SynthesizerConfig[keyof typeof SynthesizerConfig];


/**
 * 
 * @export
 * @interface SystemMetricsInput
 */
export interface SystemMetricsInput {
    /**
     * 
     * @type {string}
     * @memberof SystemMetricsInput
     */
    'average_sentiment': SystemMetricsInputAverageSentimentEnum | null;
    /**
     * 
     * @type {FillerWords}
     * @memberof SystemMetricsInput
     */
    'filler_words': FillerWords | null;
    /**
     * 
     * @type {LongestMonologue}
     * @memberof SystemMetricsInput
     */
    'longest_monologue': LongestMonologue | null;
    /**
     * 
     * @type {number}
     * @memberof SystemMetricsInput
     */
    'speech_pace': number | null;
    /**
     * 
     * @type {number}
     * @memberof SystemMetricsInput
     */
    'user_talk_ratio'?: number | null;
    /**
     * 
     * @type {Array<SparrDialogLineWithSentiment>}
     * @memberof SystemMetricsInput
     */
    'dialog_lines_sentiment': Array<SparrDialogLineWithSentiment> | null;
    /**
     * 
     * @type {{ [key: string]: SystemMetricsInput; }}
     * @memberof SystemMetricsInput
     */
    'all_speakers_metrics'?: { [key: string]: SystemMetricsInput; } | null;
}

export const SystemMetricsInputAverageSentimentEnum = {
    Positive: 'POSITIVE',
    Negative: 'NEGATIVE',
    Neutral: 'NEUTRAL',
    Empty: ''
} as const;

export type SystemMetricsInputAverageSentimentEnum = typeof SystemMetricsInputAverageSentimentEnum[keyof typeof SystemMetricsInputAverageSentimentEnum];

/**
 * 
 * @export
 * @interface SystemMetricsOutput
 */
export interface SystemMetricsOutput {
    /**
     * 
     * @type {string}
     * @memberof SystemMetricsOutput
     */
    'average_sentiment': SystemMetricsOutputAverageSentimentEnum | null;
    /**
     * 
     * @type {FillerWords}
     * @memberof SystemMetricsOutput
     */
    'filler_words': FillerWords | null;
    /**
     * 
     * @type {LongestMonologue}
     * @memberof SystemMetricsOutput
     */
    'longest_monologue': LongestMonologue | null;
    /**
     * 
     * @type {number}
     * @memberof SystemMetricsOutput
     */
    'speech_pace': number | null;
    /**
     * 
     * @type {number}
     * @memberof SystemMetricsOutput
     */
    'user_talk_ratio'?: number | null;
    /**
     * 
     * @type {Array<SparrDialogLineWithSentiment>}
     * @memberof SystemMetricsOutput
     */
    'dialog_lines_sentiment': Array<SparrDialogLineWithSentiment> | null;
    /**
     * 
     * @type {{ [key: string]: SystemMetricsOutput; }}
     * @memberof SystemMetricsOutput
     */
    'all_speakers_metrics'?: { [key: string]: SystemMetricsOutput; } | null;
}

export const SystemMetricsOutputAverageSentimentEnum = {
    Positive: 'POSITIVE',
    Negative: 'NEGATIVE',
    Neutral: 'NEUTRAL',
    Empty: ''
} as const;

export type SystemMetricsOutputAverageSentimentEnum = typeof SystemMetricsOutputAverageSentimentEnum[keyof typeof SystemMetricsOutputAverageSentimentEnum];

/**
 * Request model for creating a tag
 * @export
 * @interface TagCreate
 */
export interface TagCreate {
    /**
     * Name of the tag to create
     * @type {string}
     * @memberof TagCreate
     */
    'tagName': string;
}
/**
 * 
 * @export
 * @interface TaxDetailsInput
 */
export interface TaxDetailsInput {
    /**
     * Tax identifier
     * @type {string}
     * @memberof TaxDetailsInput
     */
    'id': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof TaxDetailsInput
     */
    'taxProps': { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface TaxDetailsOutput
 */
export interface TaxDetailsOutput {
    /**
     * 
     * @type {string}
     * @memberof TaxDetailsOutput
     */
    'id': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof TaxDetailsOutput
     */
    'taxProps': { [key: string]: any; } | null;
}
/**
 * Telephone number details of the business
 * @export
 * @interface TelephoneNumber
 */
export interface TelephoneNumber {
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    'orgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    'agentId'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof TelephoneNumber
     */
    'internalProps'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    'updatedAt'?: string;
}
/**
 * Telephony app names
 * @export
 * @enum {string}
 */

export const TelephonyApp = {
    Ringcentral: 'ringcentral',
    Vonage: 'vonage',
    MsTeams: 'ms_teams',
    Avaya: 'avaya',
    Gong: 'gong',
    Zoom: 'zoom',
    Trata: 'trata'
} as const;

export type TelephonyApp = typeof TelephonyApp[keyof typeof TelephonyApp];


/**
 * Request model for OAuth connection
 * @export
 * @interface TelephonyConnectRequest
 */
export interface TelephonyConnectRequest {
    /**
     * OAuth authorization code from the provider
     * @type {string}
     * @memberof TelephonyConnectRequest
     */
    'code': string;
    /**
     * 
     * @type {TelephonyApp}
     * @memberof TelephonyConnectRequest
     */
    'appName': TelephonyApp;
}


/**
 * Response model for OAuth connection
 * @export
 * @interface TelephonyConnectResponse
 */
export interface TelephonyConnectResponse {
    /**
     * Whether the connection was successful
     * @type {boolean}
     * @memberof TelephonyConnectResponse
     */
    'success': boolean;
    /**
     * Response message
     * @type {string}
     * @memberof TelephonyConnectResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof TelephonyConnectResponse
     */
    'connection_id'?: string | null;
}
/**
 * The timestamp range of the comment
 * @export
 * @interface TimestampRange
 */
export interface TimestampRange {
    /**
     * The start timestamp of the comment. In the format minutes:seconds
     * @type {string}
     * @memberof TimestampRange
     */
    'startTimestamp': string;
    /**
     * The end timestamp of the comment. In the format minutes:seconds
     * @type {string}
     * @memberof TimestampRange
     */
    'endTimestamp': string;
}
/**
 * Tracker represents a collection of keywords with name and description
 * @export
 * @interface Tracker
 */
export interface Tracker {
    /**
     * The user who created.
     * @type {string}
     * @memberof Tracker
     */
    'createdBy'?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof Tracker
     */
    'createdAt'?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof Tracker
     */
    'updatedBy'?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof Tracker
     */
    'updatedAt'?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof Tracker
     */
    'orgId'?: string;
    /**
     * The name of the tracker
     * @type {string}
     * @memberof Tracker
     */
    'name': string;
    /**
     * The description of the tracker
     * @type {string}
     * @memberof Tracker
     */
    'description': string;
    /**
     * The list of tracking categories with their keywords
     * @type {Array<TrackingCategory>}
     * @memberof Tracker
     */
    'tracking_categories': Array<TrackingCategory>;
    /**
     * The status of the tracker
     * @type {string}
     * @memberof Tracker
     */
    'status'?: string;
    /**
     * The unique identifier of the tracker
     * @type {string}
     * @memberof Tracker
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface TrackerAnalyticsModel
 */
export interface TrackerAnalyticsModel {
    /**
     * Name of the tracker
     * @type {string}
     * @memberof TrackerAnalyticsModel
     */
    'name': string;
    /**
     * Description of the tracker
     * @type {string}
     * @memberof TrackerAnalyticsModel
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof TrackerAnalyticsModel
     */
    'keywords_used'?: { [key: string]: number; } | null;
}
/**
 * 
 * @export
 * @interface TrackerCore
 */
export interface TrackerCore {
    /**
     * The name of the tracker
     * @type {string}
     * @memberof TrackerCore
     */
    'name': string;
    /**
     * The description of the tracker
     * @type {string}
     * @memberof TrackerCore
     */
    'description': string;
    /**
     * The list of tracking categories with their keywords
     * @type {Array<TrackingCategory>}
     * @memberof TrackerCore
     */
    'tracking_categories': Array<TrackingCategory>;
    /**
     * The status of the tracker
     * @type {string}
     * @memberof TrackerCore
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface TrackerSearchResponse
 */
export interface TrackerSearchResponse {
    /**
     * 
     * @type {Array<Tracker>}
     * @memberof TrackerSearchResponse
     */
    'items': Array<Tracker>;
    /**
     * 
     * @type {number}
     * @memberof TrackerSearchResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof TrackerSearchResponse
     */
    'pages': number;
    /**
     * 
     * @type {number}
     * @memberof TrackerSearchResponse
     */
    'current_page': number;
    /**
     * 
     * @type {number}
     * @memberof TrackerSearchResponse
     */
    'page_size': number;
}
/**
 * 
 * @export
 * @interface TrackingCategory
 */
export interface TrackingCategory {
    /**
     * The name of the tracking category
     * @type {string}
     * @memberof TrackingCategory
     */
    'name': string;
    /**
     * The description of what to track in this category
     * @type {string}
     * @memberof TrackingCategory
     */
    'description': string;
    /**
     * List of keywords provided by user or generated for this tracking category
     * @type {Array<string>}
     * @memberof TrackingCategory
     */
    'keywords': Array<string>;
}
/**
 * 
 * @export
 * @interface Transcriber
 */
export interface Transcriber {
    /**
     * 
     * @type {string}
     * @memberof Transcriber
     */
    'providerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transcriber
     */
    'transcriberModel'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Transcriber
     */
    'providerProps'?: { [key: string]: any; } | null;
}
/**
 * Enum class representing transcriber
 * @export
 * @enum {string}
 */

export const TranscriberConfig = {
    CustomPropsModelNameNova2ModelProviderDeepgram: '{\"CustomProps\":{},\"ModelName\":\"nova-2\",\"ModelProvider\":\"Deepgram\"}',
    CustomPropsModelNameNovaModelProviderDeepgram: '{\"CustomProps\":{},\"ModelName\":\"nova\",\"ModelProvider\":\"Deepgram\"}',
    CustomPropsModelNameBaseModelProviderDeepgram: '{\"CustomProps\":{},\"ModelName\":\"base\",\"ModelProvider\":\"Deepgram\"}',
    CustomPropsModelNameNova2PhonecallModelProviderDeepgram: '{\"CustomProps\":{},\"ModelName\":\"nova-2-phonecall\",\"ModelProvider\":\"Deepgram\"}',
    CustomPropsModelNameSttModelProviderGoogle: '{\"CustomProps\":{},\"ModelName\":\"stt\",\"ModelProvider\":\"google\"}',
    CustomPropsModelNameWhisperModelProviderOpenai: '{\"CustomProps\":{},\"ModelName\":\"whisper\",\"ModelProvider\":\"openai\"}',
    CustomPropsModelNameTinyModelProviderOpenWhisper: '{\"CustomProps\":{},\"ModelName\":\"tiny\",\"ModelProvider\":\"OpenWhisper\"}',
    CustomPropsModelNameMediumModelProviderFastWhisper: '{\"CustomProps\":{},\"ModelName\":\"medium\",\"ModelProvider\":\"FastWhisper\"}',
    CustomPropsModelNameMediumModelProviderFastWhisperStream: '{\"CustomProps\":{},\"ModelName\":\"medium\",\"ModelProvider\":\"FastWhisperStream\"}',
    CustomPropsModelNameMediumModelProviderFastWhisperOnline: '{\"CustomProps\":{},\"ModelName\":\"medium\",\"ModelProvider\":\"FastWhisperOnline\"}'
} as const;

export type TranscriberConfig = typeof TranscriberConfig[keyof typeof TranscriberConfig];


/**
 * Enum for UI node types
 * @export
 * @enum {string}
 */

export const UiNodeType = {
    Action: 'ACTION',
    Condition: 'CONDITION',
    Loop: 'LOOP',
    Subflow: 'SUBFLOW'
} as const;

export type UiNodeType = typeof UiNodeType[keyof typeof UiNodeType];


/**
 * 
 * @export
 * @interface UpdateResellerOrganizationRequest
 */
export interface UpdateResellerOrganizationRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateResellerOrganizationRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {AddressInput}
     * @memberof UpdateResellerOrganizationRequest
     */
    'address'?: AddressInput | null;
    /**
     * 
     * @type {TaxDetailsInput}
     * @memberof UpdateResellerOrganizationRequest
     */
    'tax'?: TaxDetailsInput | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateResellerOrganizationRequest
     */
    'billingEmailAddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateResellerOrganizationRequest
     */
    'websiteUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * Name of the user
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'name': string;
    /**
     * 
     * @type {AuthRole}
     * @memberof UpdateUserRequest
     */
    'role': AuthRole;
}


/**
 * 
 * @export
 * @interface UploadFileResponse
 */
export interface UploadFileResponse {
    /**
     * 
     * @type {string}
     * @memberof UploadFileResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof UploadFileResponse
     */
    'fileUrl': string;
}
/**
 * Model representing the users under an organization
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phoneNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'profilePictureUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'orgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'fullName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt'?: string;
}
/**
 * User id to api key mapping table
 * @export
 * @interface UserApiKeyLink
 */
export interface UserApiKeyLink {
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    'orgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    'secretKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    'keyType'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserApiKeyLink
     */
    'isActive'?: boolean;
}
/**
 * UserCourseAssignment represents a user\'s assignment to a course
 * @export
 * @interface UserCourseAssignment
 */
export interface UserCourseAssignment {
    /**
     * The user who created.
     * @type {string}
     * @memberof UserCourseAssignment
     */
    'createdBy'?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof UserCourseAssignment
     */
    'createdAt'?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof UserCourseAssignment
     */
    'updatedBy'?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof UserCourseAssignment
     */
    'updatedAt'?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof UserCourseAssignment
     */
    'orgId'?: string;
    /**
     * The ID of the user who is taking the course
     * @type {string}
     * @memberof UserCourseAssignment
     */
    'userId': string;
    /**
     * The ID of the course
     * @type {string}
     * @memberof UserCourseAssignment
     */
    'courseId': string;
    /**
     * 
     * @type {string}
     * @memberof UserCourseAssignment
     */
    'courseName': string | null;
    /**
     * 
     * @type {CourseCompletionStatus}
     * @memberof UserCourseAssignment
     */
    'courseCompletionStatus': CourseCompletionStatus;
    /**
     * The score of the course out of 100
     * @type {number}
     * @memberof UserCourseAssignment
     */
    'courseScore': number;
    /**
     * The unique identifier of the user course assignment
     * @type {string}
     * @memberof UserCourseAssignment
     */
    'id'?: string;
}


/**
 * 
 * @export
 * @interface UserCourseAssignmentAnalyticsResponse
 */
export interface UserCourseAssignmentAnalyticsResponse {
    /**
     * 
     * @type {UserCourseAssignment}
     * @memberof UserCourseAssignmentAnalyticsResponse
     */
    'userCourseAssignment': UserCourseAssignment;
    /**
     * Analytics for the course for all modules
     * @type {Array<ModuleAnalytics>}
     * @memberof UserCourseAssignmentAnalyticsResponse
     */
    'courseAnalytics': Array<ModuleAnalytics>;
}
/**
 * Model for user data
 * @export
 * @interface UserData
 */
export interface UserData {
    /**
     * Email of the user
     * @type {string}
     * @memberof UserData
     */
    'email': string;
}
/**
 * UserModuleAttempt represents a user\'s attempt at a module
 * @export
 * @interface UserModuleAttempt
 */
export interface UserModuleAttempt {
    /**
     * The user who created.
     * @type {string}
     * @memberof UserModuleAttempt
     */
    'createdBy'?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof UserModuleAttempt
     */
    'createdAt'?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof UserModuleAttempt
     */
    'updatedBy'?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof UserModuleAttempt
     */
    'updatedAt'?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof UserModuleAttempt
     */
    'orgId'?: string;
    /**
     * The ID of the user who is taking the module
     * @type {string}
     * @memberof UserModuleAttempt
     */
    'userId': string;
    /**
     * The ID of the course
     * @type {string}
     * @memberof UserModuleAttempt
     */
    'courseId': string;
    /**
     * The ID of the module
     * @type {string}
     * @memberof UserModuleAttempt
     */
    'moduleId': string;
    /**
     * 
     * @type {ModuleAttemptStatus}
     * @memberof UserModuleAttempt
     */
    'attemptStatus': ModuleAttemptStatus;
    /**
     * The score of the module out of 100
     * @type {number}
     * @memberof UserModuleAttempt
     */
    'attemptScore': number;
    /**
     * The ID of the feedback
     * @type {string}
     * @memberof UserModuleAttempt
     */
    'feedbackId': string;
    /**
     * The unique identifier of the user module attempt
     * @type {string}
     * @memberof UserModuleAttempt
     */
    'id'?: string;
}


/**
 * 
 * @export
 * @interface UserModuleAttemptCore
 */
export interface UserModuleAttemptCore {
    /**
     * The ID of the user who is taking the module
     * @type {string}
     * @memberof UserModuleAttemptCore
     */
    'userId': string;
    /**
     * The ID of the course
     * @type {string}
     * @memberof UserModuleAttemptCore
     */
    'courseId': string;
    /**
     * The ID of the module
     * @type {string}
     * @memberof UserModuleAttemptCore
     */
    'moduleId': string;
    /**
     * 
     * @type {ModuleAttemptStatus}
     * @memberof UserModuleAttemptCore
     */
    'attemptStatus': ModuleAttemptStatus;
    /**
     * The score of the module out of 100
     * @type {number}
     * @memberof UserModuleAttemptCore
     */
    'attemptScore': number;
    /**
     * The ID of the feedback
     * @type {string}
     * @memberof UserModuleAttemptCore
     */
    'feedbackId': string;
}


/**
 * 
 * @export
 * @interface UserModuleAttemptResponse
 */
export interface UserModuleAttemptResponse {
    /**
     * The ID of the user who is taking the module
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    'userId': string;
    /**
     * The ID of the course
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    'courseId': string;
    /**
     * The ID of the module
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    'moduleId': string;
    /**
     * 
     * @type {ModuleAttemptStatus}
     * @memberof UserModuleAttemptResponse
     */
    'attemptStatus': ModuleAttemptStatus;
    /**
     * The score of the module out of 100
     * @type {number}
     * @memberof UserModuleAttemptResponse
     */
    'attemptScore': number;
    /**
     * The ID of the user module attempt
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    'id': string;
    /**
     * The ID of the feedback
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    'feedbackId': string;
    /**
     * 
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    'moduleName': string | null;
    /**
     * The passing score percentage of the module
     * @type {number}
     * @memberof UserModuleAttemptResponse
     */
    'passingScorePercentage': number;
    /**
     * The difficulty level of the module
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    'difficultyLevel': string;
    /**
     * 
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    'personaName': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    'scenarioName': string | null;
    /**
     * The date and time the module was created
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    'createdBy': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    'updatedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserModuleAttemptResponse
     */
    'updatedBy': string | null;
}


/**
 * Payload for creating a new user
 * @export
 * @interface UserPayload
 */
export interface UserPayload {
    /**
     * 
     * @type {string}
     * @memberof UserPayload
     */
    'email'?: string | null;
    /**
     * 
     * @type {Role}
     * @memberof UserPayload
     */
    'role'?: Role | null;
    /**
     * 
     * @type {string}
     * @memberof UserPayload
     */
    'fullName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserPayload
     */
    'phoneNumber'?: string | null;
}


/**
 * Individual user performance summary
 * @export
 * @interface UserPerformanceSummary
 */
export interface UserPerformanceSummary {
    /**
     * User ID
     * @type {string}
     * @memberof UserPerformanceSummary
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UserPerformanceSummary
     */
    'userProfilePictureUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserPerformanceSummary
     */
    'userName': string | null;
    /**
     * 
     * @type {number}
     * @memberof UserPerformanceSummary
     */
    'avgProcessAdherenceScore': number | null;
    /**
     * 
     * @type {number}
     * @memberof UserPerformanceSummary
     */
    'avgSkillsScore': number | null;
    /**
     * 
     * @type {number}
     * @memberof UserPerformanceSummary
     */
    'avgCommunicationScore': number | null;
    /**
     * 
     * @type {number}
     * @memberof UserPerformanceSummary
     */
    'avgOverallScore': number | null;
    /**
     * Total number of sessions/analytics records
     * @type {number}
     * @memberof UserPerformanceSummary
     */
    'totalSessions': number;
}
/**
 * Request model for user performance summary API
 * @export
 * @interface UserPerformanceSummaryRequest
 */
export interface UserPerformanceSummaryRequest {
    /**
     * Start date for the analytics range
     * @type {string}
     * @memberof UserPerformanceSummaryRequest
     */
    'startDate': string;
    /**
     * End date for the analytics range
     * @type {string}
     * @memberof UserPerformanceSummaryRequest
     */
    'endDate': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPerformanceSummaryRequest
     */
    'userIds'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPerformanceSummaryRequest
     */
    'scenarioIds'?: Array<string> | null;
    /**
     * Column to sort by (userName, avgProcessAdherenceScore, avgSkillsScore, avgCommunicationScore, avgOverallScore)
     * @type {string}
     * @memberof UserPerformanceSummaryRequest
     */
    'sortBy'?: string;
    /**
     * Sort order - ascending or descending
     * @type {string}
     * @memberof UserPerformanceSummaryRequest
     */
    'sortOrder'?: UserPerformanceSummaryRequestSortOrderEnum;
    /**
     * Number of records to skip for pagination
     * @type {number}
     * @memberof UserPerformanceSummaryRequest
     */
    'skip'?: number;
    /**
     * Maximum number of records to return
     * @type {number}
     * @memberof UserPerformanceSummaryRequest
     */
    'limit'?: number;
}

export const UserPerformanceSummaryRequestSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type UserPerformanceSummaryRequestSortOrderEnum = typeof UserPerformanceSummaryRequestSortOrderEnum[keyof typeof UserPerformanceSummaryRequestSortOrderEnum];

/**
 * Response model for user performance summary API
 * @export
 * @interface UserPerformanceSummaryResponse
 */
export interface UserPerformanceSummaryResponse {
    /**
     * Start date of the analytics range
     * @type {string}
     * @memberof UserPerformanceSummaryResponse
     */
    'startDate': string;
    /**
     * End date of the analytics range
     * @type {string}
     * @memberof UserPerformanceSummaryResponse
     */
    'endDate': string;
    /**
     * List of user performance summaries
     * @type {Array<UserPerformanceSummary>}
     * @memberof UserPerformanceSummaryResponse
     */
    'users': Array<UserPerformanceSummary>;
    /**
     * Total number of users matching the criteria
     * @type {number}
     * @memberof UserPerformanceSummaryResponse
     */
    'totalCount': number;
    /**
     * Number of records skipped
     * @type {number}
     * @memberof UserPerformanceSummaryResponse
     */
    'skip': number;
    /**
     * Number of records requested
     * @type {number}
     * @memberof UserPerformanceSummaryResponse
     */
    'limit': number;
    /**
     * Column used for sorting
     * @type {string}
     * @memberof UserPerformanceSummaryResponse
     */
    'sortBy': string;
    /**
     * Sort order applied
     * @type {string}
     * @memberof UserPerformanceSummaryResponse
     */
    'sortOrder': string;
}
/**
 * 
 * @export
 * @interface UserRecentActivity
 */
export interface UserRecentActivity {
    /**
     * 
     * @type {string}
     * @memberof UserRecentActivity
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof UserRecentActivity
     */
    'sparr_persona_name': string;
    /**
     * 
     * @type {string}
     * @memberof UserRecentActivity
     */
    'sparr_scenario_name': string;
    /**
     * 
     * @type {string}
     * @memberof UserRecentActivity
     */
    'sentiment': string;
    /**
     * 
     * @type {number}
     * @memberof UserRecentActivity
     */
    'score': number;
}
/**
 * 
 * @export
 * @interface UserStats
 */
export interface UserStats {
    /**
     * 
     * @type {{ [key: string]: UserStatsItem; }}
     * @memberof UserStats
     */
    'sparr_stats': { [key: string]: UserStatsItem; };
    /**
     * 
     * @type {Array<UserRecentActivity>}
     * @memberof UserStats
     */
    'recent_activity': Array<UserRecentActivity>;
}
/**
 * 
 * @export
 * @interface UserStatsItem
 */
export interface UserStatsItem {
    /**
     * 
     * @type {number}
     * @memberof UserStatsItem
     */
    'total_calls': number;
    /**
     * 
     * @type {number}
     * @memberof UserStatsItem
     */
    'average_score': number;
    /**
     * 
     * @type {number}
     * @memberof UserStatsItem
     */
    'total_sparr_minutes': number;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * Filter value(s)
 * @export
 * @interface Value
 */
export interface Value {
}
/**
 * 
 * @export
 * @interface ValueAnyOfInner
 */
export interface ValueAnyOfInner {
}
/**
 * Link table to store the list of ai agents accessible for each virtual prospect
 * @export
 * @interface VirtualProspectAIAgentLink
 */
export interface VirtualProspectAIAgentLink {
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectAIAgentLink
     */
    'virtualProspectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectAIAgentLink
     */
    'aiAgentId'?: string;
}
/**
 * 
 * @export
 * @interface VirtualProspectInput
 */
export interface VirtualProspectInput {
    /**
     * Name of the virtual prospect
     * @type {string}
     * @memberof VirtualProspectInput
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectInput
     */
    'description'?: string | null;
    /**
     * 
     * @type {PersonaAttributesAndTraits}
     * @memberof VirtualProspectInput
     */
    'personaAttributes': PersonaAttributesAndTraits;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectInput
     */
    'additionalInfo'?: string | null;
    /**
     * 
     * @type {VoiceInput}
     * @memberof VirtualProspectInput
     */
    'voice'?: VoiceInput | null;
    /**
     * 
     * @type {VirtualProspectTypeEnum}
     * @memberof VirtualProspectInput
     */
    'virtualProspectType'?: VirtualProspectTypeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectInput
     */
    'context'?: string | null;
}


/**
 * Virtual prospect details for sparring
 * @export
 * @interface VirtualProspectOutput
 */
export interface VirtualProspectOutput {
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    'orgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    'description'?: string | null;
    /**
     * 
     * @type {PersonaAttributesAndTraits}
     * @memberof VirtualProspectOutput
     */
    'personaAttributes': PersonaAttributesAndTraits | null;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    'additionalInfo'?: string | null;
    /**
     * 
     * @type {VoiceOutput}
     * @memberof VirtualProspectOutput
     */
    'voice'?: VoiceOutput | null;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    'context'?: string | null;
    /**
     * 
     * @type {VirtualProspectTypeEnum}
     * @memberof VirtualProspectOutput
     */
    'virtualProspectType'?: VirtualProspectTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualProspectOutput
     */
    'updatedAt'?: string;
}


/**
 * Enum which stores the list of types of sparring calls
 * @export
 * @enum {string}
 */

export const VirtualProspectTypeEnum = {
    Inbound: 'INBOUND',
    Outbound: 'OUTBOUND'
} as const;

export type VirtualProspectTypeEnum = typeof VirtualProspectTypeEnum[keyof typeof VirtualProspectTypeEnum];


/**
 * 
 * @export
 * @interface VoiceInput
 */
export interface VoiceInput {
    /**
     * 
     * @type {string}
     * @memberof VoiceInput
     */
    'gender': VoiceInputGenderEnum;
    /**
     * 
     * @type {LanguageAccentCombo}
     * @memberof VoiceInput
     */
    'languageAccent': LanguageAccentCombo;
    /**
     * 
     * @type {string}
     * @memberof VoiceInput
     */
    'modelId': string;
    /**
     * 
     * @type {string}
     * @memberof VoiceInput
     */
    'playbackSpeed'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof VoiceInput
     */
    'backgroundNoise'?: boolean;
}

export const VoiceInputGenderEnum = {
    Male: 'Male',
    Female: 'Female',
    Neutral: 'Neutral'
} as const;

export type VoiceInputGenderEnum = typeof VoiceInputGenderEnum[keyof typeof VoiceInputGenderEnum];

/**
 * 
 * @export
 * @interface VoiceModel
 */
export interface VoiceModel {
    /**
     * 
     * @type {VoiceOutput}
     * @memberof VoiceModel
     */
    'voice': VoiceOutput;
    /**
     * 
     * @type {string}
     * @memberof VoiceModel
     */
    'previewUrl': string;
    /**
     * 
     * @type {string}
     * @memberof VoiceModel
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VoiceModel
     */
    'voiceDescription': string;
}
/**
 * 
 * @export
 * @interface VoiceOutput
 */
export interface VoiceOutput {
    /**
     * 
     * @type {string}
     * @memberof VoiceOutput
     */
    'gender': VoiceOutputGenderEnum;
    /**
     * 
     * @type {LanguageAccentCombo}
     * @memberof VoiceOutput
     */
    'languageAccent': LanguageAccentCombo;
    /**
     * 
     * @type {string}
     * @memberof VoiceOutput
     */
    'modelId': string;
    /**
     * 
     * @type {string}
     * @memberof VoiceOutput
     */
    'playbackSpeed'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof VoiceOutput
     */
    'backgroundNoise'?: boolean;
}

export const VoiceOutputGenderEnum = {
    Male: 'Male',
    Female: 'Female',
    Neutral: 'Neutral'
} as const;

export type VoiceOutputGenderEnum = typeof VoiceOutputGenderEnum[keyof typeof VoiceOutputGenderEnum];

/**
 * Workflow represents a sequence of steps that can be performed by an app
 * @export
 * @interface Workflow
 */
export interface Workflow {
    /**
     * The user who created.
     * @type {string}
     * @memberof Workflow
     */
    'createdBy'?: string;
    /**
     * The date and time it was created.
     * @type {string}
     * @memberof Workflow
     */
    'createdAt'?: string;
    /**
     * The user who last updated.
     * @type {string}
     * @memberof Workflow
     */
    'updatedBy'?: string;
    /**
     * The date and time when it was last updated.
     * @type {string}
     * @memberof Workflow
     */
    'updatedAt'?: string;
    /**
     * The workspace of the entity.
     * @type {string}
     * @memberof Workflow
     */
    'orgId'?: string;
    /**
     * The name of the workflow
     * @type {string}
     * @memberof Workflow
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Workflow
     */
    'description'?: string | null;
    /**
     * The version of the workflow
     * @type {string}
     * @memberof Workflow
     */
    'version'?: string;
    /**
     * The steps of the workflow
     * @type {{ [key: string]: WorkflowStepOutput; }}
     * @memberof Workflow
     */
    'steps': { [key: string]: WorkflowStepOutput; };
    /**
     * The id of the start step
     * @type {string}
     * @memberof Workflow
     */
    'startStepId'?: string;
    /**
     * The unique identifier of the workflow
     * @type {string}
     * @memberof Workflow
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface WorkflowActivityInfo
 */
export interface WorkflowActivityInfo {
    /**
     * 
     * @type {string}
     * @memberof WorkflowActivityInfo
     */
    'step_name': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowActivityInfo
     */
    'status': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WorkflowActivityInfo
     */
    'input': { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WorkflowActivityInfo
     */
    'result': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof WorkflowActivityInfo
     */
    'start_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowActivityInfo
     */
    'end_time'?: string | null;
}
/**
 * Workflow Context Model
 * @export
 * @interface WorkflowContext
 */
export interface WorkflowContext {
    /**
     * The ID of the organization
     * @type {string}
     * @memberof WorkflowContext
     */
    'orgId': string;
    /**
     * The ID of the workflow
     * @type {string}
     * @memberof WorkflowContext
     */
    'workflowId': string;
    /**
     * The ID of the run
     * @type {string}
     * @memberof WorkflowContext
     */
    'runId': string;
    /**
     * The input of the step
     * @type {{ [key: string]: any; }}
     * @memberof WorkflowContext
     */
    'stepInput': { [key: string]: any; };
    /**
     * The response of the step
     * @type {{ [key: string]: any; }}
     * @memberof WorkflowContext
     */
    'stepResponse': { [key: string]: any; };
}
/**
 * Core Workflow Model
 * @export
 * @interface WorkflowCore
 */
export interface WorkflowCore {
    /**
     * The name of the workflow
     * @type {string}
     * @memberof WorkflowCore
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowCore
     */
    'description'?: string | null;
    /**
     * The version of the workflow
     * @type {string}
     * @memberof WorkflowCore
     */
    'version'?: string;
    /**
     * The steps of the workflow
     * @type {{ [key: string]: WorkflowStepInput; }}
     * @memberof WorkflowCore
     */
    'steps': { [key: string]: WorkflowStepInput; };
    /**
     * The id of the start step
     * @type {string}
     * @memberof WorkflowCore
     */
    'startStepId'?: string;
}
/**
 * Core Workflow Execution Model
 * @export
 * @interface WorkflowExecution
 */
export interface WorkflowExecution {
    /**
     * The name of the workflow
     * @type {string}
     * @memberof WorkflowExecution
     */
    'workflowName': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowExecution
     */
    'workflowStartTimestamp': string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowExecution
     */
    'workflowEndTimestamp': string | null;
    /**
     * The id of the workflow
     * @type {string}
     * @memberof WorkflowExecution
     */
    'workflowId': string;
    /**
     * The run id of the workflow
     * @type {string}
     * @memberof WorkflowExecution
     */
    'workflowRunId': string;
    /**
     * The status of the workflow execution
     * @type {string}
     * @memberof WorkflowExecution
     */
    'status': string;
    /**
     * The activity info of the workflow execution
     * @type {Array<WorkflowActivityInfo>}
     * @memberof WorkflowExecution
     */
    'activityInfo': Array<WorkflowActivityInfo>;
    /**
     * The final result of the workflow execution
     * @type {{ [key: string]: any; }}
     * @memberof WorkflowExecution
     */
    'result': { [key: string]: any; };
}
/**
 * Flow Step Model
 * @export
 * @interface WorkflowStepInput
 */
export interface WorkflowStepInput {
    /**
     * The id of the step
     * @type {string}
     * @memberof WorkflowStepInput
     */
    'stepId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStepInput
     */
    'appConnectionId'?: string | null;
    /**
     * The app action id of the app
     * @type {string}
     * @memberof WorkflowStepInput
     */
    'appActionId'?: string;
    /**
     * The id of the app
     * @type {string}
     * @memberof WorkflowStepInput
     */
    'appId'?: string;
    /**
     * The name of the app. It must match the app name in AppDefinition implementation
     * @type {string}
     * @memberof WorkflowStepInput
     */
    'appName'?: string;
    /**
     * The version of the app. It must match the app version in AppDefinition implementation
     * @type {string}
     * @memberof WorkflowStepInput
     */
    'appVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStepInput
     */
    'dataResolver'?: string | null;
    /**
     * 
     * @type {NextStepResolver}
     * @memberof WorkflowStepInput
     */
    'nextStepResolver': NextStepResolver;
}
/**
 * Flow Step Model
 * @export
 * @interface WorkflowStepOutput
 */
export interface WorkflowStepOutput {
    /**
     * The id of the step
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    'stepId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    'appConnectionId'?: string | null;
    /**
     * The app action id of the app
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    'appActionId'?: string;
    /**
     * The id of the app
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    'appId'?: string;
    /**
     * The name of the app. It must match the app name in AppDefinition implementation
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    'appName'?: string;
    /**
     * The version of the app. It must match the app version in AppDefinition implementation
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    'appVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStepOutput
     */
    'dataResolver'?: string | null;
    /**
     * 
     * @type {NextStepResolver}
     * @memberof WorkflowStepOutput
     */
    'nextStepResolver': NextStepResolver;
}
/**
 * 
 * @export
 * @interface WorkflowStepTriggerRequest
 */
export interface WorkflowStepTriggerRequest {
    /**
     * 
     * @type {WorkflowContext}
     * @memberof WorkflowStepTriggerRequest
     */
    'workflowContext': WorkflowContext;
    /**
     * 
     * @type {WorkflowStepInput}
     * @memberof WorkflowStepTriggerRequest
     */
    'workflowStep': WorkflowStepInput;
}
/**
 * 
 * @export
 * @interface WorkflowStepTriggerResponse
 */
export interface WorkflowStepTriggerResponse {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WorkflowStepTriggerResponse
     */
    'input': { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WorkflowStepTriggerResponse
     */
    'response': { [key: string]: any; };
}

/**
 * ActionAgentLinkApi - axios parameter creator
 * @export
 */
export const ActionAgentLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionAgentLinkV1: async (actionId: string, agentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('createActionAgentLinkV1', 'actionId', actionId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('createActionAgentLinkV1', 'agentId', agentId)
            const localVarPath = `/v1/actions/{action_id}/ai-agents/{agent_id}/link`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionAgentLinkV1: async (actionId: string, agentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('deleteActionAgentLinkV1', 'actionId', actionId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('deleteActionAgentLinkV1', 'agentId', agentId)
            const localVarPath = `/v1/actions/{action_id}/ai-agents/{agent_id}/link`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsOfAgentV1: async (agentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('listActionsOfAgentV1', 'agentId', agentId)
            const localVarPath = `/v1/ai-agents/{agent_id}/actions`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionAgentLinkApi - functional programming interface
 * @export
 */
export const ActionAgentLinkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionAgentLinkApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActionAgentLinkV1(actionId: string, agentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createActionAgentLinkV1(actionId, agentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionAgentLinkApi.createActionAgentLinkV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteActionAgentLinkV1(actionId: string, agentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteActionAgentLinkV1(actionId, agentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionAgentLinkApi.deleteActionAgentLinkV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActionsOfAgentV1(agentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActionOutput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActionsOfAgentV1(agentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionAgentLinkApi.listActionsOfAgentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActionAgentLinkApi - factory interface
 * @export
 */
export const ActionAgentLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActionAgentLinkApiFp(configuration)
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionAgentLinkV1(actionId: string, agentId: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.createActionAgentLinkV1(actionId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionAgentLinkV1(actionId: string, agentId: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.deleteActionAgentLinkV1(actionId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsOfAgentV1(agentId: string, options?: AxiosRequestConfig): AxiosPromise<Array<ActionOutput>> {
            return localVarFp.listActionsOfAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionAgentLinkApi - object-oriented interface
 * @export
 * @class ActionAgentLinkApi
 * @extends {BaseAPI}
 */
export class ActionAgentLinkApi extends BaseAPI {
    /**
     * Create a Link Between an Action and an Agent
     * @summary Create a Link Between an Action and an Agent
     * @param {string} actionId ID of the action
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    public createActionAgentLinkV1(actionId: string, agentId: string, options?: AxiosRequestConfig) {
        return ActionAgentLinkApiFp(this.configuration).createActionAgentLinkV1(actionId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Link Between an Action and an Agent
     * @summary Delete a Link Between an Action and an Agent
     * @param {string} actionId ID of the action
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    public deleteActionAgentLinkV1(actionId: string, agentId: string, options?: AxiosRequestConfig) {
        return ActionAgentLinkApiFp(this.configuration).deleteActionAgentLinkV1(actionId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Actions Linked to a Specific Agent
     * @summary List All Actions Linked to a Specific Agent
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    public listActionsOfAgentV1(agentId: string, options?: AxiosRequestConfig) {
        return ActionAgentLinkApiFp(this.configuration).listActionsOfAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionV1: async (actionInput: ActionInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionInput' is not null or undefined
            assertParamExists('createActionV1', 'actionInput', actionInput)
            const localVarPath = `/v1/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(actionInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionV1: async (actionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('deleteActionV1', 'actionId', actionId)
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1: async (actionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('getActionV1', 'actionId', actionId)
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Actions
         * @summary List All Actions
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsV1: async (searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActionV1: async (actionId: string, actionInput: ActionInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('updateActionV1', 'actionId', actionId)
            // verify required parameter 'actionInput' is not null or undefined
            assertParamExists('updateActionV1', 'actionInput', actionInput)
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(actionInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActionV1(actionInput: ActionInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createActionV1(actionInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.createActionV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteActionV1(actionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteActionV1(actionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.deleteActionV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActionV1(actionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActionV1(actionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.getActionV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List All Actions
         * @summary List All Actions
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActionsV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActionOutput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.listActionsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateActionV1(actionId: string, actionInput: ActionInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateActionV1(actionId, actionInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.updateActionV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActionsApiFp(configuration)
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionV1(actionInput: ActionInput, options?: AxiosRequestConfig): AxiosPromise<ActionOutput> {
            return localVarFp.createActionV1(actionInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionV1(actionId: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.deleteActionV1(actionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1(actionId: string, options?: AxiosRequestConfig): AxiosPromise<ActionOutput> {
            return localVarFp.getActionV1(actionId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Actions
         * @summary List All Actions
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<ActionOutput>> {
            return localVarFp.listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActionV1(actionId: string, actionInput: ActionInput, options?: AxiosRequestConfig): AxiosPromise<ActionOutput> {
            return localVarFp.updateActionV1(actionId, actionInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI {
    /**
     * Create a New Action
     * @summary Create a New Action
     * @param {ActionInput} actionInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public createActionV1(actionInput: ActionInput, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration).createActionV1(actionInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific Action by ID
     * @summary Delete a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public deleteActionV1(actionId: string, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration).deleteActionV1(actionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Action by ID
     * @summary Get a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getActionV1(actionId: string, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration).getActionV1(actionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Actions
     * @summary List All Actions
     * @param {string | null} [searchBy] 
     * @param {string | null} [searchValue] 
     * @param {string | null} [status] 
     * @param {string | null} [sortBy] 
     * @param {SortOrder | null} [sortOrder] 
     * @param {number | null} [skip] 
     * @param {number | null} [limit] 
     * @param {string | null} [updatedAfter] 
     * @param {string | null} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public listActionsV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration).listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific Action by ID
     * @summary Update a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {ActionInput} actionInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public updateActionV1(actionId: string, actionInput: ActionInput, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration).updateActionV1(actionId, actionInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AgentsApi - axios parameter creator
 * @export
 */
export const AgentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAIAgentV1: async (aIAgentInput: AIAgentInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aIAgentInput' is not null or undefined
            assertParamExists('createAIAgentV1', 'aIAgentInput', aIAgentInput)
            const localVarPath = `/v1/ai-agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aIAgentInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAIAgentV1: async (agentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('deleteAIAgentV1', 'agentId', agentId)
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIAgentV1: async (agentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('getAIAgentV1', 'agentId', agentId)
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All AI Agents
         * @summary List All AI Agents
         * @param {AppEnumInput | null} [app] 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIAgentsV1: async (app?: AppEnumInput | null, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ai-agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIAgentV1: async (agentId: string, aIAgentInput: AIAgentInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('updateAIAgentV1', 'agentId', agentId)
            // verify required parameter 'aIAgentInput' is not null or undefined
            assertParamExists('updateAIAgentV1', 'aIAgentInput', aIAgentInput)
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aIAgentInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentsApi - functional programming interface
 * @export
 */
export const AgentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AgentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAIAgentV1(aIAgentInput: AIAgentInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AIAgentOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAIAgentV1(aIAgentInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.createAIAgentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAIAgentV1(agentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAIAgentV1(agentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.deleteAIAgentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAIAgentV1(agentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AIAgentOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAIAgentV1(agentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.getAIAgentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List All AI Agents
         * @summary List All AI Agents
         * @param {AppEnumInput | null} [app] 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAIAgentsV1(app?: AppEnumInput | null, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AIAgentOutput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.listAIAgentsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAIAgentV1(agentId: string, aIAgentInput: AIAgentInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AIAgentOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAIAgentV1(agentId, aIAgentInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.updateAIAgentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AgentsApi - factory interface
 * @export
 */
export const AgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AgentsApiFp(configuration)
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAIAgentV1(aIAgentInput: AIAgentInput, options?: AxiosRequestConfig): AxiosPromise<AIAgentOutput> {
            return localVarFp.createAIAgentV1(aIAgentInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAIAgentV1(agentId: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.deleteAIAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIAgentV1(agentId: string, options?: AxiosRequestConfig): AxiosPromise<AIAgentOutput> {
            return localVarFp.getAIAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All AI Agents
         * @summary List All AI Agents
         * @param {AppEnumInput | null} [app] 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIAgentsV1(app?: AppEnumInput | null, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<AIAgentOutput>> {
            return localVarFp.listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIAgentV1(agentId: string, aIAgentInput: AIAgentInput, options?: AxiosRequestConfig): AxiosPromise<AIAgentOutput> {
            return localVarFp.updateAIAgentV1(agentId, aIAgentInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AgentsApi - object-oriented interface
 * @export
 * @class AgentsApi
 * @extends {BaseAPI}
 */
export class AgentsApi extends BaseAPI {
    /**
     * Create a New AI Agent
     * @summary Create a New AI Agent
     * @param {AIAgentInput} aIAgentInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public createAIAgentV1(aIAgentInput: AIAgentInput, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).createAIAgentV1(aIAgentInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific AI Agent by ID
     * @summary Delete a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public deleteAIAgentV1(agentId: string, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).deleteAIAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific AI Agent by ID
     * @summary Get a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public getAIAgentV1(agentId: string, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).getAIAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All AI Agents
     * @summary List All AI Agents
     * @param {AppEnumInput | null} [app] 
     * @param {string | null} [searchBy] 
     * @param {string | null} [searchValue] 
     * @param {string | null} [status] 
     * @param {string | null} [sortBy] 
     * @param {SortOrder | null} [sortOrder] 
     * @param {number | null} [skip] 
     * @param {number | null} [limit] 
     * @param {string | null} [updatedAfter] 
     * @param {string | null} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public listAIAgentsV1(app?: AppEnumInput | null, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).listAIAgentsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific AI Agent by ID
     * @summary Update a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {AIAgentInput} aIAgentInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public updateAIAgentV1(agentId: string, aIAgentInput: AIAgentInput, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).updateAIAgentV1(agentId, aIAgentInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get fine grained analytics data from Trata AI like call, duration stats, etc.
         * @summary Get Metrics
         * @param {BatchMetricsRequestsInput} batchMetricsRequestsInput 
         * @param {string | null} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1MetricsPost: async (batchMetricsRequestsInput: BatchMetricsRequestsInput, app?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchMetricsRequestsInput' is not null or undefined
            assertParamExists('getMetricsV1MetricsPost', 'batchMetricsRequestsInput', batchMetricsRequestsInput)
            const localVarPath = `/v1/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchMetricsRequestsInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get aggregated stats from Trata AI like call count, prospect count, etc.
         * @summary Get Aggregated Stats
         * @param {AppEnumInput | null} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallStatsV1StatsGet: async (app?: AppEnumInput | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get simplified user analytics with custom metrics and single date range aggregation.  This endpoint aggregates metrics over the entire date range without time-based grouping. Perfect for getting summary statistics or single aggregated values.  Example request: ```json {     \"startDate\": \"2024-01-01\",     \"endDate\": \"2024-03-31\",     \"metrics\": [         {             \"name\": \"overallScore\",             \"aggregation\": \"AVG\",             \"alias\": \"average_performance\"         },         {             \"name\": \"callDuration\",             \"aggregation\": \"SUM\",             \"alias\": \"total_call_time\"         },         {             \"name\": \"modulesCompleted\",             \"aggregation\": \"COUNT\",             \"alias\": \"completion_count\"         }     ],     \"userIds\": [\"user_id_1\", \"user_id_2\"] } ```  Available metric names: - processAdherenceScore: Process adherence score metric - skillsScore: Skills assessment score metric - communicationScore: Communication effectiveness score metric - userTalkingRatio: Ratio of user talking time vs total conversation time - fillerWords: Count of filler words used - overallScore: Overall performance score metric - modulesCompleted: Number of modules completed - callDuration: Duration of the call in seconds - longestMonologue: Duration of the longest monologue in seconds - winrate: Percentage of calls with overallScore > threshold (use with AVG aggregation) - callCount: Count of calls (each analytics record represents one call) - activeDays: Count of unique days with user activity (use with COUNT aggregation) - userId: User ID for counting unique users - feedbackId: Feedback ID for counting records  Note: Both camelCase and snake_case formats are supported for column names (e.g., \"processAdherenceScore\" or \"process_adherence_score\")  Available aggregations: - SUM: Total values - AVG: Average values - COUNT: Count of non-null values - MIN: Minimum value - MAX: Maximum value
         * @summary Get User Analytics
         * @param {AnalyticsRequest} analyticsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAnalyticsV1: async (analyticsRequest: AnalyticsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'analyticsRequest' is not null or undefined
            assertParamExists('getUserAnalyticsV1', 'analyticsRequest', analyticsRequest)
            const localVarPath = `/v1/sparr/analytics/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(analyticsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user performance summary with aggregated metrics grouped by user.  This endpoint returns a list of users with their average performance scores: - Average Process Adherence Score - Average Skills Score - Average Communication Score - Average Overall Score - Total number of sessions  Features: - Date range filtering (startDate, endDate) - Optional user ID filtering - Sorting by any column (userName, avgProcessAdherenceScore, avgSkillsScore, avgCommunicationScore, avgOverallScore) - Sort order (asc/desc, default desc) - Pagination support (skip/limit)  Example request: ```json {     \"startDate\": \"2024-01-01\",     \"endDate\": \"2024-03-31\",     \"userIds\": [\"user_id_1\", \"user_id_2\"],     \"sortBy\": \"avgOverallScore\",     \"sortOrder\": \"desc\",     \"skip\": 0,     \"limit\": 50 } ```  Available sort columns: - userName: User name - avgProcessAdherenceScore: Average process adherence score - avgSkillsScore: Average skills assessment score - avgCommunicationScore: Average communication effectiveness score - avgOverallScore: Average overall performance score (default)  Returns: - List of user performance summaries - Total count of matching users - Pagination metadata
         * @summary Get User Performance Summary
         * @param {UserPerformanceSummaryRequest} userPerformanceSummaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPerformanceSummaryV1: async (userPerformanceSummaryRequest: UserPerformanceSummaryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPerformanceSummaryRequest' is not null or undefined
            assertParamExists('getUserPerformanceSummaryV1', 'userPerformanceSummaryRequest', userPerformanceSummaryRequest)
            const localVarPath = `/v1/sparr/analytics/users/performance-summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPerformanceSummaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get fine grained analytics data from Trata AI like call, duration stats, etc.
         * @summary Get Metrics
         * @param {BatchMetricsRequestsInput} batchMetricsRequestsInput 
         * @param {string | null} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetricsV1MetricsPost(batchMetricsRequestsInput: BatchMetricsRequestsInput, app?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchMetricsResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetricsV1MetricsPost(batchMetricsRequestsInput, app, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getMetricsV1MetricsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get aggregated stats from Trata AI like call count, prospect count, etc.
         * @summary Get Aggregated Stats
         * @param {AppEnumInput | null} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOverallStatsV1StatsGet(app?: AppEnumInput | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOverallStatsV1StatsGet(app, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getOverallStatsV1StatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get simplified user analytics with custom metrics and single date range aggregation.  This endpoint aggregates metrics over the entire date range without time-based grouping. Perfect for getting summary statistics or single aggregated values.  Example request: ```json {     \"startDate\": \"2024-01-01\",     \"endDate\": \"2024-03-31\",     \"metrics\": [         {             \"name\": \"overallScore\",             \"aggregation\": \"AVG\",             \"alias\": \"average_performance\"         },         {             \"name\": \"callDuration\",             \"aggregation\": \"SUM\",             \"alias\": \"total_call_time\"         },         {             \"name\": \"modulesCompleted\",             \"aggregation\": \"COUNT\",             \"alias\": \"completion_count\"         }     ],     \"userIds\": [\"user_id_1\", \"user_id_2\"] } ```  Available metric names: - processAdherenceScore: Process adherence score metric - skillsScore: Skills assessment score metric - communicationScore: Communication effectiveness score metric - userTalkingRatio: Ratio of user talking time vs total conversation time - fillerWords: Count of filler words used - overallScore: Overall performance score metric - modulesCompleted: Number of modules completed - callDuration: Duration of the call in seconds - longestMonologue: Duration of the longest monologue in seconds - winrate: Percentage of calls with overallScore > threshold (use with AVG aggregation) - callCount: Count of calls (each analytics record represents one call) - activeDays: Count of unique days with user activity (use with COUNT aggregation) - userId: User ID for counting unique users - feedbackId: Feedback ID for counting records  Note: Both camelCase and snake_case formats are supported for column names (e.g., \"processAdherenceScore\" or \"process_adherence_score\")  Available aggregations: - SUM: Total values - AVG: Average values - COUNT: Count of non-null values - MIN: Minimum value - MAX: Maximum value
         * @summary Get User Analytics
         * @param {AnalyticsRequest} analyticsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAnalyticsV1(analyticsRequest: AnalyticsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalyticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAnalyticsV1(analyticsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getUserAnalyticsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user performance summary with aggregated metrics grouped by user.  This endpoint returns a list of users with their average performance scores: - Average Process Adherence Score - Average Skills Score - Average Communication Score - Average Overall Score - Total number of sessions  Features: - Date range filtering (startDate, endDate) - Optional user ID filtering - Sorting by any column (userName, avgProcessAdherenceScore, avgSkillsScore, avgCommunicationScore, avgOverallScore) - Sort order (asc/desc, default desc) - Pagination support (skip/limit)  Example request: ```json {     \"startDate\": \"2024-01-01\",     \"endDate\": \"2024-03-31\",     \"userIds\": [\"user_id_1\", \"user_id_2\"],     \"sortBy\": \"avgOverallScore\",     \"sortOrder\": \"desc\",     \"skip\": 0,     \"limit\": 50 } ```  Available sort columns: - userName: User name - avgProcessAdherenceScore: Average process adherence score - avgSkillsScore: Average skills assessment score - avgCommunicationScore: Average communication effectiveness score - avgOverallScore: Average overall performance score (default)  Returns: - List of user performance summaries - Total count of matching users - Pagination metadata
         * @summary Get User Performance Summary
         * @param {UserPerformanceSummaryRequest} userPerformanceSummaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPerformanceSummaryV1(userPerformanceSummaryRequest: UserPerformanceSummaryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPerformanceSummaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPerformanceSummaryV1(userPerformanceSummaryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getUserPerformanceSummaryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * Get fine grained analytics data from Trata AI like call, duration stats, etc.
         * @summary Get Metrics
         * @param {BatchMetricsRequestsInput} batchMetricsRequestsInput 
         * @param {string | null} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1MetricsPost(batchMetricsRequestsInput: BatchMetricsRequestsInput, app?: string | null, options?: AxiosRequestConfig): AxiosPromise<BatchMetricsResponseInput> {
            return localVarFp.getMetricsV1MetricsPost(batchMetricsRequestsInput, app, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregated stats from Trata AI like call count, prospect count, etc.
         * @summary Get Aggregated Stats
         * @param {AppEnumInput | null} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallStatsV1StatsGet(app?: AppEnumInput | null, options?: AxiosRequestConfig): AxiosPromise<StatsResponse> {
            return localVarFp.getOverallStatsV1StatsGet(app, options).then((request) => request(axios, basePath));
        },
        /**
         * Get simplified user analytics with custom metrics and single date range aggregation.  This endpoint aggregates metrics over the entire date range without time-based grouping. Perfect for getting summary statistics or single aggregated values.  Example request: ```json {     \"startDate\": \"2024-01-01\",     \"endDate\": \"2024-03-31\",     \"metrics\": [         {             \"name\": \"overallScore\",             \"aggregation\": \"AVG\",             \"alias\": \"average_performance\"         },         {             \"name\": \"callDuration\",             \"aggregation\": \"SUM\",             \"alias\": \"total_call_time\"         },         {             \"name\": \"modulesCompleted\",             \"aggregation\": \"COUNT\",             \"alias\": \"completion_count\"         }     ],     \"userIds\": [\"user_id_1\", \"user_id_2\"] } ```  Available metric names: - processAdherenceScore: Process adherence score metric - skillsScore: Skills assessment score metric - communicationScore: Communication effectiveness score metric - userTalkingRatio: Ratio of user talking time vs total conversation time - fillerWords: Count of filler words used - overallScore: Overall performance score metric - modulesCompleted: Number of modules completed - callDuration: Duration of the call in seconds - longestMonologue: Duration of the longest monologue in seconds - winrate: Percentage of calls with overallScore > threshold (use with AVG aggregation) - callCount: Count of calls (each analytics record represents one call) - activeDays: Count of unique days with user activity (use with COUNT aggregation) - userId: User ID for counting unique users - feedbackId: Feedback ID for counting records  Note: Both camelCase and snake_case formats are supported for column names (e.g., \"processAdherenceScore\" or \"process_adherence_score\")  Available aggregations: - SUM: Total values - AVG: Average values - COUNT: Count of non-null values - MIN: Minimum value - MAX: Maximum value
         * @summary Get User Analytics
         * @param {AnalyticsRequest} analyticsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAnalyticsV1(analyticsRequest: AnalyticsRequest, options?: AxiosRequestConfig): AxiosPromise<AnalyticsResponse> {
            return localVarFp.getUserAnalyticsV1(analyticsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user performance summary with aggregated metrics grouped by user.  This endpoint returns a list of users with their average performance scores: - Average Process Adherence Score - Average Skills Score - Average Communication Score - Average Overall Score - Total number of sessions  Features: - Date range filtering (startDate, endDate) - Optional user ID filtering - Sorting by any column (userName, avgProcessAdherenceScore, avgSkillsScore, avgCommunicationScore, avgOverallScore) - Sort order (asc/desc, default desc) - Pagination support (skip/limit)  Example request: ```json {     \"startDate\": \"2024-01-01\",     \"endDate\": \"2024-03-31\",     \"userIds\": [\"user_id_1\", \"user_id_2\"],     \"sortBy\": \"avgOverallScore\",     \"sortOrder\": \"desc\",     \"skip\": 0,     \"limit\": 50 } ```  Available sort columns: - userName: User name - avgProcessAdherenceScore: Average process adherence score - avgSkillsScore: Average skills assessment score - avgCommunicationScore: Average communication effectiveness score - avgOverallScore: Average overall performance score (default)  Returns: - List of user performance summaries - Total count of matching users - Pagination metadata
         * @summary Get User Performance Summary
         * @param {UserPerformanceSummaryRequest} userPerformanceSummaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPerformanceSummaryV1(userPerformanceSummaryRequest: UserPerformanceSummaryRequest, options?: AxiosRequestConfig): AxiosPromise<UserPerformanceSummaryResponse> {
            return localVarFp.getUserPerformanceSummaryV1(userPerformanceSummaryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * Get fine grained analytics data from Trata AI like call, duration stats, etc.
     * @summary Get Metrics
     * @param {BatchMetricsRequestsInput} batchMetricsRequestsInput 
     * @param {string | null} [app] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getMetricsV1MetricsPost(batchMetricsRequestsInput: BatchMetricsRequestsInput, app?: string | null, options?: AxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getMetricsV1MetricsPost(batchMetricsRequestsInput, app, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get aggregated stats from Trata AI like call count, prospect count, etc.
     * @summary Get Aggregated Stats
     * @param {AppEnumInput | null} [app] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getOverallStatsV1StatsGet(app?: AppEnumInput | null, options?: AxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getOverallStatsV1StatsGet(app, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get simplified user analytics with custom metrics and single date range aggregation.  This endpoint aggregates metrics over the entire date range without time-based grouping. Perfect for getting summary statistics or single aggregated values.  Example request: ```json {     \"startDate\": \"2024-01-01\",     \"endDate\": \"2024-03-31\",     \"metrics\": [         {             \"name\": \"overallScore\",             \"aggregation\": \"AVG\",             \"alias\": \"average_performance\"         },         {             \"name\": \"callDuration\",             \"aggregation\": \"SUM\",             \"alias\": \"total_call_time\"         },         {             \"name\": \"modulesCompleted\",             \"aggregation\": \"COUNT\",             \"alias\": \"completion_count\"         }     ],     \"userIds\": [\"user_id_1\", \"user_id_2\"] } ```  Available metric names: - processAdherenceScore: Process adherence score metric - skillsScore: Skills assessment score metric - communicationScore: Communication effectiveness score metric - userTalkingRatio: Ratio of user talking time vs total conversation time - fillerWords: Count of filler words used - overallScore: Overall performance score metric - modulesCompleted: Number of modules completed - callDuration: Duration of the call in seconds - longestMonologue: Duration of the longest monologue in seconds - winrate: Percentage of calls with overallScore > threshold (use with AVG aggregation) - callCount: Count of calls (each analytics record represents one call) - activeDays: Count of unique days with user activity (use with COUNT aggregation) - userId: User ID for counting unique users - feedbackId: Feedback ID for counting records  Note: Both camelCase and snake_case formats are supported for column names (e.g., \"processAdherenceScore\" or \"process_adherence_score\")  Available aggregations: - SUM: Total values - AVG: Average values - COUNT: Count of non-null values - MIN: Minimum value - MAX: Maximum value
     * @summary Get User Analytics
     * @param {AnalyticsRequest} analyticsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getUserAnalyticsV1(analyticsRequest: AnalyticsRequest, options?: AxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getUserAnalyticsV1(analyticsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user performance summary with aggregated metrics grouped by user.  This endpoint returns a list of users with their average performance scores: - Average Process Adherence Score - Average Skills Score - Average Communication Score - Average Overall Score - Total number of sessions  Features: - Date range filtering (startDate, endDate) - Optional user ID filtering - Sorting by any column (userName, avgProcessAdherenceScore, avgSkillsScore, avgCommunicationScore, avgOverallScore) - Sort order (asc/desc, default desc) - Pagination support (skip/limit)  Example request: ```json {     \"startDate\": \"2024-01-01\",     \"endDate\": \"2024-03-31\",     \"userIds\": [\"user_id_1\", \"user_id_2\"],     \"sortBy\": \"avgOverallScore\",     \"sortOrder\": \"desc\",     \"skip\": 0,     \"limit\": 50 } ```  Available sort columns: - userName: User name - avgProcessAdherenceScore: Average process adherence score - avgSkillsScore: Average skills assessment score - avgCommunicationScore: Average communication effectiveness score - avgOverallScore: Average overall performance score (default)  Returns: - List of user performance summaries - Total count of matching users - Pagination metadata
     * @summary Get User Performance Summary
     * @param {UserPerformanceSummaryRequest} userPerformanceSummaryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getUserPerformanceSummaryV1(userPerformanceSummaryRequest: UserPerformanceSummaryRequest, options?: AxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getUserPerformanceSummaryV1(userPerformanceSummaryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApiKeyApi - axios parameter creator
 * @export
 */
export const ApiKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyV1: async (apiKeyRequest: ApiKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeyRequest' is not null or undefined
            assertParamExists('createApiKeyV1', 'apiKeyRequest', apiKeyRequest)
            const localVarPath = `/v1/api-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyV1: async (keyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('deleteApiKeyV1', 'keyId', keyId)
            const localVarPath = `/v1/api-keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallKeyV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/api-keys/call-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/api-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeyApi - functional programming interface
 * @export
 */
export const ApiKeyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiKeyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKeyV1(apiKeyRequest: ApiKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserApiKeyLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKeyV1(apiKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeyApi.createApiKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiKeyV1(keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiKeyV1(keyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeyApi.deleteApiKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCallKeyV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserApiKeyLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCallKeyV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeyApi.getCallKeyV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApiKeysV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserApiKeyLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApiKeysV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeyApi.listApiKeysV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiKeyApi - factory interface
 * @export
 */
export const ApiKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiKeyApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyV1(apiKeyRequest: ApiKeyRequest, options?: AxiosRequestConfig): AxiosPromise<UserApiKeyLink> {
            return localVarFp.createApiKeyV1(apiKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyV1(keyId: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.deleteApiKeyV1(keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallKeyV1(options?: AxiosRequestConfig): AxiosPromise<UserApiKeyLink> {
            return localVarFp.getCallKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysV1(options?: AxiosRequestConfig): AxiosPromise<Array<UserApiKeyLink>> {
            return localVarFp.listApiKeysV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiKeyApi - object-oriented interface
 * @export
 * @class ApiKeyApi
 * @extends {BaseAPI}
 */
export class ApiKeyApi extends BaseAPI {
    /**
     * 
     * @summary Create Api Key
     * @param {ApiKeyRequest} apiKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public createApiKeyV1(apiKeyRequest: ApiKeyRequest, options?: AxiosRequestConfig) {
        return ApiKeyApiFp(this.configuration).createApiKeyV1(apiKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Api Key
     * @param {string} keyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public deleteApiKeyV1(keyId: string, options?: AxiosRequestConfig) {
        return ApiKeyApiFp(this.configuration).deleteApiKeyV1(keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Call Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public getCallKeyV1(options?: AxiosRequestConfig) {
        return ApiKeyApiFp(this.configuration).getCallKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Api Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public listApiKeysV1(options?: AxiosRequestConfig) {
        return ApiKeyApiFp(this.configuration).listApiKeysV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BillingApi - axios parameter creator
 * @export
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForBillableProductV1: async (billableProductId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billableProductId' is not null or undefined
            assertParamExists('createCheckoutSessionForBillableProductV1', 'billableProductId', billableProductId)
            const localVarPath = `/v1/subscription/billable-products/{billable_product_id}/checkout`
                .replace(`{${"billable_product_id"}}`, encodeURIComponent(String(billableProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerSessionSecretV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription/customer-session-secret`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionBillableProductsV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription/billable-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPortalV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription/portal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckoutSessionForBillableProductV1(billableProductId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheckoutSessionForBillableProductV1(billableProductId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.createCheckoutSessionForBillableProductV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerSessionSecretV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerSessionSecretV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getCustomerSessionSecretV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionBillableProductsV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Price>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionBillableProductsV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getSubscriptionBillableProductsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionPortalV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionPortalV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getSubscriptionPortalV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getSubscriptionV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForBillableProductV1(billableProductId: string, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createCheckoutSessionForBillableProductV1(billableProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerSessionSecretV1(options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getCustomerSessionSecretV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionBillableProductsV1(options?: AxiosRequestConfig): AxiosPromise<Array<Price>> {
            return localVarFp.getSubscriptionBillableProductsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPortalV1(options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getSubscriptionPortalV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionV1(options?: AxiosRequestConfig): AxiosPromise<SubscriptionInfo> {
            return localVarFp.getSubscriptionV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI {
    /**
     * 
     * @summary Create Checkout Session For Billable Product
     * @param {string} billableProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public createCheckoutSessionForBillableProductV1(billableProductId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).createCheckoutSessionForBillableProductV1(billableProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Customer Session Secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getCustomerSessionSecretV1(options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getCustomerSessionSecretV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Subscription Billable Products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getSubscriptionBillableProductsV1(options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getSubscriptionBillableProductsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Subscription Portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getSubscriptionPortalV1(options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getSubscriptionPortalV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getSubscriptionV1(options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getSubscriptionV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConnectApi - axios parameter creator
 * @export
 */
export const ConnectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Connect a telephony app via OAuth and set up user sync and workflow automation.  This endpoint: 1. Creates a connection to the telephony app 2. Syncs users from the telephony app to Propel Auth 3. Creates a workflow to automatically generate feedback from call recordings
         * @summary Telephonyoauthconnect
         * @param {TelephonyConnectRequest} telephonyConnectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectOauthV1: async (telephonyConnectRequest: TelephonyConnectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'telephonyConnectRequest' is not null or undefined
            assertParamExists('connectOauthV1', 'telephonyConnectRequest', telephonyConnectRequest)
            const localVarPath = `/v1/sparr/connect/telephony/oauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(telephonyConnectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectApi - functional programming interface
 * @export
 */
export const ConnectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectApiAxiosParamCreator(configuration)
    return {
        /**
         * Connect a telephony app via OAuth and set up user sync and workflow automation.  This endpoint: 1. Creates a connection to the telephony app 2. Syncs users from the telephony app to Propel Auth 3. Creates a workflow to automatically generate feedback from call recordings
         * @summary Telephonyoauthconnect
         * @param {TelephonyConnectRequest} telephonyConnectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectOauthV1(telephonyConnectRequest: TelephonyConnectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TelephonyConnectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectOauthV1(telephonyConnectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectApi.connectOauthV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConnectApi - factory interface
 * @export
 */
export const ConnectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectApiFp(configuration)
    return {
        /**
         * Connect a telephony app via OAuth and set up user sync and workflow automation.  This endpoint: 1. Creates a connection to the telephony app 2. Syncs users from the telephony app to Propel Auth 3. Creates a workflow to automatically generate feedback from call recordings
         * @summary Telephonyoauthconnect
         * @param {TelephonyConnectRequest} telephonyConnectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectOauthV1(telephonyConnectRequest: TelephonyConnectRequest, options?: AxiosRequestConfig): AxiosPromise<TelephonyConnectResponse> {
            return localVarFp.connectOauthV1(telephonyConnectRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectApi - object-oriented interface
 * @export
 * @class ConnectApi
 * @extends {BaseAPI}
 */
export class ConnectApi extends BaseAPI {
    /**
     * Connect a telephony app via OAuth and set up user sync and workflow automation.  This endpoint: 1. Creates a connection to the telephony app 2. Syncs users from the telephony app to Propel Auth 3. Creates a workflow to automatically generate feedback from call recordings
     * @summary Telephonyoauthconnect
     * @param {TelephonyConnectRequest} telephonyConnectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectApi
     */
    public connectOauthV1(telephonyConnectRequest: TelephonyConnectRequest, options?: AxiosRequestConfig) {
        return ConnectApiFp(this.configuration).connectOauthV1(telephonyConnectRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConversationProspectLinkApi - axios parameter creator
 * @export
 */
export const ConversationProspectLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationProspectLinkV1: async (conversationId: string, prospectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('createConversationProspectLinkV1', 'conversationId', conversationId)
            // verify required parameter 'prospectId' is not null or undefined
            assertParamExists('createConversationProspectLinkV1', 'prospectId', prospectId)
            const localVarPath = `/v1/conversations/{conversation_id}/prospects/{prospect_id}/links`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationProspectLinkV1: async (conversationId: string, prospectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('deleteConversationProspectLinkV1', 'conversationId', conversationId)
            // verify required parameter 'prospectId' is not null or undefined
            assertParamExists('deleteConversationProspectLinkV1', 'prospectId', prospectId)
            const localVarPath = `/v1/conversations/{conversation_id}/prospects/{prospect_id}/links`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsOfProspectsV1: async (prospectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            assertParamExists('listConversationsOfProspectsV1', 'prospectId', prospectId)
            const localVarPath = `/v1/prospects/{prospect_id}/conversations`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversationProspectLinkApi - functional programming interface
 * @export
 */
export const ConversationProspectLinkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConversationProspectLinkApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversationProspectLinkV1(conversationId: string, prospectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConversationProspectLinkV1(conversationId, prospectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationProspectLinkApi.createConversationProspectLinkV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConversationProspectLinkV1(conversationId: string, prospectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConversationProspectLinkV1(conversationId, prospectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationProspectLinkApi.deleteConversationProspectLinkV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConversationsOfProspectsV1(prospectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConversationOutput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConversationsOfProspectsV1(prospectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationProspectLinkApi.listConversationsOfProspectsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConversationProspectLinkApi - factory interface
 * @export
 */
export const ConversationProspectLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConversationProspectLinkApiFp(configuration)
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationProspectLinkV1(conversationId: string, prospectId: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.createConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationProspectLinkV1(conversationId: string, prospectId: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.deleteConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsOfProspectsV1(prospectId: string, options?: AxiosRequestConfig): AxiosPromise<Array<ConversationOutput>> {
            return localVarFp.listConversationsOfProspectsV1(prospectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConversationProspectLinkApi - object-oriented interface
 * @export
 * @class ConversationProspectLinkApi
 * @extends {BaseAPI}
 */
export class ConversationProspectLinkApi extends BaseAPI {
    /**
     * Create a link between a conversation and a prospect
     * @summary Create a link between a conversation and a prospect
     * @param {string} conversationId ID of the conversation
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    public createConversationProspectLinkV1(conversationId: string, prospectId: string, options?: AxiosRequestConfig) {
        return ConversationProspectLinkApiFp(this.configuration).createConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a link between a conversation and a prospect
     * @summary Delete a link between a conversation and a prospect
     * @param {string} conversationId ID of the conversation
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    public deleteConversationProspectLinkV1(conversationId: string, prospectId: string, options?: AxiosRequestConfig) {
        return ConversationProspectLinkApiFp(this.configuration).deleteConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all conversations linked to a specific prospect
     * @summary List all conversations linked to a specific prospect
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    public listConversationsOfProspectsV1(prospectId: string, options?: AxiosRequestConfig) {
        return ConversationProspectLinkApiFp(this.configuration).listConversationsOfProspectsV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConversationsApi - axios parameter creator
 * @export
 */
export const ConversationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedbackV1: async (conversationId: string, comment: Comment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('addFeedbackV1', 'conversationId', conversationId)
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('addFeedbackV1', 'comment', comment)
            const localVarPath = `/v1/conversations/{conversation_id}/feedback`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(comment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationV1: async (conversationInput: ConversationInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationInput' is not null or undefined
            assertParamExists('createConversationV1', 'conversationInput', conversationInput)
            const localVarPath = `/v1/conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conversationInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationV1: async (conversationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('deleteConversationV1', 'conversationId', conversationId)
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationV1: async (conversationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('getConversationV1', 'conversationId', conversationId)
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Conversations
         * @summary List All Conversations
         * @param {AppEnumInput | null} [app] 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsV1: async (app?: AppEnumInput | null, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationV1: async (conversationId: string, conversationInput: ConversationInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('updateConversationV1', 'conversationId', conversationId)
            // verify required parameter 'conversationInput' is not null or undefined
            assertParamExists('updateConversationV1', 'conversationInput', conversationInput)
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conversationInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversationsApi - functional programming interface
 * @export
 */
export const ConversationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConversationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFeedbackV1(conversationId: string, comment: Comment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationFeedback>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFeedbackV1(conversationId, comment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationsApi.addFeedbackV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversationV1(conversationInput: ConversationInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConversationV1(conversationInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationsApi.createConversationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConversationV1(conversationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConversationV1(conversationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationsApi.deleteConversationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversationV1(conversationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversationV1(conversationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationsApi.getConversationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List All Conversations
         * @summary List All Conversations
         * @param {AppEnumInput | null} [app] 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConversationsV1(app?: AppEnumInput | null, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConversationOutput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationsApi.listConversationsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConversationV1(conversationId: string, conversationInput: ConversationInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConversationV1(conversationId, conversationInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationsApi.updateConversationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConversationsApi - factory interface
 * @export
 */
export const ConversationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConversationsApiFp(configuration)
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedbackV1(conversationId: string, comment: Comment, options?: AxiosRequestConfig): AxiosPromise<ConversationFeedback> {
            return localVarFp.addFeedbackV1(conversationId, comment, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationV1(conversationInput: ConversationInput, options?: AxiosRequestConfig): AxiosPromise<ConversationOutput> {
            return localVarFp.createConversationV1(conversationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationV1(conversationId: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.deleteConversationV1(conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationV1(conversationId: string, options?: AxiosRequestConfig): AxiosPromise<ConversationOutput> {
            return localVarFp.getConversationV1(conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Conversations
         * @summary List All Conversations
         * @param {AppEnumInput | null} [app] 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsV1(app?: AppEnumInput | null, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<ConversationOutput>> {
            return localVarFp.listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationV1(conversationId: string, conversationInput: ConversationInput, options?: AxiosRequestConfig): AxiosPromise<ConversationOutput> {
            return localVarFp.updateConversationV1(conversationId, conversationInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConversationsApi - object-oriented interface
 * @export
 * @class ConversationsApi
 * @extends {BaseAPI}
 */
export class ConversationsApi extends BaseAPI {
    /**
     * Add Feedback to a Specific Conversation
     * @summary Add Feedback to a Specific Conversation
     * @param {string} conversationId ID of the conversation
     * @param {Comment} comment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public addFeedbackV1(conversationId: string, comment: Comment, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).addFeedbackV1(conversationId, comment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a New Conversation
     * @summary Create a New Conversation
     * @param {ConversationInput} conversationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public createConversationV1(conversationInput: ConversationInput, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).createConversationV1(conversationInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific Conversation by ID
     * @summary Delete a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public deleteConversationV1(conversationId: string, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).deleteConversationV1(conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Conversation by ID
     * @summary Get a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public getConversationV1(conversationId: string, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).getConversationV1(conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Conversations
     * @summary List All Conversations
     * @param {AppEnumInput | null} [app] 
     * @param {string | null} [searchBy] 
     * @param {string | null} [searchValue] 
     * @param {string | null} [status] 
     * @param {string | null} [sortBy] 
     * @param {SortOrder | null} [sortOrder] 
     * @param {number | null} [skip] 
     * @param {number | null} [limit] 
     * @param {string | null} [updatedAfter] 
     * @param {string | null} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public listConversationsV1(app?: AppEnumInput | null, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).listConversationsV1(app, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific Conversation by ID
     * @summary Update a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {ConversationInput} conversationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public updateConversationV1(conversationId: string, conversationInput: ConversationInput, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).updateConversationV1(conversationId, conversationInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DataPlaneApi - axios parameter creator
 * @export
 */
export const DataPlaneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new connection for an AI Agent to start a voice conversation
         * @summary Create Connection
         * @param {string} agentId 
         * @param {ConnectionSource} connectionSource 
         * @param {string | null} [prospectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection: async (agentId: string, connectionSource: ConnectionSource, prospectId?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('createConnection', 'agentId', agentId)
            // verify required parameter 'connectionSource' is not null or undefined
            assertParamExists('createConnection', 'connectionSource', connectionSource)
            const localVarPath = `/v1/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (agentId !== undefined) {
                localVarQueryParameter['agentId'] = agentId;
            }

            if (prospectId !== undefined) {
                localVarQueryParameter['prospect_id'] = prospectId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectionSource, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the audio stream xml for Plivo to start a voice conversation
         * @summary Get Audio Stream XML For Plivo
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlivoAudioStreamXml: async (connectionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('getPlivoAudioStreamXml', 'connectionId', connectionId)
            const localVarPath = `/v1/connections/{connection_id}/plivo-audio-stream-xml`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List connections
         * @summary Listconnections
         * @param {string | null} [sourceName] 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections: async (sourceName?: string | null, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sourceName !== undefined) {
                localVarQueryParameter['sourceName'] = sourceName;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataPlaneApi - functional programming interface
 * @export
 */
export const DataPlaneApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataPlaneApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new connection for an AI Agent to start a voice conversation
         * @summary Create Connection
         * @param {string} agentId 
         * @param {ConnectionSource} connectionSource 
         * @param {string | null} [prospectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnection(agentId: string, connectionSource: ConnectionSource, prospectId?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnection(agentId, connectionSource, prospectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataPlaneApi.createConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the audio stream xml for Plivo to start a voice conversation
         * @summary Get Audio Stream XML For Plivo
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlivoAudioStreamXml(connectionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlivoAudioStreamXml(connectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataPlaneApi.getPlivoAudioStreamXml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List connections
         * @summary Listconnections
         * @param {string | null} [sourceName] 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnections(sourceName?: string | null, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConnectionOutput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnections(sourceName, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataPlaneApi.listConnections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DataPlaneApi - factory interface
 * @export
 */
export const DataPlaneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataPlaneApiFp(configuration)
    return {
        /**
         * Create a new connection for an AI Agent to start a voice conversation
         * @summary Create Connection
         * @param {string} agentId 
         * @param {ConnectionSource} connectionSource 
         * @param {string | null} [prospectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(agentId: string, connectionSource: ConnectionSource, prospectId?: string | null, options?: AxiosRequestConfig): AxiosPromise<ConnectionOutput> {
            return localVarFp.createConnection(agentId, connectionSource, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the audio stream xml for Plivo to start a voice conversation
         * @summary Get Audio Stream XML For Plivo
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlivoAudioStreamXml(connectionId: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.getPlivoAudioStreamXml(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * List connections
         * @summary Listconnections
         * @param {string | null} [sourceName] 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections(sourceName?: string | null, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<ConnectionOutput>> {
            return localVarFp.listConnections(sourceName, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataPlaneApi - object-oriented interface
 * @export
 * @class DataPlaneApi
 * @extends {BaseAPI}
 */
export class DataPlaneApi extends BaseAPI {
    /**
     * Create a new connection for an AI Agent to start a voice conversation
     * @summary Create Connection
     * @param {string} agentId 
     * @param {ConnectionSource} connectionSource 
     * @param {string | null} [prospectId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPlaneApi
     */
    public createConnection(agentId: string, connectionSource: ConnectionSource, prospectId?: string | null, options?: AxiosRequestConfig) {
        return DataPlaneApiFp(this.configuration).createConnection(agentId, connectionSource, prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the audio stream xml for Plivo to start a voice conversation
     * @summary Get Audio Stream XML For Plivo
     * @param {string} connectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPlaneApi
     */
    public getPlivoAudioStreamXml(connectionId: string, options?: AxiosRequestConfig) {
        return DataPlaneApiFp(this.configuration).getPlivoAudioStreamXml(connectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List connections
     * @summary Listconnections
     * @param {string | null} [sourceName] 
     * @param {string | null} [searchBy] 
     * @param {string | null} [searchValue] 
     * @param {string | null} [status] 
     * @param {string | null} [sortBy] 
     * @param {SortOrder | null} [sortOrder] 
     * @param {number | null} [skip] 
     * @param {number | null} [limit] 
     * @param {string | null} [updatedAfter] 
     * @param {string | null} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPlaneApi
     */
    public listConnections(sourceName?: string | null, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig) {
        return DataPlaneApiFp(this.configuration).listConnections(sourceName, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete files from Trata account
         * @summary Delete Files
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1: async (fileIds: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileIds' is not null or undefined
            assertParamExists('deleteFileV1', 'fileIds', fileIds)
            const localVarPath = `/v1/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fileIds !== undefined) {
                localVarQueryParameter['file_ids'] = fileIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload audio file to Trata account to use in AI Agents
         * @summary Upload Audio Files
         * @param {Array<File>} files 
         * @param {string | null} [validator] Validator type to use for file validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAudioFileV1: async (files: Array<File>, validator?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'files' is not null or undefined
            assertParamExists('uploadAudioFileV1', 'files', files)
            const localVarPath = `/v1/audio-files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (validator !== undefined) {
                localVarQueryParameter['validator'] = validator;
            }

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<File>} files 
         * @param {string | null} [validator] Validator type to use for file validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1: async (files: Array<File>, validator?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'files' is not null or undefined
            assertParamExists('uploadFileV1', 'files', files)
            const localVarPath = `/v1/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (validator !== undefined) {
                localVarQueryParameter['validator'] = validator;
            }

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete files from Trata account
         * @summary Delete Files
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileV1(fileIds: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFileV1(fileIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.deleteFileV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload audio file to Trata account to use in AI Agents
         * @summary Upload Audio Files
         * @param {Array<File>} files 
         * @param {string | null} [validator] Validator type to use for file validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadAudioFileV1(files: Array<File>, validator?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Files>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadAudioFileV1(files, validator, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.uploadAudioFileV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<File>} files 
         * @param {string | null} [validator] Validator type to use for file validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileV1(files: Array<File>, validator?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Files>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFileV1(files, validator, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.uploadFileV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * Delete files from Trata account
         * @summary Delete Files
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1(fileIds: string, options?: AxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.deleteFileV1(fileIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload audio file to Trata account to use in AI Agents
         * @summary Upload Audio Files
         * @param {Array<File>} files 
         * @param {string | null} [validator] Validator type to use for file validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAudioFileV1(files: Array<File>, validator?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<Files>> {
            return localVarFp.uploadAudioFileV1(files, validator, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<File>} files 
         * @param {string | null} [validator] Validator type to use for file validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1(files: Array<File>, validator?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<Files>> {
            return localVarFp.uploadFileV1(files, validator, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * Delete files from Trata account
     * @summary Delete Files
     * @param {string} fileIds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public deleteFileV1(fileIds: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).deleteFileV1(fileIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload audio file to Trata account to use in AI Agents
     * @summary Upload Audio Files
     * @param {Array<File>} files 
     * @param {string | null} [validator] Validator type to use for file validation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public uploadAudioFileV1(files: Array<File>, validator?: string | null, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).uploadAudioFileV1(files, validator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload file to Trata account to use in AI Agents
     * @summary Upload Files
     * @param {Array<File>} files 
     * @param {string | null} [validator] Validator type to use for file validation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public uploadFileV1(files: Array<File>, validator?: string | null, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).uploadFileV1(files, validator, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Heart Beat check to check the health of Trata Backend
         * @summary Heart Beat Status Of Trata Backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatusGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Heart Beat check to check the health of Workflow Service
         * @summary Heart Beat Status Of Workflow Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusWorkflowsStatusGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflows/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * Heart Beat check to check the health of Trata Backend
         * @summary Heart Beat Status Of Trata Backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusStatusGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusStatusGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.statusStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Heart Beat check to check the health of Workflow Service
         * @summary Heart Beat Status Of Workflow Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusWorkflowsStatusGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusWorkflowsStatusGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.statusWorkflowsStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * Heart Beat check to check the health of Trata Backend
         * @summary Heart Beat Status Of Trata Backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatusGet(options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.statusStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Heart Beat check to check the health of Workflow Service
         * @summary Heart Beat Status Of Workflow Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusWorkflowsStatusGet(options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.statusWorkflowsStatusGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * Heart Beat check to check the health of Trata Backend
     * @summary Heart Beat Status Of Trata Backend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public statusStatusGet(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).statusStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Heart Beat check to check the health of Workflow Service
     * @summary Heart Beat Status Of Workflow Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public statusWorkflowsStatusGet(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).statusWorkflowsStatusGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HiveApi - axios parameter creator
 * @export
 */
export const HiveApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1: async (hiveContentInput: HiveContentInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveContentInput' is not null or undefined
            assertParamExists('createHiveV1', 'hiveContentInput', hiveContentInput)
            const localVarPath = `/v1/hives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hiveContentInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1: async (hiveId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            assertParamExists('deleteHiveV1', 'hiveId', hiveId)
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1: async (hiveId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            assertParamExists('getHiveV1', 'hiveId', hiveId)
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Hives
         * @summary List All Hives
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1: async (searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/hives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1: async (hiveId: string, hiveContentOutput: HiveContentOutput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            assertParamExists('updateHiveV1', 'hiveId', hiveId)
            // verify required parameter 'hiveContentOutput' is not null or undefined
            assertParamExists('updateHiveV1', 'hiveContentOutput', hiveContentOutput)
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hiveContentOutput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HiveApi - functional programming interface
 * @export
 */
export const HiveApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HiveApiAxiosParamCreator(configuration)
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHiveV1(hiveContentInput: HiveContentInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHiveV1(hiveContentInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HiveApi.createHiveV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHiveV1(hiveId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHiveV1(hiveId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HiveApi.deleteHiveV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHiveV1(hiveId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHiveV1(hiveId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HiveApi.getHiveV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List All Hives
         * @summary List All Hives
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHivesV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hive>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HiveApi.listHivesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHiveV1(hiveId: string, hiveContentOutput: HiveContentOutput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateHiveV1(hiveId, hiveContentOutput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HiveApi.updateHiveV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HiveApi - factory interface
 * @export
 */
export const HiveApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HiveApiFp(configuration)
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1(hiveContentInput: HiveContentInput, options?: AxiosRequestConfig): AxiosPromise<Hive> {
            return localVarFp.createHiveV1(hiveContentInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1(hiveId: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.deleteHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1(hiveId: string, options?: AxiosRequestConfig): AxiosPromise<Hive> {
            return localVarFp.getHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Hives
         * @summary List All Hives
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<Hive>> {
            return localVarFp.listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1(hiveId: string, hiveContentOutput: HiveContentOutput, options?: AxiosRequestConfig): AxiosPromise<Hive> {
            return localVarFp.updateHiveV1(hiveId, hiveContentOutput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HiveApi - object-oriented interface
 * @export
 * @class HiveApi
 * @extends {BaseAPI}
 */
export class HiveApi extends BaseAPI {
    /**
     * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
     * @summary Create a New Hive
     * @param {HiveContentInput} hiveContentInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public createHiveV1(hiveContentInput: HiveContentInput, options?: AxiosRequestConfig) {
        return HiveApiFp(this.configuration).createHiveV1(hiveContentInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific Hive by ID
     * @summary Delete a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public deleteHiveV1(hiveId: string, options?: AxiosRequestConfig) {
        return HiveApiFp(this.configuration).deleteHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Hive by ID
     * @summary Get a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public getHiveV1(hiveId: string, options?: AxiosRequestConfig) {
        return HiveApiFp(this.configuration).getHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Hives
     * @summary List All Hives
     * @param {string | null} [searchBy] 
     * @param {string | null} [searchValue] 
     * @param {string | null} [status] 
     * @param {string | null} [sortBy] 
     * @param {SortOrder | null} [sortOrder] 
     * @param {number | null} [skip] 
     * @param {number | null} [limit] 
     * @param {string | null} [updatedAfter] 
     * @param {string | null} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public listHivesV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig) {
        return HiveApiFp(this.configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific Hive by ID
     * @summary Update a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {HiveContentOutput} hiveContentOutput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public updateHiveV1(hiveId: string, hiveContentOutput: HiveContentOutput, options?: AxiosRequestConfig) {
        return HiveApiFp(this.configuration).updateHiveV1(hiveId, hiveContentOutput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HiveAgentLinkApi - axios parameter creator
 * @export
 */
export const HiveAgentLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveAgentLinkV1: async (hiveId: string, agentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            assertParamExists('createHiveAgentLinkV1', 'hiveId', hiveId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('createHiveAgentLinkV1', 'agentId', agentId)
            const localVarPath = `/v1/hives/{hive_id}/ai-agents/{agent_id}/link`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveAgentLinkV1: async (hiveId: string, agentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            assertParamExists('deleteHiveAgentLinkV1', 'hiveId', hiveId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('deleteHiveAgentLinkV1', 'agentId', agentId)
            const localVarPath = `/v1/hives/{hive_id}/ai-agents/{agent_id}/link`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfHiveV1: async (hiveId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            assertParamExists('listAgentsOfHiveV1', 'hiveId', hiveId)
            const localVarPath = `/v1/hives/{hive_id}/ai-agents`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesOfAgentV1: async (agentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('listHivesOfAgentV1', 'agentId', agentId)
            const localVarPath = `/v1/ai-agents/{agent_id}/hives`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HiveAgentLinkApi - functional programming interface
 * @export
 */
export const HiveAgentLinkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HiveAgentLinkApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHiveAgentLinkV1(hiveId: string, agentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHiveAgentLinkV1(hiveId, agentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HiveAgentLinkApi.createHiveAgentLinkV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHiveAgentLinkV1(hiveId: string, agentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHiveAgentLinkV1(hiveId, agentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HiveAgentLinkApi.deleteHiveAgentLinkV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAgentsOfHiveV1(hiveId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AIAgentOutput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAgentsOfHiveV1(hiveId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HiveAgentLinkApi.listAgentsOfHiveV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHivesOfAgentV1(agentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hive>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHivesOfAgentV1(agentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HiveAgentLinkApi.listHivesOfAgentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HiveAgentLinkApi - factory interface
 * @export
 */
export const HiveAgentLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HiveAgentLinkApiFp(configuration)
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveAgentLinkV1(hiveId: string, agentId: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.createHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveAgentLinkV1(hiveId: string, agentId: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.deleteHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfHiveV1(hiveId: string, options?: AxiosRequestConfig): AxiosPromise<Array<AIAgentOutput>> {
            return localVarFp.listAgentsOfHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesOfAgentV1(agentId: string, options?: AxiosRequestConfig): AxiosPromise<Array<Hive>> {
            return localVarFp.listHivesOfAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HiveAgentLinkApi - object-oriented interface
 * @export
 * @class HiveAgentLinkApi
 * @extends {BaseAPI}
 */
export class HiveAgentLinkApi extends BaseAPI {
    /**
     * Create a Link Between a Hive and an Agent
     * @summary Create a Link Between a Hive and an Agent
     * @param {string} hiveId ID of the hive
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    public createHiveAgentLinkV1(hiveId: string, agentId: string, options?: AxiosRequestConfig) {
        return HiveAgentLinkApiFp(this.configuration).createHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Link Between a Hive and an Agent
     * @summary Delete a Link Between a Hive and an Agent
     * @param {string} hiveId ID of the hive
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    public deleteHiveAgentLinkV1(hiveId: string, agentId: string, options?: AxiosRequestConfig) {
        return HiveAgentLinkApiFp(this.configuration).deleteHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Agents Linked to a Specific Hive
     * @summary List All Agents Linked to a Specific Hive
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    public listAgentsOfHiveV1(hiveId: string, options?: AxiosRequestConfig) {
        return HiveAgentLinkApiFp(this.configuration).listAgentsOfHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Hives Linked to a Specific Agent
     * @summary List All Hives Linked to a Specific Agent
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    public listHivesOfAgentV1(agentId: string, options?: AxiosRequestConfig) {
        return HiveAgentLinkApiFp(this.configuration).listHivesOfAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InternalApi - axios parameter creator
 * @export
 */
export const InternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteV1: async (acceptInviteRequest: AcceptInviteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acceptInviteRequest' is not null or undefined
            assertParamExists('acceptInviteV1', 'acceptInviteRequest', acceptInviteRequest)
            const localVarPath = `/v1/invites/accept`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(acceptInviteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationV1: async (bodyCreateOrganizationV1: BodyCreateOrganizationV1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateOrganizationV1' is not null or undefined
            assertParamExists('createOrganizationV1', 'bodyCreateOrganizationV1', bodyCreateOrganizationV1)
            const localVarPath = `/v1/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyCreateOrganizationV1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user
         * @summary Createuser
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserV1: async (userPayload: UserPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPayload' is not null or undefined
            assertParamExists('createUserV1', 'userPayload', userPayload)
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserV1', 'userId', userId)
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get customer credits
         * @summary Get Customer Credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCreditsV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/customers/credits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get customer pricing
         * @summary Get Customer Pricing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerPricingV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/customers/pricing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getorganizationbranding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBrandingV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organizations/branding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getuserbyid
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIdV1: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserByIdV1', 'userId', userId)
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesV1: async (searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {boolean} [showResellerOwner] Show owner users
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersV1: async (showResellerOwner?: boolean, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (showResellerOwner !== undefined) {
                localVarQueryParameter['showResellerOwner'] = showResellerOwner;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput 
         * @param {SendInviteV1AppEnum} [app] The app to use for the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInviteV1: async (guestInput: GuestInput, app?: SendInviteV1AppEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guestInput' is not null or undefined
            assertParamExists('sendInviteV1', 'guestInput', guestInput)
            const localVarPath = `/v1/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(guestInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationV1: async (orgId: string, organizationInput: OrganizationInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateOrganizationV1', 'orgId', orgId)
            // verify required parameter 'organizationInput' is not null or undefined
            assertParamExists('updateOrganizationV1', 'organizationInput', organizationInput)
            const localVarPath = `/v1/organizations/{org_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId 
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1: async (userId: string, userPayload: UserPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserV1', 'userId', userId)
            // verify required parameter 'userPayload' is not null or undefined
            assertParamExists('updateUserV1', 'userPayload', userPayload)
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalApi - functional programming interface
 * @export
 */
export const InternalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InternalApiAxiosParamCreator(configuration)
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInviteV1(acceptInviteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.acceptInviteV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationV1(bodyCreateOrganizationV1: BodyCreateOrganizationV1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationV1(bodyCreateOrganizationV1, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.createOrganizationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new user
         * @summary Createuser
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserV1(userPayload: UserPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserV1(userPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.createUserV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.deleteOrganizationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserV1(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserV1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.deleteUserV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get customer credits
         * @summary Get Customer Credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerCreditsV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Credit>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerCreditsV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.getCustomerCreditsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get customer pricing
         * @summary Get Customer Pricing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerPricingV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Price>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerPricingV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.getCustomerPricingV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Getorganizationbranding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationBrandingV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGetorganizationbrandingv1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationBrandingV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.getOrganizationBrandingV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.getOrganizationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Getuserbyid
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByIdV1(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByIdV1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.getUserByIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInvitesV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuestOutput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.listInvitesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {boolean} [showResellerOwner] Show owner users
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsersV1(showResellerOwner?: boolean, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsersV1(showResellerOwner, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.listUsersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput 
         * @param {SendInviteV1AppEnum} [app] The app to use for the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendInviteV1(guestInput: GuestInput, app?: SendInviteV1AppEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuestOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendInviteV1(guestInput, app, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.sendInviteV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationV1(orgId: string, organizationInput: OrganizationInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationV1(orgId, organizationInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.updateOrganizationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId 
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserV1(userId: string, userPayload: UserPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserV1(userId, userPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.updateUserV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InternalApi - factory interface
 * @export
 */
export const InternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InternalApiFp(configuration)
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.acceptInviteV1(acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationV1(bodyCreateOrganizationV1: BodyCreateOrganizationV1, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createOrganizationV1(bodyCreateOrganizationV1, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user
         * @summary Createuser
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserV1(userPayload: UserPayload, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createUserV1(userPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationV1(options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.deleteOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1(userId: string, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.deleteUserV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get customer credits
         * @summary Get Customer Credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCreditsV1(options?: AxiosRequestConfig): AxiosPromise<Array<Credit>> {
            return localVarFp.getCustomerCreditsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get customer pricing
         * @summary Get Customer Pricing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerPricingV1(options?: AxiosRequestConfig): AxiosPromise<Array<Price>> {
            return localVarFp.getCustomerPricingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getorganizationbranding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBrandingV1(options?: AxiosRequestConfig): AxiosPromise<ResponseGetorganizationbrandingv1> {
            return localVarFp.getOrganizationBrandingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationV1(options?: AxiosRequestConfig): AxiosPromise<OrganizationOutput> {
            return localVarFp.getOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getuserbyid
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIdV1(userId: string, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUserByIdV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<GuestOutput>> {
            return localVarFp.listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {boolean} [showResellerOwner] Show owner users
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersV1(showResellerOwner?: boolean, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.listUsersV1(showResellerOwner, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput 
         * @param {SendInviteV1AppEnum} [app] The app to use for the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInviteV1(guestInput: GuestInput, app?: SendInviteV1AppEnum, options?: AxiosRequestConfig): AxiosPromise<GuestOutput> {
            return localVarFp.sendInviteV1(guestInput, app, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationV1(orgId: string, organizationInput: OrganizationInput, options?: AxiosRequestConfig): AxiosPromise<OrganizationOutput> {
            return localVarFp.updateOrganizationV1(orgId, organizationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId 
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1(userId: string, userPayload: UserPayload, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUserV1(userId, userPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
export class InternalApi extends BaseAPI {
    /**
     * Accept invite and add new user to organization
     * @summary Acceptinvite
     * @param {AcceptInviteRequest} acceptInviteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public acceptInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).acceptInviteV1(acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new organization and adds the user as the \"ADMIN\" user for the org
     * @summary Createorganization
     * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public createOrganizationV1(bodyCreateOrganizationV1: BodyCreateOrganizationV1, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).createOrganizationV1(bodyCreateOrganizationV1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user
     * @summary Createuser
     * @param {UserPayload} userPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public createUserV1(userPayload: UserPayload, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).createUserV1(userPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deleteorganization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public deleteOrganizationV1(options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).deleteOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user
     * @summary Deleteuser
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public deleteUserV1(userId: string, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).deleteUserV1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get customer credits
     * @summary Get Customer Credits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getCustomerCreditsV1(options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).getCustomerCreditsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get customer pricing
     * @summary Get Customer Pricing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getCustomerPricingV1(options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).getCustomerPricingV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Getorganizationbranding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getOrganizationBrandingV1(options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).getOrganizationBrandingV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Getorganization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getOrganizationV1(options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).getOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Getuserbyid
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getUserByIdV1(userId: string, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).getUserByIdV1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of all open invites from the organization
     * @summary Listinvites
     * @param {string | null} [searchBy] 
     * @param {string | null} [searchValue] 
     * @param {string | null} [status] 
     * @param {string | null} [sortBy] 
     * @param {SortOrder | null} [sortOrder] 
     * @param {number | null} [skip] 
     * @param {number | null} [limit] 
     * @param {string | null} [updatedAfter] 
     * @param {string | null} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public listInvitesV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all users under the user\'s organization
     * @summary Listusers
     * @param {boolean} [showResellerOwner] Show owner users
     * @param {string | null} [searchBy] 
     * @param {string | null} [searchValue] 
     * @param {string | null} [status] 
     * @param {string | null} [sortBy] 
     * @param {SortOrder | null} [sortOrder] 
     * @param {number | null} [skip] 
     * @param {number | null} [limit] 
     * @param {string | null} [updatedAfter] 
     * @param {string | null} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public listUsersV1(showResellerOwner?: boolean, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).listUsersV1(showResellerOwner, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a new user to an organization or resend invite to the user if the user is already invited
     * @summary Inviteusers
     * @param {GuestInput} guestInput 
     * @param {SendInviteV1AppEnum} [app] The app to use for the invite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public sendInviteV1(guestInput: GuestInput, app?: SendInviteV1AppEnum, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).sendInviteV1(guestInput, app, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updateorganization
     * @param {string} orgId ID of the organization
     * @param {OrganizationInput} organizationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public updateOrganizationV1(orgId: string, organizationInput: OrganizationInput, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).updateOrganizationV1(orgId, organizationInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user details
     * @summary Updateuser
     * @param {string} userId 
     * @param {UserPayload} userPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public updateUserV1(userId: string, userPayload: UserPayload, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).updateUserV1(userId, userPayload, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SendInviteV1AppEnum = {
    Trata: 'trata',
    Sparr: 'sparr'
} as const;
export type SendInviteV1AppEnum = typeof SendInviteV1AppEnum[keyof typeof SendInviteV1AppEnum];


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductV1: async (productInput: ProductInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productInput' is not null or undefined
            assertParamExists('createProductV1', 'productInput', productInput)
            const localVarPath = `/v1/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductV1: async (productId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('deleteProductV1', 'productId', productId)
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductV1: async (productId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductV1', 'productId', productId)
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfProductV1: async (productId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('listAgentsOfProductV1', 'productId', productId)
            const localVarPath = `/v1/products/{product_id}/agents`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Products
         * @summary List All Products
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {string | null} [tags] 
         * @param {string | null} [productIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1: async (searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, tags?: string | null, productIds?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (productIds !== undefined) {
                localVarQueryParameter['product_ids'] = productIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductV1: async (productId: string, productInput: ProductInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('updateProductV1', 'productId', productId)
            // verify required parameter 'productInput' is not null or undefined
            assertParamExists('updateProductV1', 'productInput', productInput)
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProductV1(productInput: ProductInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProductV1(productInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.createProductV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductV1(productId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProductV1(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.deleteProductV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductV1(productId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductV1(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.getProductV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAgentsOfProductV1(productId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AIAgentOutput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAgentsOfProductV1(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.listAgentsOfProductV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List All Products
         * @summary List All Products
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {string | null} [tags] 
         * @param {string | null} [productIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProductsV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, tags?: string | null, productIds?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductOutput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.listProductsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProductV1(productId: string, productInput: ProductInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProductV1(productId, productInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.updateProductV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductV1(productInput: ProductInput, options?: AxiosRequestConfig): AxiosPromise<ProductOutput> {
            return localVarFp.createProductV1(productInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductV1(productId: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.deleteProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductV1(productId: string, options?: AxiosRequestConfig): AxiosPromise<ProductOutput> {
            return localVarFp.getProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfProductV1(productId: string, options?: AxiosRequestConfig): AxiosPromise<Array<AIAgentOutput>> {
            return localVarFp.listAgentsOfProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Products
         * @summary List All Products
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {string | null} [tags] 
         * @param {string | null} [productIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, tags?: string | null, productIds?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<ProductOutput>> {
            return localVarFp.listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductV1(productId: string, productInput: ProductInput, options?: AxiosRequestConfig): AxiosPromise<ProductOutput> {
            return localVarFp.updateProductV1(productId, productInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * Create a New Product
     * @summary Create a New Product
     * @param {ProductInput} productInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public createProductV1(productInput: ProductInput, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).createProductV1(productInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific Product by ID
     * @summary Delete a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProductV1(productId: string, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).deleteProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Product by ID
     * @summary Get a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductV1(productId: string, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Agents Linked to a Specific Product
     * @summary List All Agents Linked to a Specific Product
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listAgentsOfProductV1(productId: string, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).listAgentsOfProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Products
     * @summary List All Products
     * @param {string | null} [searchBy] 
     * @param {string | null} [searchValue] 
     * @param {string | null} [status] 
     * @param {string | null} [sortBy] 
     * @param {SortOrder | null} [sortOrder] 
     * @param {number | null} [skip] 
     * @param {number | null} [limit] 
     * @param {string | null} [updatedAfter] 
     * @param {string | null} [updatedBefore] 
     * @param {string | null} [tags] 
     * @param {string | null} [productIds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listProductsV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, tags?: string | null, productIds?: string | null, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific Product by ID
     * @summary Update a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {ProductInput} productInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProductV1(productId: string, productInput: ProductInput, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).updateProductV1(productId, productInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProspectsApi - axios parameter creator
 * @export
 */
export const ProspectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProspectV1: async (prospectInput: ProspectInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectInput' is not null or undefined
            assertParamExists('createProspectV1', 'prospectInput', prospectInput)
            const localVarPath = `/v1/prospects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prospectInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProspectV1: async (prospectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            assertParamExists('deleteProspectV1', 'prospectId', prospectId)
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProspectV1: async (prospectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            assertParamExists('getProspectV1', 'prospectId', prospectId)
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Prospects
         * @summary List All Prospects
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProspectsV1: async (searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/prospects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProspectV1: async (prospectId: string, prospectInput: ProspectInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            assertParamExists('updateProspectV1', 'prospectId', prospectId)
            // verify required parameter 'prospectInput' is not null or undefined
            assertParamExists('updateProspectV1', 'prospectInput', prospectInput)
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prospectInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProspectsApi - functional programming interface
 * @export
 */
export const ProspectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProspectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProspectV1(prospectInput: ProspectInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProspectOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProspectV1(prospectInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProspectsApi.createProspectV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProspectV1(prospectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProspectV1(prospectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProspectsApi.deleteProspectV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProspectV1(prospectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProspectOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProspectV1(prospectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProspectsApi.getProspectV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List All Prospects
         * @summary List All Prospects
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProspectsV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProspectOutput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProspectsApi.listProspectsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProspectV1(prospectId: string, prospectInput: ProspectInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProspectOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProspectV1(prospectId, prospectInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProspectsApi.updateProspectV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProspectsApi - factory interface
 * @export
 */
export const ProspectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProspectsApiFp(configuration)
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProspectV1(prospectInput: ProspectInput, options?: AxiosRequestConfig): AxiosPromise<ProspectOutput> {
            return localVarFp.createProspectV1(prospectInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProspectV1(prospectId: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.deleteProspectV1(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProspectV1(prospectId: string, options?: AxiosRequestConfig): AxiosPromise<ProspectOutput> {
            return localVarFp.getProspectV1(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Prospects
         * @summary List All Prospects
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProspectsV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<ProspectOutput>> {
            return localVarFp.listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProspectV1(prospectId: string, prospectInput: ProspectInput, options?: AxiosRequestConfig): AxiosPromise<ProspectOutput> {
            return localVarFp.updateProspectV1(prospectId, prospectInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProspectsApi - object-oriented interface
 * @export
 * @class ProspectsApi
 * @extends {BaseAPI}
 */
export class ProspectsApi extends BaseAPI {
    /**
     * Create a New Prospect
     * @summary Create a New Prospect
     * @param {ProspectInput} prospectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public createProspectV1(prospectInput: ProspectInput, options?: AxiosRequestConfig) {
        return ProspectsApiFp(this.configuration).createProspectV1(prospectInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific Prospect by ID
     * @summary Delete a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public deleteProspectV1(prospectId: string, options?: AxiosRequestConfig) {
        return ProspectsApiFp(this.configuration).deleteProspectV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Prospect by ID
     * @summary Get a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public getProspectV1(prospectId: string, options?: AxiosRequestConfig) {
        return ProspectsApiFp(this.configuration).getProspectV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Prospects
     * @summary List All Prospects
     * @param {string | null} [searchBy] 
     * @param {string | null} [searchValue] 
     * @param {string | null} [status] 
     * @param {string | null} [sortBy] 
     * @param {SortOrder | null} [sortOrder] 
     * @param {number | null} [skip] 
     * @param {number | null} [limit] 
     * @param {string | null} [updatedAfter] 
     * @param {string | null} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public listProspectsV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig) {
        return ProspectsApiFp(this.configuration).listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific Prospect by ID
     * @summary Update a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {ProspectInput} prospectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public updateProspectV1(prospectId: string, prospectInput: ProspectInput, options?: AxiosRequestConfig) {
        return ProspectsApiFp(this.configuration).updateProspectV1(prospectId, prospectInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResellerCourseAssignmentsApi - axios parameter creator
 * @export
 */
export const ResellerCourseAssignmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assign or remove courses for reseller customers
         * @summary Change Reseller Course Assignments
         * @param {ChangeAssignmentRequest} changeAssignmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeResellerCourseAssignmentsV1: async (changeAssignmentRequest: ChangeAssignmentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changeAssignmentRequest' is not null or undefined
            assertParamExists('changeResellerCourseAssignmentsV1', 'changeAssignmentRequest', changeAssignmentRequest)
            const localVarPath = `/v1/resellers/course-assignments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeAssignmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all courses that have been assigned to a specific customer
         * @summary Get Assigned Courses By Customer V1
         * @param {string} customerOrgId 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedCoursesByCustomerV1: async (customerOrgId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('getAssignedCoursesByCustomerV1', 'customerOrgId', customerOrgId)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/courses`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all customers with their course assignment status
         * @summary Get Customers By Assigned Course V1
         * @param {string} courseId 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersByAssignedCourseV1: async (courseId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCustomersByAssignedCourseV1', 'courseId', courseId)
            const localVarPath = `/v1/resellers/courses/{course_id}/customers`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerCourseAssignmentsApi - functional programming interface
 * @export
 */
export const ResellerCourseAssignmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResellerCourseAssignmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Assign or remove courses for reseller customers
         * @summary Change Reseller Course Assignments
         * @param {ChangeAssignmentRequest} changeAssignmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeResellerCourseAssignmentsV1(changeAssignmentRequest: ChangeAssignmentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeResellerCourseAssignmentsV1(changeAssignmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCourseAssignmentsApi.changeResellerCourseAssignmentsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all courses that have been assigned to a specific customer
         * @summary Get Assigned Courses By Customer V1
         * @param {string} customerOrgId 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssignedCoursesByCustomerV1(customerOrgId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseWithAssignmentStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssignedCoursesByCustomerV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCourseAssignmentsApi.getAssignedCoursesByCustomerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all customers with their course assignment status
         * @summary Get Customers By Assigned Course V1
         * @param {string} courseId 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomersByAssignedCourseV1(courseId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrgWithCourseAssignment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomersByAssignedCourseV1(courseId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCourseAssignmentsApi.getCustomersByAssignedCourseV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResellerCourseAssignmentsApi - factory interface
 * @export
 */
export const ResellerCourseAssignmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResellerCourseAssignmentsApiFp(configuration)
    return {
        /**
         * Assign or remove courses for reseller customers
         * @summary Change Reseller Course Assignments
         * @param {ChangeAssignmentRequest} changeAssignmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeResellerCourseAssignmentsV1(changeAssignmentRequest: ChangeAssignmentRequest, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.changeResellerCourseAssignmentsV1(changeAssignmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all courses that have been assigned to a specific customer
         * @summary Get Assigned Courses By Customer V1
         * @param {string} customerOrgId 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedCoursesByCustomerV1(customerOrgId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<CourseWithAssignmentStatus>> {
            return localVarFp.getAssignedCoursesByCustomerV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all customers with their course assignment status
         * @summary Get Customers By Assigned Course V1
         * @param {string} courseId 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersByAssignedCourseV1(courseId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<OrgWithCourseAssignment>> {
            return localVarFp.getCustomersByAssignedCourseV1(courseId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerCourseAssignmentsApi - object-oriented interface
 * @export
 * @class ResellerCourseAssignmentsApi
 * @extends {BaseAPI}
 */
export class ResellerCourseAssignmentsApi extends BaseAPI {
    /**
     * Assign or remove courses for reseller customers
     * @summary Change Reseller Course Assignments
     * @param {ChangeAssignmentRequest} changeAssignmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCourseAssignmentsApi
     */
    public changeResellerCourseAssignmentsV1(changeAssignmentRequest: ChangeAssignmentRequest, options?: AxiosRequestConfig) {
        return ResellerCourseAssignmentsApiFp(this.configuration).changeResellerCourseAssignmentsV1(changeAssignmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all courses that have been assigned to a specific customer
     * @summary Get Assigned Courses By Customer V1
     * @param {string} customerOrgId 
     * @param {string | null} [searchBy] 
     * @param {string | null} [searchValue] 
     * @param {string | null} [status] 
     * @param {string | null} [sortBy] 
     * @param {SortOrder | null} [sortOrder] 
     * @param {number | null} [skip] 
     * @param {number | null} [limit] 
     * @param {string | null} [updatedAfter] 
     * @param {string | null} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCourseAssignmentsApi
     */
    public getAssignedCoursesByCustomerV1(customerOrgId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig) {
        return ResellerCourseAssignmentsApiFp(this.configuration).getAssignedCoursesByCustomerV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all customers with their course assignment status
     * @summary Get Customers By Assigned Course V1
     * @param {string} courseId 
     * @param {string | null} [searchBy] 
     * @param {string | null} [searchValue] 
     * @param {string | null} [status] 
     * @param {string | null} [sortBy] 
     * @param {SortOrder | null} [sortOrder] 
     * @param {number | null} [skip] 
     * @param {number | null} [limit] 
     * @param {string | null} [updatedAfter] 
     * @param {string | null} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCourseAssignmentsApi
     */
    public getCustomersByAssignedCourseV1(courseId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig) {
        return ResellerCourseAssignmentsApiFp(this.configuration).getCustomersByAssignedCourseV1(courseId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResellerCustomerApi - axios parameter creator
 * @export
 */
export const ResellerCustomerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new customer organization under a reseller organization
         * @summary Create Customer V1
         * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerOrganizationV1: async (bodyCreateCustomerOrganizationV1: BodyCreateCustomerOrganizationV1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateCustomerOrganizationV1' is not null or undefined
            assertParamExists('createCustomerOrganizationV1', 'bodyCreateCustomerOrganizationV1', bodyCreateCustomerOrganizationV1)
            const localVarPath = `/v1/resellers/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyCreateCustomerOrganizationV1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a reseller\'s customer and all associated data
         * @summary Delete Customer V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerCustomerV1: async (customerOrgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('deleteResellerCustomerV1', 'customerOrgId', customerOrgId)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the basic credentials of a customer organization under a reseller organization.
         * @summary Get Customer Basic Credentials V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerBasicCredentialsV1: async (customerOrgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('getCustomerBasicCredentialsV1', 'customerOrgId', customerOrgId)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/basic_credentials`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
         * @summary Get Customer Credentials V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCredentialsV1: async (customerOrgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('getCustomerCredentialsV1', 'customerOrgId', customerOrgId)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/credentials`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get reseller customer by id
         * @summary Get Reseller Customer By Id V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerByIdV1: async (customerOrgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('getResellerCustomerByIdV1', 'customerOrgId', customerOrgId)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List reseller customers with prices, users and credits
         * @summary List Reseller Customers V1
         * @param {string | null} [searchQuery] Search query
         * @param {boolean | null} [expandPrices] Whether to expand the prices
         * @param {boolean | null} [expandUsers] Whether to expand the users
         * @param {boolean | null} [expandCredits] Whether to expand the credits
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerCustomersV1: async (searchQuery?: string | null, expandPrices?: boolean | null, expandUsers?: boolean | null, expandCredits?: boolean | null, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchQuery !== undefined) {
                localVarQueryParameter['search_query'] = searchQuery;
            }

            if (expandPrices !== undefined) {
                localVarQueryParameter['expand_prices'] = expandPrices;
            }

            if (expandUsers !== undefined) {
                localVarQueryParameter['expand_users'] = expandUsers;
            }

            if (expandCredits !== undefined) {
                localVarQueryParameter['expand_credits'] = expandCredits;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a customer organization under a reseller organization
         * @summary Update Customer V1
         * @param {string} customerOrgId 
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerOrganizationV1: async (customerOrgId: string, organizationInput: OrganizationInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('updateCustomerOrganizationV1', 'customerOrgId', customerOrgId)
            // verify required parameter 'organizationInput' is not null or undefined
            assertParamExists('updateCustomerOrganizationV1', 'organizationInput', organizationInput)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerCustomerApi - functional programming interface
 * @export
 */
export const ResellerCustomerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResellerCustomerApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new customer organization under a reseller organization
         * @summary Create Customer V1
         * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1: BodyCreateCustomerOrganizationV1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerApi.createCustomerOrganizationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a reseller\'s customer and all associated data
         * @summary Delete Customer V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResellerCustomerV1(customerOrgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResellerCustomerV1(customerOrgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerApi.deleteResellerCustomerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the basic credentials of a customer organization under a reseller organization.
         * @summary Get Customer Basic Credentials V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerBasicCredentialsV1(customerOrgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasicCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerBasicCredentialsV1(customerOrgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerApi.getCustomerBasicCredentialsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
         * @summary Get Customer Credentials V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerCredentialsV1(customerOrgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerCredentialsV1(customerOrgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerApi.getCustomerCredentialsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get reseller customer by id
         * @summary Get Reseller Customer By Id V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerCustomerByIdV1(customerOrgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgUsersPriceCredits>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResellerCustomerByIdV1(customerOrgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerApi.getResellerCustomerByIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List reseller customers with prices, users and credits
         * @summary List Reseller Customers V1
         * @param {string | null} [searchQuery] Search query
         * @param {boolean | null} [expandPrices] Whether to expand the prices
         * @param {boolean | null} [expandUsers] Whether to expand the users
         * @param {boolean | null} [expandCredits] Whether to expand the credits
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResellerCustomersV1(searchQuery?: string | null, expandPrices?: boolean | null, expandUsers?: boolean | null, expandCredits?: boolean | null, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrgUsersPriceCredits>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResellerCustomersV1(searchQuery, expandPrices, expandUsers, expandCredits, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerApi.listResellerCustomersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a customer organization under a reseller organization
         * @summary Update Customer V1
         * @param {string} customerOrgId 
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomerOrganizationV1(customerOrgId: string, organizationInput: OrganizationInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomerOrganizationV1(customerOrgId, organizationInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerApi.updateCustomerOrganizationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResellerCustomerApi - factory interface
 * @export
 */
export const ResellerCustomerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResellerCustomerApiFp(configuration)
    return {
        /**
         * Creates a new customer organization under a reseller organization
         * @summary Create Customer V1
         * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1: BodyCreateCustomerOrganizationV1, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a reseller\'s customer and all associated data
         * @summary Delete Customer V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerCustomerV1(customerOrgId: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.deleteResellerCustomerV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the basic credentials of a customer organization under a reseller organization.
         * @summary Get Customer Basic Credentials V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerBasicCredentialsV1(customerOrgId: string, options?: AxiosRequestConfig): AxiosPromise<BasicCredentials> {
            return localVarFp.getCustomerBasicCredentialsV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
         * @summary Get Customer Credentials V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCredentialsV1(customerOrgId: string, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getCustomerCredentialsV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get reseller customer by id
         * @summary Get Reseller Customer By Id V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerByIdV1(customerOrgId: string, options?: AxiosRequestConfig): AxiosPromise<OrgUsersPriceCredits> {
            return localVarFp.getResellerCustomerByIdV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * List reseller customers with prices, users and credits
         * @summary List Reseller Customers V1
         * @param {string | null} [searchQuery] Search query
         * @param {boolean | null} [expandPrices] Whether to expand the prices
         * @param {boolean | null} [expandUsers] Whether to expand the users
         * @param {boolean | null} [expandCredits] Whether to expand the credits
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerCustomersV1(searchQuery?: string | null, expandPrices?: boolean | null, expandUsers?: boolean | null, expandCredits?: boolean | null, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<OrgUsersPriceCredits>> {
            return localVarFp.listResellerCustomersV1(searchQuery, expandPrices, expandUsers, expandCredits, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a customer organization under a reseller organization
         * @summary Update Customer V1
         * @param {string} customerOrgId 
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerOrganizationV1(customerOrgId: string, organizationInput: OrganizationInput, options?: AxiosRequestConfig): AxiosPromise<OrganizationOutput> {
            return localVarFp.updateCustomerOrganizationV1(customerOrgId, organizationInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerCustomerApi - object-oriented interface
 * @export
 * @class ResellerCustomerApi
 * @extends {BaseAPI}
 */
export class ResellerCustomerApi extends BaseAPI {
    /**
     * Creates a new customer organization under a reseller organization
     * @summary Create Customer V1
     * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    public createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1: BodyCreateCustomerOrganizationV1, options?: AxiosRequestConfig) {
        return ResellerCustomerApiFp(this.configuration).createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a reseller\'s customer and all associated data
     * @summary Delete Customer V1
     * @param {string} customerOrgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    public deleteResellerCustomerV1(customerOrgId: string, options?: AxiosRequestConfig) {
        return ResellerCustomerApiFp(this.configuration).deleteResellerCustomerV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the basic credentials of a customer organization under a reseller organization.
     * @summary Get Customer Basic Credentials V1
     * @param {string} customerOrgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    public getCustomerBasicCredentialsV1(customerOrgId: string, options?: AxiosRequestConfig) {
        return ResellerCustomerApiFp(this.configuration).getCustomerBasicCredentialsV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
     * @summary Get Customer Credentials V1
     * @param {string} customerOrgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    public getCustomerCredentialsV1(customerOrgId: string, options?: AxiosRequestConfig) {
        return ResellerCustomerApiFp(this.configuration).getCustomerCredentialsV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get reseller customer by id
     * @summary Get Reseller Customer By Id V1
     * @param {string} customerOrgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    public getResellerCustomerByIdV1(customerOrgId: string, options?: AxiosRequestConfig) {
        return ResellerCustomerApiFp(this.configuration).getResellerCustomerByIdV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List reseller customers with prices, users and credits
     * @summary List Reseller Customers V1
     * @param {string | null} [searchQuery] Search query
     * @param {boolean | null} [expandPrices] Whether to expand the prices
     * @param {boolean | null} [expandUsers] Whether to expand the users
     * @param {boolean | null} [expandCredits] Whether to expand the credits
     * @param {string | null} [searchBy] 
     * @param {string | null} [searchValue] 
     * @param {string | null} [status] 
     * @param {string | null} [sortBy] 
     * @param {SortOrder | null} [sortOrder] 
     * @param {number | null} [skip] 
     * @param {number | null} [limit] 
     * @param {string | null} [updatedAfter] 
     * @param {string | null} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    public listResellerCustomersV1(searchQuery?: string | null, expandPrices?: boolean | null, expandUsers?: boolean | null, expandCredits?: boolean | null, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig) {
        return ResellerCustomerApiFp(this.configuration).listResellerCustomersV1(searchQuery, expandPrices, expandUsers, expandCredits, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a customer organization under a reseller organization
     * @summary Update Customer V1
     * @param {string} customerOrgId 
     * @param {OrganizationInput} organizationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerApi
     */
    public updateCustomerOrganizationV1(customerOrgId: string, organizationInput: OrganizationInput, options?: AxiosRequestConfig) {
        return ResellerCustomerApiFp(this.configuration).updateCustomerOrganizationV1(customerOrgId, organizationInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResellerCustomerAuditLogsApi - axios parameter creator
 * @export
 */
export const ResellerCustomerAuditLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Reseller Customer Audit Logs
         * @param {string} customerOrgId 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet: async (customerOrgId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet', 'customerOrgId', customerOrgId)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/audit-logs`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerCustomerAuditLogsApi - functional programming interface
 * @export
 */
export const ResellerCustomerAuditLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResellerCustomerAuditLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Reseller Customer Audit Logs
         * @param {string} customerOrgId 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerAuditLogsApi.getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResellerCustomerAuditLogsApi - factory interface
 * @export
 */
export const ResellerCustomerAuditLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResellerCustomerAuditLogsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Reseller Customer Audit Logs
         * @param {string} customerOrgId 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<AuditLog>> {
            return localVarFp.getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerCustomerAuditLogsApi - object-oriented interface
 * @export
 * @class ResellerCustomerAuditLogsApi
 * @extends {BaseAPI}
 */
export class ResellerCustomerAuditLogsApi extends BaseAPI {
    /**
     * 
     * @summary Get Reseller Customer Audit Logs
     * @param {string} customerOrgId 
     * @param {string | null} [searchBy] 
     * @param {string | null} [searchValue] 
     * @param {string | null} [status] 
     * @param {string | null} [sortBy] 
     * @param {SortOrder | null} [sortOrder] 
     * @param {number | null} [skip] 
     * @param {number | null} [limit] 
     * @param {string | null} [updatedAfter] 
     * @param {string | null} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerAuditLogsApi
     */
    public getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig) {
        return ResellerCustomerAuditLogsApiFp(this.configuration).getResellerCustomerAuditLogsV1ResellersCustomersCustomerOrgIdAuditLogsGet(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResellerCustomerCheckoutApi - axios parameter creator
 * @export
 */
export const ResellerCustomerCheckoutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a checkout session for a reseller customer
         * @summary Create Checkout Session For Reseller Customer
         * @param {string} customerOrgId 
         * @param {string} priceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForResellerCustomerV1: async (customerOrgId: string, priceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('createCheckoutSessionForResellerCustomerV1', 'customerOrgId', customerOrgId)
            // verify required parameter 'priceId' is not null or undefined
            assertParamExists('createCheckoutSessionForResellerCustomerV1', 'priceId', priceId)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/pricing/{price_id}/checkout`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"price_id"}}`, encodeURIComponent(String(priceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerCustomerCheckoutApi - functional programming interface
 * @export
 */
export const ResellerCustomerCheckoutApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResellerCustomerCheckoutApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a checkout session for a reseller customer
         * @summary Create Checkout Session For Reseller Customer
         * @param {string} customerOrgId 
         * @param {string} priceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckoutSessionForResellerCustomerV1(customerOrgId: string, priceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheckoutSessionForResellerCustomerV1(customerOrgId, priceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerCheckoutApi.createCheckoutSessionForResellerCustomerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResellerCustomerCheckoutApi - factory interface
 * @export
 */
export const ResellerCustomerCheckoutApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResellerCustomerCheckoutApiFp(configuration)
    return {
        /**
         * Create a checkout session for a reseller customer
         * @summary Create Checkout Session For Reseller Customer
         * @param {string} customerOrgId 
         * @param {string} priceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForResellerCustomerV1(customerOrgId: string, priceId: string, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createCheckoutSessionForResellerCustomerV1(customerOrgId, priceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerCustomerCheckoutApi - object-oriented interface
 * @export
 * @class ResellerCustomerCheckoutApi
 * @extends {BaseAPI}
 */
export class ResellerCustomerCheckoutApi extends BaseAPI {
    /**
     * Create a checkout session for a reseller customer
     * @summary Create Checkout Session For Reseller Customer
     * @param {string} customerOrgId 
     * @param {string} priceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerCheckoutApi
     */
    public createCheckoutSessionForResellerCustomerV1(customerOrgId: string, priceId: string, options?: AxiosRequestConfig) {
        return ResellerCustomerCheckoutApiFp(this.configuration).createCheckoutSessionForResellerCustomerV1(customerOrgId, priceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResellerCustomerDefaultPricingApi - axios parameter creator
 * @export
 */
export const ResellerCustomerDefaultPricingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the default pricing for all customers under the reseller organization
         * @summary Get Customer Default Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerDefaultPricingV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/customers/pricing/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update customer default pricing
         * @summary Update Customer Default Pricing V1
         * @param {string} priceId 
         * @param {PricingRequest} pricingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerDefaultPricingV1: async (priceId: string, pricingRequest: PricingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'priceId' is not null or undefined
            assertParamExists('updateCustomerDefaultPricingV1', 'priceId', priceId)
            // verify required parameter 'pricingRequest' is not null or undefined
            assertParamExists('updateCustomerDefaultPricingV1', 'pricingRequest', pricingRequest)
            const localVarPath = `/v1/resellers/customers/pricing/default/{price_id}`
                .replace(`{${"price_id"}}`, encodeURIComponent(String(priceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pricingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerCustomerDefaultPricingApi - functional programming interface
 * @export
 */
export const ResellerCustomerDefaultPricingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResellerCustomerDefaultPricingApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the default pricing for all customers under the reseller organization
         * @summary Get Customer Default Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerDefaultPricingV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Price>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerDefaultPricingV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerDefaultPricingApi.getCustomerDefaultPricingV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update customer default pricing
         * @summary Update Customer Default Pricing V1
         * @param {string} priceId 
         * @param {PricingRequest} pricingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomerDefaultPricingV1(priceId: string, pricingRequest: PricingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Price>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomerDefaultPricingV1(priceId, pricingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerDefaultPricingApi.updateCustomerDefaultPricingV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResellerCustomerDefaultPricingApi - factory interface
 * @export
 */
export const ResellerCustomerDefaultPricingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResellerCustomerDefaultPricingApiFp(configuration)
    return {
        /**
         * Get the default pricing for all customers under the reseller organization
         * @summary Get Customer Default Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerDefaultPricingV1(options?: AxiosRequestConfig): AxiosPromise<Array<Price>> {
            return localVarFp.getCustomerDefaultPricingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Update customer default pricing
         * @summary Update Customer Default Pricing V1
         * @param {string} priceId 
         * @param {PricingRequest} pricingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerDefaultPricingV1(priceId: string, pricingRequest: PricingRequest, options?: AxiosRequestConfig): AxiosPromise<Price> {
            return localVarFp.updateCustomerDefaultPricingV1(priceId, pricingRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerCustomerDefaultPricingApi - object-oriented interface
 * @export
 * @class ResellerCustomerDefaultPricingApi
 * @extends {BaseAPI}
 */
export class ResellerCustomerDefaultPricingApi extends BaseAPI {
    /**
     * Get the default pricing for all customers under the reseller organization
     * @summary Get Customer Default Pricing V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerDefaultPricingApi
     */
    public getCustomerDefaultPricingV1(options?: AxiosRequestConfig) {
        return ResellerCustomerDefaultPricingApiFp(this.configuration).getCustomerDefaultPricingV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update customer default pricing
     * @summary Update Customer Default Pricing V1
     * @param {string} priceId 
     * @param {PricingRequest} pricingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerDefaultPricingApi
     */
    public updateCustomerDefaultPricingV1(priceId: string, pricingRequest: PricingRequest, options?: AxiosRequestConfig) {
        return ResellerCustomerDefaultPricingApiFp(this.configuration).updateCustomerDefaultPricingV1(priceId, pricingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResellerCustomerPortalApi - axios parameter creator
 * @export
 */
export const ResellerCustomerPortalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a customer portal for a reseller customer
         * @summary Create Customer Portal For Reseller Customer
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPortalForResellerCustomerV1: async (customerOrgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('createCustomerPortalForResellerCustomerV1', 'customerOrgId', customerOrgId)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/portal`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerCustomerPortalApi - functional programming interface
 * @export
 */
export const ResellerCustomerPortalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResellerCustomerPortalApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a customer portal for a reseller customer
         * @summary Create Customer Portal For Reseller Customer
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomerPortalForResellerCustomerV1(customerOrgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomerPortalForResellerCustomerV1(customerOrgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerPortalApi.createCustomerPortalForResellerCustomerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResellerCustomerPortalApi - factory interface
 * @export
 */
export const ResellerCustomerPortalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResellerCustomerPortalApiFp(configuration)
    return {
        /**
         * Create a customer portal for a reseller customer
         * @summary Create Customer Portal For Reseller Customer
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPortalForResellerCustomerV1(customerOrgId: string, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createCustomerPortalForResellerCustomerV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerCustomerPortalApi - object-oriented interface
 * @export
 * @class ResellerCustomerPortalApi
 * @extends {BaseAPI}
 */
export class ResellerCustomerPortalApi extends BaseAPI {
    /**
     * Create a customer portal for a reseller customer
     * @summary Create Customer Portal For Reseller Customer
     * @param {string} customerOrgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerPortalApi
     */
    public createCustomerPortalForResellerCustomerV1(customerOrgId: string, options?: AxiosRequestConfig) {
        return ResellerCustomerPortalApiFp(this.configuration).createCustomerPortalForResellerCustomerV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResellerCustomerPricingApi - axios parameter creator
 * @export
 */
export const ResellerCustomerPricingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Override pricing for customer
         * @summary Create Customer Pricing V1
         * @param {string} customerOrgId 
         * @param {PricingRequest} pricingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPricingV1: async (customerOrgId: string, pricingRequest: PricingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('createCustomerPricingV1', 'customerOrgId', customerOrgId)
            // verify required parameter 'pricingRequest' is not null or undefined
            assertParamExists('createCustomerPricingV1', 'pricingRequest', pricingRequest)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/pricing`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pricingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get resellers customer credits
         * @summary Get Reseller Customer Credits V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerCreditsV1: async (customerOrgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('getResellerCustomerCreditsV1', 'customerOrgId', customerOrgId)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/credits`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get resellers customer pricing
         * @summary Get Reseller Customer Pricing V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerPricingV1: async (customerOrgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('getResellerCustomerPricingV1', 'customerOrgId', customerOrgId)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/pricing`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update customer pricing
         * @summary Update Customer Pricing V1
         * @param {string} customerOrgId 
         * @param {string} priceId 
         * @param {PricingRequest} pricingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerPricingV1: async (customerOrgId: string, priceId: string, pricingRequest: PricingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('updateCustomerPricingV1', 'customerOrgId', customerOrgId)
            // verify required parameter 'priceId' is not null or undefined
            assertParamExists('updateCustomerPricingV1', 'priceId', priceId)
            // verify required parameter 'pricingRequest' is not null or undefined
            assertParamExists('updateCustomerPricingV1', 'pricingRequest', pricingRequest)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/pricing/{price_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"price_id"}}`, encodeURIComponent(String(priceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pricingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerCustomerPricingApi - functional programming interface
 * @export
 */
export const ResellerCustomerPricingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResellerCustomerPricingApiAxiosParamCreator(configuration)
    return {
        /**
         * Override pricing for customer
         * @summary Create Customer Pricing V1
         * @param {string} customerOrgId 
         * @param {PricingRequest} pricingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomerPricingV1(customerOrgId: string, pricingRequest: PricingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Price>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomerPricingV1(customerOrgId, pricingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerPricingApi.createCustomerPricingV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get resellers customer credits
         * @summary Get Reseller Customer Credits V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerCustomerCreditsV1(customerOrgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Credit>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResellerCustomerCreditsV1(customerOrgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerPricingApi.getResellerCustomerCreditsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get resellers customer pricing
         * @summary Get Reseller Customer Pricing V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerCustomerPricingV1(customerOrgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Price>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResellerCustomerPricingV1(customerOrgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerPricingApi.getResellerCustomerPricingV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update customer pricing
         * @summary Update Customer Pricing V1
         * @param {string} customerOrgId 
         * @param {string} priceId 
         * @param {PricingRequest} pricingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomerPricingV1(customerOrgId: string, priceId: string, pricingRequest: PricingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Price>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomerPricingV1(customerOrgId, priceId, pricingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerPricingApi.updateCustomerPricingV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResellerCustomerPricingApi - factory interface
 * @export
 */
export const ResellerCustomerPricingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResellerCustomerPricingApiFp(configuration)
    return {
        /**
         * Override pricing for customer
         * @summary Create Customer Pricing V1
         * @param {string} customerOrgId 
         * @param {PricingRequest} pricingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPricingV1(customerOrgId: string, pricingRequest: PricingRequest, options?: AxiosRequestConfig): AxiosPromise<Price> {
            return localVarFp.createCustomerPricingV1(customerOrgId, pricingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get resellers customer credits
         * @summary Get Reseller Customer Credits V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerCreditsV1(customerOrgId: string, options?: AxiosRequestConfig): AxiosPromise<Array<Credit>> {
            return localVarFp.getResellerCustomerCreditsV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get resellers customer pricing
         * @summary Get Reseller Customer Pricing V1
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerPricingV1(customerOrgId: string, options?: AxiosRequestConfig): AxiosPromise<Array<Price>> {
            return localVarFp.getResellerCustomerPricingV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update customer pricing
         * @summary Update Customer Pricing V1
         * @param {string} customerOrgId 
         * @param {string} priceId 
         * @param {PricingRequest} pricingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerPricingV1(customerOrgId: string, priceId: string, pricingRequest: PricingRequest, options?: AxiosRequestConfig): AxiosPromise<Price> {
            return localVarFp.updateCustomerPricingV1(customerOrgId, priceId, pricingRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerCustomerPricingApi - object-oriented interface
 * @export
 * @class ResellerCustomerPricingApi
 * @extends {BaseAPI}
 */
export class ResellerCustomerPricingApi extends BaseAPI {
    /**
     * Override pricing for customer
     * @summary Create Customer Pricing V1
     * @param {string} customerOrgId 
     * @param {PricingRequest} pricingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerPricingApi
     */
    public createCustomerPricingV1(customerOrgId: string, pricingRequest: PricingRequest, options?: AxiosRequestConfig) {
        return ResellerCustomerPricingApiFp(this.configuration).createCustomerPricingV1(customerOrgId, pricingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get resellers customer credits
     * @summary Get Reseller Customer Credits V1
     * @param {string} customerOrgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerPricingApi
     */
    public getResellerCustomerCreditsV1(customerOrgId: string, options?: AxiosRequestConfig) {
        return ResellerCustomerPricingApiFp(this.configuration).getResellerCustomerCreditsV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get resellers customer pricing
     * @summary Get Reseller Customer Pricing V1
     * @param {string} customerOrgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerPricingApi
     */
    public getResellerCustomerPricingV1(customerOrgId: string, options?: AxiosRequestConfig) {
        return ResellerCustomerPricingApiFp(this.configuration).getResellerCustomerPricingV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update customer pricing
     * @summary Update Customer Pricing V1
     * @param {string} customerOrgId 
     * @param {string} priceId 
     * @param {PricingRequest} pricingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerPricingApi
     */
    public updateCustomerPricingV1(customerOrgId: string, priceId: string, pricingRequest: PricingRequest, options?: AxiosRequestConfig) {
        return ResellerCustomerPricingApiFp(this.configuration).updateCustomerPricingV1(customerOrgId, priceId, pricingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResellerCustomerUserApi - axios parameter creator
 * @export
 */
export const ResellerCustomerUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete reseller customer user
         * @summary Delete Reseller Customer User V1
         * @param {string} customerOrgId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerCustomerUserV1: async (customerOrgId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('deleteResellerCustomerUserV1', 'customerOrgId', customerOrgId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteResellerCustomerUserV1', 'userId', userId)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/users/{user_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get resellers customer users and invites by id
         * @summary Get Reseller Customer User And Invites V1
         * @param {string} customerOrgId 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerUserAndInvitesV1: async (customerOrgId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('getResellerCustomerUserAndInvitesV1', 'customerOrgId', customerOrgId)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/users_and_invites`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get resellers customer user by id
         * @summary Get Reseller Customer User By Id V1
         * @param {string} customerOrgId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerUserByIdV1: async (customerOrgId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('getResellerCustomerUserByIdV1', 'customerOrgId', customerOrgId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getResellerCustomerUserByIdV1', 'userId', userId)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/users/{user_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all invites for a customer organization
         * @summary List Customer Invites V1
         * @param {string} customerOrgId 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomerInvitesV1: async (customerOrgId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('listCustomerInvitesV1', 'customerOrgId', customerOrgId)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/invites`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List resellers customer users
         * @summary List Reseller Customer Users V1
         * @param {string} customerOrgId 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerCustomerUsersV1: async (customerOrgId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('listResellerCustomerUsersV1', 'customerOrgId', customerOrgId)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/users`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke an invite for a customer organization
         * @summary Revoke Customer Invite V1
         * @param {string} customerOrgId 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCustomerInviteV1: async (customerOrgId: string, email: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('revokeCustomerInviteV1', 'customerOrgId', customerOrgId)
            // verify required parameter 'email' is not null or undefined
            assertParamExists('revokeCustomerInviteV1', 'email', email)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/invites/{email}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send invite to a user on behalf of a customer organization
         * @summary Invite Customer Users V1
         * @param {string} customerOrgId 
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCustomerUserInviteV1: async (customerOrgId: string, guestInput: GuestInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('sendCustomerUserInviteV1', 'customerOrgId', customerOrgId)
            // verify required parameter 'guestInput' is not null or undefined
            assertParamExists('sendCustomerUserInviteV1', 'guestInput', guestInput)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/invites`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(guestInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update reseller customer user
         * @summary Update Reseller Customer User V1
         * @param {string} customerOrgId 
         * @param {string} userId 
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerCustomerUserV1: async (customerOrgId: string, userId: string, updateUserRequest: UpdateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            assertParamExists('updateResellerCustomerUserV1', 'customerOrgId', customerOrgId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateResellerCustomerUserV1', 'userId', userId)
            // verify required parameter 'updateUserRequest' is not null or undefined
            assertParamExists('updateResellerCustomerUserV1', 'updateUserRequest', updateUserRequest)
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/users/{user_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerCustomerUserApi - functional programming interface
 * @export
 */
export const ResellerCustomerUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResellerCustomerUserApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete reseller customer user
         * @summary Delete Reseller Customer User V1
         * @param {string} customerOrgId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResellerCustomerUserV1(customerOrgId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResellerCustomerUserV1(customerOrgId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerUserApi.deleteResellerCustomerUserV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get resellers customer users and invites by id
         * @summary Get Reseller Customer User And Invites V1
         * @param {string} customerOrgId 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerCustomerUserAndInvitesV1(customerOrgId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResellerCustomerUserAndInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerUserApi.getResellerCustomerUserAndInvitesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get resellers customer user by id
         * @summary Get Reseller Customer User By Id V1
         * @param {string} customerOrgId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerCustomerUserByIdV1(customerOrgId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResellerCustomerUserByIdV1(customerOrgId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerUserApi.getResellerCustomerUserByIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all invites for a customer organization
         * @summary List Customer Invites V1
         * @param {string} customerOrgId 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCustomerInvitesV1(customerOrgId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuestOutput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCustomerInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerUserApi.listCustomerInvitesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List resellers customer users
         * @summary List Reseller Customer Users V1
         * @param {string} customerOrgId 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResellerCustomerUsersV1(customerOrgId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResellerCustomerUsersV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerUserApi.listResellerCustomerUsersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke an invite for a customer organization
         * @summary Revoke Customer Invite V1
         * @param {string} customerOrgId 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeCustomerInviteV1(customerOrgId: string, email: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeCustomerInviteV1(customerOrgId, email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerUserApi.revokeCustomerInviteV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send invite to a user on behalf of a customer organization
         * @summary Invite Customer Users V1
         * @param {string} customerOrgId 
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendCustomerUserInviteV1(customerOrgId: string, guestInput: GuestInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendCustomerUserInviteV1(customerOrgId, guestInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerUserApi.sendCustomerUserInviteV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update reseller customer user
         * @summary Update Reseller Customer User V1
         * @param {string} customerOrgId 
         * @param {string} userId 
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResellerCustomerUserV1(customerOrgId: string, userId: string, updateUserRequest: UpdateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResellerCustomerUserV1(customerOrgId, userId, updateUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerCustomerUserApi.updateResellerCustomerUserV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResellerCustomerUserApi - factory interface
 * @export
 */
export const ResellerCustomerUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResellerCustomerUserApiFp(configuration)
    return {
        /**
         * Delete reseller customer user
         * @summary Delete Reseller Customer User V1
         * @param {string} customerOrgId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerCustomerUserV1(customerOrgId: string, userId: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.deleteResellerCustomerUserV1(customerOrgId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get resellers customer users and invites by id
         * @summary Get Reseller Customer User And Invites V1
         * @param {string} customerOrgId 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerUserAndInvitesV1(customerOrgId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.getResellerCustomerUserAndInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Get resellers customer user by id
         * @summary Get Reseller Customer User By Id V1
         * @param {string} customerOrgId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerCustomerUserByIdV1(customerOrgId: string, userId: string, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getResellerCustomerUserByIdV1(customerOrgId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all invites for a customer organization
         * @summary List Customer Invites V1
         * @param {string} customerOrgId 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomerInvitesV1(customerOrgId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<GuestOutput>> {
            return localVarFp.listCustomerInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * List resellers customer users
         * @summary List Reseller Customer Users V1
         * @param {string} customerOrgId 
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerCustomerUsersV1(customerOrgId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.listResellerCustomerUsersV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke an invite for a customer organization
         * @summary Revoke Customer Invite V1
         * @param {string} customerOrgId 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCustomerInviteV1(customerOrgId: string, email: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.revokeCustomerInviteV1(customerOrgId, email, options).then((request) => request(axios, basePath));
        },
        /**
         * Send invite to a user on behalf of a customer organization
         * @summary Invite Customer Users V1
         * @param {string} customerOrgId 
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCustomerUserInviteV1(customerOrgId: string, guestInput: GuestInput, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.sendCustomerUserInviteV1(customerOrgId, guestInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update reseller customer user
         * @summary Update Reseller Customer User V1
         * @param {string} customerOrgId 
         * @param {string} userId 
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerCustomerUserV1(customerOrgId: string, userId: string, updateUserRequest: UpdateUserRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateResellerCustomerUserV1(customerOrgId, userId, updateUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerCustomerUserApi - object-oriented interface
 * @export
 * @class ResellerCustomerUserApi
 * @extends {BaseAPI}
 */
export class ResellerCustomerUserApi extends BaseAPI {
    /**
     * Delete reseller customer user
     * @summary Delete Reseller Customer User V1
     * @param {string} customerOrgId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    public deleteResellerCustomerUserV1(customerOrgId: string, userId: string, options?: AxiosRequestConfig) {
        return ResellerCustomerUserApiFp(this.configuration).deleteResellerCustomerUserV1(customerOrgId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get resellers customer users and invites by id
     * @summary Get Reseller Customer User And Invites V1
     * @param {string} customerOrgId 
     * @param {string | null} [searchBy] 
     * @param {string | null} [searchValue] 
     * @param {string | null} [status] 
     * @param {string | null} [sortBy] 
     * @param {SortOrder | null} [sortOrder] 
     * @param {number | null} [skip] 
     * @param {number | null} [limit] 
     * @param {string | null} [updatedAfter] 
     * @param {string | null} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    public getResellerCustomerUserAndInvitesV1(customerOrgId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig) {
        return ResellerCustomerUserApiFp(this.configuration).getResellerCustomerUserAndInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get resellers customer user by id
     * @summary Get Reseller Customer User By Id V1
     * @param {string} customerOrgId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    public getResellerCustomerUserByIdV1(customerOrgId: string, userId: string, options?: AxiosRequestConfig) {
        return ResellerCustomerUserApiFp(this.configuration).getResellerCustomerUserByIdV1(customerOrgId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all invites for a customer organization
     * @summary List Customer Invites V1
     * @param {string} customerOrgId 
     * @param {string | null} [searchBy] 
     * @param {string | null} [searchValue] 
     * @param {string | null} [status] 
     * @param {string | null} [sortBy] 
     * @param {SortOrder | null} [sortOrder] 
     * @param {number | null} [skip] 
     * @param {number | null} [limit] 
     * @param {string | null} [updatedAfter] 
     * @param {string | null} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    public listCustomerInvitesV1(customerOrgId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig) {
        return ResellerCustomerUserApiFp(this.configuration).listCustomerInvitesV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List resellers customer users
     * @summary List Reseller Customer Users V1
     * @param {string} customerOrgId 
     * @param {string | null} [searchBy] 
     * @param {string | null} [searchValue] 
     * @param {string | null} [status] 
     * @param {string | null} [sortBy] 
     * @param {SortOrder | null} [sortOrder] 
     * @param {number | null} [skip] 
     * @param {number | null} [limit] 
     * @param {string | null} [updatedAfter] 
     * @param {string | null} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    public listResellerCustomerUsersV1(customerOrgId: string, searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig) {
        return ResellerCustomerUserApiFp(this.configuration).listResellerCustomerUsersV1(customerOrgId, searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke an invite for a customer organization
     * @summary Revoke Customer Invite V1
     * @param {string} customerOrgId 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    public revokeCustomerInviteV1(customerOrgId: string, email: string, options?: AxiosRequestConfig) {
        return ResellerCustomerUserApiFp(this.configuration).revokeCustomerInviteV1(customerOrgId, email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send invite to a user on behalf of a customer organization
     * @summary Invite Customer Users V1
     * @param {string} customerOrgId 
     * @param {GuestInput} guestInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    public sendCustomerUserInviteV1(customerOrgId: string, guestInput: GuestInput, options?: AxiosRequestConfig) {
        return ResellerCustomerUserApiFp(this.configuration).sendCustomerUserInviteV1(customerOrgId, guestInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update reseller customer user
     * @summary Update Reseller Customer User V1
     * @param {string} customerOrgId 
     * @param {string} userId 
     * @param {UpdateUserRequest} updateUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerCustomerUserApi
     */
    public updateResellerCustomerUserV1(customerOrgId: string, userId: string, updateUserRequest: UpdateUserRequest, options?: AxiosRequestConfig) {
        return ResellerCustomerUserApiFp(this.configuration).updateResellerCustomerUserV1(customerOrgId, userId, updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResellerFilesApi - axios parameter creator
 * @export
 */
export const ResellerFilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete files from Trata reseller account
         * @summary Delete Files
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerFilesV1: async (fileIds: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileIds' is not null or undefined
            assertParamExists('deleteResellerFilesV1', 'fileIds', fileIds)
            const localVarPath = `/v1/resellers/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fileIds !== undefined) {
                localVarQueryParameter['file_ids'] = fileIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<File>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadResellerFilesV1: async (files: Array<File>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'files' is not null or undefined
            assertParamExists('uploadResellerFilesV1', 'files', files)
            const localVarPath = `/v1/resellers/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerFilesApi - functional programming interface
 * @export
 */
export const ResellerFilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResellerFilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete files from Trata reseller account
         * @summary Delete Files
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResellerFilesV1(fileIds: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResellerFilesV1(fileIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerFilesApi.deleteResellerFilesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<File>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadResellerFilesV1(files: Array<File>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Files>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadResellerFilesV1(files, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerFilesApi.uploadResellerFilesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResellerFilesApi - factory interface
 * @export
 */
export const ResellerFilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResellerFilesApiFp(configuration)
    return {
        /**
         * Delete files from Trata reseller account
         * @summary Delete Files
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerFilesV1(fileIds: string, options?: AxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.deleteResellerFilesV1(fileIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<File>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadResellerFilesV1(files: Array<File>, options?: AxiosRequestConfig): AxiosPromise<Array<Files>> {
            return localVarFp.uploadResellerFilesV1(files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerFilesApi - object-oriented interface
 * @export
 * @class ResellerFilesApi
 * @extends {BaseAPI}
 */
export class ResellerFilesApi extends BaseAPI {
    /**
     * Delete files from Trata reseller account
     * @summary Delete Files
     * @param {string} fileIds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerFilesApi
     */
    public deleteResellerFilesV1(fileIds: string, options?: AxiosRequestConfig) {
        return ResellerFilesApiFp(this.configuration).deleteResellerFilesV1(fileIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload file to Trata account to use in AI Agents
     * @summary Upload Files
     * @param {Array<File>} files 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerFilesApi
     */
    public uploadResellerFilesV1(files: Array<File>, options?: AxiosRequestConfig) {
        return ResellerFilesApiFp(this.configuration).uploadResellerFilesV1(files, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResellerMetricsApi - axios parameter creator
 * @export
 */
export const ResellerMetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get analytics data for Reseller
         * @summary Get Reseller Metrics
         * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerMetricsV1: async (resellerBatchMetricsRequests: ResellerBatchMetricsRequests, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resellerBatchMetricsRequests' is not null or undefined
            assertParamExists('getResellerMetricsV1', 'resellerBatchMetricsRequests', resellerBatchMetricsRequests)
            const localVarPath = `/v1/resellers/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resellerBatchMetricsRequests, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerMetricsApi - functional programming interface
 * @export
 */
export const ResellerMetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResellerMetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get analytics data for Reseller
         * @summary Get Reseller Metrics
         * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerMetricsV1(resellerBatchMetricsRequests: ResellerBatchMetricsRequests, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchMetricsResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResellerMetricsV1(resellerBatchMetricsRequests, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerMetricsApi.getResellerMetricsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResellerMetricsApi - factory interface
 * @export
 */
export const ResellerMetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResellerMetricsApiFp(configuration)
    return {
        /**
         * Get analytics data for Reseller
         * @summary Get Reseller Metrics
         * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerMetricsV1(resellerBatchMetricsRequests: ResellerBatchMetricsRequests, options?: AxiosRequestConfig): AxiosPromise<BatchMetricsResponseInput> {
            return localVarFp.getResellerMetricsV1(resellerBatchMetricsRequests, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerMetricsApi - object-oriented interface
 * @export
 * @class ResellerMetricsApi
 * @extends {BaseAPI}
 */
export class ResellerMetricsApi extends BaseAPI {
    /**
     * Get analytics data for Reseller
     * @summary Get Reseller Metrics
     * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerMetricsApi
     */
    public getResellerMetricsV1(resellerBatchMetricsRequests: ResellerBatchMetricsRequests, options?: AxiosRequestConfig) {
        return ResellerMetricsApiFp(this.configuration).getResellerMetricsV1(resellerBatchMetricsRequests, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResellerOrganizationApi - axios parameter creator
 * @export
 */
export const ResellerOrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
         * @summary Create Reseller Organization V1
         * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResellerOrganizationV1: async (bodyCreateResellerOrganizationV1: BodyCreateResellerOrganizationV1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateResellerOrganizationV1' is not null or undefined
            assertParamExists('createResellerOrganizationV1', 'bodyCreateResellerOrganizationV1', bodyCreateResellerOrganizationV1)
            const localVarPath = `/v1/resellers/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyCreateResellerOrganizationV1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a reseller organization
         * @summary Delete Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerOrganizationV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a reseller organization by id
         * @summary Get Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerOrganizationV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a reseller organization
         * @summary Update Reseller Organization V1
         * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerOrganizationV1: async (updateResellerOrganizationRequest: UpdateResellerOrganizationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateResellerOrganizationRequest' is not null or undefined
            assertParamExists('updateResellerOrganizationV1', 'updateResellerOrganizationRequest', updateResellerOrganizationRequest)
            const localVarPath = `/v1/resellers/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResellerOrganizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerOrganizationApi - functional programming interface
 * @export
 */
export const ResellerOrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResellerOrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
         * @summary Create Reseller Organization V1
         * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResellerOrganizationV1(bodyCreateResellerOrganizationV1: BodyCreateResellerOrganizationV1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerOrganizationApi.createResellerOrganizationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a reseller organization
         * @summary Delete Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResellerOrganizationV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResellerOrganizationV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerOrganizationApi.deleteResellerOrganizationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a reseller organization by id
         * @summary Get Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerOrganizationV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgWithUsers>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResellerOrganizationV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerOrganizationApi.getResellerOrganizationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a reseller organization
         * @summary Update Reseller Organization V1
         * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResellerOrganizationV1(updateResellerOrganizationRequest: UpdateResellerOrganizationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResellerOrganizationV1(updateResellerOrganizationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerOrganizationApi.updateResellerOrganizationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResellerOrganizationApi - factory interface
 * @export
 */
export const ResellerOrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResellerOrganizationApiFp(configuration)
    return {
        /**
         * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
         * @summary Create Reseller Organization V1
         * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResellerOrganizationV1(bodyCreateResellerOrganizationV1: BodyCreateResellerOrganizationV1, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a reseller organization
         * @summary Delete Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerOrganizationV1(options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.deleteResellerOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a reseller organization by id
         * @summary Get Reseller Organization V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerOrganizationV1(options?: AxiosRequestConfig): AxiosPromise<OrgWithUsers> {
            return localVarFp.getResellerOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a reseller organization
         * @summary Update Reseller Organization V1
         * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerOrganizationV1(updateResellerOrganizationRequest: UpdateResellerOrganizationRequest, options?: AxiosRequestConfig): AxiosPromise<OrganizationOutput> {
            return localVarFp.updateResellerOrganizationV1(updateResellerOrganizationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerOrganizationApi - object-oriented interface
 * @export
 * @class ResellerOrganizationApi
 * @extends {BaseAPI}
 */
export class ResellerOrganizationApi extends BaseAPI {
    /**
     * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
     * @summary Create Reseller Organization V1
     * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerOrganizationApi
     */
    public createResellerOrganizationV1(bodyCreateResellerOrganizationV1: BodyCreateResellerOrganizationV1, options?: AxiosRequestConfig) {
        return ResellerOrganizationApiFp(this.configuration).createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a reseller organization
     * @summary Delete Reseller Organization V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerOrganizationApi
     */
    public deleteResellerOrganizationV1(options?: AxiosRequestConfig) {
        return ResellerOrganizationApiFp(this.configuration).deleteResellerOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a reseller organization by id
     * @summary Get Reseller Organization V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerOrganizationApi
     */
    public getResellerOrganizationV1(options?: AxiosRequestConfig) {
        return ResellerOrganizationApiFp(this.configuration).getResellerOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a reseller organization
     * @summary Update Reseller Organization V1
     * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerOrganizationApi
     */
    public updateResellerOrganizationV1(updateResellerOrganizationRequest: UpdateResellerOrganizationRequest, options?: AxiosRequestConfig) {
        return ResellerOrganizationApiFp(this.configuration).updateResellerOrganizationV1(updateResellerOrganizationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResellerPricingApi - axios parameter creator
 * @export
 */
export const ResellerPricingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new account link to the reseller organization
         * @summary Add Stripe Account Link To Reseller Org
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addStripeAccountLinkToResellerOrgV1: async (code: string, state: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('addStripeAccountLinkToResellerOrgV1', 'code', code)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('addStripeAccountLinkToResellerOrgV1', 'state', state)
            const localVarPath = `/v1/resellers/stripe-account/link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new account link URL for the reseller
         * @summary Create Stripe Account Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStripeAccountLinkV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/stripe-account/connect-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stripe account details
         * @summary Get Stripe Account Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripeAccountDetailsV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/stripe-account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disconnect reseller stripe account connection
         * @summary Revoke Stripe Connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeDisconnectV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/stripe-account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerPricingApi - functional programming interface
 * @export
 */
export const ResellerPricingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResellerPricingApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new account link to the reseller organization
         * @summary Add Stripe Account Link To Reseller Org
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addStripeAccountLinkToResellerOrgV1(code: string, state: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addStripeAccountLinkToResellerOrgV1(code, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerPricingApi.addStripeAccountLinkToResellerOrgV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new account link URL for the reseller
         * @summary Create Stripe Account Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStripeAccountLinkV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStripeAccountLinkV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerPricingApi.createStripeAccountLinkV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get stripe account details
         * @summary Get Stripe Account Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStripeAccountDetailsV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResellerPaymentAccountDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStripeAccountDetailsV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerPricingApi.getStripeAccountDetailsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disconnect reseller stripe account connection
         * @summary Revoke Stripe Connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeDisconnectV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stripeDisconnectV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerPricingApi.stripeDisconnectV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResellerPricingApi - factory interface
 * @export
 */
export const ResellerPricingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResellerPricingApiFp(configuration)
    return {
        /**
         * Adds a new account link to the reseller organization
         * @summary Add Stripe Account Link To Reseller Org
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addStripeAccountLinkToResellerOrgV1(code: string, state: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.addStripeAccountLinkToResellerOrgV1(code, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new account link URL for the reseller
         * @summary Create Stripe Account Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStripeAccountLinkV1(options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createStripeAccountLinkV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get stripe account details
         * @summary Get Stripe Account Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripeAccountDetailsV1(options?: AxiosRequestConfig): AxiosPromise<ResellerPaymentAccountDetails> {
            return localVarFp.getStripeAccountDetailsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Disconnect reseller stripe account connection
         * @summary Revoke Stripe Connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeDisconnectV1(options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.stripeDisconnectV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerPricingApi - object-oriented interface
 * @export
 * @class ResellerPricingApi
 * @extends {BaseAPI}
 */
export class ResellerPricingApi extends BaseAPI {
    /**
     * Adds a new account link to the reseller organization
     * @summary Add Stripe Account Link To Reseller Org
     * @param {string} code 
     * @param {string} state 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerPricingApi
     */
    public addStripeAccountLinkToResellerOrgV1(code: string, state: string, options?: AxiosRequestConfig) {
        return ResellerPricingApiFp(this.configuration).addStripeAccountLinkToResellerOrgV1(code, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new account link URL for the reseller
     * @summary Create Stripe Account Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerPricingApi
     */
    public createStripeAccountLinkV1(options?: AxiosRequestConfig) {
        return ResellerPricingApiFp(this.configuration).createStripeAccountLinkV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stripe account details
     * @summary Get Stripe Account Details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerPricingApi
     */
    public getStripeAccountDetailsV1(options?: AxiosRequestConfig) {
        return ResellerPricingApiFp(this.configuration).getStripeAccountDetailsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disconnect reseller stripe account connection
     * @summary Revoke Stripe Connection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerPricingApi
     */
    public stripeDisconnectV1(options?: AxiosRequestConfig) {
        return ResellerPricingApiFp(this.configuration).stripeDisconnectV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResellerSettingsApi - axios parameter creator
 * @export
 */
export const ResellerSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add Reseller settings
         * @summary Organization Settings V1
         * @param {OrganizationSettings} organizationSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResellerSettingsV1: async (organizationSettings: OrganizationSettings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSettings' is not null or undefined
            assertParamExists('addResellerSettingsV1', 'organizationSettings', organizationSettings)
            const localVarPath = `/v1/resellers/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization settings
         * @summary Get Organization Settings V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSettingsV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update organization settings
         * @summary Organization Settings Update V1
         * @param {OrganizationSettings} organizationSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerSettingsV1: async (organizationSettings: OrganizationSettings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSettings' is not null or undefined
            assertParamExists('updateResellerSettingsV1', 'organizationSettings', organizationSettings)
            const localVarPath = `/v1/resellers/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerSettingsApi - functional programming interface
 * @export
 */
export const ResellerSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResellerSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add Reseller settings
         * @summary Organization Settings V1
         * @param {OrganizationSettings} organizationSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addResellerSettingsV1(organizationSettings: OrganizationSettings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addResellerSettingsV1(organizationSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerSettingsApi.addResellerSettingsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization settings
         * @summary Get Organization Settings V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationSettingsV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationSettingsV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerSettingsApi.getOrganizationSettingsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update organization settings
         * @summary Organization Settings Update V1
         * @param {OrganizationSettings} organizationSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResellerSettingsV1(organizationSettings: OrganizationSettings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResellerSettingsV1(organizationSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerSettingsApi.updateResellerSettingsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResellerSettingsApi - factory interface
 * @export
 */
export const ResellerSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResellerSettingsApiFp(configuration)
    return {
        /**
         * Add Reseller settings
         * @summary Organization Settings V1
         * @param {OrganizationSettings} organizationSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResellerSettingsV1(organizationSettings: OrganizationSettings, options?: AxiosRequestConfig): AxiosPromise<OrganizationSettings> {
            return localVarFp.addResellerSettingsV1(organizationSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization settings
         * @summary Get Organization Settings V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSettingsV1(options?: AxiosRequestConfig): AxiosPromise<OrganizationSettings> {
            return localVarFp.getOrganizationSettingsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Update organization settings
         * @summary Organization Settings Update V1
         * @param {OrganizationSettings} organizationSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerSettingsV1(organizationSettings: OrganizationSettings, options?: AxiosRequestConfig): AxiosPromise<OrganizationSettings> {
            return localVarFp.updateResellerSettingsV1(organizationSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerSettingsApi - object-oriented interface
 * @export
 * @class ResellerSettingsApi
 * @extends {BaseAPI}
 */
export class ResellerSettingsApi extends BaseAPI {
    /**
     * Add Reseller settings
     * @summary Organization Settings V1
     * @param {OrganizationSettings} organizationSettings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerSettingsApi
     */
    public addResellerSettingsV1(organizationSettings: OrganizationSettings, options?: AxiosRequestConfig) {
        return ResellerSettingsApiFp(this.configuration).addResellerSettingsV1(organizationSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization settings
     * @summary Get Organization Settings V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerSettingsApi
     */
    public getOrganizationSettingsV1(options?: AxiosRequestConfig) {
        return ResellerSettingsApiFp(this.configuration).getOrganizationSettingsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update organization settings
     * @summary Organization Settings Update V1
     * @param {OrganizationSettings} organizationSettings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerSettingsApi
     */
    public updateResellerSettingsV1(organizationSettings: OrganizationSettings, options?: AxiosRequestConfig) {
        return ResellerSettingsApiFp(this.configuration).updateResellerSettingsV1(organizationSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResellerUserApi - axios parameter creator
 * @export
 */
export const ResellerUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Accept Invite V1
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptResellerUserInviteV1: async (acceptInviteRequest: AcceptInviteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acceptInviteRequest' is not null or undefined
            assertParamExists('acceptResellerUserInviteV1', 'acceptInviteRequest', acceptInviteRequest)
            const localVarPath = `/v1/resellers/invites/accept`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(acceptInviteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user
         * @summary Delete Reseller User V1
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerUserV1: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteResellerUserV1', 'userId', userId)
            const localVarPath = `/v1/resellers/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Reseller User By Id V1
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerUserByIdV1: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getResellerUserByIdV1', 'userId', userId)
            const localVarPath = `/v1/resellers/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of all open invites from the organization
         * @summary List Reseller User Invites V1
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUserInvitesV1: async (searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all users under the user\'s organization
         * @summary List Reseller Users V1
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUsersV1: async (searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Invite Users V1
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendResellerUserInviteV1: async (guestInput: GuestInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guestInput' is not null or undefined
            assertParamExists('sendResellerUserInviteV1', 'guestInput', guestInput)
            const localVarPath = `/v1/resellers/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(guestInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user details
         * @summary Update Reseller User V1
         * @param {string} userId 
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerUserV1: async (userId: string, userPayload: UserPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateResellerUserV1', 'userId', userId)
            // verify required parameter 'userPayload' is not null or undefined
            assertParamExists('updateResellerUserV1', 'userPayload', userPayload)
            const localVarPath = `/v1/resellers/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerUserApi - functional programming interface
 * @export
 */
export const ResellerUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResellerUserApiAxiosParamCreator(configuration)
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Accept Invite V1
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptResellerUserInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptResellerUserInviteV1(acceptInviteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerUserApi.acceptResellerUserInviteV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a user
         * @summary Delete Reseller User V1
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResellerUserV1(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResellerUserV1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerUserApi.deleteResellerUserV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Reseller User By Id V1
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerUserByIdV1(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResellerUserByIdV1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerUserApi.getResellerUserByIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of all open invites from the organization
         * @summary List Reseller User Invites V1
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResellerUserInvitesV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuestOutput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerUserApi.listResellerUserInvitesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all users under the user\'s organization
         * @summary List Reseller Users V1
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResellerUsersV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerUserApi.listResellerUsersV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Invite Users V1
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendResellerUserInviteV1(guestInput: GuestInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuestOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendResellerUserInviteV1(guestInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerUserApi.sendResellerUserInviteV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user details
         * @summary Update Reseller User V1
         * @param {string} userId 
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResellerUserV1(userId: string, userPayload: UserPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResellerUserV1(userId, userPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResellerUserApi.updateResellerUserV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResellerUserApi - factory interface
 * @export
 */
export const ResellerUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResellerUserApiFp(configuration)
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Accept Invite V1
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptResellerUserInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.acceptResellerUserInviteV1(acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user
         * @summary Delete Reseller User V1
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerUserV1(userId: string, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.deleteResellerUserV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Reseller User By Id V1
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerUserByIdV1(userId: string, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getResellerUserByIdV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List of all open invites from the organization
         * @summary List Reseller User Invites V1
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUserInvitesV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<GuestOutput>> {
            return localVarFp.listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all users under the user\'s organization
         * @summary List Reseller Users V1
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUsersV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Invite Users V1
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendResellerUserInviteV1(guestInput: GuestInput, options?: AxiosRequestConfig): AxiosPromise<GuestOutput> {
            return localVarFp.sendResellerUserInviteV1(guestInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user details
         * @summary Update Reseller User V1
         * @param {string} userId 
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerUserV1(userId: string, userPayload: UserPayload, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateResellerUserV1(userId, userPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerUserApi - object-oriented interface
 * @export
 * @class ResellerUserApi
 * @extends {BaseAPI}
 */
export class ResellerUserApi extends BaseAPI {
    /**
     * Accept invite and add new user to organization
     * @summary Accept Invite V1
     * @param {AcceptInviteRequest} acceptInviteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    public acceptResellerUserInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: AxiosRequestConfig) {
        return ResellerUserApiFp(this.configuration).acceptResellerUserInviteV1(acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user
     * @summary Delete Reseller User V1
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    public deleteResellerUserV1(userId: string, options?: AxiosRequestConfig) {
        return ResellerUserApiFp(this.configuration).deleteResellerUserV1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Reseller User By Id V1
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    public getResellerUserByIdV1(userId: string, options?: AxiosRequestConfig) {
        return ResellerUserApiFp(this.configuration).getResellerUserByIdV1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of all open invites from the organization
     * @summary List Reseller User Invites V1
     * @param {string | null} [searchBy] 
     * @param {string | null} [searchValue] 
     * @param {string | null} [status] 
     * @param {string | null} [sortBy] 
     * @param {SortOrder | null} [sortOrder] 
     * @param {number | null} [skip] 
     * @param {number | null} [limit] 
     * @param {string | null} [updatedAfter] 
     * @param {string | null} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    public listResellerUserInvitesV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig) {
        return ResellerUserApiFp(this.configuration).listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all users under the user\'s organization
     * @summary List Reseller Users V1
     * @param {string | null} [searchBy] 
     * @param {string | null} [searchValue] 
     * @param {string | null} [status] 
     * @param {string | null} [sortBy] 
     * @param {SortOrder | null} [sortOrder] 
     * @param {number | null} [skip] 
     * @param {number | null} [limit] 
     * @param {string | null} [updatedAfter] 
     * @param {string | null} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    public listResellerUsersV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig) {
        return ResellerUserApiFp(this.configuration).listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a new user to an organization or resend invite to the user if the user is already invited
     * @summary Invite Users V1
     * @param {GuestInput} guestInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    public sendResellerUserInviteV1(guestInput: GuestInput, options?: AxiosRequestConfig) {
        return ResellerUserApiFp(this.configuration).sendResellerUserInviteV1(guestInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user details
     * @summary Update Reseller User V1
     * @param {string} userId 
     * @param {UserPayload} userPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerUserApi
     */
    public updateResellerUserV1(userId: string, userPayload: UserPayload, options?: AxiosRequestConfig) {
        return ResellerUserApiFp(this.configuration).updateResellerUserV1(userId, userPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SparrApi - axios parameter creator
 * @export
 */
export const SparrApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a module attempt for a user
         * @summary Add Module Attempt
         * @param {string} moduleId 
         * @param {UserModuleAttemptCore} userModuleAttemptCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addModuleAttemptV1: async (moduleId: string, userModuleAttemptCore: UserModuleAttemptCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('addModuleAttemptV1', 'moduleId', moduleId)
            // verify required parameter 'userModuleAttemptCore' is not null or undefined
            assertParamExists('addModuleAttemptV1', 'userModuleAttemptCore', userModuleAttemptCore)
            const localVarPath = `/v1/sparr/courses/modules/{module_id}/attempts`
                .replace(`{${"module_id"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userModuleAttemptCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign a course to a user
         * @summary Assign Course
         * @param {string} courseId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignCourseV1: async (courseId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('assignCourseV1', 'courseId', courseId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('assignCourseV1', 'userId', userId)
            const localVarPath = `/v1/sparr/courses/{course_id}/assign/{user_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attach a tag to an entity
         * @summary Attach Tag
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {TagCreate} tagCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost: async (entityType: string, entityId: string, tagCreate: TagCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityType' is not null or undefined
            assertParamExists('attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost', 'entityType', entityType)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost', 'entityId', entityId)
            // verify required parameter 'tagCreate' is not null or undefined
            assertParamExists('attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost', 'tagCreate', tagCreate)
            const localVarPath = `/v1/sparr/entity-tags/{entity_type}/{entity_id}/tags`
                .replace(`{${"entity_type"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a checkout session for a price
         * @summary Create Checkout Session For Price
         * @param {string} priceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForPriceV1: async (priceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'priceId' is not null or undefined
            assertParamExists('createCheckoutSessionForPriceV1', 'priceId', priceId)
            const localVarPath = `/v1/sparr/pricing/{price_id}/checkout`
                .replace(`{${"price_id"}}`, encodeURIComponent(String(priceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseV1: async (courseRequest: CourseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseRequest' is not null or undefined
            assertParamExists('createCourseV1', 'courseRequest', courseRequest)
            const localVarPath = `/v1/sparr/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a customer portal for customer
         * @summary Create Customer Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPortalV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/customers/portal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Feedback Comment
         * @param {FeedbackCommentCore} feedbackCommentCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedbackCommentV1: async (feedbackCommentCore: FeedbackCommentCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackCommentCore' is not null or undefined
            assertParamExists('createFeedbackCommentV1', 'feedbackCommentCore', feedbackCommentCore)
            const localVarPath = `/v1/sparr/feedback-comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(feedbackCommentCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new feedback
         * @summary Create Feedback
         * @param {FeedbackCore} feedbackCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedbackV1: async (feedbackCore: FeedbackCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackCore' is not null or undefined
            assertParamExists('createFeedbackV1', 'feedbackCore', feedbackCore)
            const localVarPath = `/v1/sparr/feedbacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(feedbackCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new goals collection
         * @summary Create Goals
         * @param {GoalCoreInput} goalCoreInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoalsV1: async (goalCoreInput: GoalCoreInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalCoreInput' is not null or undefined
            assertParamExists('createGoalsV1', 'goalCoreInput', goalCoreInput)
            const localVarPath = `/v1/sparr/goals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(goalCoreInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonaV1: async (personaCore: PersonaCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaCore' is not null or undefined
            assertParamExists('createPersonaV1', 'personaCore', personaCore)
            const localVarPath = `/v1/sparr/personas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new evaluator
         * @summary Create Evaluator
         * @param {EvaluatorCore} evaluatorCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPostCallEvaluationParamsV1: async (evaluatorCore: EvaluatorCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'evaluatorCore' is not null or undefined
            assertParamExists('createPostCallEvaluationParamsV1', 'evaluatorCore', evaluatorCore)
            const localVarPath = `/v1/sparr/evaluators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(evaluatorCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenarioV1: async (createScenarioRequest: CreateScenarioRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createScenarioRequest' is not null or undefined
            assertParamExists('createScenarioV1', 'createScenarioRequest', createScenarioRequest)
            const localVarPath = `/v1/sparr/scenarios`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createScenarioRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new tracker
         * @summary Create Tracker
         * @param {TrackerCore} trackerCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackerV1: async (trackerCore: TrackerCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackerCore' is not null or undefined
            assertParamExists('createTrackerV1', 'trackerCore', trackerCore)
            const localVarPath = `/v1/sparr/trackers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackerCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseV1: async (courseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('deleteCourseV1', 'courseId', courseId)
            const localVarPath = `/v1/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete evaluator
         * @summary Delete Evaluator
         * @param {string} paramsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvaluatorV1: async (paramsId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paramsId' is not null or undefined
            assertParamExists('deleteEvaluatorV1', 'paramsId', paramsId)
            const localVarPath = `/v1/sparr/evaluators/{params_id}`
                .replace(`{${"params_id"}}`, encodeURIComponent(String(paramsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Feedback Comment
         * @param {string} feedbackCommentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedbackCommentV1: async (feedbackCommentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackCommentId' is not null or undefined
            assertParamExists('deleteFeedbackCommentV1', 'feedbackCommentId', feedbackCommentId)
            const localVarPath = `/v1/sparr/feedback-comments/{feedback_comment_id}`
                .replace(`{${"feedback_comment_id"}}`, encodeURIComponent(String(feedbackCommentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a feedback
         * @summary Delete Feedback
         * @param {string} feedbackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedbackV1: async (feedbackId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackId' is not null or undefined
            assertParamExists('deleteFeedbackV1', 'feedbackId', feedbackId)
            const localVarPath = `/v1/sparr/feedbacks/{feedback_id}`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a file
         * @summary Delete File
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1: async (fileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('deleteFileV1', 'fileId', fileId)
            const localVarPath = `/v1/sparr/files/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a goals collection
         * @summary Delete Goals
         * @param {string} goalsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoalsV1: async (goalsId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalsId' is not null or undefined
            assertParamExists('deleteGoalsV1', 'goalsId', goalsId)
            const localVarPath = `/v1/sparr/goals/{goals_id}`
                .replace(`{${"goals_id"}}`, encodeURIComponent(String(goalsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonaV1: async (personaId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('deletePersonaV1', 'personaId', personaId)
            const localVarPath = `/v1/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioV1: async (scenarioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deleteScenarioV1', 'scenarioId', scenarioId)
            const localVarPath = `/v1/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a tracker
         * @summary Delete Tracker
         * @param {string} trackerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackerV1: async (trackerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackerId' is not null or undefined
            assertParamExists('deleteTrackerV1', 'trackerId', trackerId)
            const localVarPath = `/v1/sparr/trackers/{tracker_id}`
                .replace(`{${"tracker_id"}}`, encodeURIComponent(String(trackerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detach a tag from an entity
         * @summary Detach Tag
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {string} tagName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete: async (entityType: string, entityId: string, tagName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityType' is not null or undefined
            assertParamExists('detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete', 'entityType', entityType)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete', 'entityId', entityId)
            // verify required parameter 'tagName' is not null or undefined
            assertParamExists('detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete', 'tagName', tagName)
            const localVarPath = `/v1/sparr/entity-tags/{entity_type}/{entity_id}/tags/{tag_name}`
                .replace(`{${"entity_type"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Evaluate a feedback
         * @summary Evaluate Feedback V1
         * @param {Sparrv1EvaluateFeedbackRequest} sparrv1EvaluateFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateFeedbackV1: async (sparrv1EvaluateFeedbackRequest: Sparrv1EvaluateFeedbackRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sparrv1EvaluateFeedbackRequest' is not null or undefined
            assertParamExists('evaluateFeedbackV1', 'sparrv1EvaluateFeedbackRequest', sparrv1EvaluateFeedbackRequest)
            const localVarPath = `/v1/sparr/evaluate-feedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sparrv1EvaluateFeedbackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate evaluator data from files and/or existing core components
         * @summary Generate Evaluator
         * @param {FlexibleGenerationRequest} flexibleGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEvaluatorV1: async (flexibleGenerationRequest: FlexibleGenerationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flexibleGenerationRequest' is not null or undefined
            assertParamExists('generateEvaluatorV1', 'flexibleGenerationRequest', flexibleGenerationRequest)
            const localVarPath = `/v1/sparr/evaluators/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flexibleGenerationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate feedback from call recording and user data
         * @summary Generate Feedback
         * @param {GenerateFeedbackRequest} generateFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateFeedbackV1: async (generateFeedbackRequest: GenerateFeedbackRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateFeedbackRequest' is not null or undefined
            assertParamExists('generateFeedbackV1', 'generateFeedbackRequest', generateFeedbackRequest)
            const localVarPath = `/v1/sparr/feedbacks/generate_feedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateFeedbackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseV1: async (courseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourseV1', 'courseId', courseId)
            const localVarPath = `/v1/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get credits
         * @summary Get Credits V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditsV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/credits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all entities of a type that have a specific tag
         * @summary Get Entities By Tag
         * @param {string} entityType 
         * @param {string} tagName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet: async (entityType: string, tagName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityType' is not null or undefined
            assertParamExists('getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet', 'entityType', entityType)
            // verify required parameter 'tagName' is not null or undefined
            assertParamExists('getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet', 'tagName', tagName)
            const localVarPath = `/v1/sparr/entity-tags/{entity_type}/by-tag/{tag_name}`
                .replace(`{${"entity_type"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all tags for an entity
         * @summary Get Entity Tags
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet: async (entityType: string, entityId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityType' is not null or undefined
            assertParamExists('getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet', 'entityType', entityType)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet', 'entityId', entityId)
            const localVarPath = `/v1/sparr/entity-tags/{entity_type}/{entity_id}/tags`
                .replace(`{${"entity_type"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
         * @summary Get Evaluator By Id
         * @param {string} paramsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluatorV1: async (paramsId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paramsId' is not null or undefined
            assertParamExists('getEvaluatorV1', 'paramsId', paramsId)
            const localVarPath = `/v1/sparr/evaluators/{params_id}`
                .replace(`{${"params_id"}}`, encodeURIComponent(String(paramsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Feedback Comment By Id
         * @param {string} feedbackCommentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedbackCommentV1: async (feedbackCommentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackCommentId' is not null or undefined
            assertParamExists('getFeedbackCommentV1', 'feedbackCommentId', feedbackCommentId)
            const localVarPath = `/v1/sparr/feedback-comments/{feedback_comment_id}`
                .replace(`{${"feedback_comment_id"}}`, encodeURIComponent(String(feedbackCommentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific feedback by ID
         * @summary Get Feedback
         * @param {string} feedbackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedbackV1: async (feedbackId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackId' is not null or undefined
            assertParamExists('getFeedbackV1', 'feedbackId', feedbackId)
            const localVarPath = `/v1/sparr/feedbacks/{feedback_id}`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific file by ID
         * @summary Get File
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileV1: async (fileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFileV1', 'fileId', fileId)
            const localVarPath = `/v1/sparr/files/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
         * @summary Get Goals By Id
         * @param {string} goalsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalsV1: async (goalsId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalsId' is not null or undefined
            assertParamExists('getGoalsV1', 'goalsId', goalsId)
            const localVarPath = `/v1/sparr/goals/{goals_id}`
                .replace(`{${"goals_id"}}`, encodeURIComponent(String(goalsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get metrics for a given batch of metrics requests
         * @summary Get Metrics
         * @param {SparrModelsAnalyticsBatchMetricsRequests} sparrModelsAnalyticsBatchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1: async (sparrModelsAnalyticsBatchMetricsRequests: SparrModelsAnalyticsBatchMetricsRequests, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sparrModelsAnalyticsBatchMetricsRequests' is not null or undefined
            assertParamExists('getMetricsV1', 'sparrModelsAnalyticsBatchMetricsRequests', sparrModelsAnalyticsBatchMetricsRequests)
            const localVarPath = `/v1/sparr/feedbacks/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sparrModelsAnalyticsBatchMetricsRequests, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific persona by ID that is either directly owned or available through reseller course assignments
         * @summary Get Persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaV1: async (personaId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('getPersonaV1', 'personaId', personaId)
            const localVarPath = `/v1/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pricing
         * @summary Get Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/pricing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
         * @summary Get Scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioV1: async (scenarioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('getScenarioV1', 'scenarioId', scenarioId)
            const localVarPath = `/v1/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
         * @summary Get Tracker By Id
         * @param {string} trackerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackerV1: async (trackerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackerId' is not null or undefined
            assertParamExists('getTrackerV1', 'trackerId', trackerId)
            const localVarPath = `/v1/sparr/trackers/{tracker_id}`
                .replace(`{${"tracker_id"}}`, encodeURIComponent(String(trackerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search personas by name, title and company
         * @summary Get User Stats
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStatsV1: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserStatsV1', 'userId', userId)
            const localVarPath = `/v1/sparr/user_stats/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLinkedinPersonaV1: async (linkedinUrl: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'linkedinUrl' is not null or undefined
            assertParamExists('importLinkedinPersonaV1', 'linkedinUrl', linkedinUrl)
            const localVarPath = `/v1/sparr/personas/import-linkedin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (linkedinUrl !== undefined) {
                localVarQueryParameter['linkedin_url'] = linkedinUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string | null} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoursesV1: async (skip?: number, limit?: number, status?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all evaluator that are either directly owned or available through reseller course assignments
         * @summary Get Evaluator
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvaluatorV1: async (skip?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/evaluators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Feedback Comments
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string | null} [feedbackId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeedbackCommentsV1: async (skip?: number, limit?: number, feedbackId?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/feedback-comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (feedbackId !== undefined) {
                localVarQueryParameter['feedback_id'] = feedbackId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all feedbacks
         * @summary Get Feedbacks
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string | null} [fromDate] Start date for filtering feedbacks
         * @param {string | null} [toDate] End date for filtering feedbacks
         * @param {string | null} [userFilter] User filter for filtering feedbacks. Comma separated list of user ids.
         * @param {string | null} [statusFilter] Status filter for filtering feedbacks. Comma separated list of statuses.
         * @param {string | null} [scenarioFilter] Scenario filter for filtering feedbacks. Comma separated list of scenario ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeedbacksV1: async (skip?: number, limit?: number, fromDate?: string | null, toDate?: string | null, userFilter?: string | null, statusFilter?: string | null, scenarioFilter?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/feedbacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }

            if (userFilter !== undefined) {
                localVarQueryParameter['user_filter'] = userFilter;
            }

            if (statusFilter !== undefined) {
                localVarQueryParameter['status_filter'] = statusFilter;
            }

            if (scenarioFilter !== undefined) {
                localVarQueryParameter['scenario_filter'] = scenarioFilter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all goals that are either directly owned or available through reseller course assignments
         * @summary Get Goals
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGoalsV1: async (skip?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/goals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all personas that are either directly owned or available through reseller course assignments
         * @summary Get Personas
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [tags] Filter personas by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonasV1: async (skip?: number, limit?: number, tags?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/personas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all scenarios that are either directly owned or available through reseller course assignments
         * @summary Get Scenarios
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [tags] Filter scenarios by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenariosV1: async (skip?: number, limit?: number, tags?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/scenarios`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all trackers that are either directly owned or available through reseller course assignments
         * @summary Get Trackers
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrackerV1: async (skip?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/trackers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all course assignments for a user with analytics
         * @summary Get User Assignments
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAssignmentsV1: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserAssignmentsV1', 'userId', userId)
            const localVarPath = `/v1/sparr/courses/users/{user_id}/assignments`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all module attempts with module information for a user in a specific course
         * @summary Get User Course Attempts
         * @param {string} courseId 
         * @param {string} userId 
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCourseAttemptsV1: async (courseId: string, userId: string, skip?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('listUserCourseAttemptsV1', 'courseId', courseId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserCourseAttemptsV1', 'userId', userId)
            const localVarPath = `/v1/sparr/courses/{course_id}/attempts/users/{user_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all module attempts for a user
         * @summary Get User Module Attempts
         * @param {string} moduleId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserModuleAttemptsV1: async (moduleId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('listUserModuleAttemptsV1', 'moduleId', moduleId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserModuleAttemptsV1', 'userId', userId)
            const localVarPath = `/v1/sparr/courses/modules/{module_id}/attempts/{user_id}`
                .replace(`{${"module_id"}}`, encodeURIComponent(String(moduleId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke a course from a user
         * @summary Revoke Course
         * @param {string} courseId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCourseV1: async (courseId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('revokeCourseV1', 'courseId', courseId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('revokeCourseV1', 'userId', userId)
            const localVarPath = `/v1/sparr/courses/{course_id}/assign/{user_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search goals by name and description
         * @summary Search Goals
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGoalsV1: async (query: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('searchGoalsV1', 'query', query)
            const localVarPath = `/v1/sparr/goals/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonasV1: async (query: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('searchPersonasV1', 'query', query)
            const localVarPath = `/v1/sparr/personas/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenariosV1: async (query: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('searchScenariosV1', 'query', query)
            const localVarPath = `/v1/sparr/scenarios/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search trackers by name and description
         * @summary Search Tracker
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTrackerV1: async (query: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('searchTrackerV1', 'query', query)
            const localVarPath = `/v1/sparr/trackers/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Heart Beat check to check the health of Sparr Service
         * @summary Heart Beat Status Of Sparr Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusSparrStatusGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sparr/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update course completion status
         * @summary Update Course Completion Status
         * @param {string} courseId 
         * @param {string} userId 
         * @param {CourseCompletionStatus} completionStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseCompletionStatusV1: async (courseId: string, userId: string, completionStatus: CourseCompletionStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('updateCourseCompletionStatusV1', 'courseId', courseId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateCourseCompletionStatusV1', 'userId', userId)
            // verify required parameter 'completionStatus' is not null or undefined
            assertParamExists('updateCourseCompletionStatusV1', 'completionStatus', completionStatus)
            const localVarPath = `/v1/sparr/courses/{course_id}/assign/{user_id}/status`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (completionStatus !== undefined) {
                localVarQueryParameter['completionStatus'] = completionStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId 
         * @param {CourseUpdateRequest} courseUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseV1: async (courseId: string, courseUpdateRequest: CourseUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('updateCourseV1', 'courseId', courseId)
            // verify required parameter 'courseUpdateRequest' is not null or undefined
            assertParamExists('updateCourseV1', 'courseUpdateRequest', courseUpdateRequest)
            const localVarPath = `/v1/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update evaluator
         * @summary Update Evaluator
         * @param {string} paramsId 
         * @param {EvaluatorCore} evaluatorCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvaluatorV1: async (paramsId: string, evaluatorCore: EvaluatorCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paramsId' is not null or undefined
            assertParamExists('updateEvaluatorV1', 'paramsId', paramsId)
            // verify required parameter 'evaluatorCore' is not null or undefined
            assertParamExists('updateEvaluatorV1', 'evaluatorCore', evaluatorCore)
            const localVarPath = `/v1/sparr/evaluators/{params_id}`
                .replace(`{${"params_id"}}`, encodeURIComponent(String(paramsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(evaluatorCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Feedback Comment
         * @param {string} feedbackCommentId 
         * @param {FeedbackCommentCore} feedbackCommentCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedbackCommentV1: async (feedbackCommentId: string, feedbackCommentCore: FeedbackCommentCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackCommentId' is not null or undefined
            assertParamExists('updateFeedbackCommentV1', 'feedbackCommentId', feedbackCommentId)
            // verify required parameter 'feedbackCommentCore' is not null or undefined
            assertParamExists('updateFeedbackCommentV1', 'feedbackCommentCore', feedbackCommentCore)
            const localVarPath = `/v1/sparr/feedback-comments/{feedback_comment_id}`
                .replace(`{${"feedback_comment_id"}}`, encodeURIComponent(String(feedbackCommentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(feedbackCommentCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a feedback
         * @summary Update Feedback
         * @param {string} feedbackId 
         * @param {FeedbackCore} feedbackCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedbackV1: async (feedbackId: string, feedbackCore: FeedbackCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackId' is not null or undefined
            assertParamExists('updateFeedbackV1', 'feedbackId', feedbackId)
            // verify required parameter 'feedbackCore' is not null or undefined
            assertParamExists('updateFeedbackV1', 'feedbackCore', feedbackCore)
            const localVarPath = `/v1/sparr/feedbacks/{feedback_id}`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(feedbackCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a goals collection
         * @summary Update Goals
         * @param {string} goalsId 
         * @param {GoalCoreInput} goalCoreInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalsV1: async (goalsId: string, goalCoreInput: GoalCoreInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalsId' is not null or undefined
            assertParamExists('updateGoalsV1', 'goalsId', goalsId)
            // verify required parameter 'goalCoreInput' is not null or undefined
            assertParamExists('updateGoalsV1', 'goalCoreInput', goalCoreInput)
            const localVarPath = `/v1/sparr/goals/{goals_id}`
                .replace(`{${"goals_id"}}`, encodeURIComponent(String(goalsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(goalCoreInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId 
         * @param {PersonaCore} personaCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonaV1: async (personaId: string, personaCore: PersonaCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('updatePersonaV1', 'personaId', personaId)
            // verify required parameter 'personaCore' is not null or undefined
            assertParamExists('updatePersonaV1', 'personaCore', personaCore)
            const localVarPath = `/v1/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId 
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenarioV1: async (scenarioId: string, createScenarioRequest: CreateScenarioRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('updateScenarioV1', 'scenarioId', scenarioId)
            // verify required parameter 'createScenarioRequest' is not null or undefined
            assertParamExists('updateScenarioV1', 'createScenarioRequest', createScenarioRequest)
            const localVarPath = `/v1/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createScenarioRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a tracker
         * @summary Update Tracker
         * @param {string} trackerId 
         * @param {TrackerCore} trackerCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackerV1: async (trackerId: string, trackerCore: TrackerCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackerId' is not null or undefined
            assertParamExists('updateTrackerV1', 'trackerId', trackerId)
            // verify required parameter 'trackerCore' is not null or undefined
            assertParamExists('updateTrackerV1', 'trackerCore', trackerCore)
            const localVarPath = `/v1/sparr/trackers/{tracker_id}`
                .replace(`{${"tracker_id"}}`, encodeURIComponent(String(trackerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackerCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload multiple files and create file records. Maximum 5 files per request, each file max 10MB.
         * @summary Upload Files
         * @param {Array<File>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilesV1: async (files: Array<File>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'files' is not null or undefined
            assertParamExists('uploadFilesV1', 'files', files)
            const localVarPath = `/v1/sparr/files/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SparrApi - functional programming interface
 * @export
 */
export const SparrApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SparrApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a module attempt for a user
         * @summary Add Module Attempt
         * @param {string} moduleId 
         * @param {UserModuleAttemptCore} userModuleAttemptCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addModuleAttemptV1(moduleId: string, userModuleAttemptCore: UserModuleAttemptCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModuleAttempt>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addModuleAttemptV1(moduleId, userModuleAttemptCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.addModuleAttemptV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign a course to a user
         * @summary Assign Course
         * @param {string} courseId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignCourseV1(courseId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCourseAssignment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignCourseV1(courseId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.assignCourseV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Attach a tag to an entity
         * @summary Attach Tag
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {TagCreate} tagCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost(entityType: string, entityId: string, tagCreate: TagCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost(entityType, entityId, tagCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a checkout session for a price
         * @summary Create Checkout Session For Price
         * @param {string} priceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckoutSessionForPriceV1(priceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheckoutSessionForPriceV1(priceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.createCheckoutSessionForPriceV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCourseV1(courseRequest: CourseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCourseV1(courseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.createCourseV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a customer portal for customer
         * @summary Create Customer Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomerPortalV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomerPortalV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.createCustomerPortalV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Feedback Comment
         * @param {FeedbackCommentCore} feedbackCommentCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeedbackCommentV1(feedbackCommentCore: FeedbackCommentCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrDbModelsFeedbackComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFeedbackCommentV1(feedbackCommentCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.createFeedbackCommentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new feedback
         * @summary Create Feedback
         * @param {FeedbackCore} feedbackCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeedbackV1(feedbackCore: FeedbackCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Feedback>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFeedbackV1(feedbackCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.createFeedbackV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new goals collection
         * @summary Create Goals
         * @param {GoalCoreInput} goalCoreInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGoalsV1(goalCoreInput: GoalCoreInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrDbModelsGoal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGoalsV1(goalCoreInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.createGoalsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPersonaV1(personaCore: PersonaCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPersonaV1(personaCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.createPersonaV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new evaluator
         * @summary Create Evaluator
         * @param {EvaluatorCore} evaluatorCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPostCallEvaluationParamsV1(evaluatorCore: EvaluatorCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Evaluator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPostCallEvaluationParamsV1(evaluatorCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.createPostCallEvaluationParamsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScenarioV1(createScenarioRequest: CreateScenarioRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScenarioV1(createScenarioRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.createScenarioV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new tracker
         * @summary Create Tracker
         * @param {TrackerCore} trackerCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTrackerV1(trackerCore: TrackerCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tracker>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTrackerV1(trackerCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.createTrackerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCourseV1(courseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCourseV1(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.deleteCourseV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete evaluator
         * @summary Delete Evaluator
         * @param {string} paramsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEvaluatorV1(paramsId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvaluatorV1(paramsId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.deleteEvaluatorV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Feedback Comment
         * @param {string} feedbackCommentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFeedbackCommentV1(feedbackCommentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFeedbackCommentV1(feedbackCommentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.deleteFeedbackCommentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a feedback
         * @summary Delete Feedback
         * @param {string} feedbackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFeedbackV1(feedbackId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFeedbackV1(feedbackId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.deleteFeedbackV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a file
         * @summary Delete File
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileV1(fileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFileV1(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.deleteFileV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a goals collection
         * @summary Delete Goals
         * @param {string} goalsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGoalsV1(goalsId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGoalsV1(goalsId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.deleteGoalsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePersonaV1(personaId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersonaV1(personaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.deletePersonaV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScenarioV1(scenarioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScenarioV1(scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.deleteScenarioV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a tracker
         * @summary Delete Tracker
         * @param {string} trackerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTrackerV1(trackerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTrackerV1(trackerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.deleteTrackerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Detach a tag from an entity
         * @summary Detach Tag
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {string} tagName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete(entityType: string, entityId: string, tagName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete(entityType, entityId, tagName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Evaluate a feedback
         * @summary Evaluate Feedback V1
         * @param {Sparrv1EvaluateFeedbackRequest} sparrv1EvaluateFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluateFeedbackV1(sparrv1EvaluateFeedbackRequest: Sparrv1EvaluateFeedbackRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluateFeedbackV1(sparrv1EvaluateFeedbackRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.evaluateFeedbackV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate evaluator data from files and/or existing core components
         * @summary Generate Evaluator
         * @param {FlexibleGenerationRequest} flexibleGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateEvaluatorV1(flexibleGenerationRequest: FlexibleGenerationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CombinedEvaluatorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateEvaluatorV1(flexibleGenerationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.generateEvaluatorV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate feedback from call recording and user data
         * @summary Generate Feedback
         * @param {GenerateFeedbackRequest} generateFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateFeedbackV1(generateFeedbackRequest: GenerateFeedbackRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Feedback>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateFeedbackV1(generateFeedbackRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.generateFeedbackV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseV1(courseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseV1(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.getCourseV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get credits
         * @summary Get Credits V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCreditsV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Credit>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCreditsV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.getCreditsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all entities of a type that have a specific tag
         * @summary Get Entities By Tag
         * @param {string} entityType 
         * @param {string} tagName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet(entityType: string, tagName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntityTag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet(entityType, tagName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all tags for an entity
         * @summary Get Entity Tags
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet(entityType: string, entityId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntityTag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet(entityType, entityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
         * @summary Get Evaluator By Id
         * @param {string} paramsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvaluatorV1(paramsId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Evaluator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvaluatorV1(paramsId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.getEvaluatorV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Feedback Comment By Id
         * @param {string} feedbackCommentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeedbackCommentV1(feedbackCommentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrDbModelsFeedbackComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeedbackCommentV1(feedbackCommentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.getFeedbackCommentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific feedback by ID
         * @summary Get Feedback
         * @param {string} feedbackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeedbackV1(feedbackId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Feedback>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeedbackV1(feedbackId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.getFeedbackV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific file by ID
         * @summary Get File
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileV1(fileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileV1(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.getFileV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
         * @summary Get Goals By Id
         * @param {string} goalsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGoalsV1(goalsId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrDbModelsGoal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGoalsV1(goalsId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.getGoalsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get metrics for a given batch of metrics requests
         * @summary Get Metrics
         * @param {SparrModelsAnalyticsBatchMetricsRequests} sparrModelsAnalyticsBatchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests: SparrModelsAnalyticsBatchMetricsRequests, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsAnalyticsBatchMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.getMetricsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific persona by ID that is either directly owned or available through reseller course assignments
         * @summary Get Persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonaV1(personaId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonaV1(personaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.getPersonaV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pricing
         * @summary Get Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricingV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Price>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricingV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.getPricingV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
         * @summary Get Scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenarioV1(scenarioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioV1(scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.getScenarioV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
         * @summary Get Tracker By Id
         * @param {string} trackerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrackerV1(trackerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tracker>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrackerV1(trackerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.getTrackerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search personas by name, title and company
         * @summary Get User Stats
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserStatsV1(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserStatsV1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.getUserStatsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importLinkedinPersonaV1(linkedinUrl: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importLinkedinPersonaV1(linkedinUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.importLinkedinPersonaV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string | null} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCoursesV1(skip?: number, limit?: number, status?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCoursesV1(skip, limit, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.listCoursesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all evaluator that are either directly owned or available through reseller course assignments
         * @summary Get Evaluator
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEvaluatorV1(skip?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Evaluator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEvaluatorV1(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.listEvaluatorV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Feedback Comments
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string | null} [feedbackId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFeedbackCommentsV1(skip?: number, limit?: number, feedbackId?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SparrDbModelsFeedbackComment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFeedbackCommentsV1(skip, limit, feedbackId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.listFeedbackCommentsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all feedbacks
         * @summary Get Feedbacks
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string | null} [fromDate] Start date for filtering feedbacks
         * @param {string | null} [toDate] End date for filtering feedbacks
         * @param {string | null} [userFilter] User filter for filtering feedbacks. Comma separated list of user ids.
         * @param {string | null} [statusFilter] Status filter for filtering feedbacks. Comma separated list of statuses.
         * @param {string | null} [scenarioFilter] Scenario filter for filtering feedbacks. Comma separated list of scenario ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFeedbacksV1(skip?: number, limit?: number, fromDate?: string | null, toDate?: string | null, userFilter?: string | null, statusFilter?: string | null, scenarioFilter?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Feedback>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFeedbacksV1(skip, limit, fromDate, toDate, userFilter, statusFilter, scenarioFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.listFeedbacksV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all goals that are either directly owned or available through reseller course assignments
         * @summary Get Goals
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGoalsV1(skip?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SparrDbModelsGoal>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGoalsV1(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.listGoalsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all personas that are either directly owned or available through reseller course assignments
         * @summary Get Personas
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [tags] Filter personas by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPersonasV1(skip?: number, limit?: number, tags?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Persona>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPersonasV1(skip, limit, tags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.listPersonasV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all scenarios that are either directly owned or available through reseller course assignments
         * @summary Get Scenarios
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [tags] Filter scenarios by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScenariosV1(skip?: number, limit?: number, tags?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScenarioResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScenariosV1(skip, limit, tags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.listScenariosV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all trackers that are either directly owned or available through reseller course assignments
         * @summary Get Trackers
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTrackerV1(skip?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tracker>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTrackerV1(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.listTrackerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all course assignments for a user with analytics
         * @summary Get User Assignments
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserAssignmentsV1(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserCourseAssignmentAnalyticsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserAssignmentsV1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.listUserAssignmentsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all module attempts with module information for a user in a specific course
         * @summary Get User Course Attempts
         * @param {string} courseId 
         * @param {string} userId 
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserCourseAttemptsV1(courseId: string, userId: string, skip?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserModuleAttemptResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserCourseAttemptsV1(courseId, userId, skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.listUserCourseAttemptsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all module attempts for a user
         * @summary Get User Module Attempts
         * @param {string} moduleId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserModuleAttemptsV1(moduleId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserModuleAttemptResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserModuleAttemptsV1(moduleId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.listUserModuleAttemptsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke a course from a user
         * @summary Revoke Course
         * @param {string} courseId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeCourseV1(courseId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeCourseV1(courseId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.revokeCourseV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search goals by name and description
         * @summary Search Goals
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchGoalsV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoalsSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchGoalsV1(query, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.searchGoalsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPersonasV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPersonasV1(query, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.searchPersonasV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchScenariosV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchScenariosV1(query, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.searchScenariosV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search trackers by name and description
         * @summary Search Tracker
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTrackerV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackerSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTrackerV1(query, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.searchTrackerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Heart Beat check to check the health of Sparr Service
         * @summary Heart Beat Status Of Sparr Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusSparrStatusGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusSparrStatusGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.statusSparrStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update course completion status
         * @summary Update Course Completion Status
         * @param {string} courseId 
         * @param {string} userId 
         * @param {CourseCompletionStatus} completionStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCourseCompletionStatusV1(courseId: string, userId: string, completionStatus: CourseCompletionStatus, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCourseAssignment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCourseCompletionStatusV1(courseId, userId, completionStatus, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.updateCourseCompletionStatusV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId 
         * @param {CourseUpdateRequest} courseUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCourseV1(courseId: string, courseUpdateRequest: CourseUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCourseV1(courseId, courseUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.updateCourseV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update evaluator
         * @summary Update Evaluator
         * @param {string} paramsId 
         * @param {EvaluatorCore} evaluatorCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvaluatorV1(paramsId: string, evaluatorCore: EvaluatorCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Evaluator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvaluatorV1(paramsId, evaluatorCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.updateEvaluatorV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Feedback Comment
         * @param {string} feedbackCommentId 
         * @param {FeedbackCommentCore} feedbackCommentCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeedbackCommentV1(feedbackCommentId: string, feedbackCommentCore: FeedbackCommentCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrDbModelsFeedbackComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeedbackCommentV1(feedbackCommentId, feedbackCommentCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.updateFeedbackCommentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a feedback
         * @summary Update Feedback
         * @param {string} feedbackId 
         * @param {FeedbackCore} feedbackCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeedbackV1(feedbackId: string, feedbackCore: FeedbackCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Feedback>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeedbackV1(feedbackId, feedbackCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.updateFeedbackV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a goals collection
         * @summary Update Goals
         * @param {string} goalsId 
         * @param {GoalCoreInput} goalCoreInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGoalsV1(goalsId: string, goalCoreInput: GoalCoreInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrDbModelsGoal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGoalsV1(goalsId, goalCoreInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.updateGoalsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId 
         * @param {PersonaCore} personaCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePersonaV1(personaId: string, personaCore: PersonaCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePersonaV1(personaId, personaCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.updatePersonaV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId 
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScenarioV1(scenarioId: string, createScenarioRequest: CreateScenarioRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScenarioV1(scenarioId, createScenarioRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.updateScenarioV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a tracker
         * @summary Update Tracker
         * @param {string} trackerId 
         * @param {TrackerCore} trackerCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTrackerV1(trackerId: string, trackerCore: TrackerCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tracker>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTrackerV1(trackerId, trackerCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.updateTrackerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload multiple files and create file records. Maximum 5 files per request, each file max 10MB.
         * @summary Upload Files
         * @param {Array<File>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFilesV1(files: Array<File>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFilesV1(files, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrApi.uploadFilesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SparrApi - factory interface
 * @export
 */
export const SparrApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SparrApiFp(configuration)
    return {
        /**
         * Add a module attempt for a user
         * @summary Add Module Attempt
         * @param {string} moduleId 
         * @param {UserModuleAttemptCore} userModuleAttemptCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addModuleAttemptV1(moduleId: string, userModuleAttemptCore: UserModuleAttemptCore, options?: AxiosRequestConfig): AxiosPromise<UserModuleAttempt> {
            return localVarFp.addModuleAttemptV1(moduleId, userModuleAttemptCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign a course to a user
         * @summary Assign Course
         * @param {string} courseId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignCourseV1(courseId: string, userId: string, options?: AxiosRequestConfig): AxiosPromise<UserCourseAssignment> {
            return localVarFp.assignCourseV1(courseId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Attach a tag to an entity
         * @summary Attach Tag
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {TagCreate} tagCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost(entityType: string, entityId: string, tagCreate: TagCreate, options?: AxiosRequestConfig): AxiosPromise<EntityTag> {
            return localVarFp.attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost(entityType, entityId, tagCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a checkout session for a price
         * @summary Create Checkout Session For Price
         * @param {string} priceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForPriceV1(priceId: string, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createCheckoutSessionForPriceV1(priceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseV1(courseRequest: CourseRequest, options?: AxiosRequestConfig): AxiosPromise<CourseResponse> {
            return localVarFp.createCourseV1(courseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a customer portal for customer
         * @summary Create Customer Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPortalV1(options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createCustomerPortalV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Feedback Comment
         * @param {FeedbackCommentCore} feedbackCommentCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedbackCommentV1(feedbackCommentCore: FeedbackCommentCore, options?: AxiosRequestConfig): AxiosPromise<SparrDbModelsFeedbackComment> {
            return localVarFp.createFeedbackCommentV1(feedbackCommentCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new feedback
         * @summary Create Feedback
         * @param {FeedbackCore} feedbackCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedbackV1(feedbackCore: FeedbackCore, options?: AxiosRequestConfig): AxiosPromise<Feedback> {
            return localVarFp.createFeedbackV1(feedbackCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new goals collection
         * @summary Create Goals
         * @param {GoalCoreInput} goalCoreInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoalsV1(goalCoreInput: GoalCoreInput, options?: AxiosRequestConfig): AxiosPromise<SparrDbModelsGoal> {
            return localVarFp.createGoalsV1(goalCoreInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonaV1(personaCore: PersonaCore, options?: AxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.createPersonaV1(personaCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new evaluator
         * @summary Create Evaluator
         * @param {EvaluatorCore} evaluatorCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPostCallEvaluationParamsV1(evaluatorCore: EvaluatorCore, options?: AxiosRequestConfig): AxiosPromise<Evaluator> {
            return localVarFp.createPostCallEvaluationParamsV1(evaluatorCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenarioV1(createScenarioRequest: CreateScenarioRequest, options?: AxiosRequestConfig): AxiosPromise<ScenarioResponse> {
            return localVarFp.createScenarioV1(createScenarioRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new tracker
         * @summary Create Tracker
         * @param {TrackerCore} trackerCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackerV1(trackerCore: TrackerCore, options?: AxiosRequestConfig): AxiosPromise<Tracker> {
            return localVarFp.createTrackerV1(trackerCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseV1(courseId: string, options?: AxiosRequestConfig): AxiosPromise<SparrModelsBaseBaseResponse> {
            return localVarFp.deleteCourseV1(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete evaluator
         * @summary Delete Evaluator
         * @param {string} paramsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvaluatorV1(paramsId: string, options?: AxiosRequestConfig): AxiosPromise<SparrModelsBaseBaseResponse> {
            return localVarFp.deleteEvaluatorV1(paramsId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Feedback Comment
         * @param {string} feedbackCommentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedbackCommentV1(feedbackCommentId: string, options?: AxiosRequestConfig): AxiosPromise<SparrModelsBaseBaseResponse> {
            return localVarFp.deleteFeedbackCommentV1(feedbackCommentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a feedback
         * @summary Delete Feedback
         * @param {string} feedbackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedbackV1(feedbackId: string, options?: AxiosRequestConfig): AxiosPromise<SparrModelsBaseBaseResponse> {
            return localVarFp.deleteFeedbackV1(feedbackId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a file
         * @summary Delete File
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1(fileId: string, options?: AxiosRequestConfig): AxiosPromise<SparrModelsBaseBaseResponse> {
            return localVarFp.deleteFileV1(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a goals collection
         * @summary Delete Goals
         * @param {string} goalsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoalsV1(goalsId: string, options?: AxiosRequestConfig): AxiosPromise<SparrModelsBaseBaseResponse> {
            return localVarFp.deleteGoalsV1(goalsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonaV1(personaId: string, options?: AxiosRequestConfig): AxiosPromise<SparrModelsBaseBaseResponse> {
            return localVarFp.deletePersonaV1(personaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioV1(scenarioId: string, options?: AxiosRequestConfig): AxiosPromise<SparrModelsBaseBaseResponse> {
            return localVarFp.deleteScenarioV1(scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a tracker
         * @summary Delete Tracker
         * @param {string} trackerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackerV1(trackerId: string, options?: AxiosRequestConfig): AxiosPromise<SparrModelsBaseBaseResponse> {
            return localVarFp.deleteTrackerV1(trackerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detach a tag from an entity
         * @summary Detach Tag
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {string} tagName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete(entityType: string, entityId: string, tagName: string, options?: AxiosRequestConfig): AxiosPromise<SparrModelsBaseBaseResponse> {
            return localVarFp.detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete(entityType, entityId, tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Evaluate a feedback
         * @summary Evaluate Feedback V1
         * @param {Sparrv1EvaluateFeedbackRequest} sparrv1EvaluateFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateFeedbackV1(sparrv1EvaluateFeedbackRequest: Sparrv1EvaluateFeedbackRequest, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.evaluateFeedbackV1(sparrv1EvaluateFeedbackRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate evaluator data from files and/or existing core components
         * @summary Generate Evaluator
         * @param {FlexibleGenerationRequest} flexibleGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEvaluatorV1(flexibleGenerationRequest: FlexibleGenerationRequest, options?: AxiosRequestConfig): AxiosPromise<CombinedEvaluatorResponse> {
            return localVarFp.generateEvaluatorV1(flexibleGenerationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate feedback from call recording and user data
         * @summary Generate Feedback
         * @param {GenerateFeedbackRequest} generateFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateFeedbackV1(generateFeedbackRequest: GenerateFeedbackRequest, options?: AxiosRequestConfig): AxiosPromise<Feedback> {
            return localVarFp.generateFeedbackV1(generateFeedbackRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseV1(courseId: string, options?: AxiosRequestConfig): AxiosPromise<CourseResponse> {
            return localVarFp.getCourseV1(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get credits
         * @summary Get Credits V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditsV1(options?: AxiosRequestConfig): AxiosPromise<Array<Credit>> {
            return localVarFp.getCreditsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all entities of a type that have a specific tag
         * @summary Get Entities By Tag
         * @param {string} entityType 
         * @param {string} tagName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet(entityType: string, tagName: string, options?: AxiosRequestConfig): AxiosPromise<Array<EntityTag>> {
            return localVarFp.getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet(entityType, tagName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all tags for an entity
         * @summary Get Entity Tags
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet(entityType: string, entityId: string, options?: AxiosRequestConfig): AxiosPromise<Array<EntityTag>> {
            return localVarFp.getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet(entityType, entityId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
         * @summary Get Evaluator By Id
         * @param {string} paramsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluatorV1(paramsId: string, options?: AxiosRequestConfig): AxiosPromise<Evaluator> {
            return localVarFp.getEvaluatorV1(paramsId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Feedback Comment By Id
         * @param {string} feedbackCommentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedbackCommentV1(feedbackCommentId: string, options?: AxiosRequestConfig): AxiosPromise<SparrDbModelsFeedbackComment> {
            return localVarFp.getFeedbackCommentV1(feedbackCommentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific feedback by ID
         * @summary Get Feedback
         * @param {string} feedbackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedbackV1(feedbackId: string, options?: AxiosRequestConfig): AxiosPromise<Feedback> {
            return localVarFp.getFeedbackV1(feedbackId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific file by ID
         * @summary Get File
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileV1(fileId: string, options?: AxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getFileV1(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
         * @summary Get Goals By Id
         * @param {string} goalsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalsV1(goalsId: string, options?: AxiosRequestConfig): AxiosPromise<SparrDbModelsGoal> {
            return localVarFp.getGoalsV1(goalsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get metrics for a given batch of metrics requests
         * @summary Get Metrics
         * @param {SparrModelsAnalyticsBatchMetricsRequests} sparrModelsAnalyticsBatchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests: SparrModelsAnalyticsBatchMetricsRequests, options?: AxiosRequestConfig): AxiosPromise<SparrModelsAnalyticsBatchMetricsResponse> {
            return localVarFp.getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific persona by ID that is either directly owned or available through reseller course assignments
         * @summary Get Persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaV1(personaId: string, options?: AxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.getPersonaV1(personaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pricing
         * @summary Get Pricing V1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingV1(options?: AxiosRequestConfig): AxiosPromise<Array<Price>> {
            return localVarFp.getPricingV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
         * @summary Get Scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioV1(scenarioId: string, options?: AxiosRequestConfig): AxiosPromise<ScenarioResponse> {
            return localVarFp.getScenarioV1(scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
         * @summary Get Tracker By Id
         * @param {string} trackerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackerV1(trackerId: string, options?: AxiosRequestConfig): AxiosPromise<Tracker> {
            return localVarFp.getTrackerV1(trackerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search personas by name, title and company
         * @summary Get User Stats
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStatsV1(userId: string, options?: AxiosRequestConfig): AxiosPromise<UserStats> {
            return localVarFp.getUserStatsV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLinkedinPersonaV1(linkedinUrl: string, options?: AxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.importLinkedinPersonaV1(linkedinUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string | null} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoursesV1(skip?: number, limit?: number, status?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<CourseResponse>> {
            return localVarFp.listCoursesV1(skip, limit, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all evaluator that are either directly owned or available through reseller course assignments
         * @summary Get Evaluator
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvaluatorV1(skip?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Evaluator>> {
            return localVarFp.listEvaluatorV1(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Feedback Comments
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string | null} [feedbackId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeedbackCommentsV1(skip?: number, limit?: number, feedbackId?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<SparrDbModelsFeedbackComment>> {
            return localVarFp.listFeedbackCommentsV1(skip, limit, feedbackId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all feedbacks
         * @summary Get Feedbacks
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string | null} [fromDate] Start date for filtering feedbacks
         * @param {string | null} [toDate] End date for filtering feedbacks
         * @param {string | null} [userFilter] User filter for filtering feedbacks. Comma separated list of user ids.
         * @param {string | null} [statusFilter] Status filter for filtering feedbacks. Comma separated list of statuses.
         * @param {string | null} [scenarioFilter] Scenario filter for filtering feedbacks. Comma separated list of scenario ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFeedbacksV1(skip?: number, limit?: number, fromDate?: string | null, toDate?: string | null, userFilter?: string | null, statusFilter?: string | null, scenarioFilter?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<Feedback>> {
            return localVarFp.listFeedbacksV1(skip, limit, fromDate, toDate, userFilter, statusFilter, scenarioFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all goals that are either directly owned or available through reseller course assignments
         * @summary Get Goals
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGoalsV1(skip?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<SparrDbModelsGoal>> {
            return localVarFp.listGoalsV1(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all personas that are either directly owned or available through reseller course assignments
         * @summary Get Personas
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [tags] Filter personas by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonasV1(skip?: number, limit?: number, tags?: string, options?: AxiosRequestConfig): AxiosPromise<Array<Persona>> {
            return localVarFp.listPersonasV1(skip, limit, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all scenarios that are either directly owned or available through reseller course assignments
         * @summary Get Scenarios
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [tags] Filter scenarios by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenariosV1(skip?: number, limit?: number, tags?: string, options?: AxiosRequestConfig): AxiosPromise<Array<ScenarioResponse>> {
            return localVarFp.listScenariosV1(skip, limit, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all trackers that are either directly owned or available through reseller course assignments
         * @summary Get Trackers
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrackerV1(skip?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Tracker>> {
            return localVarFp.listTrackerV1(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all course assignments for a user with analytics
         * @summary Get User Assignments
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAssignmentsV1(userId: string, options?: AxiosRequestConfig): AxiosPromise<Array<UserCourseAssignmentAnalyticsResponse>> {
            return localVarFp.listUserAssignmentsV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all module attempts with module information for a user in a specific course
         * @summary Get User Course Attempts
         * @param {string} courseId 
         * @param {string} userId 
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCourseAttemptsV1(courseId: string, userId: string, skip?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<UserModuleAttemptResponse>> {
            return localVarFp.listUserCourseAttemptsV1(courseId, userId, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all module attempts for a user
         * @summary Get User Module Attempts
         * @param {string} moduleId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserModuleAttemptsV1(moduleId: string, userId: string, options?: AxiosRequestConfig): AxiosPromise<Array<UserModuleAttemptResponse>> {
            return localVarFp.listUserModuleAttemptsV1(moduleId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke a course from a user
         * @summary Revoke Course
         * @param {string} courseId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCourseV1(courseId: string, userId: string, options?: AxiosRequestConfig): AxiosPromise<SparrModelsBaseBaseResponse> {
            return localVarFp.revokeCourseV1(courseId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search goals by name and description
         * @summary Search Goals
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGoalsV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<GoalsSearchResponse> {
            return localVarFp.searchGoalsV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonasV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<PersonaSearchResponse> {
            return localVarFp.searchPersonasV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenariosV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<ScenarioSearchResponse> {
            return localVarFp.searchScenariosV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Search trackers by name and description
         * @summary Search Tracker
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTrackerV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<TrackerSearchResponse> {
            return localVarFp.searchTrackerV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Heart Beat check to check the health of Sparr Service
         * @summary Heart Beat Status Of Sparr Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusSparrStatusGet(options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.statusSparrStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update course completion status
         * @summary Update Course Completion Status
         * @param {string} courseId 
         * @param {string} userId 
         * @param {CourseCompletionStatus} completionStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseCompletionStatusV1(courseId: string, userId: string, completionStatus: CourseCompletionStatus, options?: AxiosRequestConfig): AxiosPromise<UserCourseAssignment> {
            return localVarFp.updateCourseCompletionStatusV1(courseId, userId, completionStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId 
         * @param {CourseUpdateRequest} courseUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseV1(courseId: string, courseUpdateRequest: CourseUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<CourseResponse> {
            return localVarFp.updateCourseV1(courseId, courseUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update evaluator
         * @summary Update Evaluator
         * @param {string} paramsId 
         * @param {EvaluatorCore} evaluatorCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvaluatorV1(paramsId: string, evaluatorCore: EvaluatorCore, options?: AxiosRequestConfig): AxiosPromise<Evaluator> {
            return localVarFp.updateEvaluatorV1(paramsId, evaluatorCore, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Feedback Comment
         * @param {string} feedbackCommentId 
         * @param {FeedbackCommentCore} feedbackCommentCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedbackCommentV1(feedbackCommentId: string, feedbackCommentCore: FeedbackCommentCore, options?: AxiosRequestConfig): AxiosPromise<SparrDbModelsFeedbackComment> {
            return localVarFp.updateFeedbackCommentV1(feedbackCommentId, feedbackCommentCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a feedback
         * @summary Update Feedback
         * @param {string} feedbackId 
         * @param {FeedbackCore} feedbackCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedbackV1(feedbackId: string, feedbackCore: FeedbackCore, options?: AxiosRequestConfig): AxiosPromise<Feedback> {
            return localVarFp.updateFeedbackV1(feedbackId, feedbackCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a goals collection
         * @summary Update Goals
         * @param {string} goalsId 
         * @param {GoalCoreInput} goalCoreInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalsV1(goalsId: string, goalCoreInput: GoalCoreInput, options?: AxiosRequestConfig): AxiosPromise<SparrDbModelsGoal> {
            return localVarFp.updateGoalsV1(goalsId, goalCoreInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId 
         * @param {PersonaCore} personaCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonaV1(personaId: string, personaCore: PersonaCore, options?: AxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.updatePersonaV1(personaId, personaCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId 
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenarioV1(scenarioId: string, createScenarioRequest: CreateScenarioRequest, options?: AxiosRequestConfig): AxiosPromise<ScenarioResponse> {
            return localVarFp.updateScenarioV1(scenarioId, createScenarioRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a tracker
         * @summary Update Tracker
         * @param {string} trackerId 
         * @param {TrackerCore} trackerCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackerV1(trackerId: string, trackerCore: TrackerCore, options?: AxiosRequestConfig): AxiosPromise<Tracker> {
            return localVarFp.updateTrackerV1(trackerId, trackerCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload multiple files and create file records. Maximum 5 files per request, each file max 10MB.
         * @summary Upload Files
         * @param {Array<File>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilesV1(files: Array<File>, options?: AxiosRequestConfig): AxiosPromise<Array<any>> {
            return localVarFp.uploadFilesV1(files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SparrApi - object-oriented interface
 * @export
 * @class SparrApi
 * @extends {BaseAPI}
 */
export class SparrApi extends BaseAPI {
    /**
     * Add a module attempt for a user
     * @summary Add Module Attempt
     * @param {string} moduleId 
     * @param {UserModuleAttemptCore} userModuleAttemptCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public addModuleAttemptV1(moduleId: string, userModuleAttemptCore: UserModuleAttemptCore, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).addModuleAttemptV1(moduleId, userModuleAttemptCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign a course to a user
     * @summary Assign Course
     * @param {string} courseId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public assignCourseV1(courseId: string, userId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).assignCourseV1(courseId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attach a tag to an entity
     * @summary Attach Tag
     * @param {string} entityType 
     * @param {string} entityId 
     * @param {TagCreate} tagCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost(entityType: string, entityId: string, tagCreate: TagCreate, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).attachTagV1SparrEntityTagsEntityTypeEntityIdTagsPost(entityType, entityId, tagCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a checkout session for a price
     * @summary Create Checkout Session For Price
     * @param {string} priceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public createCheckoutSessionForPriceV1(priceId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).createCheckoutSessionForPriceV1(priceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new course
     * @summary Create Course
     * @param {CourseRequest} courseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public createCourseV1(courseRequest: CourseRequest, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).createCourseV1(courseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a customer portal for customer
     * @summary Create Customer Portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public createCustomerPortalV1(options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).createCustomerPortalV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Feedback Comment
     * @param {FeedbackCommentCore} feedbackCommentCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public createFeedbackCommentV1(feedbackCommentCore: FeedbackCommentCore, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).createFeedbackCommentV1(feedbackCommentCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new feedback
     * @summary Create Feedback
     * @param {FeedbackCore} feedbackCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public createFeedbackV1(feedbackCore: FeedbackCore, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).createFeedbackV1(feedbackCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new goals collection
     * @summary Create Goals
     * @param {GoalCoreInput} goalCoreInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public createGoalsV1(goalCoreInput: GoalCoreInput, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).createGoalsV1(goalCoreInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new persona
     * @summary Create Persona
     * @param {PersonaCore} personaCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public createPersonaV1(personaCore: PersonaCore, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).createPersonaV1(personaCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new evaluator
     * @summary Create Evaluator
     * @param {EvaluatorCore} evaluatorCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public createPostCallEvaluationParamsV1(evaluatorCore: EvaluatorCore, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).createPostCallEvaluationParamsV1(evaluatorCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new scenario
     * @summary Create Scenario
     * @param {CreateScenarioRequest} createScenarioRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public createScenarioV1(createScenarioRequest: CreateScenarioRequest, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).createScenarioV1(createScenarioRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new tracker
     * @summary Create Tracker
     * @param {TrackerCore} trackerCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public createTrackerV1(trackerCore: TrackerCore, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).createTrackerV1(trackerCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a course
     * @summary Delete Course
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public deleteCourseV1(courseId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).deleteCourseV1(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete evaluator
     * @summary Delete Evaluator
     * @param {string} paramsId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public deleteEvaluatorV1(paramsId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).deleteEvaluatorV1(paramsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Feedback Comment
     * @param {string} feedbackCommentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public deleteFeedbackCommentV1(feedbackCommentId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).deleteFeedbackCommentV1(feedbackCommentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a feedback
     * @summary Delete Feedback
     * @param {string} feedbackId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public deleteFeedbackV1(feedbackId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).deleteFeedbackV1(feedbackId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a file
     * @summary Delete File
     * @param {string} fileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public deleteFileV1(fileId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).deleteFileV1(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a goals collection
     * @summary Delete Goals
     * @param {string} goalsId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public deleteGoalsV1(goalsId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).deleteGoalsV1(goalsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a persona
     * @summary Delete Persona
     * @param {string} personaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public deletePersonaV1(personaId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).deletePersonaV1(personaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a scenario
     * @summary Delete Scenario
     * @param {string} scenarioId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public deleteScenarioV1(scenarioId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).deleteScenarioV1(scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a tracker
     * @summary Delete Tracker
     * @param {string} trackerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public deleteTrackerV1(trackerId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).deleteTrackerV1(trackerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detach a tag from an entity
     * @summary Detach Tag
     * @param {string} entityType 
     * @param {string} entityId 
     * @param {string} tagName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete(entityType: string, entityId: string, tagName: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).detachTagV1SparrEntityTagsEntityTypeEntityIdTagsTagNameDelete(entityType, entityId, tagName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Evaluate a feedback
     * @summary Evaluate Feedback V1
     * @param {Sparrv1EvaluateFeedbackRequest} sparrv1EvaluateFeedbackRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public evaluateFeedbackV1(sparrv1EvaluateFeedbackRequest: Sparrv1EvaluateFeedbackRequest, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).evaluateFeedbackV1(sparrv1EvaluateFeedbackRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate evaluator data from files and/or existing core components
     * @summary Generate Evaluator
     * @param {FlexibleGenerationRequest} flexibleGenerationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public generateEvaluatorV1(flexibleGenerationRequest: FlexibleGenerationRequest, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).generateEvaluatorV1(flexibleGenerationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate feedback from call recording and user data
     * @summary Generate Feedback
     * @param {GenerateFeedbackRequest} generateFeedbackRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public generateFeedbackV1(generateFeedbackRequest: GenerateFeedbackRequest, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).generateFeedbackV1(generateFeedbackRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific course by ID
     * @summary Get Course
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getCourseV1(courseId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).getCourseV1(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get credits
     * @summary Get Credits V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getCreditsV1(options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).getCreditsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all entities of a type that have a specific tag
     * @summary Get Entities By Tag
     * @param {string} entityType 
     * @param {string} tagName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet(entityType: string, tagName: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).getEntitiesByTagV1SparrEntityTagsEntityTypeByTagTagNameGet(entityType, tagName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all tags for an entity
     * @summary Get Entity Tags
     * @param {string} entityType 
     * @param {string} entityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet(entityType: string, entityId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).getEntityTagsV1SparrEntityTagsEntityTypeEntityIdTagsGet(entityType, entityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
     * @summary Get Evaluator By Id
     * @param {string} paramsId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getEvaluatorV1(paramsId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).getEvaluatorV1(paramsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Feedback Comment By Id
     * @param {string} feedbackCommentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getFeedbackCommentV1(feedbackCommentId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).getFeedbackCommentV1(feedbackCommentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific feedback by ID
     * @summary Get Feedback
     * @param {string} feedbackId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getFeedbackV1(feedbackId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).getFeedbackV1(feedbackId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific file by ID
     * @summary Get File
     * @param {string} fileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getFileV1(fileId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).getFileV1(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
     * @summary Get Goals By Id
     * @param {string} goalsId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getGoalsV1(goalsId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).getGoalsV1(goalsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get metrics for a given batch of metrics requests
     * @summary Get Metrics
     * @param {SparrModelsAnalyticsBatchMetricsRequests} sparrModelsAnalyticsBatchMetricsRequests 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests: SparrModelsAnalyticsBatchMetricsRequests, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).getMetricsV1(sparrModelsAnalyticsBatchMetricsRequests, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific persona by ID that is either directly owned or available through reseller course assignments
     * @summary Get Persona
     * @param {string} personaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getPersonaV1(personaId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).getPersonaV1(personaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pricing
     * @summary Get Pricing V1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getPricingV1(options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).getPricingV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
     * @summary Get Scenario
     * @param {string} scenarioId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getScenarioV1(scenarioId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).getScenarioV1(scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
     * @summary Get Tracker By Id
     * @param {string} trackerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getTrackerV1(trackerId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).getTrackerV1(trackerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search personas by name, title and company
     * @summary Get User Stats
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public getUserStatsV1(userId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).getUserStatsV1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import a persona from LinkedIn URL
     * @summary Import Linkedin Persona
     * @param {string} linkedinUrl 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public importLinkedinPersonaV1(linkedinUrl: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).importLinkedinPersonaV1(linkedinUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all courses including reseller assignments
     * @summary Get Courses
     * @param {number} [skip] Skip for pagination
     * @param {number} [limit] Limit for pagination
     * @param {string | null} [status] Filter by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public listCoursesV1(skip?: number, limit?: number, status?: string | null, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).listCoursesV1(skip, limit, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all evaluator that are either directly owned or available through reseller course assignments
     * @summary Get Evaluator
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public listEvaluatorV1(skip?: number, limit?: number, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).listEvaluatorV1(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Feedback Comments
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string | null} [feedbackId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public listFeedbackCommentsV1(skip?: number, limit?: number, feedbackId?: string | null, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).listFeedbackCommentsV1(skip, limit, feedbackId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all feedbacks
     * @summary Get Feedbacks
     * @param {number} [skip] Skip for pagination
     * @param {number} [limit] Limit for pagination
     * @param {string | null} [fromDate] Start date for filtering feedbacks
     * @param {string | null} [toDate] End date for filtering feedbacks
     * @param {string | null} [userFilter] User filter for filtering feedbacks. Comma separated list of user ids.
     * @param {string | null} [statusFilter] Status filter for filtering feedbacks. Comma separated list of statuses.
     * @param {string | null} [scenarioFilter] Scenario filter for filtering feedbacks. Comma separated list of scenario ids.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public listFeedbacksV1(skip?: number, limit?: number, fromDate?: string | null, toDate?: string | null, userFilter?: string | null, statusFilter?: string | null, scenarioFilter?: string | null, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).listFeedbacksV1(skip, limit, fromDate, toDate, userFilter, statusFilter, scenarioFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all goals that are either directly owned or available through reseller course assignments
     * @summary Get Goals
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public listGoalsV1(skip?: number, limit?: number, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).listGoalsV1(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all personas that are either directly owned or available through reseller course assignments
     * @summary Get Personas
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [tags] Filter personas by tag, comma separated names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public listPersonasV1(skip?: number, limit?: number, tags?: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).listPersonasV1(skip, limit, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all scenarios that are either directly owned or available through reseller course assignments
     * @summary Get Scenarios
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [tags] Filter scenarios by tag, comma separated names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public listScenariosV1(skip?: number, limit?: number, tags?: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).listScenariosV1(skip, limit, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all trackers that are either directly owned or available through reseller course assignments
     * @summary Get Trackers
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public listTrackerV1(skip?: number, limit?: number, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).listTrackerV1(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all course assignments for a user with analytics
     * @summary Get User Assignments
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public listUserAssignmentsV1(userId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).listUserAssignmentsV1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all module attempts with module information for a user in a specific course
     * @summary Get User Course Attempts
     * @param {string} courseId 
     * @param {string} userId 
     * @param {number} [skip] Skip for pagination
     * @param {number} [limit] Limit for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public listUserCourseAttemptsV1(courseId: string, userId: string, skip?: number, limit?: number, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).listUserCourseAttemptsV1(courseId, userId, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all module attempts for a user
     * @summary Get User Module Attempts
     * @param {string} moduleId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public listUserModuleAttemptsV1(moduleId: string, userId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).listUserModuleAttemptsV1(moduleId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke a course from a user
     * @summary Revoke Course
     * @param {string} courseId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public revokeCourseV1(courseId: string, userId: string, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).revokeCourseV1(courseId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search goals by name and description
     * @summary Search Goals
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public searchGoalsV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).searchGoalsV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search personas by name, title and company
     * @summary Search Personas
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public searchPersonasV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).searchPersonasV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search scenarios by name and description
     * @summary Search Scenarios
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public searchScenariosV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).searchScenariosV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search trackers by name and description
     * @summary Search Tracker
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public searchTrackerV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).searchTrackerV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Heart Beat check to check the health of Sparr Service
     * @summary Heart Beat Status Of Sparr Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public statusSparrStatusGet(options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).statusSparrStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update course completion status
     * @summary Update Course Completion Status
     * @param {string} courseId 
     * @param {string} userId 
     * @param {CourseCompletionStatus} completionStatus 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public updateCourseCompletionStatusV1(courseId: string, userId: string, completionStatus: CourseCompletionStatus, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).updateCourseCompletionStatusV1(courseId, userId, completionStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a course
     * @summary Update Course
     * @param {string} courseId 
     * @param {CourseUpdateRequest} courseUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public updateCourseV1(courseId: string, courseUpdateRequest: CourseUpdateRequest, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).updateCourseV1(courseId, courseUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update evaluator
     * @summary Update Evaluator
     * @param {string} paramsId 
     * @param {EvaluatorCore} evaluatorCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public updateEvaluatorV1(paramsId: string, evaluatorCore: EvaluatorCore, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).updateEvaluatorV1(paramsId, evaluatorCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Feedback Comment
     * @param {string} feedbackCommentId 
     * @param {FeedbackCommentCore} feedbackCommentCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public updateFeedbackCommentV1(feedbackCommentId: string, feedbackCommentCore: FeedbackCommentCore, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).updateFeedbackCommentV1(feedbackCommentId, feedbackCommentCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a feedback
     * @summary Update Feedback
     * @param {string} feedbackId 
     * @param {FeedbackCore} feedbackCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public updateFeedbackV1(feedbackId: string, feedbackCore: FeedbackCore, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).updateFeedbackV1(feedbackId, feedbackCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a goals collection
     * @summary Update Goals
     * @param {string} goalsId 
     * @param {GoalCoreInput} goalCoreInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public updateGoalsV1(goalsId: string, goalCoreInput: GoalCoreInput, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).updateGoalsV1(goalsId, goalCoreInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a persona
     * @summary Update Persona
     * @param {string} personaId 
     * @param {PersonaCore} personaCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public updatePersonaV1(personaId: string, personaCore: PersonaCore, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).updatePersonaV1(personaId, personaCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a scenario
     * @summary Update Scenario
     * @param {string} scenarioId 
     * @param {CreateScenarioRequest} createScenarioRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public updateScenarioV1(scenarioId: string, createScenarioRequest: CreateScenarioRequest, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).updateScenarioV1(scenarioId, createScenarioRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a tracker
     * @summary Update Tracker
     * @param {string} trackerId 
     * @param {TrackerCore} trackerCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public updateTrackerV1(trackerId: string, trackerCore: TrackerCore, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).updateTrackerV1(trackerId, trackerCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload multiple files and create file records. Maximum 5 files per request, each file max 10MB.
     * @summary Upload Files
     * @param {Array<File>} files 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrApi
     */
    public uploadFilesV1(files: Array<File>, options?: AxiosRequestConfig) {
        return SparrApiFp(this.configuration).uploadFilesV1(files, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SparrResellerApi - axios parameter creator
 * @export
 */
export const SparrResellerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseResellerV1: async (courseRequest: CourseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseRequest' is not null or undefined
            assertParamExists('createCourseResellerV1', 'courseRequest', courseRequest)
            const localVarPath = `/v1/resellers/sparr/courses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new evaluator
         * @summary Create Evaluator
         * @param {EvaluatorCore} evaluatorCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvaluatorResellerV1: async (evaluatorCore: EvaluatorCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'evaluatorCore' is not null or undefined
            assertParamExists('createEvaluatorResellerV1', 'evaluatorCore', evaluatorCore)
            const localVarPath = `/v1/resellers/sparr/evaluators/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(evaluatorCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new goals collection
         * @summary Create Goals
         * @param {GoalCoreInput} goalCoreInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoalsResellerV1: async (goalCoreInput: GoalCoreInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalCoreInput' is not null or undefined
            assertParamExists('createGoalsResellerV1', 'goalCoreInput', goalCoreInput)
            const localVarPath = `/v1/resellers/sparr/goals/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(goalCoreInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonaResellerV1: async (personaCore: PersonaCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaCore' is not null or undefined
            assertParamExists('createPersonaResellerV1', 'personaCore', personaCore)
            const localVarPath = `/v1/resellers/sparr/personas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenarioResellerV1: async (createScenarioRequest: CreateScenarioRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createScenarioRequest' is not null or undefined
            assertParamExists('createScenarioResellerV1', 'createScenarioRequest', createScenarioRequest)
            const localVarPath = `/v1/resellers/sparr/scenarios/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createScenarioRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new tracker
         * @summary Create Tracker
         * @param {TrackerCore} trackerCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackerResellerV1: async (trackerCore: TrackerCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackerCore' is not null or undefined
            assertParamExists('createTrackerResellerV1', 'trackerCore', trackerCore)
            const localVarPath = `/v1/resellers/sparr/trackers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackerCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseResellerV1: async (courseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('deleteCourseResellerV1', 'courseId', courseId)
            const localVarPath = `/v1/resellers/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete evaluator
         * @summary Delete Evaluator
         * @param {string} paramsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvaluatorResellerV1: async (paramsId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paramsId' is not null or undefined
            assertParamExists('deleteEvaluatorResellerV1', 'paramsId', paramsId)
            const localVarPath = `/v1/resellers/sparr/evaluators/{params_id}`
                .replace(`{${"params_id"}}`, encodeURIComponent(String(paramsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a goals collection
         * @summary Delete Goals
         * @param {string} goalsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoalsResellerV1: async (goalsId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalsId' is not null or undefined
            assertParamExists('deleteGoalsResellerV1', 'goalsId', goalsId)
            const localVarPath = `/v1/resellers/sparr/goals/{goals_id}`
                .replace(`{${"goals_id"}}`, encodeURIComponent(String(goalsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonaResellerV1: async (personaId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('deletePersonaResellerV1', 'personaId', personaId)
            const localVarPath = `/v1/resellers/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioResellerV1: async (scenarioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deleteScenarioResellerV1', 'scenarioId', scenarioId)
            const localVarPath = `/v1/resellers/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a tracker
         * @summary Delete Tracker
         * @param {string} trackerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackerResellerV1: async (trackerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackerId' is not null or undefined
            assertParamExists('deleteTrackerResellerV1', 'trackerId', trackerId)
            const localVarPath = `/v1/resellers/sparr/trackers/{tracker_id}`
                .replace(`{${"tracker_id"}}`, encodeURIComponent(String(trackerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate evaluator data from files and/or existing core components
         * @summary Generate Evaluator
         * @param {FlexibleGenerationRequest} flexibleGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEvaluatorResellerV1: async (flexibleGenerationRequest: FlexibleGenerationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flexibleGenerationRequest' is not null or undefined
            assertParamExists('generateEvaluatorResellerV1', 'flexibleGenerationRequest', flexibleGenerationRequest)
            const localVarPath = `/v1/resellers/sparr/evaluators/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flexibleGenerationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseResellerV1: async (courseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getCourseResellerV1', 'courseId', courseId)
            const localVarPath = `/v1/resellers/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
         * @summary Get Evaluator By Id
         * @param {string} paramsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluatorResellerV1: async (paramsId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paramsId' is not null or undefined
            assertParamExists('getEvaluatorResellerV1', 'paramsId', paramsId)
            const localVarPath = `/v1/resellers/sparr/evaluators/{params_id}`
                .replace(`{${"params_id"}}`, encodeURIComponent(String(paramsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
         * @summary Get Goals By Id
         * @param {string} goalsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalsResellerV1: async (goalsId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalsId' is not null or undefined
            assertParamExists('getGoalsResellerV1', 'goalsId', goalsId)
            const localVarPath = `/v1/resellers/sparr/goals/{goals_id}`
                .replace(`{${"goals_id"}}`, encodeURIComponent(String(goalsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific persona by ID that is either directly owned or available through reseller course assignments
         * @summary Get Persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaResellerV1: async (personaId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('getPersonaResellerV1', 'personaId', personaId)
            const localVarPath = `/v1/resellers/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
         * @summary Get Scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioResellerV1: async (scenarioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('getScenarioResellerV1', 'scenarioId', scenarioId)
            const localVarPath = `/v1/resellers/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
         * @summary Get Tracker By Id
         * @param {string} trackerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackerResellerV1: async (trackerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackerId' is not null or undefined
            assertParamExists('getTrackerResellerV1', 'trackerId', trackerId)
            const localVarPath = `/v1/resellers/sparr/trackers/{tracker_id}`
                .replace(`{${"tracker_id"}}`, encodeURIComponent(String(trackerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLinkedinPersonaResellerV1: async (linkedinUrl: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'linkedinUrl' is not null or undefined
            assertParamExists('importLinkedinPersonaResellerV1', 'linkedinUrl', linkedinUrl)
            const localVarPath = `/v1/resellers/sparr/personas/import-linkedin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (linkedinUrl !== undefined) {
                localVarQueryParameter['linkedin_url'] = linkedinUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string | null} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoursesResellerV1: async (skip?: number, limit?: number, status?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/sparr/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all evaluator that are either directly owned or available through reseller course assignments
         * @summary Get Evaluator
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvaluatorResellerV1: async (skip?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/sparr/evaluators/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all goals that are either directly owned or available through reseller course assignments
         * @summary Get Goals
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGoalsResellerV1: async (skip?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/sparr/goals/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all personas that are either directly owned or available through reseller course assignments
         * @summary Get Personas
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [tags] Filter personas by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonasResellerV1: async (skip?: number, limit?: number, tags?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/sparr/personas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all scenarios that are either directly owned or available through reseller course assignments
         * @summary Get Scenarios
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [tags] Filter scenarios by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenariosResellerV1: async (skip?: number, limit?: number, tags?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/sparr/scenarios/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all trackers that are either directly owned or available through reseller course assignments
         * @summary Get Trackers
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrackerResellerV1: async (skip?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/sparr/trackers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search goals by name and description
         * @summary Search Goals
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGoalsResellerV1: async (query: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('searchGoalsResellerV1', 'query', query)
            const localVarPath = `/v1/resellers/sparr/goals/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonasResellerV1: async (query: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('searchPersonasResellerV1', 'query', query)
            const localVarPath = `/v1/resellers/sparr/personas/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenariosResellerV1: async (query: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('searchScenariosResellerV1', 'query', query)
            const localVarPath = `/v1/resellers/sparr/scenarios/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search trackers by name and description
         * @summary Search Tracker
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTrackerResellerV1: async (query: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('searchTrackerResellerV1', 'query', query)
            const localVarPath = `/v1/resellers/sparr/trackers/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId 
         * @param {CourseUpdateRequest} courseUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseResellerV1: async (courseId: string, courseUpdateRequest: CourseUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('updateCourseResellerV1', 'courseId', courseId)
            // verify required parameter 'courseUpdateRequest' is not null or undefined
            assertParamExists('updateCourseResellerV1', 'courseUpdateRequest', courseUpdateRequest)
            const localVarPath = `/v1/resellers/sparr/courses/{course_id}`
                .replace(`{${"course_id"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update evaluator
         * @summary Update Evaluator
         * @param {string} paramsId 
         * @param {EvaluatorCore} evaluatorCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvaluatorResellerV1: async (paramsId: string, evaluatorCore: EvaluatorCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paramsId' is not null or undefined
            assertParamExists('updateEvaluatorResellerV1', 'paramsId', paramsId)
            // verify required parameter 'evaluatorCore' is not null or undefined
            assertParamExists('updateEvaluatorResellerV1', 'evaluatorCore', evaluatorCore)
            const localVarPath = `/v1/resellers/sparr/evaluators/{params_id}`
                .replace(`{${"params_id"}}`, encodeURIComponent(String(paramsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(evaluatorCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a goals collection
         * @summary Update Goals
         * @param {string} goalsId 
         * @param {GoalCoreInput} goalCoreInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalsResellerV1: async (goalsId: string, goalCoreInput: GoalCoreInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalsId' is not null or undefined
            assertParamExists('updateGoalsResellerV1', 'goalsId', goalsId)
            // verify required parameter 'goalCoreInput' is not null or undefined
            assertParamExists('updateGoalsResellerV1', 'goalCoreInput', goalCoreInput)
            const localVarPath = `/v1/resellers/sparr/goals/{goals_id}`
                .replace(`{${"goals_id"}}`, encodeURIComponent(String(goalsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(goalCoreInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId 
         * @param {PersonaCore} personaCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonaResellerV1: async (personaId: string, personaCore: PersonaCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('updatePersonaResellerV1', 'personaId', personaId)
            // verify required parameter 'personaCore' is not null or undefined
            assertParamExists('updatePersonaResellerV1', 'personaCore', personaCore)
            const localVarPath = `/v1/resellers/sparr/personas/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId 
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenarioResellerV1: async (scenarioId: string, createScenarioRequest: CreateScenarioRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('updateScenarioResellerV1', 'scenarioId', scenarioId)
            // verify required parameter 'createScenarioRequest' is not null or undefined
            assertParamExists('updateScenarioResellerV1', 'createScenarioRequest', createScenarioRequest)
            const localVarPath = `/v1/resellers/sparr/scenarios/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createScenarioRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a tracker
         * @summary Update Tracker
         * @param {string} trackerId 
         * @param {TrackerCore} trackerCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackerResellerV1: async (trackerId: string, trackerCore: TrackerCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackerId' is not null or undefined
            assertParamExists('updateTrackerResellerV1', 'trackerId', trackerId)
            // verify required parameter 'trackerCore' is not null or undefined
            assertParamExists('updateTrackerResellerV1', 'trackerCore', trackerCore)
            const localVarPath = `/v1/resellers/sparr/trackers/{tracker_id}`
                .replace(`{${"tracker_id"}}`, encodeURIComponent(String(trackerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackerCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SparrResellerApi - functional programming interface
 * @export
 */
export const SparrResellerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SparrResellerApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCourseResellerV1(courseRequest: CourseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCourseResellerV1(courseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.createCourseResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new evaluator
         * @summary Create Evaluator
         * @param {EvaluatorCore} evaluatorCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvaluatorResellerV1(evaluatorCore: EvaluatorCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Evaluator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvaluatorResellerV1(evaluatorCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.createEvaluatorResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new goals collection
         * @summary Create Goals
         * @param {GoalCoreInput} goalCoreInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGoalsResellerV1(goalCoreInput: GoalCoreInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrDbModelsGoal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGoalsResellerV1(goalCoreInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.createGoalsResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPersonaResellerV1(personaCore: PersonaCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPersonaResellerV1(personaCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.createPersonaResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScenarioResellerV1(createScenarioRequest: CreateScenarioRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScenarioResellerV1(createScenarioRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.createScenarioResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new tracker
         * @summary Create Tracker
         * @param {TrackerCore} trackerCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTrackerResellerV1(trackerCore: TrackerCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tracker>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTrackerResellerV1(trackerCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.createTrackerResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCourseResellerV1(courseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCourseResellerV1(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.deleteCourseResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete evaluator
         * @summary Delete Evaluator
         * @param {string} paramsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEvaluatorResellerV1(paramsId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvaluatorResellerV1(paramsId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.deleteEvaluatorResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a goals collection
         * @summary Delete Goals
         * @param {string} goalsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGoalsResellerV1(goalsId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGoalsResellerV1(goalsId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.deleteGoalsResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePersonaResellerV1(personaId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersonaResellerV1(personaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.deletePersonaResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScenarioResellerV1(scenarioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScenarioResellerV1(scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.deleteScenarioResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a tracker
         * @summary Delete Tracker
         * @param {string} trackerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTrackerResellerV1(trackerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTrackerResellerV1(trackerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.deleteTrackerResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate evaluator data from files and/or existing core components
         * @summary Generate Evaluator
         * @param {FlexibleGenerationRequest} flexibleGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateEvaluatorResellerV1(flexibleGenerationRequest: FlexibleGenerationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CombinedEvaluatorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateEvaluatorResellerV1(flexibleGenerationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.generateEvaluatorResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseResellerV1(courseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseResellerV1(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.getCourseResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
         * @summary Get Evaluator By Id
         * @param {string} paramsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvaluatorResellerV1(paramsId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Evaluator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvaluatorResellerV1(paramsId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.getEvaluatorResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
         * @summary Get Goals By Id
         * @param {string} goalsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGoalsResellerV1(goalsId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrDbModelsGoal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGoalsResellerV1(goalsId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.getGoalsResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific persona by ID that is either directly owned or available through reseller course assignments
         * @summary Get Persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonaResellerV1(personaId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonaResellerV1(personaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.getPersonaResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
         * @summary Get Scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenarioResellerV1(scenarioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioResellerV1(scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.getScenarioResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
         * @summary Get Tracker By Id
         * @param {string} trackerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrackerResellerV1(trackerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tracker>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrackerResellerV1(trackerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.getTrackerResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importLinkedinPersonaResellerV1(linkedinUrl: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importLinkedinPersonaResellerV1(linkedinUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.importLinkedinPersonaResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string | null} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCoursesResellerV1(skip?: number, limit?: number, status?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCoursesResellerV1(skip, limit, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.listCoursesResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all evaluator that are either directly owned or available through reseller course assignments
         * @summary Get Evaluator
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEvaluatorResellerV1(skip?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Evaluator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEvaluatorResellerV1(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.listEvaluatorResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all goals that are either directly owned or available through reseller course assignments
         * @summary Get Goals
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGoalsResellerV1(skip?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SparrDbModelsGoal>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGoalsResellerV1(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.listGoalsResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all personas that are either directly owned or available through reseller course assignments
         * @summary Get Personas
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [tags] Filter personas by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPersonasResellerV1(skip?: number, limit?: number, tags?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Persona>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPersonasResellerV1(skip, limit, tags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.listPersonasResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all scenarios that are either directly owned or available through reseller course assignments
         * @summary Get Scenarios
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [tags] Filter scenarios by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScenariosResellerV1(skip?: number, limit?: number, tags?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScenarioResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScenariosResellerV1(skip, limit, tags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.listScenariosResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all trackers that are either directly owned or available through reseller course assignments
         * @summary Get Trackers
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTrackerResellerV1(skip?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tracker>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTrackerResellerV1(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.listTrackerResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search goals by name and description
         * @summary Search Goals
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchGoalsResellerV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoalsSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchGoalsResellerV1(query, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.searchGoalsResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPersonasResellerV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPersonasResellerV1(query, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.searchPersonasResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchScenariosResellerV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchScenariosResellerV1(query, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.searchScenariosResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search trackers by name and description
         * @summary Search Tracker
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTrackerResellerV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackerSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTrackerResellerV1(query, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.searchTrackerResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId 
         * @param {CourseUpdateRequest} courseUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCourseResellerV1(courseId: string, courseUpdateRequest: CourseUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCourseResellerV1(courseId, courseUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.updateCourseResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update evaluator
         * @summary Update Evaluator
         * @param {string} paramsId 
         * @param {EvaluatorCore} evaluatorCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvaluatorResellerV1(paramsId: string, evaluatorCore: EvaluatorCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Evaluator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvaluatorResellerV1(paramsId, evaluatorCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.updateEvaluatorResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a goals collection
         * @summary Update Goals
         * @param {string} goalsId 
         * @param {GoalCoreInput} goalCoreInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGoalsResellerV1(goalsId: string, goalCoreInput: GoalCoreInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrDbModelsGoal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGoalsResellerV1(goalsId, goalCoreInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.updateGoalsResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId 
         * @param {PersonaCore} personaCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePersonaResellerV1(personaId: string, personaCore: PersonaCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePersonaResellerV1(personaId, personaCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.updatePersonaResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId 
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScenarioResellerV1(scenarioId: string, createScenarioRequest: CreateScenarioRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScenarioResellerV1(scenarioId, createScenarioRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.updateScenarioResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a tracker
         * @summary Update Tracker
         * @param {string} trackerId 
         * @param {TrackerCore} trackerCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTrackerResellerV1(trackerId: string, trackerCore: TrackerCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tracker>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTrackerResellerV1(trackerId, trackerCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparrResellerApi.updateTrackerResellerV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SparrResellerApi - factory interface
 * @export
 */
export const SparrResellerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SparrResellerApiFp(configuration)
    return {
        /**
         * Create a new course
         * @summary Create Course
         * @param {CourseRequest} courseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseResellerV1(courseRequest: CourseRequest, options?: AxiosRequestConfig): AxiosPromise<CourseResponse> {
            return localVarFp.createCourseResellerV1(courseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new evaluator
         * @summary Create Evaluator
         * @param {EvaluatorCore} evaluatorCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvaluatorResellerV1(evaluatorCore: EvaluatorCore, options?: AxiosRequestConfig): AxiosPromise<Evaluator> {
            return localVarFp.createEvaluatorResellerV1(evaluatorCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new goals collection
         * @summary Create Goals
         * @param {GoalCoreInput} goalCoreInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoalsResellerV1(goalCoreInput: GoalCoreInput, options?: AxiosRequestConfig): AxiosPromise<SparrDbModelsGoal> {
            return localVarFp.createGoalsResellerV1(goalCoreInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new persona
         * @summary Create Persona
         * @param {PersonaCore} personaCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonaResellerV1(personaCore: PersonaCore, options?: AxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.createPersonaResellerV1(personaCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new scenario
         * @summary Create Scenario
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenarioResellerV1(createScenarioRequest: CreateScenarioRequest, options?: AxiosRequestConfig): AxiosPromise<ScenarioResponse> {
            return localVarFp.createScenarioResellerV1(createScenarioRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new tracker
         * @summary Create Tracker
         * @param {TrackerCore} trackerCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackerResellerV1(trackerCore: TrackerCore, options?: AxiosRequestConfig): AxiosPromise<Tracker> {
            return localVarFp.createTrackerResellerV1(trackerCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a course
         * @summary Delete Course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseResellerV1(courseId: string, options?: AxiosRequestConfig): AxiosPromise<SparrModelsBaseBaseResponse> {
            return localVarFp.deleteCourseResellerV1(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete evaluator
         * @summary Delete Evaluator
         * @param {string} paramsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvaluatorResellerV1(paramsId: string, options?: AxiosRequestConfig): AxiosPromise<SparrModelsBaseBaseResponse> {
            return localVarFp.deleteEvaluatorResellerV1(paramsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a goals collection
         * @summary Delete Goals
         * @param {string} goalsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoalsResellerV1(goalsId: string, options?: AxiosRequestConfig): AxiosPromise<SparrModelsBaseBaseResponse> {
            return localVarFp.deleteGoalsResellerV1(goalsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a persona
         * @summary Delete Persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonaResellerV1(personaId: string, options?: AxiosRequestConfig): AxiosPromise<SparrModelsBaseBaseResponse> {
            return localVarFp.deletePersonaResellerV1(personaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a scenario
         * @summary Delete Scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioResellerV1(scenarioId: string, options?: AxiosRequestConfig): AxiosPromise<SparrModelsBaseBaseResponse> {
            return localVarFp.deleteScenarioResellerV1(scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a tracker
         * @summary Delete Tracker
         * @param {string} trackerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackerResellerV1(trackerId: string, options?: AxiosRequestConfig): AxiosPromise<SparrModelsBaseBaseResponse> {
            return localVarFp.deleteTrackerResellerV1(trackerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate evaluator data from files and/or existing core components
         * @summary Generate Evaluator
         * @param {FlexibleGenerationRequest} flexibleGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEvaluatorResellerV1(flexibleGenerationRequest: FlexibleGenerationRequest, options?: AxiosRequestConfig): AxiosPromise<CombinedEvaluatorResponse> {
            return localVarFp.generateEvaluatorResellerV1(flexibleGenerationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific course by ID
         * @summary Get Course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseResellerV1(courseId: string, options?: AxiosRequestConfig): AxiosPromise<CourseResponse> {
            return localVarFp.getCourseResellerV1(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
         * @summary Get Evaluator By Id
         * @param {string} paramsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluatorResellerV1(paramsId: string, options?: AxiosRequestConfig): AxiosPromise<Evaluator> {
            return localVarFp.getEvaluatorResellerV1(paramsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
         * @summary Get Goals By Id
         * @param {string} goalsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalsResellerV1(goalsId: string, options?: AxiosRequestConfig): AxiosPromise<SparrDbModelsGoal> {
            return localVarFp.getGoalsResellerV1(goalsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific persona by ID that is either directly owned or available through reseller course assignments
         * @summary Get Persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaResellerV1(personaId: string, options?: AxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.getPersonaResellerV1(personaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
         * @summary Get Scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioResellerV1(scenarioId: string, options?: AxiosRequestConfig): AxiosPromise<ScenarioResponse> {
            return localVarFp.getScenarioResellerV1(scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
         * @summary Get Tracker By Id
         * @param {string} trackerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackerResellerV1(trackerId: string, options?: AxiosRequestConfig): AxiosPromise<Tracker> {
            return localVarFp.getTrackerResellerV1(trackerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Import a persona from LinkedIn URL
         * @summary Import Linkedin Persona
         * @param {string} linkedinUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLinkedinPersonaResellerV1(linkedinUrl: string, options?: AxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.importLinkedinPersonaResellerV1(linkedinUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all courses including reseller assignments
         * @summary Get Courses
         * @param {number} [skip] Skip for pagination
         * @param {number} [limit] Limit for pagination
         * @param {string | null} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoursesResellerV1(skip?: number, limit?: number, status?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<CourseResponse>> {
            return localVarFp.listCoursesResellerV1(skip, limit, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all evaluator that are either directly owned or available through reseller course assignments
         * @summary Get Evaluator
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvaluatorResellerV1(skip?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Evaluator>> {
            return localVarFp.listEvaluatorResellerV1(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all goals that are either directly owned or available through reseller course assignments
         * @summary Get Goals
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGoalsResellerV1(skip?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<SparrDbModelsGoal>> {
            return localVarFp.listGoalsResellerV1(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all personas that are either directly owned or available through reseller course assignments
         * @summary Get Personas
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [tags] Filter personas by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonasResellerV1(skip?: number, limit?: number, tags?: string, options?: AxiosRequestConfig): AxiosPromise<Array<Persona>> {
            return localVarFp.listPersonasResellerV1(skip, limit, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all scenarios that are either directly owned or available through reseller course assignments
         * @summary Get Scenarios
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [tags] Filter scenarios by tag, comma separated names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenariosResellerV1(skip?: number, limit?: number, tags?: string, options?: AxiosRequestConfig): AxiosPromise<Array<ScenarioResponse>> {
            return localVarFp.listScenariosResellerV1(skip, limit, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all trackers that are either directly owned or available through reseller course assignments
         * @summary Get Trackers
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrackerResellerV1(skip?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Tracker>> {
            return localVarFp.listTrackerResellerV1(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Search goals by name and description
         * @summary Search Goals
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGoalsResellerV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<GoalsSearchResponse> {
            return localVarFp.searchGoalsResellerV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Search personas by name, title and company
         * @summary Search Personas
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersonasResellerV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<PersonaSearchResponse> {
            return localVarFp.searchPersonasResellerV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Search scenarios by name and description
         * @summary Search Scenarios
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenariosResellerV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<ScenarioSearchResponse> {
            return localVarFp.searchScenariosResellerV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Search trackers by name and description
         * @summary Search Tracker
         * @param {string} query Search query string
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTrackerResellerV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig): AxiosPromise<TrackerSearchResponse> {
            return localVarFp.searchTrackerResellerV1(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a course
         * @summary Update Course
         * @param {string} courseId 
         * @param {CourseUpdateRequest} courseUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseResellerV1(courseId: string, courseUpdateRequest: CourseUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<CourseResponse> {
            return localVarFp.updateCourseResellerV1(courseId, courseUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update evaluator
         * @summary Update Evaluator
         * @param {string} paramsId 
         * @param {EvaluatorCore} evaluatorCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvaluatorResellerV1(paramsId: string, evaluatorCore: EvaluatorCore, options?: AxiosRequestConfig): AxiosPromise<Evaluator> {
            return localVarFp.updateEvaluatorResellerV1(paramsId, evaluatorCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a goals collection
         * @summary Update Goals
         * @param {string} goalsId 
         * @param {GoalCoreInput} goalCoreInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalsResellerV1(goalsId: string, goalCoreInput: GoalCoreInput, options?: AxiosRequestConfig): AxiosPromise<SparrDbModelsGoal> {
            return localVarFp.updateGoalsResellerV1(goalsId, goalCoreInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a persona
         * @summary Update Persona
         * @param {string} personaId 
         * @param {PersonaCore} personaCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonaResellerV1(personaId: string, personaCore: PersonaCore, options?: AxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.updatePersonaResellerV1(personaId, personaCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a scenario
         * @summary Update Scenario
         * @param {string} scenarioId 
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenarioResellerV1(scenarioId: string, createScenarioRequest: CreateScenarioRequest, options?: AxiosRequestConfig): AxiosPromise<ScenarioResponse> {
            return localVarFp.updateScenarioResellerV1(scenarioId, createScenarioRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a tracker
         * @summary Update Tracker
         * @param {string} trackerId 
         * @param {TrackerCore} trackerCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackerResellerV1(trackerId: string, trackerCore: TrackerCore, options?: AxiosRequestConfig): AxiosPromise<Tracker> {
            return localVarFp.updateTrackerResellerV1(trackerId, trackerCore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SparrResellerApi - object-oriented interface
 * @export
 * @class SparrResellerApi
 * @extends {BaseAPI}
 */
export class SparrResellerApi extends BaseAPI {
    /**
     * Create a new course
     * @summary Create Course
     * @param {CourseRequest} courseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public createCourseResellerV1(courseRequest: CourseRequest, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).createCourseResellerV1(courseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new evaluator
     * @summary Create Evaluator
     * @param {EvaluatorCore} evaluatorCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public createEvaluatorResellerV1(evaluatorCore: EvaluatorCore, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).createEvaluatorResellerV1(evaluatorCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new goals collection
     * @summary Create Goals
     * @param {GoalCoreInput} goalCoreInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public createGoalsResellerV1(goalCoreInput: GoalCoreInput, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).createGoalsResellerV1(goalCoreInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new persona
     * @summary Create Persona
     * @param {PersonaCore} personaCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public createPersonaResellerV1(personaCore: PersonaCore, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).createPersonaResellerV1(personaCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new scenario
     * @summary Create Scenario
     * @param {CreateScenarioRequest} createScenarioRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public createScenarioResellerV1(createScenarioRequest: CreateScenarioRequest, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).createScenarioResellerV1(createScenarioRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new tracker
     * @summary Create Tracker
     * @param {TrackerCore} trackerCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public createTrackerResellerV1(trackerCore: TrackerCore, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).createTrackerResellerV1(trackerCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a course
     * @summary Delete Course
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public deleteCourseResellerV1(courseId: string, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).deleteCourseResellerV1(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete evaluator
     * @summary Delete Evaluator
     * @param {string} paramsId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public deleteEvaluatorResellerV1(paramsId: string, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).deleteEvaluatorResellerV1(paramsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a goals collection
     * @summary Delete Goals
     * @param {string} goalsId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public deleteGoalsResellerV1(goalsId: string, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).deleteGoalsResellerV1(goalsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a persona
     * @summary Delete Persona
     * @param {string} personaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public deletePersonaResellerV1(personaId: string, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).deletePersonaResellerV1(personaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a scenario
     * @summary Delete Scenario
     * @param {string} scenarioId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public deleteScenarioResellerV1(scenarioId: string, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).deleteScenarioResellerV1(scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a tracker
     * @summary Delete Tracker
     * @param {string} trackerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public deleteTrackerResellerV1(trackerId: string, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).deleteTrackerResellerV1(trackerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate evaluator data from files and/or existing core components
     * @summary Generate Evaluator
     * @param {FlexibleGenerationRequest} flexibleGenerationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public generateEvaluatorResellerV1(flexibleGenerationRequest: FlexibleGenerationRequest, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).generateEvaluatorResellerV1(flexibleGenerationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific course by ID
     * @summary Get Course
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public getCourseResellerV1(courseId: string, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).getCourseResellerV1(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific evaluator by ID that is either directly owned or available through reseller course assignments
     * @summary Get Evaluator By Id
     * @param {string} paramsId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public getEvaluatorResellerV1(paramsId: string, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).getEvaluatorResellerV1(paramsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific goals collection by ID that is either directly owned or available through reseller course assignments
     * @summary Get Goals By Id
     * @param {string} goalsId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public getGoalsResellerV1(goalsId: string, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).getGoalsResellerV1(goalsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific persona by ID that is either directly owned or available through reseller course assignments
     * @summary Get Persona
     * @param {string} personaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public getPersonaResellerV1(personaId: string, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).getPersonaResellerV1(personaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific scenario by ID that is either directly owned or available through reseller course assignments
     * @summary Get Scenario
     * @param {string} scenarioId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public getScenarioResellerV1(scenarioId: string, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).getScenarioResellerV1(scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific tracker by ID that is either directly owned or available through reseller course assignments
     * @summary Get Tracker By Id
     * @param {string} trackerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public getTrackerResellerV1(trackerId: string, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).getTrackerResellerV1(trackerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import a persona from LinkedIn URL
     * @summary Import Linkedin Persona
     * @param {string} linkedinUrl 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public importLinkedinPersonaResellerV1(linkedinUrl: string, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).importLinkedinPersonaResellerV1(linkedinUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all courses including reseller assignments
     * @summary Get Courses
     * @param {number} [skip] Skip for pagination
     * @param {number} [limit] Limit for pagination
     * @param {string | null} [status] Filter by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public listCoursesResellerV1(skip?: number, limit?: number, status?: string | null, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).listCoursesResellerV1(skip, limit, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all evaluator that are either directly owned or available through reseller course assignments
     * @summary Get Evaluator
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public listEvaluatorResellerV1(skip?: number, limit?: number, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).listEvaluatorResellerV1(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all goals that are either directly owned or available through reseller course assignments
     * @summary Get Goals
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public listGoalsResellerV1(skip?: number, limit?: number, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).listGoalsResellerV1(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all personas that are either directly owned or available through reseller course assignments
     * @summary Get Personas
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [tags] Filter personas by tag, comma separated names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public listPersonasResellerV1(skip?: number, limit?: number, tags?: string, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).listPersonasResellerV1(skip, limit, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all scenarios that are either directly owned or available through reseller course assignments
     * @summary Get Scenarios
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [tags] Filter scenarios by tag, comma separated names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public listScenariosResellerV1(skip?: number, limit?: number, tags?: string, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).listScenariosResellerV1(skip, limit, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all trackers that are either directly owned or available through reseller course assignments
     * @summary Get Trackers
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public listTrackerResellerV1(skip?: number, limit?: number, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).listTrackerResellerV1(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search goals by name and description
     * @summary Search Goals
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public searchGoalsResellerV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).searchGoalsResellerV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search personas by name, title and company
     * @summary Search Personas
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public searchPersonasResellerV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).searchPersonasResellerV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search scenarios by name and description
     * @summary Search Scenarios
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public searchScenariosResellerV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).searchScenariosResellerV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search trackers by name and description
     * @summary Search Tracker
     * @param {string} query Search query string
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public searchTrackerResellerV1(query: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).searchTrackerResellerV1(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a course
     * @summary Update Course
     * @param {string} courseId 
     * @param {CourseUpdateRequest} courseUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public updateCourseResellerV1(courseId: string, courseUpdateRequest: CourseUpdateRequest, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).updateCourseResellerV1(courseId, courseUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update evaluator
     * @summary Update Evaluator
     * @param {string} paramsId 
     * @param {EvaluatorCore} evaluatorCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public updateEvaluatorResellerV1(paramsId: string, evaluatorCore: EvaluatorCore, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).updateEvaluatorResellerV1(paramsId, evaluatorCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a goals collection
     * @summary Update Goals
     * @param {string} goalsId 
     * @param {GoalCoreInput} goalCoreInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public updateGoalsResellerV1(goalsId: string, goalCoreInput: GoalCoreInput, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).updateGoalsResellerV1(goalsId, goalCoreInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a persona
     * @summary Update Persona
     * @param {string} personaId 
     * @param {PersonaCore} personaCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public updatePersonaResellerV1(personaId: string, personaCore: PersonaCore, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).updatePersonaResellerV1(personaId, personaCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a scenario
     * @summary Update Scenario
     * @param {string} scenarioId 
     * @param {CreateScenarioRequest} createScenarioRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public updateScenarioResellerV1(scenarioId: string, createScenarioRequest: CreateScenarioRequest, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).updateScenarioResellerV1(scenarioId, createScenarioRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a tracker
     * @summary Update Tracker
     * @param {string} trackerId 
     * @param {TrackerCore} trackerCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparrResellerApi
     */
    public updateTrackerResellerV1(trackerId: string, trackerCore: TrackerCore, options?: AxiosRequestConfig) {
        return SparrResellerApiFp(this.configuration).updateTrackerResellerV1(trackerId, trackerCore, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SparringApi - axios parameter creator
 * @export
 */
export const SparringApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a virtual prospect
         * @summary Create Virtual Prospect
         * @param {VirtualProspectInput} virtualProspectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualProspectV1SparrVirtualProspectsPost: async (virtualProspectInput: VirtualProspectInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualProspectInput' is not null or undefined
            assertParamExists('createVirtualProspectV1SparrVirtualProspectsPost', 'virtualProspectInput', virtualProspectInput)
            const localVarPath = `/v1/sparr/virtual-prospects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(virtualProspectInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a virtual prospect
         * @summary Delete Virtual Prospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete: async (prospectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            assertParamExists('deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete', 'prospectId', prospectId)
            const localVarPath = `/v1/sparr/virtual-prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get sparring stats from Trata AI like call count, prospect count, etc.
         * @summary Get Sparring Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSparringStatsV1SparrSparringStatsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/sparring-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get virtual prospect associated with an agent
         * @summary Get Virtual Prospect by Agent ID
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet: async (agentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet', 'agentId', agentId)
            const localVarPath = `/v1/sparr/agent/{agent_id}/virtual-prospect`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a virtual prospect
         * @summary Get Virtual Prospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectV1SparrVirtualProspectsProspectIdGet: async (prospectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            assertParamExists('getVirtualProspectV1SparrVirtualProspectsProspectIdGet', 'prospectId', prospectId)
            const localVarPath = `/v1/sparr/virtual-prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Link a virtual prospect to an agent
         * @summary Link Virtual Prospect to Agent
         * @param {string} prospectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost: async (prospectId: string, agentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            assertParamExists('linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost', 'prospectId', prospectId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost', 'agentId', agentId)
            const localVarPath = `/v1/sparr/virtual-prospects/{prospect_id}/agent/{agent_id}/link`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all virtual prospects
         * @summary List Virtual Prospects
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualProspectsV1SparrVirtualProspectsGet: async (searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr/virtual-prospects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a virtual prospect
         * @summary Update Virtual Prospect
         * @param {string} prospectId 
         * @param {VirtualProspectInput} virtualProspectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVirtualProspectV1SparrVirtualProspectsProspectIdPut: async (prospectId: string, virtualProspectInput: VirtualProspectInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            assertParamExists('updateVirtualProspectV1SparrVirtualProspectsProspectIdPut', 'prospectId', prospectId)
            // verify required parameter 'virtualProspectInput' is not null or undefined
            assertParamExists('updateVirtualProspectV1SparrVirtualProspectsProspectIdPut', 'virtualProspectInput', virtualProspectInput)
            const localVarPath = `/v1/sparr/virtual-prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(virtualProspectInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SparringApi - functional programming interface
 * @export
 */
export const SparringApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SparringApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a virtual prospect
         * @summary Create Virtual Prospect
         * @param {VirtualProspectInput} virtualProspectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput: VirtualProspectInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualProspectOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparringApi.createVirtualProspectV1SparrVirtualProspectsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a virtual prospect
         * @summary Delete Virtual Prospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparringApi.deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get sparring stats from Trata AI like call count, prospect count, etc.
         * @summary Get Sparring Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSparringStatsV1SparrSparringStatsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SparrStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSparringStatsV1SparrSparringStatsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparringApi.getSparringStatsV1SparrSparringStatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get virtual prospect associated with an agent
         * @summary Get Virtual Prospect by Agent ID
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VirtualProspectOutput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparringApi.getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a virtual prospect
         * @summary Get Virtual Prospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualProspectOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparringApi.getVirtualProspectV1SparrVirtualProspectsProspectIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Link a virtual prospect to an agent
         * @summary Link Virtual Prospect to Agent
         * @param {string} prospectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId: string, agentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualProspectAIAgentLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparringApi.linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all virtual prospects
         * @summary List Virtual Prospects
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVirtualProspectsV1SparrVirtualProspectsGet(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VirtualProspectOutput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparringApi.listVirtualProspectsV1SparrVirtualProspectsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a virtual prospect
         * @summary Update Virtual Prospect
         * @param {string} prospectId 
         * @param {VirtualProspectInput} virtualProspectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId: string, virtualProspectInput: VirtualProspectInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualProspectOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SparringApi.updateVirtualProspectV1SparrVirtualProspectsProspectIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SparringApi - factory interface
 * @export
 */
export const SparringApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SparringApiFp(configuration)
    return {
        /**
         * Create a virtual prospect
         * @summary Create Virtual Prospect
         * @param {VirtualProspectInput} virtualProspectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput: VirtualProspectInput, options?: AxiosRequestConfig): AxiosPromise<VirtualProspectOutput> {
            return localVarFp.createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a virtual prospect
         * @summary Delete Virtual Prospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get sparring stats from Trata AI like call count, prospect count, etc.
         * @summary Get Sparring Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSparringStatsV1SparrSparringStatsGet(options?: AxiosRequestConfig): AxiosPromise<SparrStatsResponse> {
            return localVarFp.getSparringStatsV1SparrSparringStatsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get virtual prospect associated with an agent
         * @summary Get Virtual Prospect by Agent ID
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId: string, options?: AxiosRequestConfig): AxiosPromise<Array<VirtualProspectOutput>> {
            return localVarFp.getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a virtual prospect
         * @summary Get Virtual Prospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId: string, options?: AxiosRequestConfig): AxiosPromise<VirtualProspectOutput> {
            return localVarFp.getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Link a virtual prospect to an agent
         * @summary Link Virtual Prospect to Agent
         * @param {string} prospectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId: string, agentId: string, options?: AxiosRequestConfig): AxiosPromise<VirtualProspectAIAgentLink> {
            return localVarFp.linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all virtual prospects
         * @summary List Virtual Prospects
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualProspectsV1SparrVirtualProspectsGet(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<VirtualProspectOutput>> {
            return localVarFp.listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a virtual prospect
         * @summary Update Virtual Prospect
         * @param {string} prospectId 
         * @param {VirtualProspectInput} virtualProspectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId: string, virtualProspectInput: VirtualProspectInput, options?: AxiosRequestConfig): AxiosPromise<VirtualProspectOutput> {
            return localVarFp.updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SparringApi - object-oriented interface
 * @export
 * @class SparringApi
 * @extends {BaseAPI}
 */
export class SparringApi extends BaseAPI {
    /**
     * Create a virtual prospect
     * @summary Create Virtual Prospect
     * @param {VirtualProspectInput} virtualProspectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput: VirtualProspectInput, options?: AxiosRequestConfig) {
        return SparringApiFp(this.configuration).createVirtualProspectV1SparrVirtualProspectsPost(virtualProspectInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a virtual prospect
     * @summary Delete Virtual Prospect
     * @param {string} prospectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId: string, options?: AxiosRequestConfig) {
        return SparringApiFp(this.configuration).deleteVirtualProspectV1SparrVirtualProspectsProspectIdDelete(prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get sparring stats from Trata AI like call count, prospect count, etc.
     * @summary Get Sparring Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public getSparringStatsV1SparrSparringStatsGet(options?: AxiosRequestConfig) {
        return SparringApiFp(this.configuration).getSparringStatsV1SparrSparringStatsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get virtual prospect associated with an agent
     * @summary Get Virtual Prospect by Agent ID
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId: string, options?: AxiosRequestConfig) {
        return SparringApiFp(this.configuration).getVirtualProspectByAgentIdV1SparrAgentAgentIdVirtualProspectGet(agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a virtual prospect
     * @summary Get Virtual Prospect
     * @param {string} prospectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId: string, options?: AxiosRequestConfig) {
        return SparringApiFp(this.configuration).getVirtualProspectV1SparrVirtualProspectsProspectIdGet(prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Link a virtual prospect to an agent
     * @summary Link Virtual Prospect to Agent
     * @param {string} prospectId 
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId: string, agentId: string, options?: AxiosRequestConfig) {
        return SparringApiFp(this.configuration).linkVirtualProspectToAgentV1SparrVirtualProspectsProspectIdAgentAgentIdLinkPost(prospectId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all virtual prospects
     * @summary List Virtual Prospects
     * @param {string | null} [searchBy] 
     * @param {string | null} [searchValue] 
     * @param {string | null} [status] 
     * @param {string | null} [sortBy] 
     * @param {SortOrder | null} [sortOrder] 
     * @param {number | null} [skip] 
     * @param {number | null} [limit] 
     * @param {string | null} [updatedAfter] 
     * @param {string | null} [updatedBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public listVirtualProspectsV1SparrVirtualProspectsGet(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, options?: AxiosRequestConfig) {
        return SparringApiFp(this.configuration).listVirtualProspectsV1SparrVirtualProspectsGet(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a virtual prospect
     * @summary Update Virtual Prospect
     * @param {string} prospectId 
     * @param {VirtualProspectInput} virtualProspectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SparringApi
     */
    public updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId: string, virtualProspectInput: VirtualProspectInput, options?: AxiosRequestConfig) {
        return SparringApiFp(this.configuration).updateVirtualProspectV1SparrVirtualProspectsProspectIdPut(prospectId, virtualProspectInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TelephonyApi - axios parameter creator
 * @export
 */
export const TelephonyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Agent Phones
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentPhonesV1: async (agentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('getAgentPhonesV1', 'agentId', agentId)
            const localVarPath = `/v1/ai-agents/{agent_id}/phones`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Link Phone To Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPhoneToAgentV1: async (phoneId: string, agentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'phoneId' is not null or undefined
            assertParamExists('linkPhoneToAgentV1', 'phoneId', phoneId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('linkPhoneToAgentV1', 'agentId', agentId)
            const localVarPath = `/v1/telephony/phones/{phone_id}/ai-agents/{agent_id}/link`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Available Phones
         * @param {string} countryCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailablePhonesV1: async (countryCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryCode' is not null or undefined
            assertParamExists('listAvailablePhonesV1', 'countryCode', countryCode)
            const localVarPath = `/v1/telephony/countries/{country_code}/available-phones`
                .replace(`{${"country_code"}}`, encodeURIComponent(String(countryCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Purchased Phones
         * @param {string | null} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPurchasedPhonesV1: async (countryCode?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/telephony/phones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedCountriesV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/telephony/countries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePhoneV1: async (numberPurchaseRequest: NumberPurchaseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'numberPurchaseRequest' is not null or undefined
            assertParamExists('purchasePhoneV1', 'numberPurchaseRequest', numberPurchaseRequest)
            const localVarPath = `/v1/telephony/phones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(numberPurchaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Release Phone
         * @param {string} phoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePhoneV1: async (phoneId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'phoneId' is not null or undefined
            assertParamExists('releasePhoneV1', 'phoneId', phoneId)
            const localVarPath = `/v1/telephony/phones/{phone_id}`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlink Phone From Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPhoneFromAgentV1: async (phoneId: string, agentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'phoneId' is not null or undefined
            assertParamExists('unlinkPhoneFromAgentV1', 'phoneId', phoneId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('unlinkPhoneFromAgentV1', 'agentId', agentId)
            const localVarPath = `/v1/telephony/phones/{phone_id}/ai-agents/{agent_id}/link`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TelephonyApi - functional programming interface
 * @export
 */
export const TelephonyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TelephonyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Agent Phones
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgentPhonesV1(agentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TelephoneNumber>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAgentPhonesV1(agentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TelephonyApi.getAgentPhonesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Link Phone To Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkPhoneToAgentV1(phoneId: string, agentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkPhoneToAgentV1(phoneId, agentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TelephonyApi.linkPhoneToAgentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Available Phones
         * @param {string} countryCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAvailablePhonesV1(countryCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AvailablePhoneNumber>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAvailablePhonesV1(countryCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TelephonyApi.listAvailablePhonesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Purchased Phones
         * @param {string | null} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPurchasedPhonesV1(countryCode?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TelephoneNumber>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPurchasedPhonesV1(countryCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TelephonyApi.listPurchasedPhonesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSupportedCountriesV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CountryInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSupportedCountriesV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TelephonyApi.listSupportedCountriesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchasePhoneV1(numberPurchaseRequest: NumberPurchaseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TelephoneNumber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchasePhoneV1(numberPurchaseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TelephonyApi.purchasePhoneV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Release Phone
         * @param {string} phoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async releasePhoneV1(phoneId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.releasePhoneV1(phoneId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TelephonyApi.releasePhoneV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unlink Phone From Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkPhoneFromAgentV1(phoneId: string, agentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponseInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkPhoneFromAgentV1(phoneId, agentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TelephonyApi.unlinkPhoneFromAgentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TelephonyApi - factory interface
 * @export
 */
export const TelephonyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TelephonyApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Agent Phones
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentPhonesV1(agentId: string, options?: AxiosRequestConfig): AxiosPromise<Array<TelephoneNumber>> {
            return localVarFp.getAgentPhonesV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Link Phone To Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPhoneToAgentV1(phoneId: string, agentId: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.linkPhoneToAgentV1(phoneId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Available Phones
         * @param {string} countryCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailablePhonesV1(countryCode: string, options?: AxiosRequestConfig): AxiosPromise<Array<AvailablePhoneNumber>> {
            return localVarFp.listAvailablePhonesV1(countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Purchased Phones
         * @param {string | null} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPurchasedPhonesV1(countryCode?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<TelephoneNumber>> {
            return localVarFp.listPurchasedPhonesV1(countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedCountriesV1(options?: AxiosRequestConfig): AxiosPromise<Array<CountryInfo>> {
            return localVarFp.listSupportedCountriesV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePhoneV1(numberPurchaseRequest: NumberPurchaseRequest, options?: AxiosRequestConfig): AxiosPromise<TelephoneNumber> {
            return localVarFp.purchasePhoneV1(numberPurchaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Release Phone
         * @param {string} phoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePhoneV1(phoneId: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.releasePhoneV1(phoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlink Phone From Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPhoneFromAgentV1(phoneId: string, agentId: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponseInput> {
            return localVarFp.unlinkPhoneFromAgentV1(phoneId, agentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TelephonyApi - object-oriented interface
 * @export
 * @class TelephonyApi
 * @extends {BaseAPI}
 */
export class TelephonyApi extends BaseAPI {
    /**
     * 
     * @summary Get Agent Phones
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public getAgentPhonesV1(agentId: string, options?: AxiosRequestConfig) {
        return TelephonyApiFp(this.configuration).getAgentPhonesV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Link Phone To Agent
     * @param {string} phoneId 
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public linkPhoneToAgentV1(phoneId: string, agentId: string, options?: AxiosRequestConfig) {
        return TelephonyApiFp(this.configuration).linkPhoneToAgentV1(phoneId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Available Phones
     * @param {string} countryCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public listAvailablePhonesV1(countryCode: string, options?: AxiosRequestConfig) {
        return TelephonyApiFp(this.configuration).listAvailablePhonesV1(countryCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Purchased Phones
     * @param {string | null} [countryCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public listPurchasedPhonesV1(countryCode?: string | null, options?: AxiosRequestConfig) {
        return TelephonyApiFp(this.configuration).listPurchasedPhonesV1(countryCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Supported Countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public listSupportedCountriesV1(options?: AxiosRequestConfig) {
        return TelephonyApiFp(this.configuration).listSupportedCountriesV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purchase Phone
     * @param {NumberPurchaseRequest} numberPurchaseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public purchasePhoneV1(numberPurchaseRequest: NumberPurchaseRequest, options?: AxiosRequestConfig) {
        return TelephonyApiFp(this.configuration).purchasePhoneV1(numberPurchaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Release Phone
     * @param {string} phoneId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public releasePhoneV1(phoneId: string, options?: AxiosRequestConfig) {
        return TelephonyApiFp(this.configuration).releasePhoneV1(phoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlink Phone From Agent
     * @param {string} phoneId 
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public unlinkPhoneFromAgentV1(phoneId: string, agentId: string, options?: AxiosRequestConfig) {
        return TelephonyApiFp(this.configuration).unlinkPhoneFromAgentV1(phoneId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UIApi - axios parameter creator
 * @export
 */
export const UIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Action Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionTemplatesV1: async (language?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ui/action-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Products
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {string | null} [tags] 
         * @param {string | null} [productIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsDetailedV1: async (searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, tags?: string | null, productIds?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ui/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (productIds !== undefined) {
                localVarQueryParameter['product_ids'] = productIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Prompt Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptTemplatesV1: async (language?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ui/prompt-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Role Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleTemplatesV1: async (language?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ui/role-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UIApi - functional programming interface
 * @export
 */
export const UIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UIApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Action Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActionTemplatesV1(language?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActionInput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActionTemplatesV1(language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UIApi.listActionTemplatesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Products
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {string | null} [tags] 
         * @param {string | null} [productIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProductsDetailedV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, tags?: string | null, productIds?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductWithAgents>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UIApi.listProductsDetailedV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Prompt Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPromptTemplatesV1(language?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: PromptTemplate; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPromptTemplatesV1(language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UIApi.listPromptTemplatesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Role Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoleTemplatesV1(language?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoleTemplatesV1(language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UIApi.listRoleTemplatesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UIApi - factory interface
 * @export
 */
export const UIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UIApiFp(configuration)
    return {
        /**
         * 
         * @summary List Action Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionTemplatesV1(language?: string, options?: AxiosRequestConfig): AxiosPromise<Array<ActionInput>> {
            return localVarFp.listActionTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Products
         * @param {string | null} [searchBy] 
         * @param {string | null} [searchValue] 
         * @param {string | null} [status] 
         * @param {string | null} [sortBy] 
         * @param {SortOrder | null} [sortOrder] 
         * @param {number | null} [skip] 
         * @param {number | null} [limit] 
         * @param {string | null} [updatedAfter] 
         * @param {string | null} [updatedBefore] 
         * @param {string | null} [tags] 
         * @param {string | null} [productIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsDetailedV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, tags?: string | null, productIds?: string | null, options?: AxiosRequestConfig): AxiosPromise<Array<ProductWithAgents>> {
            return localVarFp.listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Prompt Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptTemplatesV1(language?: string, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: PromptTemplate; }> {
            return localVarFp.listPromptTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Role Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleTemplatesV1(language?: string, options?: AxiosRequestConfig): AxiosPromise<Array<RoleTemplate>> {
            return localVarFp.listRoleTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UIApi - object-oriented interface
 * @export
 * @class UIApi
 * @extends {BaseAPI}
 */
export class UIApi extends BaseAPI {
    /**
     * 
     * @summary List Action Templates
     * @param {string} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    public listActionTemplatesV1(language?: string, options?: AxiosRequestConfig) {
        return UIApiFp(this.configuration).listActionTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Products
     * @param {string | null} [searchBy] 
     * @param {string | null} [searchValue] 
     * @param {string | null} [status] 
     * @param {string | null} [sortBy] 
     * @param {SortOrder | null} [sortOrder] 
     * @param {number | null} [skip] 
     * @param {number | null} [limit] 
     * @param {string | null} [updatedAfter] 
     * @param {string | null} [updatedBefore] 
     * @param {string | null} [tags] 
     * @param {string | null} [productIds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    public listProductsDetailedV1(searchBy?: string | null, searchValue?: string | null, status?: string | null, sortBy?: string | null, sortOrder?: SortOrder | null, skip?: number | null, limit?: number | null, updatedAfter?: string | null, updatedBefore?: string | null, tags?: string | null, productIds?: string | null, options?: AxiosRequestConfig) {
        return UIApiFp(this.configuration).listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, updatedAfter, updatedBefore, tags, productIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Prompt Templates
     * @param {string} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    public listPromptTemplatesV1(language?: string, options?: AxiosRequestConfig) {
        return UIApiFp(this.configuration).listPromptTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Role Templates
     * @param {string} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    public listRoleTemplatesV1(language?: string, options?: AxiosRequestConfig) {
        return UIApiFp(this.configuration).listRoleTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VoiceModelsApi - axios parameter creator
 * @export
 */
export const VoiceModelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get List Of Voices Available For Sparr
         * @summary Get List Of Voices Available For Sparr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSparrVoiceModelsV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sparr-voice-models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get List Of Voices Available For Conversations
         * @summary Get List Of Voices Available For Conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceModelsV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/voice-models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoiceModelsApi - functional programming interface
 * @export
 */
export const VoiceModelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VoiceModelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get List Of Voices Available For Sparr
         * @summary Get List Of Voices Available For Sparr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSparrVoiceModelsV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VoiceModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSparrVoiceModelsV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceModelsApi.listSparrVoiceModelsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get List Of Voices Available For Conversations
         * @summary Get List Of Voices Available For Conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVoiceModelsV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VoiceModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVoiceModelsV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceModelsApi.listVoiceModelsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VoiceModelsApi - factory interface
 * @export
 */
export const VoiceModelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VoiceModelsApiFp(configuration)
    return {
        /**
         * Get List Of Voices Available For Sparr
         * @summary Get List Of Voices Available For Sparr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSparrVoiceModelsV1(options?: AxiosRequestConfig): AxiosPromise<Array<VoiceModel>> {
            return localVarFp.listSparrVoiceModelsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get List Of Voices Available For Conversations
         * @summary Get List Of Voices Available For Conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceModelsV1(options?: AxiosRequestConfig): AxiosPromise<Array<VoiceModel>> {
            return localVarFp.listVoiceModelsV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VoiceModelsApi - object-oriented interface
 * @export
 * @class VoiceModelsApi
 * @extends {BaseAPI}
 */
export class VoiceModelsApi extends BaseAPI {
    /**
     * Get List Of Voices Available For Sparr
     * @summary Get List Of Voices Available For Sparr
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceModelsApi
     */
    public listSparrVoiceModelsV1(options?: AxiosRequestConfig) {
        return VoiceModelsApiFp(this.configuration).listSparrVoiceModelsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get List Of Voices Available For Conversations
     * @summary Get List Of Voices Available For Conversations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceModelsApi
     */
    public listVoiceModelsV1(options?: AxiosRequestConfig) {
        return VoiceModelsApiFp(this.configuration).listVoiceModelsV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkflowsApi - axios parameter creator
 * @export
 */
export const WorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Workflow
         * @param {WorkflowCore} workflowCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowV1WorkflowsPost: async (workflowCore: WorkflowCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowCore' is not null or undefined
            assertParamExists('createWorkflowV1WorkflowsPost', 'workflowCore', workflowCore)
            const localVarPath = `/v1/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Workflow
         * @param {string} workflowId 
         * @param {boolean} [cascade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowV1WorkflowsWorkflowIdDelete: async (workflowId: string, cascade?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('deleteWorkflowV1WorkflowsWorkflowIdDelete', 'workflowId', workflowId)
            const localVarPath = `/v1/workflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cascade !== undefined) {
                localVarQueryParameter['cascade'] = cascade;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowV1WorkflowsWorkflowIdGet: async (workflowId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('readWorkflowV1WorkflowsWorkflowIdGet', 'workflowId', workflowId)
            const localVarPath = `/v1/workflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Workflows
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {AgenticWorkflowAdkModelsWorkflowAppEnum | null} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowsV1WorkflowsGet: async (skip?: number, limit?: number, app?: AgenticWorkflowAdkModelsWorkflowAppEnum | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger Workflow Step
         * @param {string} workflowId 
         * @param {string} stepId 
         * @param {WorkflowStepTriggerRequest} workflowStepTriggerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost: async (workflowId: string, stepId: string, workflowStepTriggerRequest: WorkflowStepTriggerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost', 'workflowId', workflowId)
            // verify required parameter 'stepId' is not null or undefined
            assertParamExists('triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost', 'stepId', stepId)
            // verify required parameter 'workflowStepTriggerRequest' is not null or undefined
            assertParamExists('triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost', 'workflowStepTriggerRequest', workflowStepTriggerRequest)
            const localVarPath = `/v1/workflows/{workflow_id}/step/{step_id}/trigger`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)))
                .replace(`{${"step_id"}}`, encodeURIComponent(String(stepId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowStepTriggerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Workflow
         * @param {string} workflowId 
         * @param {WorkflowCore} workflowCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowV1WorkflowsWorkflowIdPut: async (workflowId: string, workflowCore: WorkflowCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('updateWorkflowV1WorkflowsWorkflowIdPut', 'workflowId', workflowId)
            // verify required parameter 'workflowCore' is not null or undefined
            assertParamExists('updateWorkflowV1WorkflowsWorkflowIdPut', 'workflowCore', workflowCore)
            const localVarPath = `/v1/workflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload File
         * @param {string} workflowId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1WorkflowsWorkflowIdFilePost: async (workflowId: string, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('uploadFileV1WorkflowsWorkflowIdFilePost', 'workflowId', workflowId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadFileV1WorkflowsWorkflowIdFilePost', 'file', file)
            const localVarPath = `/v1/workflows/{workflow_id}/file`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsApi - functional programming interface
 * @export
 */
export const WorkflowsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Workflow
         * @param {WorkflowCore} workflowCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflowV1WorkflowsPost(workflowCore: WorkflowCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflowV1WorkflowsPost(workflowCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.createWorkflowV1WorkflowsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Workflow
         * @param {string} workflowId 
         * @param {boolean} [cascade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId: string, cascade?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, cascade, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.deleteWorkflowV1WorkflowsWorkflowIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readWorkflowV1WorkflowsWorkflowIdGet(workflowId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.readWorkflowV1WorkflowsWorkflowIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read Workflows
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {AgenticWorkflowAdkModelsWorkflowAppEnum | null} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readWorkflowsV1WorkflowsGet(skip?: number, limit?: number, app?: AgenticWorkflowAdkModelsWorkflowAppEnum | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workflow>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readWorkflowsV1WorkflowsGet(skip, limit, app, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.readWorkflowsV1WorkflowsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Trigger Workflow Step
         * @param {string} workflowId 
         * @param {string} stepId 
         * @param {WorkflowStepTriggerRequest} workflowStepTriggerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId: string, stepId: string, workflowStepTriggerRequest: WorkflowStepTriggerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowStepTriggerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Workflow
         * @param {string} workflowId 
         * @param {WorkflowCore} workflowCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkflowV1WorkflowsWorkflowIdPut(workflowId: string, workflowCore: WorkflowCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.updateWorkflowV1WorkflowsWorkflowIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload File
         * @param {string} workflowId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileV1WorkflowsWorkflowIdFilePost(workflowId: string, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFileV1WorkflowsWorkflowIdFilePost(workflowId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.uploadFileV1WorkflowsWorkflowIdFilePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkflowsApi - factory interface
 * @export
 */
export const WorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Workflow
         * @param {WorkflowCore} workflowCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowV1WorkflowsPost(workflowCore: WorkflowCore, options?: AxiosRequestConfig): AxiosPromise<Workflow> {
            return localVarFp.createWorkflowV1WorkflowsPost(workflowCore, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Workflow
         * @param {string} workflowId 
         * @param {boolean} [cascade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId: string, cascade?: boolean, options?: AxiosRequestConfig): AxiosPromise<AgenticWorkflowModelsBaseBaseResponse> {
            return localVarFp.deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, cascade, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowV1WorkflowsWorkflowIdGet(workflowId: string, options?: AxiosRequestConfig): AxiosPromise<Workflow> {
            return localVarFp.readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Workflows
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {AgenticWorkflowAdkModelsWorkflowAppEnum | null} [app] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readWorkflowsV1WorkflowsGet(skip?: number, limit?: number, app?: AgenticWorkflowAdkModelsWorkflowAppEnum | null, options?: AxiosRequestConfig): AxiosPromise<Array<Workflow>> {
            return localVarFp.readWorkflowsV1WorkflowsGet(skip, limit, app, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger Workflow Step
         * @param {string} workflowId 
         * @param {string} stepId 
         * @param {WorkflowStepTriggerRequest} workflowStepTriggerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId: string, stepId: string, workflowStepTriggerRequest: WorkflowStepTriggerRequest, options?: AxiosRequestConfig): AxiosPromise<WorkflowStepTriggerResponse> {
            return localVarFp.triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Workflow
         * @param {string} workflowId 
         * @param {WorkflowCore} workflowCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowV1WorkflowsWorkflowIdPut(workflowId: string, workflowCore: WorkflowCore, options?: AxiosRequestConfig): AxiosPromise<Workflow> {
            return localVarFp.updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload File
         * @param {string} workflowId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1WorkflowsWorkflowIdFilePost(workflowId: string, file: File, options?: AxiosRequestConfig): AxiosPromise<UploadFileResponse> {
            return localVarFp.uploadFileV1WorkflowsWorkflowIdFilePost(workflowId, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsApi
 * @extends {BaseAPI}
 */
export class WorkflowsApi extends BaseAPI {
    /**
     * 
     * @summary Create Workflow
     * @param {WorkflowCore} workflowCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public createWorkflowV1WorkflowsPost(workflowCore: WorkflowCore, options?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).createWorkflowV1WorkflowsPost(workflowCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Workflow
     * @param {string} workflowId 
     * @param {boolean} [cascade] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId: string, cascade?: boolean, options?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).deleteWorkflowV1WorkflowsWorkflowIdDelete(workflowId, cascade, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Workflow
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public readWorkflowV1WorkflowsWorkflowIdGet(workflowId: string, options?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).readWorkflowV1WorkflowsWorkflowIdGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Workflows
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {AgenticWorkflowAdkModelsWorkflowAppEnum | null} [app] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public readWorkflowsV1WorkflowsGet(skip?: number, limit?: number, app?: AgenticWorkflowAdkModelsWorkflowAppEnum | null, options?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).readWorkflowsV1WorkflowsGet(skip, limit, app, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger Workflow Step
     * @param {string} workflowId 
     * @param {string} stepId 
     * @param {WorkflowStepTriggerRequest} workflowStepTriggerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId: string, stepId: string, workflowStepTriggerRequest: WorkflowStepTriggerRequest, options?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).triggerWorkflowStepV1WorkflowsWorkflowIdStepStepIdTriggerPost(workflowId, stepId, workflowStepTriggerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Workflow
     * @param {string} workflowId 
     * @param {WorkflowCore} workflowCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public updateWorkflowV1WorkflowsWorkflowIdPut(workflowId: string, workflowCore: WorkflowCore, options?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).updateWorkflowV1WorkflowsWorkflowIdPut(workflowId, workflowCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload File
     * @param {string} workflowId 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public uploadFileV1WorkflowsWorkflowIdFilePost(workflowId: string, file: File, options?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).uploadFileV1WorkflowsWorkflowIdFilePost(workflowId, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkflowsApiHubspotApi - axios parameter creator
 * @export
 */
export const WorkflowsApiHubspotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Handle Hubspot Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/workflows/api/hubspot/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsApiHubspotApi - functional programming interface
 * @export
 */
export const WorkflowsApiHubspotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowsApiHubspotApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Handle Hubspot Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApiHubspotApi.handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkflowsApiHubspotApi - factory interface
 * @export
 */
export const WorkflowsApiHubspotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowsApiHubspotApiFp(configuration)
    return {
        /**
         * 
         * @summary Handle Hubspot Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options?: AxiosRequestConfig): AxiosPromise<AgenticWorkflowModelsBaseBaseResponse> {
            return localVarFp.handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsApiHubspotApi - object-oriented interface
 * @export
 * @class WorkflowsApiHubspotApi
 * @extends {BaseAPI}
 */
export class WorkflowsApiHubspotApi extends BaseAPI {
    /**
     * 
     * @summary Handle Hubspot Webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApiHubspotApi
     */
    public handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options?: AxiosRequestConfig) {
        return WorkflowsApiHubspotApiFp(this.configuration).handleHubspotWebhookV1WorkflowsApiHubspotWebhookPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkflowsAppsApi - axios parameter creator
 * @export
 */
export const WorkflowsAppsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create App
         * @param {AppEntity} appEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAppV1WorkflowsAppsPost: async (appEntity: AppEntity, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appEntity' is not null or undefined
            assertParamExists('createAppV1WorkflowsAppsPost', 'appEntity', appEntity)
            const localVarPath = `/v1/workflows/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appEntity, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete App
         * @param {string} appId 
         * @param {string | null} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppV1WorkflowsAppsAppIdDelete: async (appId: string, version?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deleteAppV1WorkflowsAppsAppIdDelete', 'appId', appId)
            const localVarPath = `/v1/workflows/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Connections By App Id
         * @param {string} appId 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet: async (appId: string, version: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet', 'appId', appId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet', 'version', version)
            const localVarPath = `/v1/workflows/apps/{app_id}/versions/{version}/connections`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read App
         * @param {string} appId 
         * @param {string | null} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppV1WorkflowsAppsAppIdGet: async (appId: string, version?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('readAppV1WorkflowsAppsAppIdGet', 'appId', appId)
            const localVarPath = `/v1/workflows/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Apps
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppsV1WorkflowsAppsGet: async (skip?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/workflows/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update App
         * @param {string} appId 
         * @param {AppEntity} appEntity 
         * @param {string | null} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppV1WorkflowsAppsAppIdPut: async (appId: string, appEntity: AppEntity, version?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updateAppV1WorkflowsAppsAppIdPut', 'appId', appId)
            // verify required parameter 'appEntity' is not null or undefined
            assertParamExists('updateAppV1WorkflowsAppsAppIdPut', 'appEntity', appEntity)
            const localVarPath = `/v1/workflows/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appEntity, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsAppsApi - functional programming interface
 * @export
 */
export const WorkflowsAppsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowsAppsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create App
         * @param {AppEntity} appEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAppV1WorkflowsAppsPost(appEntity: AppEntity, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAppV1WorkflowsAppsPost(appEntity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsAppsApi.createAppV1WorkflowsAppsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete App
         * @param {string} appId 
         * @param {string | null} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAppV1WorkflowsAppsAppIdDelete(appId: string, version?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsAppsApi.deleteAppV1WorkflowsAppsAppIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Connections By App Id
         * @param {string} appId 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId: string, version: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AgenticWorkflowDbModelsConnection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsAppsApi.getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read App
         * @param {string} appId 
         * @param {string | null} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readAppV1WorkflowsAppsAppIdGet(appId: string, version?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readAppV1WorkflowsAppsAppIdGet(appId, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsAppsApi.readAppV1WorkflowsAppsAppIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read Apps
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readAppsV1WorkflowsAppsGet(skip?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AppResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readAppsV1WorkflowsAppsGet(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsAppsApi.readAppsV1WorkflowsAppsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update App
         * @param {string} appId 
         * @param {AppEntity} appEntity 
         * @param {string | null} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAppV1WorkflowsAppsAppIdPut(appId: string, appEntity: AppEntity, version?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsAppsApi.updateAppV1WorkflowsAppsAppIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkflowsAppsApi - factory interface
 * @export
 */
export const WorkflowsAppsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowsAppsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create App
         * @param {AppEntity} appEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAppV1WorkflowsAppsPost(appEntity: AppEntity, options?: AxiosRequestConfig): AxiosPromise<AppResponse> {
            return localVarFp.createAppV1WorkflowsAppsPost(appEntity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete App
         * @param {string} appId 
         * @param {string | null} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppV1WorkflowsAppsAppIdDelete(appId: string, version?: string | null, options?: AxiosRequestConfig): AxiosPromise<AgenticWorkflowModelsBaseBaseResponse> {
            return localVarFp.deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Connections By App Id
         * @param {string} appId 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId: string, version: string, options?: AxiosRequestConfig): AxiosPromise<Array<AgenticWorkflowDbModelsConnection>> {
            return localVarFp.getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read App
         * @param {string} appId 
         * @param {string | null} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppV1WorkflowsAppsAppIdGet(appId: string, version?: string | null, options?: AxiosRequestConfig): AxiosPromise<AppResponse> {
            return localVarFp.readAppV1WorkflowsAppsAppIdGet(appId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Apps
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAppsV1WorkflowsAppsGet(skip?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<AppResponse>> {
            return localVarFp.readAppsV1WorkflowsAppsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update App
         * @param {string} appId 
         * @param {AppEntity} appEntity 
         * @param {string | null} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppV1WorkflowsAppsAppIdPut(appId: string, appEntity: AppEntity, version?: string | null, options?: AxiosRequestConfig): AxiosPromise<AppResponse> {
            return localVarFp.updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsAppsApi - object-oriented interface
 * @export
 * @class WorkflowsAppsApi
 * @extends {BaseAPI}
 */
export class WorkflowsAppsApi extends BaseAPI {
    /**
     * 
     * @summary Create App
     * @param {AppEntity} appEntity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    public createAppV1WorkflowsAppsPost(appEntity: AppEntity, options?: AxiosRequestConfig) {
        return WorkflowsAppsApiFp(this.configuration).createAppV1WorkflowsAppsPost(appEntity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete App
     * @param {string} appId 
     * @param {string | null} [version] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    public deleteAppV1WorkflowsAppsAppIdDelete(appId: string, version?: string | null, options?: AxiosRequestConfig) {
        return WorkflowsAppsApiFp(this.configuration).deleteAppV1WorkflowsAppsAppIdDelete(appId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Connections By App Id
     * @param {string} appId 
     * @param {string} version 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    public getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId: string, version: string, options?: AxiosRequestConfig) {
        return WorkflowsAppsApiFp(this.configuration).getConnectionsByAppIdV1WorkflowsAppsAppIdVersionsVersionConnectionsGet(appId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read App
     * @param {string} appId 
     * @param {string | null} [version] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    public readAppV1WorkflowsAppsAppIdGet(appId: string, version?: string | null, options?: AxiosRequestConfig) {
        return WorkflowsAppsApiFp(this.configuration).readAppV1WorkflowsAppsAppIdGet(appId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Apps
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    public readAppsV1WorkflowsAppsGet(skip?: number, limit?: number, options?: AxiosRequestConfig) {
        return WorkflowsAppsApiFp(this.configuration).readAppsV1WorkflowsAppsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update App
     * @param {string} appId 
     * @param {AppEntity} appEntity 
     * @param {string | null} [version] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsAppsApi
     */
    public updateAppV1WorkflowsAppsAppIdPut(appId: string, appEntity: AppEntity, version?: string | null, options?: AxiosRequestConfig) {
        return WorkflowsAppsApiFp(this.configuration).updateAppV1WorkflowsAppsAppIdPut(appId, appEntity, version, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkflowsConnectionsApi - axios parameter creator
 * @export
 */
export const WorkflowsConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Connection
         * @param {ConnectionCore} connectionCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectionV1WorkflowsConnectionsPost: async (connectionCore: ConnectionCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionCore' is not null or undefined
            assertParamExists('createConnectionV1WorkflowsConnectionsPost', 'connectionCore', connectionCore)
            const localVarPath = `/v1/workflows/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectionCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectionV1WorkflowsConnectionsConnectionIdDelete: async (connectionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('deleteConnectionV1WorkflowsConnectionsConnectionIdDelete', 'connectionId', connectionId)
            const localVarPath = `/v1/workflows/connections/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionV1WorkflowsConnectionsConnectionIdGet: async (connectionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('readConnectionV1WorkflowsConnectionsConnectionIdGet', 'connectionId', connectionId)
            const localVarPath = `/v1/workflows/connections/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Connections
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionsV1WorkflowsConnectionsGet: async (skip?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/workflows/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Connection
         * @param {string} connectionId 
         * @param {ConnectionCore} connectionCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnectionV1WorkflowsConnectionsConnectionIdPut: async (connectionId: string, connectionCore: ConnectionCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('updateConnectionV1WorkflowsConnectionsConnectionIdPut', 'connectionId', connectionId)
            // verify required parameter 'connectionCore' is not null or undefined
            assertParamExists('updateConnectionV1WorkflowsConnectionsConnectionIdPut', 'connectionCore', connectionCore)
            const localVarPath = `/v1/workflows/connections/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectionCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsConnectionsApi - functional programming interface
 * @export
 */
export const WorkflowsConnectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowsConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Connection
         * @param {ConnectionCore} connectionCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnectionV1WorkflowsConnectionsPost(connectionCore: ConnectionCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowDbModelsConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnectionV1WorkflowsConnectionsPost(connectionCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsConnectionsApi.createConnectionV1WorkflowsConnectionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowModelsBaseBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsConnectionsApi.deleteConnectionV1WorkflowsConnectionsConnectionIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowDbModelsConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsConnectionsApi.readConnectionV1WorkflowsConnectionsConnectionIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read Connections
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readConnectionsV1WorkflowsConnectionsGet(skip?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AgenticWorkflowDbModelsConnection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readConnectionsV1WorkflowsConnectionsGet(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsConnectionsApi.readConnectionsV1WorkflowsConnectionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Connection
         * @param {string} connectionId 
         * @param {ConnectionCore} connectionCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId: string, connectionCore: ConnectionCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgenticWorkflowDbModelsConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsConnectionsApi.updateConnectionV1WorkflowsConnectionsConnectionIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkflowsConnectionsApi - factory interface
 * @export
 */
export const WorkflowsConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowsConnectionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Connection
         * @param {ConnectionCore} connectionCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectionV1WorkflowsConnectionsPost(connectionCore: ConnectionCore, options?: AxiosRequestConfig): AxiosPromise<AgenticWorkflowDbModelsConnection> {
            return localVarFp.createConnectionV1WorkflowsConnectionsPost(connectionCore, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId: string, options?: AxiosRequestConfig): AxiosPromise<AgenticWorkflowModelsBaseBaseResponse> {
            return localVarFp.deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId: string, options?: AxiosRequestConfig): AxiosPromise<AgenticWorkflowDbModelsConnection> {
            return localVarFp.readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Connections
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnectionsV1WorkflowsConnectionsGet(skip?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<AgenticWorkflowDbModelsConnection>> {
            return localVarFp.readConnectionsV1WorkflowsConnectionsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Connection
         * @param {string} connectionId 
         * @param {ConnectionCore} connectionCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId: string, connectionCore: ConnectionCore, options?: AxiosRequestConfig): AxiosPromise<AgenticWorkflowDbModelsConnection> {
            return localVarFp.updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsConnectionsApi - object-oriented interface
 * @export
 * @class WorkflowsConnectionsApi
 * @extends {BaseAPI}
 */
export class WorkflowsConnectionsApi extends BaseAPI {
    /**
     * 
     * @summary Create Connection
     * @param {ConnectionCore} connectionCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    public createConnectionV1WorkflowsConnectionsPost(connectionCore: ConnectionCore, options?: AxiosRequestConfig) {
        return WorkflowsConnectionsApiFp(this.configuration).createConnectionV1WorkflowsConnectionsPost(connectionCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Connection
     * @param {string} connectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    public deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId: string, options?: AxiosRequestConfig) {
        return WorkflowsConnectionsApiFp(this.configuration).deleteConnectionV1WorkflowsConnectionsConnectionIdDelete(connectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Connection
     * @param {string} connectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    public readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId: string, options?: AxiosRequestConfig) {
        return WorkflowsConnectionsApiFp(this.configuration).readConnectionV1WorkflowsConnectionsConnectionIdGet(connectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Connections
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    public readConnectionsV1WorkflowsConnectionsGet(skip?: number, limit?: number, options?: AxiosRequestConfig) {
        return WorkflowsConnectionsApiFp(this.configuration).readConnectionsV1WorkflowsConnectionsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Connection
     * @param {string} connectionId 
     * @param {ConnectionCore} connectionCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsConnectionsApi
     */
    public updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId: string, connectionCore: ConnectionCore, options?: AxiosRequestConfig) {
        return WorkflowsConnectionsApiFp(this.configuration).updateConnectionV1WorkflowsConnectionsConnectionIdPut(connectionId, connectionCore, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkflowsExecutionsApi - axios parameter creator
 * @export
 */
export const WorkflowsExecutionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Execute a workflow. This is an Sync call. This returns the status of the workflow
         * @summary Execute Workflow
         * @param {string} workflowId 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost: async (workflowId: string, requestBody: { [key: string]: any; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost', 'workflowId', workflowId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost', 'requestBody', requestBody)
            const localVarPath = `/v1/workflows/executions/{workflow_id}/execute`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status of a workflow given the run id
         * @summary Get Workflow Status
         * @param {string} runId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet: async (runId: string, workflowId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet', 'runId', runId)
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet', 'workflowId', workflowId)
            const localVarPath = `/v1/workflows/executions/{workflow_id}/runs/{run_id}`
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)))
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Workflow Runs
         * @param {string} workflowId 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet: async (workflowId: string, skip?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet', 'workflowId', workflowId)
            const localVarPath = `/v1/workflows/executions/{workflow_id}/runs`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger a workflow execution. This is an Async call. This returns a workflow id which can be queried to get the status of the workflow
         * @summary Trigger Workflow
         * @param {string} workflowId 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost: async (workflowId: string, requestBody?: { [key: string]: any; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost', 'workflowId', workflowId)
            const localVarPath = `/v1/workflows/executions/{workflow_id}/trigger`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsExecutionsApi - functional programming interface
 * @export
 */
export const WorkflowsExecutionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowsExecutionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Execute a workflow. This is an Sync call. This returns the status of the workflow
         * @summary Execute Workflow
         * @param {string} workflowId 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId: string, requestBody: { [key: string]: any; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowExecution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsExecutionsApi.executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the status of a workflow given the run id
         * @summary Get Workflow Status
         * @param {string} runId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId: string, workflowId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowExecution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsExecutionsApi.getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Workflow Runs
         * @param {string} workflowId 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId: string, skip?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowExecution>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsExecutionsApi.listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Trigger a workflow execution. This is an Async call. This returns a workflow id which can be queried to get the status of the workflow
         * @summary Trigger Workflow
         * @param {string} workflowId 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId: string, requestBody?: { [key: string]: any; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowExecution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsExecutionsApi.triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkflowsExecutionsApi - factory interface
 * @export
 */
export const WorkflowsExecutionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowsExecutionsApiFp(configuration)
    return {
        /**
         * Execute a workflow. This is an Sync call. This returns the status of the workflow
         * @summary Execute Workflow
         * @param {string} workflowId 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId: string, requestBody: { [key: string]: any; }, options?: AxiosRequestConfig): AxiosPromise<WorkflowExecution> {
            return localVarFp.executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status of a workflow given the run id
         * @summary Get Workflow Status
         * @param {string} runId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId: string, workflowId: string, options?: AxiosRequestConfig): AxiosPromise<WorkflowExecution> {
            return localVarFp.getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Workflow Runs
         * @param {string} workflowId 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId: string, skip?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<WorkflowExecution>> {
            return localVarFp.listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger a workflow execution. This is an Async call. This returns a workflow id which can be queried to get the status of the workflow
         * @summary Trigger Workflow
         * @param {string} workflowId 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId: string, requestBody?: { [key: string]: any; }, options?: AxiosRequestConfig): AxiosPromise<WorkflowExecution> {
            return localVarFp.triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsExecutionsApi - object-oriented interface
 * @export
 * @class WorkflowsExecutionsApi
 * @extends {BaseAPI}
 */
export class WorkflowsExecutionsApi extends BaseAPI {
    /**
     * Execute a workflow. This is an Sync call. This returns the status of the workflow
     * @summary Execute Workflow
     * @param {string} workflowId 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsExecutionsApi
     */
    public executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId: string, requestBody: { [key: string]: any; }, options?: AxiosRequestConfig) {
        return WorkflowsExecutionsApiFp(this.configuration).executeWorkflowV1WorkflowsExecutionsWorkflowIdExecutePost(workflowId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the status of a workflow given the run id
     * @summary Get Workflow Status
     * @param {string} runId 
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsExecutionsApi
     */
    public getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId: string, workflowId: string, options?: AxiosRequestConfig) {
        return WorkflowsExecutionsApiFp(this.configuration).getWorkflowStatusV1WorkflowsExecutionsWorkflowIdRunsRunIdGet(runId, workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Workflow Runs
     * @param {string} workflowId 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsExecutionsApi
     */
    public listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId: string, skip?: number, limit?: number, options?: AxiosRequestConfig) {
        return WorkflowsExecutionsApiFp(this.configuration).listWorkflowRunsV1WorkflowsExecutionsWorkflowIdRunsGet(workflowId, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger a workflow execution. This is an Async call. This returns a workflow id which can be queried to get the status of the workflow
     * @summary Trigger Workflow
     * @param {string} workflowId 
     * @param {{ [key: string]: any; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsExecutionsApi
     */
    public triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId: string, requestBody?: { [key: string]: any; }, options?: AxiosRequestConfig) {
        return WorkflowsExecutionsApiFp(this.configuration).triggerWorkflowV1WorkflowsExecutionsWorkflowIdTriggerPost(workflowId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkflowsSubWorkflowsApi - axios parameter creator
 * @export
 */
export const WorkflowsSubWorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all sub workflows which can be invoked for a given workflow step
         * @summary Get Sub Workflows
         * @param {WorkflowStepInput} workflowStepInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost: async (workflowStepInput: WorkflowStepInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowStepInput' is not null or undefined
            assertParamExists('getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost', 'workflowStepInput', workflowStepInput)
            const localVarPath = `/v1/workflows/steps/sub_workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowStepInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsSubWorkflowsApi - functional programming interface
 * @export
 */
export const WorkflowsSubWorkflowsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowsSubWorkflowsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all sub workflows which can be invoked for a given workflow step
         * @summary Get Sub Workflows
         * @param {WorkflowStepInput} workflowStepInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput: WorkflowStepInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workflow>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsSubWorkflowsApi.getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkflowsSubWorkflowsApi - factory interface
 * @export
 */
export const WorkflowsSubWorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowsSubWorkflowsApiFp(configuration)
    return {
        /**
         * Returns all sub workflows which can be invoked for a given workflow step
         * @summary Get Sub Workflows
         * @param {WorkflowStepInput} workflowStepInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput: WorkflowStepInput, options?: AxiosRequestConfig): AxiosPromise<Array<Workflow>> {
            return localVarFp.getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsSubWorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsSubWorkflowsApi
 * @extends {BaseAPI}
 */
export class WorkflowsSubWorkflowsApi extends BaseAPI {
    /**
     * Returns all sub workflows which can be invoked for a given workflow step
     * @summary Get Sub Workflows
     * @param {WorkflowStepInput} workflowStepInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsSubWorkflowsApi
     */
    public getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput: WorkflowStepInput, options?: AxiosRequestConfig) {
        return WorkflowsSubWorkflowsApiFp(this.configuration).getSubWorkflowsV1WorkflowsStepsSubWorkflowsPost(workflowStepInput, options).then((request) => request(this.axios, this.basePath));
    }
}



