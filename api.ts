// tslint:disable
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AIAgentInput
 */
export interface AIAgentInput {
    /**
     * Name of the AI agent
     * @type {string}
     * @memberof AIAgentInput
     */
    name: string;
    /**
     * Image URL for the AI agent
     * @type {string}
     * @memberof AIAgentInput
     */
    imageUrl: string;
    /**
     * Mission of the AI agent
     * @type {Mission}
     * @memberof AIAgentInput
     */
    mission?: Mission | null;
    /**
     * Status of the AI agent
     * @type {Status}
     * @memberof AIAgentInput
     */
    status: Status;
    /**
     * Role of the AI agent in the company
     * @type {string}
     * @memberof AIAgentInput
     */
    role: string;
    /**
     * Description of the role of the AI agent
     * @type {string}
     * @memberof AIAgentInput
     */
    roleDescription: string;
    /**
     * Timezone of the AI agent used for scheduling meetings
     * @type {string}
     * @memberof AIAgentInput
     */
    timezone: string;
    /**
     * Voice of the AI agent
     * @type {VoiceInput}
     * @memberof AIAgentInput
     */
    voice?: VoiceInput | null;
}
/**
 * AI agent configured by businesses
 * @export
 * @interface AIAgentOutput
 */
export interface AIAgentOutput {
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    imageUrl?: string;
    /**
     * 
     * @type {Mission}
     * @memberof AIAgentOutput
     */
    mission?: Mission | null;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    roleDescription?: string;
    /**
     * 
     * @type {Transcriber}
     * @memberof AIAgentOutput
     */
    transcriber?: Transcriber | null;
    /**
     * 
     * @type {IntelligenceProvider}
     * @memberof AIAgentOutput
     */
    intelligenceProvider?: IntelligenceProvider | null;
    /**
     * 
     * @type {VoiceOutput}
     * @memberof AIAgentOutput
     */
    voice?: VoiceOutput | null;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    timezone?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Accent {
    American = 'American',
    Indian = 'Indian',
    Australian = 'Australian',
    British = 'British'
}

/**
 * 
 * @export
 * @interface ActionInput
 */
export interface ActionInput {
    /**
     * Name of the action
     * @type {string}
     * @memberof ActionInput
     */
    name: string;
    /**
     * Description about the action and it should also contain when the action should be triggered
     * @type {string}
     * @memberof ActionInput
     */
    description: string;
    /**
     * Parameters for the action. It should be a JSON schema object
     * @type {object}
     * @memberof ActionInput
     */
    parameters: object;
    /**
     * Endpoint for the action
     * @type {HttpActionEndpoint | InternalActionEndpoint}
     * @memberof ActionInput
     */
    endpoint: HttpActionEndpoint | InternalActionEndpoint;
    /**
     * Text to be rendered to user when action is invoked
     * @type {string}
     * @memberof ActionInput
     */
    userWaitingText?: string | null;
    /**
     * Text to be rendered to user when action is successful
     * @type {string}
     * @memberof ActionInput
     */
    userSuccessText?: string | null;
    /**
     * Text to be rendered to user when action is not successful
     * @type {string}
     * @memberof ActionInput
     */
    userErrorText?: string | null;
    /**
     * Trigger who invokes the action
     * @type {ActionInvocationTrigger}
     * @memberof ActionInput
     */
    invocationTrigger: ActionInvocationTrigger;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ActionInvocationTrigger {
    UserQuery = 'user_query',
    WebhookConversationStart = 'webhook.conversation_start',
    WebhookConversationEnd = 'webhook.conversation_end'
}

/**
 * 
 * @export
 * @interface AddressInput
 */
export interface AddressInput {
    /**
     * Address line 1
     * @type {string}
     * @memberof AddressInput
     */
    line1: string;
    /**
     * Address line 2
     * @type {string}
     * @memberof AddressInput
     */
    line2?: string | null;
    /**
     * City
     * @type {string}
     * @memberof AddressInput
     */
    city?: string | null;
    /**
     * State
     * @type {string}
     * @memberof AddressInput
     */
    state?: string | null;
    /**
     * Country
     * @type {string}
     * @memberof AddressInput
     */
    country: string;
}
/**
 * 
 * @export
 * @interface AddressOutput
 */
export interface AddressOutput {
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    line1: string;
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    line2: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    city: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    state: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    country: string | null;
}
/**
 * 
 * @export
 * @interface AgentConfig
 */
export interface AgentConfig {
    /**
     * Enum class representing transcriber
     * @type {string}
     * @memberof AgentConfig
     */
    transcriber: string;
    /**
     * Enum class representing intelligence provider
     * @type {string}
     * @memberof AgentConfig
     */
    intelligenceProvider: string;
    /**
     * 
     * @type {string}
     * @memberof AgentConfig
     */
    synthesizer: string;
    /**
     * 
     * @type {string}
     * @memberof AgentConfig
     */
    embeddingsModelConfig: string;
    /**
     * 
     * @type {string}
     * @memberof AgentConfig
     */
    hiveStorageConfig: string;
    /**
     * 
     * @type {string}
     * @memberof AgentConfig
     */
    fillersConfig?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum AggregationFormula {
    COUNT = 'COUNT',
    SUM = 'SUM',
    MEDIAN = 'MEDIAN'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum AggregationPeriod {
    MONTHLY = 'MONTHLY',
    WEEKLY = 'WEEKLY',
    DAILY = 'DAILY'
}

/**
 * Action entity to store the actions which can be performed by ai agents
 * @export
 * @interface BackendDbModelsAction
 */
export interface BackendDbModelsAction {
    /**
     * 
     * @type {string}
     * @memberof BackendDbModelsAction
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof BackendDbModelsAction
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof BackendDbModelsAction
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof BackendDbModelsAction
     */
    description?: string;
    /**
     * 
     * @type {object}
     * @memberof BackendDbModelsAction
     */
    parameters?: object | null;
    /**
     * 
     * @type {object}
     * @memberof BackendDbModelsAction
     */
    endpoint?: object | null;
    /**
     * 
     * @type {string}
     * @memberof BackendDbModelsAction
     */
    invocationTrigger?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BackendDbModelsAction
     */
    userWaitingText?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BackendDbModelsAction
     */
    userSuccessText?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BackendDbModelsAction
     */
    userErrorText?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BackendDbModelsAction
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof BackendDbModelsAction
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof BackendDbModelsAction
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof BackendDbModelsAction
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface BackendDbModelsHiveContent
 */
export interface BackendDbModelsHiveContent {
    /**
     * 
     * @type {HiveType}
     * @memberof BackendDbModelsHiveContent
     */
    hiveType: HiveType;
    /**
     * URL of the content
     * @type {string}
     * @memberof BackendDbModelsHiveContent
     */
    url?: string | null;
    /**
     * List of files to be referenced for the hive
     * @type {Array<Files>}
     * @memberof BackendDbModelsHiveContent
     */
    files?: Array<Files> | null;
    /**
     * To recursively crawl child pages, add this as props {\"crawl_child_pages\": true},  \"depth\": \"3\"
     * @type {object}
     * @memberof BackendDbModelsHiveContent
     */
    hiveProps?: object | null;
    /**
     * To add any internal props, add this as props {\"last_crawl_time\": \"123123123123\"}
     * @type {object}
     * @memberof BackendDbModelsHiveContent
     */
    internalProps?: object | null;
}
/**
 * 
 * @export
 * @interface BackendDtoModelsAction
 */
export interface BackendDtoModelsAction {
    /**
     * Name of the action
     * @type {string}
     * @memberof BackendDtoModelsAction
     */
    name: string;
    /**
     * Description about the action and it should also contain when the action should be triggered
     * @type {string}
     * @memberof BackendDtoModelsAction
     */
    description: string;
    /**
     * Parameters for the action. It should be a JSON schema object
     * @type {object}
     * @memberof BackendDtoModelsAction
     */
    parameters: object;
    /**
     * Endpoint for the action
     * @type {HttpActionEndpoint | InternalActionEndpoint}
     * @memberof BackendDtoModelsAction
     */
    endpoint: HttpActionEndpoint | InternalActionEndpoint;
    /**
     * Text to be rendered to user when action is invoked
     * @type {string}
     * @memberof BackendDtoModelsAction
     */
    userWaitingText?: string | null;
    /**
     * Text to be rendered to user when action is successful
     * @type {string}
     * @memberof BackendDtoModelsAction
     */
    userSuccessText?: string | null;
    /**
     * Text to be rendered to user when action is not successful
     * @type {string}
     * @memberof BackendDtoModelsAction
     */
    userErrorText?: string | null;
    /**
     * Trigger who invokes the action
     * @type {ActionInvocationTrigger}
     * @memberof BackendDtoModelsAction
     */
    invocationTrigger: ActionInvocationTrigger;
}
/**
 * 
 * @export
 * @interface BackendDtoModelsHiveContent
 */
export interface BackendDtoModelsHiveContent {
    /**
     * 
     * @type {HiveType}
     * @memberof BackendDtoModelsHiveContent
     */
    hiveType: HiveType;
    /**
     * URL of the content
     * @type {string}
     * @memberof BackendDtoModelsHiveContent
     */
    url?: string | null;
    /**
     * List of file ids to be referenced for the hive
     * @type {Array<string>}
     * @memberof BackendDtoModelsHiveContent
     */
    file_ids?: Array<string> | null;
    /**
     * To recursively crawl child pages, add this as props {\"crawl_child_pages\": true},  \"depth\": \"3\"
     * @type {object}
     * @memberof BackendDtoModelsHiveContent
     */
    hiveProps?: object | null;
}
/**
 * 
 * @export
 * @interface BaseResponse
 */
export interface BaseResponse {
    /**
     * Address line 1
     * @type {string}
     * @memberof BaseResponse
     */
    message: string;
}
/**
 * 
 * @export
 * @interface BatchMetricsRequests
 */
export interface BatchMetricsRequests {
    /**
     * 
     * @type {Array<MetricsRequest>}
     * @memberof BatchMetricsRequests
     */
    requests: Array<MetricsRequest>;
}
/**
 * 
 * @export
 * @interface BatchMetricsResponse
 */
export interface BatchMetricsResponse {
    /**
     * 
     * @type {Array<MetricsResponse>}
     * @memberof BatchMetricsResponse
     */
    responses: Array<MetricsResponse>;
}
/**
 * 
 * @export
 * @interface BodyCreateOrganizationV1
 */
export interface BodyCreateOrganizationV1 {
    /**
     * 
     * @type {OrganizationInput}
     * @memberof BodyCreateOrganizationV1
     */
    org: OrganizationInput;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateOrganizationV1
     */
    adminUserName: string;
}
/**
 * 
 * @export
 * @interface BodyUploadFileV1
 */
export interface BodyUploadFileV1 {
    /**
     * 
     * @type {Array<any>}
     * @memberof BodyUploadFileV1
     */
    files: Array<any>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CallSentiment {
    Positive = 'positive',
    Negative = 'negative',
    Neutral = 'neutral'
}

/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * Notes or comments to record
     * @type {string}
     * @memberof Comment
     */
    comment: string;
    /**
     * Star rating to record
     * @type {number}
     * @memberof Comment
     */
    rating: number;
}
/**
 * This represents the connection between the user and the assistant
 * @export
 * @interface Connection
 */
export interface Connection {
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    sourceName?: string;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    sourceId?: string;
    /**
     * 
     * @type {object}
     * @memberof Connection
     */
    sourceProps?: object | null;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    agentId?: string;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    prospectId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface ConnectionSource
 */
export interface ConnectionSource {
    /**
     * Name of the source
     * @type {string}
     * @memberof ConnectionSource
     */
    sourceName?: ConnectionSourceSourceNameEnum;
    /**
     * Unique identifier for the source
     * @type {string}
     * @memberof ConnectionSource
     */
    sourceId: string;
    /**
     * Extra properties of source
     * @type {object}
     * @memberof ConnectionSource
     */
    sourceProps: object;
}

/**
    * @export
    * @enum {string}
    */
export enum ConnectionSourceSourceNameEnum {
    TWILIO = 'TWILIO',
    BROWSER = 'BROWSER'
}

/**
 * Expected output of the post conversation task
 * @export
 * @interface ConversationAnalyticsModel
 */
export interface ConversationAnalyticsModel {
    /**
     * Summary of the conversation happened with important details on the conversation.
     * @type {string}
     * @memberof ConversationAnalyticsModel
     */
    summary: string;
    /**
     * List of action items and the next steps to be performed from the conversation details.
     * @type {Array<string>}
     * @memberof ConversationAnalyticsModel
     */
    action_items: Array<string> | null;
    /**
     * If the user has given consent to store the audio of the conversation.
     * @type {boolean}
     * @memberof ConversationAnalyticsModel
     */
    is_audio_consent_given: boolean;
    /**
     * Extracted email address of the caller from the conversation details.
     * @type {string}
     * @memberof ConversationAnalyticsModel
     */
    email_address_of_caller: string | null;
    /**
     * Extracted name of the caller from the conversation details.
     * @type {string}
     * @memberof ConversationAnalyticsModel
     */
    name_of_caller: string | null;
    /**
     * Extracted phone number of the caller from the conversation details.
     * @type {string}
     * @memberof ConversationAnalyticsModel
     */
    phone_number_of_caller: string | null;
    /**
     * Extracted address of the caller from the conversation details.
     * @type {string}
     * @memberof ConversationAnalyticsModel
     */
    address_of_caller: string | null;
    /**
     * Sentiment of the caller based on the conversation details.
     * @type {CallSentiment}
     * @memberof ConversationAnalyticsModel
     */
    sentiment_of_caller: CallSentiment;
    /**
     * Status of the prospect after this conversation.
     * @type {ProspectStatus}
     * @memberof ConversationAnalyticsModel
     */
    prospectStatus: ProspectStatus | null;
}
/**
 * Any feedback added to the conversation by business is managed here.
 * @export
 * @interface ConversationFeedback
 */
export interface ConversationFeedback {
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    conversationId?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    feedback?: string;
    /**
     * 
     * @type {number}
     * @memberof ConversationFeedback
     */
    rating?: number;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface ConversationInput
 */
export interface ConversationInput {
    /**
     * Source from where the conversation originated. This can be device id, phone number, etc.
     * @type {string}
     * @memberof ConversationInput
     */
    source: string;
    /**
     * Type of the conversation source
     * @type {ConversationSourceType}
     * @memberof ConversationInput
     */
    sourceType: ConversationSourceType;
    /**
     * AI agent which handled the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    agentId: string;
    /**
     * URL to the full transcript of the conversation
     * @type {Array<DialogLine>}
     * @memberof ConversationInput
     */
    transcriptText?: Array<DialogLine> | null;
    /**
     * Summary of the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    transcriptSummary?: string | null;
    /**
     * URL to the recording of the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    transcriptRecordingUrl?: string | null;
    /**
     * Start time of the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    timestampStart: string;
    /**
     * End time of the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    timestampEnd?: string | null;
    /**
     * Analytics of the conversation
     * @type {ConversationAnalyticsModel}
     * @memberof ConversationInput
     */
    conversationAnalytics?: ConversationAnalyticsModel | null;
    /**
     * Comments from the admin on the conversation
     * @type {Array<Comment>}
     * @memberof ConversationInput
     */
    adminComments?: Array<Comment> | null;
}
/**
 * Any conversation happening between the end user and assistant is stored in this table
 * @export
 * @interface ConversationOutput
 */
export interface ConversationOutput {
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    prospectId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    source?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    sourceType?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    aiAgentId?: string;
    /**
     * 
     * @type {Array<DialogLine>}
     * @memberof ConversationOutput
     */
    transcriptText?: Array<DialogLine> | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    transcriptSummary?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    transcriptRecordingUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    timestampStart?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    timestampEnd?: string | null;
    /**
     * Analytics of the conversation
     * @type {ConversationAnalyticsModel}
     * @memberof ConversationOutput
     */
    conversationAnalytics?: ConversationAnalyticsModel | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ConversationSourceType {
    BROWSER = 'BROWSER',
    TWILIO = 'TWILIO'
}

/**
 * 
 * @export
 * @interface DialogLine
 */
export interface DialogLine {
    /**
     * 
     * @type {string}
     * @memberof DialogLine
     */
    speaker: string;
    /**
     * 
     * @type {string}
     * @memberof DialogLine
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof DialogLine
     */
    timestamp: string;
    /**
     * 
     * @type {string}
     * @memberof DialogLine
     */
    message_id: string;
}
/**
 * 
 * @export
 * @interface ExternalReference
 */
export interface ExternalReference {
    /**
     * External service provider name
     * @type {string}
     * @memberof ExternalReference
     */
    providerName: string;
    /**
     * External service identifier
     * @type {string}
     * @memberof ExternalReference
     */
    id: string;
    /**
     * Props for the external reference
     * @type {any}
     * @memberof ExternalReference
     */
    providerProps?: any | null;
}
/**
 * 
 * @export
 * @interface ExternalServicePorviderInput
 */
export interface ExternalServicePorviderInput {
    /**
     * External service provider name
     * @type {string}
     * @memberof ExternalServicePorviderInput
     */
    providerName: string;
    /**
     * External service identifier
     * @type {string}
     * @memberof ExternalServicePorviderInput
     */
    id: string;
    /**
     * Props for the external service provider
     * @type {object}
     * @memberof ExternalServicePorviderInput
     */
    providerProps: object | null;
}
/**
 * 
 * @export
 * @interface ExternalServicePorviderOutput
 */
export interface ExternalServicePorviderOutput {
    /**
     * 
     * @type {string}
     * @memberof ExternalServicePorviderOutput
     */
    providerName: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalServicePorviderOutput
     */
    id: string;
    /**
     * 
     * @type {object}
     * @memberof ExternalServicePorviderOutput
     */
    providerProps: object | null;
}
/**
 * Stores the map of file id with respective file URL in storage manager
 * @export
 * @interface Files
 */
export interface Files {
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    fileName?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    fileUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    updatedAt?: string;
}
/**
 * Guest users who are not verified by Trata yet
 * @export
 * @interface GuestInput
 */
export interface GuestInput {
    /**
     * 
     * @type {string}
     * @memberof GuestInput
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof GuestInput
     */
    role: string;
}
/**
 * Guest users who are not verified by Trata yet. They will not be able to use Trata until they are verified.
 * @export
 * @interface GuestOutput
 */
export interface GuestOutput {
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    role?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GuestOutput
     */
    isEmailVerified?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * Reference to all business knowledge base will be stored in Hive
 * @export
 * @interface Hive
 */
export interface Hive {
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    orgId?: string;
    /**
     * 
     * @type {HiveContentOutput}
     * @memberof Hive
     */
    content: HiveContentOutput;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface HiveContentOutput
 */
export interface HiveContentOutput {
    /**
     * 
     * @type {HiveType}
     * @memberof HiveContentOutput
     */
    hiveType: HiveType;
    /**
     * URL of the content
     * @type {string}
     * @memberof HiveContentOutput
     */
    url?: string | null;
    /**
     * List of files to be referenced for the hive
     * @type {Array<Files>}
     * @memberof HiveContentOutput
     */
    files?: Array<Files> | null;
    /**
     * To recursively crawl child pages, add this as props {\"crawl_child_pages\": true},  \"depth\": \"3\"
     * @type {object}
     * @memberof HiveContentOutput
     */
    hiveProps?: object | null;
    /**
     * To add any internal props, add this as props {\"last_crawl_time\": \"123123123123\"}
     * @type {object}
     * @memberof HiveContentOutput
     */
    internalProps?: object | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum HiveType {
    WEBSITE = 'WEBSITE',
    GOOGLEDOCS = 'GOOGLE_DOCS',
    DOCS = 'DOCS',
    TRANSCRIPTS = 'TRANSCRIPTS'
}

/**
 * 
 * @export
 * @interface HttpActionEndpoint
 */
export interface HttpActionEndpoint {
    /**
     * Action endpoint URL
     * @type {string}
     * @memberof HttpActionEndpoint
     */
    url: string;
    /**
     * Method to be used for invoking the endpoint
     * @type {string}
     * @memberof HttpActionEndpoint
     */
    method?: HttpActionEndpointMethodEnum;
    /**
     * Headers for the endpoint
     * @type {any}
     * @memberof HttpActionEndpoint
     */
    headers?: any | null;
    /**
     * Payload for the endpoint
     * @type {object}
     * @memberof HttpActionEndpoint
     */
    payload?: object | null;
}

/**
    * @export
    * @enum {string}
    */
export enum HttpActionEndpointMethodEnum {
    GET = 'GET',
    POST = 'POST'
}

/**
 * 
 * @export
 * @interface IntelligenceProvider
 */
export interface IntelligenceProvider {
    /**
     * 
     * @type {string}
     * @memberof IntelligenceProvider
     */
    providerName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IntelligenceProvider
     */
    model?: string | null;
    /**
     * 
     * @type {object}
     * @memberof IntelligenceProvider
     */
    providerProps?: object | null;
}
/**
 * Internal action endpoint to be used for calling the action inside the module. Not used by external users
 * @export
 * @interface InternalActionEndpoint
 */
export interface InternalActionEndpoint {
    /**
     * Module where the action is defined
     * @type {string}
     * @memberof InternalActionEndpoint
     */
    module: string;
    /**
     * Function to be called inside the module
     * @type {string}
     * @memberof InternalActionEndpoint
     */
    _function: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Language {
    English = 'English',
    Spanish = 'Spanish'
}

/**
 * 
 * @export
 * @interface LanguageAccentCombo
 */
export interface LanguageAccentCombo {
    /**
     * 
     * @type {Language}
     * @memberof LanguageAccentCombo
     */
    language: Language;
    /**
     * 
     * @type {Accent}
     * @memberof LanguageAccentCombo
     */
    accent: Accent;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MetricName {
    CALLS = 'CALLS',
    CALLDURATION = 'CALL_DURATION',
    APPOINTMENTSCHEDULED = 'APPOINTMENT_SCHEDULED',
    PROSPECTS = 'PROSPECTS',
    INTERESTED = 'INTERESTED',
    NOTINTERESTED = 'NOT_INTERESTED'
}

/**
 * 
 * @export
 * @interface MetricResponseDataPoint
 */
export interface MetricResponseDataPoint {
    /**
     * Timestamp of the data point
     * @type {string}
     * @memberof MetricResponseDataPoint
     */
    timestamp: string;
    /**
     * Value which will be a string representation of integer or floating number
     * @type {string}
     * @memberof MetricResponseDataPoint
     */
    value: string;
}
/**
 * 
 * @export
 * @interface MetricsRequest
 */
export interface MetricsRequest {
    /**
     * Unique identifier for the metric request. This can be helped to co-relate the request and response
     * @type {string}
     * @memberof MetricsRequest
     */
    id: string;
    /**
     * Name of the metric
     * @type {MetricName}
     * @memberof MetricsRequest
     */
    name: MetricName;
    /**
     * Start date to get metric request
     * @type {string}
     * @memberof MetricsRequest
     */
    fromDate: string;
    /**
     * End date until get metric request
     * @type {string}
     * @memberof MetricsRequest
     */
    toDate: string;
    /**
     * Aggregation period for the metric request
     * @type {AggregationPeriod}
     * @memberof MetricsRequest
     */
    aggregationPeriod: AggregationPeriod;
    /**
     * Aggregation formula for the metric request
     * @type {AggregationFormula}
     * @memberof MetricsRequest
     */
    aggregationFormula: AggregationFormula;
}
/**
 * 
 * @export
 * @interface MetricsResponse
 */
export interface MetricsResponse {
    /**
     * Unique identifier for the metric response. This will help co-relate the request and response
     * @type {string}
     * @memberof MetricsResponse
     */
    id: string;
    /**
     * Name of the metric
     * @type {MetricName}
     * @memberof MetricsResponse
     */
    name: MetricName;
    /**
     * List of data points for the metric response
     * @type {Array<MetricResponseDataPoint>}
     * @memberof MetricsResponse
     */
    datapoints: Array<MetricResponseDataPoint>;
}
/**
 * 
 * @export
 * @interface Mission
 */
export interface Mission {
    /**
     * Prompt instructions for LLM model
     * @type {string}
     * @memberof Mission
     */
    prompt: string;
    /**
     * Greeting message to be read by the AI agent
     * @type {string}
     * @memberof Mission
     */
    greeting: string | null;
    /**
     * Sequence of actions to be performed by the AI agent during the conversation.
     * @type {Array<Sequence>}
     * @memberof Mission
     */
    sequence?: Array<Sequence> | null;
    /**
     * Conclusion message to be read by the AI agent
     * @type {string}
     * @memberof Mission
     */
    farewell?: string | null;
}
/**
 * Organization represents the business using Trata and all users are associated to this business entity
 * @export
 * @interface OrganizationInput
 */
export interface OrganizationInput {
    /**
     * Name of the organization
     * @type {string}
     * @memberof OrganizationInput
     */
    name: string;
    /**
     * Address of the organization
     * @type {AddressInput}
     * @memberof OrganizationInput
     */
    address?: AddressInput | null;
    /**
     * Tax details of the organization
     * @type {TaxDetailsInput}
     * @memberof OrganizationInput
     */
    tax?: TaxDetailsInput | null;
    /**
     * External references for the organization
     * @type {Array<ExternalServicePorviderInput>}
     * @memberof OrganizationInput
     */
    externalReferenceIds?: Array<ExternalServicePorviderInput> | null;
    /**
     * Configurations for all the agents going to be created in this org
     * @type {AgentConfig}
     * @memberof OrganizationInput
     */
    agentConfig?: AgentConfig | null;
}
/**
 * Organization represents the business using Trata and all users are associated to this business entity
 * @export
 * @interface OrganizationOutput
 */
export interface OrganizationOutput {
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    name?: string;
    /**
     * 
     * @type {AgentConfig}
     * @memberof OrganizationOutput
     */
    config: AgentConfig;
    /**
     * 
     * @type {AddressOutput}
     * @memberof OrganizationOutput
     */
    address: AddressOutput | null;
    /**
     * 
     * @type {TaxDetailsOutput}
     * @memberof OrganizationOutput
     */
    tax: TaxDetailsOutput | null;
    /**
     * 
     * @type {Array<ExternalServicePorviderOutput>}
     * @memberof OrganizationOutput
     */
    externalReferenceIds: Array<ExternalServicePorviderOutput> | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface ProductInput
 */
export interface ProductInput {
    /**
     * Product is active or not
     * @type {boolean}
     * @memberof ProductInput
     */
    active: boolean;
    /**
     * Default price of the product this is represented in the lowest currency denomination. Eg: 1000 for $10
     * @type {number}
     * @memberof ProductInput
     */
    defaultPrice: number;
    /**
     * Currency of the product
     * @type {string}
     * @memberof ProductInput
     */
    currency: ProductInputCurrencyEnum;
    /**
     * Description of the product
     * @type {string}
     * @memberof ProductInput
     */
    description: string;
    /**
     * Name of the product
     * @type {string}
     * @memberof ProductInput
     */
    name: string;
    /**
     * Product is shippable or not. Service is not shippable
     * @type {boolean}
     * @memberof ProductInput
     */
    shippable?: boolean;
    /**
     * List of features of the product
     * @type {Array<string>}
     * @memberof ProductInput
     */
    features?: Array<string> | null;
    /**
     * Product requires appointment scheduling or not
     * @type {boolean}
     * @memberof ProductInput
     */
    scheduleAppointment?: boolean;
    /**
     * Properties of the product
     * @type {any}
     * @memberof ProductInput
     */
    props?: any | null;
    /**
     * Tags for the product. This is used for grouping purpose. Eg: [\"gardening\", \"tools\"]
     * @type {Array<string>}
     * @memberof ProductInput
     */
    tags?: Array<string> | null;
    /**
     * 
     * @type {Status}
     * @memberof ProductInput
     */
    status: Status;
    /**
     * List of agent ids which are accessible for this product
     * @type {Array<string>}
     * @memberof ProductInput
     */
    agentIds?: Array<string> | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ProductInputCurrencyEnum {
    AED = 'AED',
    AFN = 'AFN',
    ALL = 'ALL',
    AMD = 'AMD',
    ANG = 'ANG',
    AOA = 'AOA',
    ARS = 'ARS',
    AUD = 'AUD',
    AWG = 'AWG',
    AZN = 'AZN',
    BAM = 'BAM',
    BBD = 'BBD',
    BDT = 'BDT',
    BGN = 'BGN',
    BHD = 'BHD',
    BIF = 'BIF',
    BMD = 'BMD',
    BND = 'BND',
    BOB = 'BOB',
    BOV = 'BOV',
    BRL = 'BRL',
    BSD = 'BSD',
    BTN = 'BTN',
    BWP = 'BWP',
    BYN = 'BYN',
    BZD = 'BZD',
    CAD = 'CAD',
    CDF = 'CDF',
    CHE = 'CHE',
    CHF = 'CHF',
    CHW = 'CHW',
    CLF = 'CLF',
    CLP = 'CLP',
    CNY = 'CNY',
    COP = 'COP',
    COU = 'COU',
    CRC = 'CRC',
    CUC = 'CUC',
    CUP = 'CUP',
    CVE = 'CVE',
    CZK = 'CZK',
    DJF = 'DJF',
    DKK = 'DKK',
    DOP = 'DOP',
    DZD = 'DZD',
    EGP = 'EGP',
    ERN = 'ERN',
    ETB = 'ETB',
    EUR = 'EUR',
    FJD = 'FJD',
    FKP = 'FKP',
    GBP = 'GBP',
    GEL = 'GEL',
    GHS = 'GHS',
    GIP = 'GIP',
    GMD = 'GMD',
    GNF = 'GNF',
    GTQ = 'GTQ',
    GYD = 'GYD',
    HKD = 'HKD',
    HNL = 'HNL',
    HRK = 'HRK',
    HTG = 'HTG',
    HUF = 'HUF',
    IDR = 'IDR',
    ILS = 'ILS',
    INR = 'INR',
    IQD = 'IQD',
    IRR = 'IRR',
    ISK = 'ISK',
    JMD = 'JMD',
    JOD = 'JOD',
    JPY = 'JPY',
    KES = 'KES',
    KGS = 'KGS',
    KHR = 'KHR',
    KMF = 'KMF',
    KPW = 'KPW',
    KRW = 'KRW',
    KWD = 'KWD',
    KYD = 'KYD',
    KZT = 'KZT',
    LAK = 'LAK',
    LBP = 'LBP',
    LKR = 'LKR',
    LRD = 'LRD',
    LSL = 'LSL',
    LYD = 'LYD',
    MAD = 'MAD',
    MDL = 'MDL',
    MGA = 'MGA',
    MKD = 'MKD',
    MMK = 'MMK',
    MNT = 'MNT',
    MOP = 'MOP',
    MRU = 'MRU',
    MUR = 'MUR',
    MVR = 'MVR',
    MWK = 'MWK',
    MXN = 'MXN',
    MXV = 'MXV',
    MYR = 'MYR',
    MZN = 'MZN',
    NAD = 'NAD',
    NGN = 'NGN',
    NIO = 'NIO',
    NOK = 'NOK',
    NPR = 'NPR',
    NZD = 'NZD',
    OMR = 'OMR',
    PAB = 'PAB',
    PEN = 'PEN',
    PGK = 'PGK',
    PHP = 'PHP',
    PKR = 'PKR',
    PLN = 'PLN',
    PYG = 'PYG',
    QAR = 'QAR',
    RON = 'RON',
    RSD = 'RSD',
    RUB = 'RUB',
    RWF = 'RWF',
    SAR = 'SAR',
    SBD = 'SBD',
    SCR = 'SCR',
    SDG = 'SDG',
    SEK = 'SEK',
    SGD = 'SGD',
    SHP = 'SHP',
    SLE = 'SLE',
    SLL = 'SLL',
    SOS = 'SOS',
    SRD = 'SRD',
    SSP = 'SSP',
    STN = 'STN',
    SVC = 'SVC',
    SYP = 'SYP',
    SZL = 'SZL',
    THB = 'THB',
    TJS = 'TJS',
    TMT = 'TMT',
    TND = 'TND',
    TOP = 'TOP',
    TRY = 'TRY',
    TTD = 'TTD',
    TWD = 'TWD',
    TZS = 'TZS',
    UAH = 'UAH',
    UGX = 'UGX',
    USD = 'USD',
    USN = 'USN',
    UYI = 'UYI',
    UYU = 'UYU',
    UYW = 'UYW',
    UZS = 'UZS',
    VED = 'VED',
    VES = 'VES',
    VND = 'VND',
    VUV = 'VUV',
    WST = 'WST',
    XAF = 'XAF',
    XCD = 'XCD',
    XOF = 'XOF',
    XPF = 'XPF',
    XSU = 'XSU',
    XUA = 'XUA',
    YER = 'YER',
    ZAR = 'ZAR',
    ZMW = 'ZMW',
    ZWL = 'ZWL'
}

/**
 * Product and services offered by the business
 * @export
 * @interface ProductOutput
 */
export interface ProductOutput {
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    orgId?: string;
    /**
     * Product is active or not
     * @type {boolean}
     * @memberof ProductOutput
     */
    active?: boolean;
    /**
     * Default price of the product this is represented in the lowest currency denomination. Eg: 1000 for $10
     * @type {number}
     * @memberof ProductOutput
     */
    defaultPrice?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    currency?: string | null;
    /**
     * Description of the product
     * @type {string}
     * @memberof ProductOutput
     */
    description?: string | null;
    /**
     * Name of the product
     * @type {string}
     * @memberof ProductOutput
     */
    name?: string;
    /**
     * Product is shippable or not. Service is not shippable
     * @type {boolean}
     * @memberof ProductOutput
     */
    shippable?: boolean;
    /**
     * List of features of the product
     * @type {Array<string>}
     * @memberof ProductOutput
     */
    features?: Array<string> | null;
    /**
     * Product requires appointment scheduling or not
     * @type {boolean}
     * @memberof ProductOutput
     */
    scheduleAppointment?: boolean;
    /**
     * Properties of the product
     * @type {any}
     * @memberof ProductOutput
     */
    props?: any | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductOutput
     */
    tags?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface ProductWithAgents
 */
export interface ProductWithAgents {
    /**
     * 
     * @type {ProductOutput}
     * @memberof ProductWithAgents
     */
    product: ProductOutput;
    /**
     * 
     * @type {Array<AIAgentOutput>}
     * @memberof ProductWithAgents
     */
    agents?: Array<AIAgentOutput>;
}
/**
 * 
 * @export
 * @interface PromptTemplate
 */
export interface PromptTemplate {
    /**
     * 
     * @type {string}
     * @memberof PromptTemplate
     */
    prompt: string;
    /**
     * 
     * @type {Array<Sequence>}
     * @memberof PromptTemplate
     */
    sequences: Array<Sequence>;
    /**
     * 
     * @type {string}
     * @memberof PromptTemplate
     */
    role: string;
    /**
     * 
     * @type {string}
     * @memberof PromptTemplate
     */
    roleDescription: string;
    /**
     * 
     * @type {string}
     * @memberof PromptTemplate
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ProspectInput
 */
export interface ProspectInput {
    /**
     * Name of the prospect
     * @type {string}
     * @memberof ProspectInput
     */
    name?: string | null;
    /**
     * Email of the prospect
     * @type {string}
     * @memberof ProspectInput
     */
    email?: string | null;
    /**
     * Phone number of the prospect
     * @type {string}
     * @memberof ProspectInput
     */
    phoneNumber?: string | null;
    /**
     * External references for the prospect
     * @type {Array<ExternalReference>}
     * @memberof ProspectInput
     */
    externalReference?: Array<ExternalReference> | null;
    /**
     * 
     * @type {ProspectStatus}
     * @memberof ProspectInput
     */
    status: ProspectStatus;
    /**
     * Props for the prospect
     * @type {any}
     * @memberof ProspectInput
     */
    prospectProps?: any | null;
}
/**
 * Prospects are the potential customers for business
 * @export
 * @interface ProspectOutput
 */
export interface ProspectOutput {
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    email?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    phoneNumber?: string | null;
    /**
     * 
     * @type {Array<ExternalReference>}
     * @memberof ProspectOutput
     */
    externalReference: Array<ExternalReference> | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    status: string;
    /**
     * 
     * @type {any}
     * @memberof ProspectOutput
     */
    prospectProps: any | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ProspectStatus {
    NEW = 'NEW',
    GENERALENQUIRY = 'GENERAL_ENQUIRY',
    SCHEDULEDCALLBACKWITHBOT = 'SCHEDULED_CALLBACK_WITH_BOT',
    SCHEDULEDAPPOINTMENTWITHPERSON = 'SCHEDULED_APPOINTMENT_WITH_PERSON',
    SCHEDULEDAPPOINTMENTFORSERVICE = 'SCHEDULED_APPOINTMENT_FOR_SERVICE',
    NOTINTERESTED = 'NOT_INTERESTED',
    PRODUCTORDERPLACED = 'PRODUCT_ORDER_PLACED',
    SERVICEORDERPLACED = 'SERVICE_ORDER_PLACED'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Role {
    ADMIN = 'ADMIN',
    READONLY = 'READ_ONLY'
}

/**
 * 
 * @export
 * @interface RoleTemplate
 */
export interface RoleTemplate {
    /**
     * 
     * @type {string}
     * @memberof RoleTemplate
     */
    roleName: string;
    /**
     * 
     * @type {string}
     * @memberof RoleTemplate
     */
    roleDescription: string;
}
/**
 * 
 * @export
 * @interface Sequence
 */
export interface Sequence {
    /**
     * Name of the stage
     * @type {string}
     * @memberof Sequence
     */
    stageName: string;
    /**
     * Description of the stage
     * @type {string}
     * @memberof Sequence
     */
    description: string;
    /**
     * Other notes that AI agent should know in this stage of conversation
     * @type {string}
     * @memberof Sequence
     */
    otherNotes?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SortOrder {
    Asc = 'asc',
    Desc = 'desc'
}

/**
 * 
 * @export
 * @interface StatsData
 */
export interface StatsData {
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    no_of_prospects: number;
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    appointment_scheduled: number;
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    unqualified: number;
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    average_call_duration: number;
}
/**
 * 
 * @export
 * @interface StatsResponse
 */
export interface StatsResponse {
    /**
     * Overall stats of prospects
     * @type {StatsData}
     * @memberof StatsResponse
     */
    response: StatsData;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Status {
    Active = 'active',
    Inactive = 'inactive'
}

/**
 * 
 * @export
 * @interface TaxDetailsInput
 */
export interface TaxDetailsInput {
    /**
     * Tax identifier
     * @type {string}
     * @memberof TaxDetailsInput
     */
    id: string;
    /**
     * Any extra info related to Tax
     * @type {object}
     * @memberof TaxDetailsInput
     */
    taxProps: object | null;
}
/**
 * 
 * @export
 * @interface TaxDetailsOutput
 */
export interface TaxDetailsOutput {
    /**
     * 
     * @type {string}
     * @memberof TaxDetailsOutput
     */
    id: string;
    /**
     * 
     * @type {object}
     * @memberof TaxDetailsOutput
     */
    taxProps: object | null;
}
/**
 * 
 * @export
 * @interface Transcriber
 */
export interface Transcriber {
    /**
     * 
     * @type {string}
     * @memberof Transcriber
     */
    providerName?: string;
    /**
     * 
     * @type {string}
     * @memberof Transcriber
     */
    transcriberModel?: string | null;
    /**
     * 
     * @type {object}
     * @memberof Transcriber
     */
    providerProps?: object | null;
}
/**
 * Payload for updating user details API
 * @export
 * @interface UpdateUserPayload
 */
export interface UpdateUserPayload {
    /**
     * 
     * @type {Role}
     * @memberof UpdateUserPayload
     */
    role: Role | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserPayload
     */
    fullName: string | null;
}
/**
 * Model representing the users under an organization
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    fullName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    updatedAt?: string;
}
/**
 * User id to api key mapping table
 * @export
 * @interface UserApiKeyLink
 */
export interface UserApiKeyLink {
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    secretKey?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    expiresAt?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserApiKeyLink
     */
    isActive?: boolean;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string | number>}
     * @memberof ValidationError
     */
    loc: Array<string | number>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface VoiceInput
 */
export interface VoiceInput {
    /**
     * 
     * @type {string}
     * @memberof VoiceInput
     */
    gender: VoiceInputGenderEnum;
    /**
     * 
     * @type {LanguageAccentCombo}
     * @memberof VoiceInput
     */
    languageAccent: LanguageAccentCombo;
    /**
     * 
     * @type {string}
     * @memberof VoiceInput
     */
    modelId: string;
}

/**
    * @export
    * @enum {string}
    */
export enum VoiceInputGenderEnum {
    Male = 'Male',
    Female = 'Female',
    Neutral = 'Neutral'
}

/**
 * 
 * @export
 * @interface VoiceModel
 */
export interface VoiceModel {
    /**
     * 
     * @type {VoiceOutput}
     * @memberof VoiceModel
     */
    voice: VoiceOutput;
    /**
     * 
     * @type {string}
     * @memberof VoiceModel
     */
    previewUrl: string;
    /**
     * 
     * @type {string}
     * @memberof VoiceModel
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof VoiceModel
     */
    voiceDescription: string;
}
/**
 * 
 * @export
 * @interface VoiceOutput
 */
export interface VoiceOutput {
    /**
     * 
     * @type {string}
     * @memberof VoiceOutput
     */
    gender: VoiceOutputGenderEnum;
    /**
     * 
     * @type {LanguageAccentCombo}
     * @memberof VoiceOutput
     */
    languageAccent: LanguageAccentCombo;
    /**
     * 
     * @type {string}
     * @memberof VoiceOutput
     */
    modelId: string;
}

/**
    * @export
    * @enum {string}
    */
export enum VoiceOutputGenderEnum {
    Male = 'Male',
    Female = 'Female',
    Neutral = 'Neutral'
}


/**
 * ActionAgentLinkApi - axios parameter creator
 * @export
 */
export const ActionAgentLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Createactionagentlink
         * @param {string} actionId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionAgentLinkV1: async (actionId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new RequiredError('actionId','Required parameter actionId was null or undefined when calling createActionAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling createActionAgentLinkV1.');
            }
            const localVarPath = `/v1/actions/{action_id}/ai-agents/{agent_id}/link`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deleteactionagentlink
         * @param {string} actionId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionAgentLinkV1: async (actionId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new RequiredError('actionId','Required parameter actionId was null or undefined when calling deleteActionAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling deleteActionAgentLinkV1.');
            }
            const localVarPath = `/v1/actions/{action_id}/ai-agents/{agent_id}/link`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Listactionsofagent
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsOfAgentV1: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling listActionsOfAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}/actions`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionAgentLinkApi - functional programming interface
 * @export
 */
export const ActionAgentLinkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Createactionagentlink
         * @param {string} actionId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActionAgentLinkV1(actionId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ActionAgentLinkApiAxiosParamCreator(configuration).createActionAgentLinkV1(actionId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deleteactionagentlink
         * @param {string} actionId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteActionAgentLinkV1(actionId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ActionAgentLinkApiAxiosParamCreator(configuration).deleteActionAgentLinkV1(actionId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Listactionsofagent
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActionsOfAgentV1(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BackendDbModelsAction>>> {
            const localVarAxiosArgs = await ActionAgentLinkApiAxiosParamCreator(configuration).listActionsOfAgentV1(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ActionAgentLinkApi - factory interface
 * @export
 */
export const ActionAgentLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Createactionagentlink
         * @param {string} actionId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionAgentLinkV1(actionId: string, agentId: string, options?: any): AxiosPromise<BaseResponse> {
            return ActionAgentLinkApiFp(configuration).createActionAgentLinkV1(actionId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deleteactionagentlink
         * @param {string} actionId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionAgentLinkV1(actionId: string, agentId: string, options?: any): AxiosPromise<BaseResponse> {
            return ActionAgentLinkApiFp(configuration).deleteActionAgentLinkV1(actionId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Listactionsofagent
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsOfAgentV1(agentId: string, options?: any): AxiosPromise<Array<BackendDbModelsAction>> {
            return ActionAgentLinkApiFp(configuration).listActionsOfAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionAgentLinkApi - object-oriented interface
 * @export
 * @class ActionAgentLinkApi
 * @extends {BaseAPI}
 */
export class ActionAgentLinkApi extends BaseAPI {
    /**
     * 
     * @summary Createactionagentlink
     * @param {string} actionId 
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    public createActionAgentLinkV1(actionId: string, agentId: string, options?: any) {
        return ActionAgentLinkApiFp(this.configuration).createActionAgentLinkV1(actionId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deleteactionagentlink
     * @param {string} actionId 
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    public deleteActionAgentLinkV1(actionId: string, agentId: string, options?: any) {
        return ActionAgentLinkApiFp(this.configuration).deleteActionAgentLinkV1(actionId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Listactionsofagent
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    public listActionsOfAgentV1(agentId: string, options?: any) {
        return ActionAgentLinkApiFp(this.configuration).listActionsOfAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Createaction
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionV1: async (actionInput: ActionInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionInput' is not null or undefined
            if (actionInput === null || actionInput === undefined) {
                throw new RequiredError('actionInput','Required parameter actionInput was null or undefined when calling createActionV1.');
            }
            const localVarPath = `/v1/actions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof actionInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(actionInput !== undefined ? actionInput : {}) : (actionInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deleteaction
         * @param {string} actionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionV1: async (actionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new RequiredError('actionId','Required parameter actionId was null or undefined when calling deleteActionV1.');
            }
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getaction
         * @param {string} actionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1: async (actionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new RequiredError('actionId','Required parameter actionId was null or undefined when calling getActionV1.');
            }
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Listactions
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/actions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updateaction
         * @param {string} actionId 
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActionV1: async (actionId: string, actionInput: ActionInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new RequiredError('actionId','Required parameter actionId was null or undefined when calling updateActionV1.');
            }
            // verify required parameter 'actionInput' is not null or undefined
            if (actionInput === null || actionInput === undefined) {
                throw new RequiredError('actionInput','Required parameter actionInput was null or undefined when calling updateActionV1.');
            }
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof actionInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(actionInput !== undefined ? actionInput : {}) : (actionInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Createaction
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActionV1(actionInput: ActionInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackendDbModelsAction>> {
            const localVarAxiosArgs = await ActionsApiAxiosParamCreator(configuration).createActionV1(actionInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deleteaction
         * @param {string} actionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteActionV1(actionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ActionsApiAxiosParamCreator(configuration).deleteActionV1(actionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Getaction
         * @param {string} actionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActionV1(actionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackendDbModelsAction>> {
            const localVarAxiosArgs = await ActionsApiAxiosParamCreator(configuration).getActionV1(actionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Listactions
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActionsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BackendDbModelsAction>>> {
            const localVarAxiosArgs = await ActionsApiAxiosParamCreator(configuration).listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updateaction
         * @param {string} actionId 
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateActionV1(actionId: string, actionInput: ActionInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackendDbModelsAction>> {
            const localVarAxiosArgs = await ActionsApiAxiosParamCreator(configuration).updateActionV1(actionId, actionInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Createaction
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionV1(actionInput: ActionInput, options?: any): AxiosPromise<BackendDbModelsAction> {
            return ActionsApiFp(configuration).createActionV1(actionInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deleteaction
         * @param {string} actionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionV1(actionId: string, options?: any): AxiosPromise<BaseResponse> {
            return ActionsApiFp(configuration).deleteActionV1(actionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getaction
         * @param {string} actionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1(actionId: string, options?: any): AxiosPromise<BackendDbModelsAction> {
            return ActionsApiFp(configuration).getActionV1(actionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Listactions
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<BackendDbModelsAction>> {
            return ActionsApiFp(configuration).listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updateaction
         * @param {string} actionId 
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActionV1(actionId: string, actionInput: ActionInput, options?: any): AxiosPromise<BackendDbModelsAction> {
            return ActionsApiFp(configuration).updateActionV1(actionId, actionInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI {
    /**
     * 
     * @summary Createaction
     * @param {ActionInput} actionInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public createActionV1(actionInput: ActionInput, options?: any) {
        return ActionsApiFp(this.configuration).createActionV1(actionInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deleteaction
     * @param {string} actionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public deleteActionV1(actionId: string, options?: any) {
        return ActionsApiFp(this.configuration).deleteActionV1(actionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Getaction
     * @param {string} actionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getActionV1(actionId: string, options?: any) {
        return ActionsApiFp(this.configuration).getActionV1(actionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Listactions
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public listActionsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return ActionsApiFp(this.configuration).listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updateaction
     * @param {string} actionId 
     * @param {ActionInput} actionInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public updateActionV1(actionId: string, actionInput: ActionInput, options?: any) {
        return ActionsApiFp(this.configuration).updateActionV1(actionId, actionInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * AgentsApi - axios parameter creator
 * @export
 */
export const AgentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Createaiagent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAIAgentV1: async (aIAgentInput: AIAgentInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'aIAgentInput' is not null or undefined
            if (aIAgentInput === null || aIAgentInput === undefined) {
                throw new RequiredError('aIAgentInput','Required parameter aIAgentInput was null or undefined when calling createAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof aIAgentInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(aIAgentInput !== undefined ? aIAgentInput : {}) : (aIAgentInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an AI agent.
         * @summary Deleteaiagent
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAIAgentV1: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling deleteAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific AI agent by ID.
         * @summary Getaiagent
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIAgentV1: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling getAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all AI agents under the user\'s organization.
         * @summary Listaiagents
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIAgentsV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ai-agents`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing AI agent.
         * @summary Updateaiagent
         * @param {string} agentId 
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIAgentV1: async (agentId: string, aIAgentInput: AIAgentInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling updateAIAgentV1.');
            }
            // verify required parameter 'aIAgentInput' is not null or undefined
            if (aIAgentInput === null || aIAgentInput === undefined) {
                throw new RequiredError('aIAgentInput','Required parameter aIAgentInput was null or undefined when calling updateAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof aIAgentInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(aIAgentInput !== undefined ? aIAgentInput : {}) : (aIAgentInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentsApi - functional programming interface
 * @export
 */
export const AgentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Createaiagent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAIAgentV1(aIAgentInput: AIAgentInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AIAgentOutput>> {
            const localVarAxiosArgs = await AgentsApiAxiosParamCreator(configuration).createAIAgentV1(aIAgentInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes an AI agent.
         * @summary Deleteaiagent
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAIAgentV1(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await AgentsApiAxiosParamCreator(configuration).deleteAIAgentV1(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a specific AI agent by ID.
         * @summary Getaiagent
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAIAgentV1(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AIAgentOutput>> {
            const localVarAxiosArgs = await AgentsApiAxiosParamCreator(configuration).getAIAgentV1(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all AI agents under the user\'s organization.
         * @summary Listaiagents
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAIAgentsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AIAgentOutput>>> {
            const localVarAxiosArgs = await AgentsApiAxiosParamCreator(configuration).listAIAgentsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an existing AI agent.
         * @summary Updateaiagent
         * @param {string} agentId 
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAIAgentV1(agentId: string, aIAgentInput: AIAgentInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AIAgentOutput>> {
            const localVarAxiosArgs = await AgentsApiAxiosParamCreator(configuration).updateAIAgentV1(agentId, aIAgentInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AgentsApi - factory interface
 * @export
 */
export const AgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Createaiagent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAIAgentV1(aIAgentInput: AIAgentInput, options?: any): AxiosPromise<AIAgentOutput> {
            return AgentsApiFp(configuration).createAIAgentV1(aIAgentInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an AI agent.
         * @summary Deleteaiagent
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAIAgentV1(agentId: string, options?: any): AxiosPromise<BaseResponse> {
            return AgentsApiFp(configuration).deleteAIAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific AI agent by ID.
         * @summary Getaiagent
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIAgentV1(agentId: string, options?: any): AxiosPromise<AIAgentOutput> {
            return AgentsApiFp(configuration).getAIAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all AI agents under the user\'s organization.
         * @summary Listaiagents
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIAgentsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<AIAgentOutput>> {
            return AgentsApiFp(configuration).listAIAgentsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing AI agent.
         * @summary Updateaiagent
         * @param {string} agentId 
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIAgentV1(agentId: string, aIAgentInput: AIAgentInput, options?: any): AxiosPromise<AIAgentOutput> {
            return AgentsApiFp(configuration).updateAIAgentV1(agentId, aIAgentInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AgentsApi - object-oriented interface
 * @export
 * @class AgentsApi
 * @extends {BaseAPI}
 */
export class AgentsApi extends BaseAPI {
    /**
     * 
     * @summary Createaiagent
     * @param {AIAgentInput} aIAgentInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public createAIAgentV1(aIAgentInput: AIAgentInput, options?: any) {
        return AgentsApiFp(this.configuration).createAIAgentV1(aIAgentInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an AI agent.
     * @summary Deleteaiagent
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public deleteAIAgentV1(agentId: string, options?: any) {
        return AgentsApiFp(this.configuration).deleteAIAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific AI agent by ID.
     * @summary Getaiagent
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public getAIAgentV1(agentId: string, options?: any) {
        return AgentsApiFp(this.configuration).getAIAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all AI agents under the user\'s organization.
     * @summary Listaiagents
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public listAIAgentsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return AgentsApiFp(this.configuration).listAIAgentsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing AI agent.
     * @summary Updateaiagent
     * @param {string} agentId 
     * @param {AIAgentInput} aIAgentInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public updateAIAgentV1(agentId: string, aIAgentInput: AIAgentInput, options?: any) {
        return AgentsApiFp(this.configuration).updateAIAgentV1(agentId, aIAgentInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ApiKeyApi - axios parameter creator
 * @export
 */
export const ApiKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/api-keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyV1: async (keyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            if (keyId === null || keyId === undefined) {
                throw new RequiredError('keyId','Required parameter keyId was null or undefined when calling deleteApiKeyV1.');
            }
            const localVarPath = `/v1/api-keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/api-keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeyApi - functional programming interface
 * @export
 */
export const ApiKeyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKeyV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserApiKeyLink>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).createApiKeyV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiKeyV1(keyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).deleteApiKeyV1(keyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApiKeysV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserApiKeyLink>>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).listApiKeysV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ApiKeyApi - factory interface
 * @export
 */
export const ApiKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyV1(options?: any): AxiosPromise<UserApiKeyLink> {
            return ApiKeyApiFp(configuration).createApiKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyV1(keyId: string, options?: any): AxiosPromise<BaseResponse> {
            return ApiKeyApiFp(configuration).deleteApiKeyV1(keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysV1(options?: any): AxiosPromise<Array<UserApiKeyLink>> {
            return ApiKeyApiFp(configuration).listApiKeysV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiKeyApi - object-oriented interface
 * @export
 * @class ApiKeyApi
 * @extends {BaseAPI}
 */
export class ApiKeyApi extends BaseAPI {
    /**
     * 
     * @summary Create Api Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public createApiKeyV1(options?: any) {
        return ApiKeyApiFp(this.configuration).createApiKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Api Key
     * @param {string} keyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public deleteApiKeyV1(keyId: string, options?: any) {
        return ApiKeyApiFp(this.configuration).deleteApiKeyV1(keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Api Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public listApiKeysV1(options?: any) {
        return ApiKeyApiFp(this.configuration).listApiKeysV1(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ConversationProspectLinkApi - axios parameter creator
 * @export
 */
export const ConversationProspectLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Createconversationprospectlink
         * @param {string} conversationId 
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationProspectLinkV1: async (conversationId: string, prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling createConversationProspectLinkV1.');
            }
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling createConversationProspectLinkV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}/prospects/{prospect_id}/links`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deleteconversationbyprospect
         * @param {string} conversationId 
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationProspectLinkV1: async (conversationId: string, prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling deleteConversationProspectLinkV1.');
            }
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling deleteConversationProspectLinkV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}/prospects/{prospect_id}/links`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getconversationsbyprospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsOfProspectsV1: async (prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling listConversationsOfProspectsV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}/conversations`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversationProspectLinkApi - functional programming interface
 * @export
 */
export const ConversationProspectLinkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Createconversationprospectlink
         * @param {string} conversationId 
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ConversationProspectLinkApiAxiosParamCreator(configuration).createConversationProspectLinkV1(conversationId, prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deleteconversationbyprospect
         * @param {string} conversationId 
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ConversationProspectLinkApiAxiosParamCreator(configuration).deleteConversationProspectLinkV1(conversationId, prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Getconversationsbyprospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConversationsOfProspectsV1(prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConversationOutput>>> {
            const localVarAxiosArgs = await ConversationProspectLinkApiAxiosParamCreator(configuration).listConversationsOfProspectsV1(prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ConversationProspectLinkApi - factory interface
 * @export
 */
export const ConversationProspectLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Createconversationprospectlink
         * @param {string} conversationId 
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any): AxiosPromise<BaseResponse> {
            return ConversationProspectLinkApiFp(configuration).createConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deleteconversationbyprospect
         * @param {string} conversationId 
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any): AxiosPromise<BaseResponse> {
            return ConversationProspectLinkApiFp(configuration).deleteConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getconversationsbyprospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsOfProspectsV1(prospectId: string, options?: any): AxiosPromise<Array<ConversationOutput>> {
            return ConversationProspectLinkApiFp(configuration).listConversationsOfProspectsV1(prospectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConversationProspectLinkApi - object-oriented interface
 * @export
 * @class ConversationProspectLinkApi
 * @extends {BaseAPI}
 */
export class ConversationProspectLinkApi extends BaseAPI {
    /**
     * 
     * @summary Createconversationprospectlink
     * @param {string} conversationId 
     * @param {string} prospectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    public createConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any) {
        return ConversationProspectLinkApiFp(this.configuration).createConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deleteconversationbyprospect
     * @param {string} conversationId 
     * @param {string} prospectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    public deleteConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any) {
        return ConversationProspectLinkApiFp(this.configuration).deleteConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Getconversationsbyprospect
     * @param {string} prospectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    public listConversationsOfProspectsV1(prospectId: string, options?: any) {
        return ConversationProspectLinkApiFp(this.configuration).listConversationsOfProspectsV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ConversationsApi - axios parameter creator
 * @export
 */
export const ConversationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Addfeedback
         * @param {string} conversationId 
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedbackV1: async (conversationId: string, comment: Comment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling addFeedbackV1.');
            }
            // verify required parameter 'comment' is not null or undefined
            if (comment === null || comment === undefined) {
                throw new RequiredError('comment','Required parameter comment was null or undefined when calling addFeedbackV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}/feedback`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof comment !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(comment !== undefined ? comment : {}) : (comment || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Createconversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationV1: async (conversationInput: ConversationInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationInput' is not null or undefined
            if (conversationInput === null || conversationInput === undefined) {
                throw new RequiredError('conversationInput','Required parameter conversationInput was null or undefined when calling createConversationV1.');
            }
            const localVarPath = `/v1/conversations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof conversationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(conversationInput !== undefined ? conversationInput : {}) : (conversationInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deleteconversation
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationV1: async (conversationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling deleteConversationV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getconversation
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationV1: async (conversationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling getConversationV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Listconversations
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/conversations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updateconversation
         * @param {string} conversationId 
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationV1: async (conversationId: string, conversationInput: ConversationInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling updateConversationV1.');
            }
            // verify required parameter 'conversationInput' is not null or undefined
            if (conversationInput === null || conversationInput === undefined) {
                throw new RequiredError('conversationInput','Required parameter conversationInput was null or undefined when calling updateConversationV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof conversationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(conversationInput !== undefined ? conversationInput : {}) : (conversationInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversationsApi - functional programming interface
 * @export
 */
export const ConversationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Addfeedback
         * @param {string} conversationId 
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFeedbackV1(conversationId: string, comment: Comment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationFeedback>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).addFeedbackV1(conversationId, comment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Createconversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversationV1(conversationInput: ConversationInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationOutput>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).createConversationV1(conversationInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deleteconversation
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConversationV1(conversationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).deleteConversationV1(conversationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Getconversation
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversationV1(conversationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationOutput>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).getConversationV1(conversationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Listconversations
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConversationsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConversationOutput>>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).listConversationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updateconversation
         * @param {string} conversationId 
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConversationV1(conversationId: string, conversationInput: ConversationInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationOutput>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).updateConversationV1(conversationId, conversationInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ConversationsApi - factory interface
 * @export
 */
export const ConversationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Addfeedback
         * @param {string} conversationId 
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedbackV1(conversationId: string, comment: Comment, options?: any): AxiosPromise<ConversationFeedback> {
            return ConversationsApiFp(configuration).addFeedbackV1(conversationId, comment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Createconversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationV1(conversationInput: ConversationInput, options?: any): AxiosPromise<ConversationOutput> {
            return ConversationsApiFp(configuration).createConversationV1(conversationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deleteconversation
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationV1(conversationId: string, options?: any): AxiosPromise<BaseResponse> {
            return ConversationsApiFp(configuration).deleteConversationV1(conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getconversation
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationV1(conversationId: string, options?: any): AxiosPromise<ConversationOutput> {
            return ConversationsApiFp(configuration).getConversationV1(conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Listconversations
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<ConversationOutput>> {
            return ConversationsApiFp(configuration).listConversationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updateconversation
         * @param {string} conversationId 
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationV1(conversationId: string, conversationInput: ConversationInput, options?: any): AxiosPromise<ConversationOutput> {
            return ConversationsApiFp(configuration).updateConversationV1(conversationId, conversationInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConversationsApi - object-oriented interface
 * @export
 * @class ConversationsApi
 * @extends {BaseAPI}
 */
export class ConversationsApi extends BaseAPI {
    /**
     * 
     * @summary Addfeedback
     * @param {string} conversationId 
     * @param {Comment} comment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public addFeedbackV1(conversationId: string, comment: Comment, options?: any) {
        return ConversationsApiFp(this.configuration).addFeedbackV1(conversationId, comment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Createconversation
     * @param {ConversationInput} conversationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public createConversationV1(conversationInput: ConversationInput, options?: any) {
        return ConversationsApiFp(this.configuration).createConversationV1(conversationInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deleteconversation
     * @param {string} conversationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public deleteConversationV1(conversationId: string, options?: any) {
        return ConversationsApiFp(this.configuration).deleteConversationV1(conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Getconversation
     * @param {string} conversationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public getConversationV1(conversationId: string, options?: any) {
        return ConversationsApiFp(this.configuration).getConversationV1(conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Listconversations
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public listConversationsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return ConversationsApiFp(this.configuration).listConversationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updateconversation
     * @param {string} conversationId 
     * @param {ConversationInput} conversationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public updateConversationV1(conversationId: string, conversationInput: ConversationInput, options?: any) {
        return ConversationsApiFp(this.configuration).updateConversationV1(conversationId, conversationInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * DataPlaneApi - axios parameter creator
 * @export
 */
export const DataPlaneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Createconnection
         * @param {string} agentId 
         * @param {ConnectionSource} connectionSource 
         * @param {string} [prospectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection: async (agentId: string, connectionSource: ConnectionSource, prospectId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling createConnection.');
            }
            // verify required parameter 'connectionSource' is not null or undefined
            if (connectionSource === null || connectionSource === undefined) {
                throw new RequiredError('connectionSource','Required parameter connectionSource was null or undefined when calling createConnection.');
            }
            const localVarPath = `/v1/connections`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (agentId !== undefined) {
                localVarQueryParameter['agentId'] = agentId;
            }

            if (prospectId !== undefined) {
                localVarQueryParameter['prospect_id'] = prospectId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof connectionSource !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(connectionSource !== undefined ? connectionSource : {}) : (connectionSource || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataPlaneApi - functional programming interface
 * @export
 */
export const DataPlaneApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Createconnection
         * @param {string} agentId 
         * @param {ConnectionSource} connectionSource 
         * @param {string} [prospectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnection(agentId: string, connectionSource: ConnectionSource, prospectId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connection>> {
            const localVarAxiosArgs = await DataPlaneApiAxiosParamCreator(configuration).createConnection(agentId, connectionSource, prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DataPlaneApi - factory interface
 * @export
 */
export const DataPlaneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Createconnection
         * @param {string} agentId 
         * @param {ConnectionSource} connectionSource 
         * @param {string} [prospectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(agentId: string, connectionSource: ConnectionSource, prospectId?: string, options?: any): AxiosPromise<Connection> {
            return DataPlaneApiFp(configuration).createConnection(agentId, connectionSource, prospectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataPlaneApi - object-oriented interface
 * @export
 * @class DataPlaneApi
 * @extends {BaseAPI}
 */
export class DataPlaneApi extends BaseAPI {
    /**
     * 
     * @summary Createconnection
     * @param {string} agentId 
     * @param {ConnectionSource} connectionSource 
     * @param {string} [prospectId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPlaneApi
     */
    public createConnection(agentId: string, connectionSource: ConnectionSource, prospectId?: string, options?: any) {
        return DataPlaneApiFp(this.configuration).createConnection(agentId, connectionSource, prospectId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatusGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusStatusGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await HealthApiAxiosParamCreator(configuration).statusStatusGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatusGet(options?: any): AxiosPromise<{ [key: string]: string; }> {
            return HealthApiFp(configuration).statusStatusGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public statusStatusGet(options?: any) {
        return HealthApiFp(this.configuration).statusStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * HiveApi - axios parameter creator
 * @export
 */
export const HiveApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Createhive
         * @param {BackendDtoModelsHiveContent} backendDtoModelsHiveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1: async (backendDtoModelsHiveContent: BackendDtoModelsHiveContent, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'backendDtoModelsHiveContent' is not null or undefined
            if (backendDtoModelsHiveContent === null || backendDtoModelsHiveContent === undefined) {
                throw new RequiredError('backendDtoModelsHiveContent','Required parameter backendDtoModelsHiveContent was null or undefined when calling createHiveV1.');
            }
            const localVarPath = `/v1/hives`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof backendDtoModelsHiveContent !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(backendDtoModelsHiveContent !== undefined ? backendDtoModelsHiveContent : {}) : (backendDtoModelsHiveContent || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletehive
         * @param {string} hiveId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1: async (hiveId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling deleteHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gethive
         * @param {string} hiveId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1: async (hiveId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling getHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Listhives
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/hives`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updatehive
         * @param {string} hiveId 
         * @param {BackendDbModelsHiveContent} backendDbModelsHiveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1: async (hiveId: string, backendDbModelsHiveContent: BackendDbModelsHiveContent, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling updateHiveV1.');
            }
            // verify required parameter 'backendDbModelsHiveContent' is not null or undefined
            if (backendDbModelsHiveContent === null || backendDbModelsHiveContent === undefined) {
                throw new RequiredError('backendDbModelsHiveContent','Required parameter backendDbModelsHiveContent was null or undefined when calling updateHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof backendDbModelsHiveContent !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(backendDbModelsHiveContent !== undefined ? backendDbModelsHiveContent : {}) : (backendDbModelsHiveContent || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HiveApi - functional programming interface
 * @export
 */
export const HiveApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Createhive
         * @param {BackendDtoModelsHiveContent} backendDtoModelsHiveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHiveV1(backendDtoModelsHiveContent: BackendDtoModelsHiveContent, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>> {
            const localVarAxiosArgs = await HiveApiAxiosParamCreator(configuration).createHiveV1(backendDtoModelsHiveContent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletehive
         * @param {string} hiveId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHiveV1(hiveId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await HiveApiAxiosParamCreator(configuration).deleteHiveV1(hiveId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gethive
         * @param {string} hiveId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHiveV1(hiveId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>> {
            const localVarAxiosArgs = await HiveApiAxiosParamCreator(configuration).getHiveV1(hiveId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Listhives
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHivesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hive>>> {
            const localVarAxiosArgs = await HiveApiAxiosParamCreator(configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updatehive
         * @param {string} hiveId 
         * @param {BackendDbModelsHiveContent} backendDbModelsHiveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHiveV1(hiveId: string, backendDbModelsHiveContent: BackendDbModelsHiveContent, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>> {
            const localVarAxiosArgs = await HiveApiAxiosParamCreator(configuration).updateHiveV1(hiveId, backendDbModelsHiveContent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HiveApi - factory interface
 * @export
 */
export const HiveApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Createhive
         * @param {BackendDtoModelsHiveContent} backendDtoModelsHiveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1(backendDtoModelsHiveContent: BackendDtoModelsHiveContent, options?: any): AxiosPromise<Hive> {
            return HiveApiFp(configuration).createHiveV1(backendDtoModelsHiveContent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletehive
         * @param {string} hiveId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1(hiveId: string, options?: any): AxiosPromise<BaseResponse> {
            return HiveApiFp(configuration).deleteHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gethive
         * @param {string} hiveId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1(hiveId: string, options?: any): AxiosPromise<Hive> {
            return HiveApiFp(configuration).getHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Listhives
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<Hive>> {
            return HiveApiFp(configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updatehive
         * @param {string} hiveId 
         * @param {BackendDbModelsHiveContent} backendDbModelsHiveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1(hiveId: string, backendDbModelsHiveContent: BackendDbModelsHiveContent, options?: any): AxiosPromise<Hive> {
            return HiveApiFp(configuration).updateHiveV1(hiveId, backendDbModelsHiveContent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HiveApi - object-oriented interface
 * @export
 * @class HiveApi
 * @extends {BaseAPI}
 */
export class HiveApi extends BaseAPI {
    /**
     * 
     * @summary Createhive
     * @param {BackendDtoModelsHiveContent} backendDtoModelsHiveContent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public createHiveV1(backendDtoModelsHiveContent: BackendDtoModelsHiveContent, options?: any) {
        return HiveApiFp(this.configuration).createHiveV1(backendDtoModelsHiveContent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletehive
     * @param {string} hiveId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public deleteHiveV1(hiveId: string, options?: any) {
        return HiveApiFp(this.configuration).deleteHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gethive
     * @param {string} hiveId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public getHiveV1(hiveId: string, options?: any) {
        return HiveApiFp(this.configuration).getHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Listhives
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public listHivesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return HiveApiFp(this.configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updatehive
     * @param {string} hiveId 
     * @param {BackendDbModelsHiveContent} backendDbModelsHiveContent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public updateHiveV1(hiveId: string, backendDbModelsHiveContent: BackendDbModelsHiveContent, options?: any) {
        return HiveApiFp(this.configuration).updateHiveV1(hiveId, backendDbModelsHiveContent, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * HiveAgentLinkApi - axios parameter creator
 * @export
 */
export const HiveAgentLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Createhiveagentlink
         * @param {string} hiveId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveAgentLinkV1: async (hiveId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling createHiveAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling createHiveAgentLinkV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}/ai-agents/{agent_id}/link`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletehiveagentlink
         * @param {string} hiveId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveAgentLinkV1: async (hiveId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling deleteHiveAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling deleteHiveAgentLinkV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}/ai-agents/{agent_id}/link`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Listagentsofhive
         * @param {string} hiveId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfHiveV1: async (hiveId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling listAgentsOfHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}/ai-agents`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Listhivesofagent
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesOfAgentV1: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling listHivesOfAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}/hives`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HiveAgentLinkApi - functional programming interface
 * @export
 */
export const HiveAgentLinkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Createhiveagentlink
         * @param {string} hiveId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHiveAgentLinkV1(hiveId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await HiveAgentLinkApiAxiosParamCreator(configuration).createHiveAgentLinkV1(hiveId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletehiveagentlink
         * @param {string} hiveId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHiveAgentLinkV1(hiveId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await HiveAgentLinkApiAxiosParamCreator(configuration).deleteHiveAgentLinkV1(hiveId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Listagentsofhive
         * @param {string} hiveId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAgentsOfHiveV1(hiveId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AIAgentOutput>>> {
            const localVarAxiosArgs = await HiveAgentLinkApiAxiosParamCreator(configuration).listAgentsOfHiveV1(hiveId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Listhivesofagent
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHivesOfAgentV1(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hive>>> {
            const localVarAxiosArgs = await HiveAgentLinkApiAxiosParamCreator(configuration).listHivesOfAgentV1(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HiveAgentLinkApi - factory interface
 * @export
 */
export const HiveAgentLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Createhiveagentlink
         * @param {string} hiveId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveAgentLinkV1(hiveId: string, agentId: string, options?: any): AxiosPromise<BaseResponse> {
            return HiveAgentLinkApiFp(configuration).createHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletehiveagentlink
         * @param {string} hiveId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveAgentLinkV1(hiveId: string, agentId: string, options?: any): AxiosPromise<BaseResponse> {
            return HiveAgentLinkApiFp(configuration).deleteHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Listagentsofhive
         * @param {string} hiveId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfHiveV1(hiveId: string, options?: any): AxiosPromise<Array<AIAgentOutput>> {
            return HiveAgentLinkApiFp(configuration).listAgentsOfHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Listhivesofagent
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesOfAgentV1(agentId: string, options?: any): AxiosPromise<Array<Hive>> {
            return HiveAgentLinkApiFp(configuration).listHivesOfAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HiveAgentLinkApi - object-oriented interface
 * @export
 * @class HiveAgentLinkApi
 * @extends {BaseAPI}
 */
export class HiveAgentLinkApi extends BaseAPI {
    /**
     * 
     * @summary Createhiveagentlink
     * @param {string} hiveId 
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    public createHiveAgentLinkV1(hiveId: string, agentId: string, options?: any) {
        return HiveAgentLinkApiFp(this.configuration).createHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletehiveagentlink
     * @param {string} hiveId 
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    public deleteHiveAgentLinkV1(hiveId: string, agentId: string, options?: any) {
        return HiveAgentLinkApiFp(this.configuration).deleteHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Listagentsofhive
     * @param {string} hiveId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    public listAgentsOfHiveV1(hiveId: string, options?: any) {
        return HiveAgentLinkApiFp(this.configuration).listAgentsOfHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Listhivesofagent
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    public listHivesOfAgentV1(agentId: string, options?: any) {
        return HiveAgentLinkApiFp(this.configuration).listHivesOfAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * InternalApi - axios parameter creator
 * @export
 */
export const InternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/invites/accept`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationV1: async (bodyCreateOrganizationV1: BodyCreateOrganizationV1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateOrganizationV1' is not null or undefined
            if (bodyCreateOrganizationV1 === null || bodyCreateOrganizationV1 === undefined) {
                throw new RequiredError('bodyCreateOrganizationV1','Required parameter bodyCreateOrganizationV1 was null or undefined when calling createOrganizationV1.');
            }
            const localVarPath = `/v1/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyCreateOrganizationV1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyCreateOrganizationV1 !== undefined ? bodyCreateOrganizationV1 : {}) : (bodyCreateOrganizationV1 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete File
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1: async (fileIds: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileIds' is not null or undefined
            if (fileIds === null || fileIds === undefined) {
                throw new RequiredError('fileIds','Required parameter fileIds was null or undefined when calling deleteFileV1.');
            }
            const localVarPath = `/v1/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (fileIds !== undefined) {
                localVarQueryParameter['file_ids'] = fileIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserV1.');
            }
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/invites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInviteV1: async (guestInput: GuestInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guestInput' is not null or undefined
            if (guestInput === null || guestInput === undefined) {
                throw new RequiredError('guestInput','Required parameter guestInput was null or undefined when calling sendInviteV1.');
            }
            const localVarPath = `/v1/invites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof guestInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(guestInput !== undefined ? guestInput : {}) : (guestInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updateorganization
         * @param {string} orgId 
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationV1: async (orgId: string, organizationInput: OrganizationInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            if (orgId === null || orgId === undefined) {
                throw new RequiredError('orgId','Required parameter orgId was null or undefined when calling updateOrganizationV1.');
            }
            // verify required parameter 'organizationInput' is not null or undefined
            if (organizationInput === null || organizationInput === undefined) {
                throw new RequiredError('organizationInput','Required parameter organizationInput was null or undefined when calling updateOrganizationV1.');
            }
            const localVarPath = `/v1/organizations/{org_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof organizationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(organizationInput !== undefined ? organizationInput : {}) : (organizationInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId 
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1: async (userId: string, updateUserPayload: UpdateUserPayload, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserV1.');
            }
            // verify required parameter 'updateUserPayload' is not null or undefined
            if (updateUserPayload === null || updateUserPayload === undefined) {
                throw new RequiredError('updateUserPayload','Required parameter updateUserPayload was null or undefined when calling updateUserV1.');
            }
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateUserPayload !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateUserPayload !== undefined ? updateUserPayload : {}) : (updateUserPayload || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload File
         * @param {Array<any>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1: async (files: Array<any>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'files' is not null or undefined
            if (files === null || files === undefined) {
                throw new RequiredError('files','Required parameter files was null or undefined when calling uploadFileV1.');
            }
            const localVarPath = `/v1/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (files) {
            
                localVarFormParams.append('files', files.join(COLLECTION_FORMATS.csv));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalApi - functional programming interface
 * @export
 */
export const InternalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInviteV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).acceptInviteV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationV1(bodyCreateOrganizationV1: BodyCreateOrganizationV1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).createOrganizationV1(bodyCreateOrganizationV1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete File
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileV1(fileIds: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).deleteFileV1(fileIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).deleteOrganizationV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserV1(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).deleteUserV1(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationOutput>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).getOrganizationV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInvitesV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuestOutput>>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).listInvitesV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsersV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).listUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendInviteV1(guestInput: GuestInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuestOutput>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).sendInviteV1(guestInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updateorganization
         * @param {string} orgId 
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationV1(orgId: string, organizationInput: OrganizationInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationOutput>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).updateOrganizationV1(orgId, organizationInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId 
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserV1(userId: string, updateUserPayload: UpdateUserPayload, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).updateUserV1(userId, updateUserPayload, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Upload File
         * @param {Array<any>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileV1(files: Array<any>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Files>>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).uploadFileV1(files, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InternalApi - factory interface
 * @export
 */
export const InternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteV1(options?: any): AxiosPromise<User> {
            return InternalApiFp(configuration).acceptInviteV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationV1(bodyCreateOrganizationV1: BodyCreateOrganizationV1, options?: any): AxiosPromise<User> {
            return InternalApiFp(configuration).createOrganizationV1(bodyCreateOrganizationV1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete File
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1(fileIds: string, options?: any): AxiosPromise<boolean> {
            return InternalApiFp(configuration).deleteFileV1(fileIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationV1(options?: any): AxiosPromise<BaseResponse> {
            return InternalApiFp(configuration).deleteOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1(userId: string, options?: any): AxiosPromise<User> {
            return InternalApiFp(configuration).deleteUserV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationV1(options?: any): AxiosPromise<OrganizationOutput> {
            return InternalApiFp(configuration).getOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesV1(options?: any): AxiosPromise<Array<GuestOutput>> {
            return InternalApiFp(configuration).listInvitesV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return InternalApiFp(configuration).listUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInviteV1(guestInput: GuestInput, options?: any): AxiosPromise<GuestOutput> {
            return InternalApiFp(configuration).sendInviteV1(guestInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updateorganization
         * @param {string} orgId 
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationV1(orgId: string, organizationInput: OrganizationInput, options?: any): AxiosPromise<OrganizationOutput> {
            return InternalApiFp(configuration).updateOrganizationV1(orgId, organizationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId 
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1(userId: string, updateUserPayload: UpdateUserPayload, options?: any): AxiosPromise<User> {
            return InternalApiFp(configuration).updateUserV1(userId, updateUserPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload File
         * @param {Array<any>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1(files: Array<any>, options?: any): AxiosPromise<Array<Files>> {
            return InternalApiFp(configuration).uploadFileV1(files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
export class InternalApi extends BaseAPI {
    /**
     * Accept invite and add new user to organization
     * @summary Acceptinvite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public acceptInviteV1(options?: any) {
        return InternalApiFp(this.configuration).acceptInviteV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new organization and adds the user as the \"ADMIN\" user for the org
     * @summary Createorganization
     * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public createOrganizationV1(bodyCreateOrganizationV1: BodyCreateOrganizationV1, options?: any) {
        return InternalApiFp(this.configuration).createOrganizationV1(bodyCreateOrganizationV1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete File
     * @param {string} fileIds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public deleteFileV1(fileIds: string, options?: any) {
        return InternalApiFp(this.configuration).deleteFileV1(fileIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deleteorganization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public deleteOrganizationV1(options?: any) {
        return InternalApiFp(this.configuration).deleteOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user
     * @summary Deleteuser
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public deleteUserV1(userId: string, options?: any) {
        return InternalApiFp(this.configuration).deleteUserV1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Getorganization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getOrganizationV1(options?: any) {
        return InternalApiFp(this.configuration).getOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of all open invites from the organization
     * @summary Listinvites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public listInvitesV1(options?: any) {
        return InternalApiFp(this.configuration).listInvitesV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all users under the user\'s organization
     * @summary Listusers
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public listUsersV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return InternalApiFp(this.configuration).listUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a new user to an organization or resend invite to the user if the user is already invited
     * @summary Inviteusers
     * @param {GuestInput} guestInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public sendInviteV1(guestInput: GuestInput, options?: any) {
        return InternalApiFp(this.configuration).sendInviteV1(guestInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updateorganization
     * @param {string} orgId 
     * @param {OrganizationInput} organizationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public updateOrganizationV1(orgId: string, organizationInput: OrganizationInput, options?: any) {
        return InternalApiFp(this.configuration).updateOrganizationV1(orgId, organizationInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user details
     * @summary Updateuser
     * @param {string} userId 
     * @param {UpdateUserPayload} updateUserPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public updateUserV1(userId: string, updateUserPayload: UpdateUserPayload, options?: any) {
        return InternalApiFp(this.configuration).updateUserV1(userId, updateUserPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload File
     * @param {Array<any>} files 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public uploadFileV1(files: Array<any>, options?: any) {
        return InternalApiFp(this.configuration).uploadFileV1(files, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * KnowledgeBaseApi - axios parameter creator
 * @export
 */
export const KnowledgeBaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Createhive
         * @param {BackendDtoModelsHiveContent} backendDtoModelsHiveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1: async (backendDtoModelsHiveContent: BackendDtoModelsHiveContent, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'backendDtoModelsHiveContent' is not null or undefined
            if (backendDtoModelsHiveContent === null || backendDtoModelsHiveContent === undefined) {
                throw new RequiredError('backendDtoModelsHiveContent','Required parameter backendDtoModelsHiveContent was null or undefined when calling createHiveV1.');
            }
            const localVarPath = `/v1/hives`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof backendDtoModelsHiveContent !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(backendDtoModelsHiveContent !== undefined ? backendDtoModelsHiveContent : {}) : (backendDtoModelsHiveContent || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletehive
         * @param {string} hiveId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1: async (hiveId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling deleteHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gethive
         * @param {string} hiveId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1: async (hiveId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling getHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Listhives
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/hives`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updatehive
         * @param {string} hiveId 
         * @param {BackendDbModelsHiveContent} backendDbModelsHiveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1: async (hiveId: string, backendDbModelsHiveContent: BackendDbModelsHiveContent, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling updateHiveV1.');
            }
            // verify required parameter 'backendDbModelsHiveContent' is not null or undefined
            if (backendDbModelsHiveContent === null || backendDbModelsHiveContent === undefined) {
                throw new RequiredError('backendDbModelsHiveContent','Required parameter backendDbModelsHiveContent was null or undefined when calling updateHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof backendDbModelsHiveContent !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(backendDbModelsHiveContent !== undefined ? backendDbModelsHiveContent : {}) : (backendDbModelsHiveContent || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KnowledgeBaseApi - functional programming interface
 * @export
 */
export const KnowledgeBaseApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Createhive
         * @param {BackendDtoModelsHiveContent} backendDtoModelsHiveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHiveV1(backendDtoModelsHiveContent: BackendDtoModelsHiveContent, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>> {
            const localVarAxiosArgs = await KnowledgeBaseApiAxiosParamCreator(configuration).createHiveV1(backendDtoModelsHiveContent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletehive
         * @param {string} hiveId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHiveV1(hiveId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await KnowledgeBaseApiAxiosParamCreator(configuration).deleteHiveV1(hiveId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gethive
         * @param {string} hiveId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHiveV1(hiveId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>> {
            const localVarAxiosArgs = await KnowledgeBaseApiAxiosParamCreator(configuration).getHiveV1(hiveId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Listhives
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHivesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hive>>> {
            const localVarAxiosArgs = await KnowledgeBaseApiAxiosParamCreator(configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updatehive
         * @param {string} hiveId 
         * @param {BackendDbModelsHiveContent} backendDbModelsHiveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHiveV1(hiveId: string, backendDbModelsHiveContent: BackendDbModelsHiveContent, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>> {
            const localVarAxiosArgs = await KnowledgeBaseApiAxiosParamCreator(configuration).updateHiveV1(hiveId, backendDbModelsHiveContent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * KnowledgeBaseApi - factory interface
 * @export
 */
export const KnowledgeBaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Createhive
         * @param {BackendDtoModelsHiveContent} backendDtoModelsHiveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1(backendDtoModelsHiveContent: BackendDtoModelsHiveContent, options?: any): AxiosPromise<Hive> {
            return KnowledgeBaseApiFp(configuration).createHiveV1(backendDtoModelsHiveContent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletehive
         * @param {string} hiveId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1(hiveId: string, options?: any): AxiosPromise<BaseResponse> {
            return KnowledgeBaseApiFp(configuration).deleteHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gethive
         * @param {string} hiveId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1(hiveId: string, options?: any): AxiosPromise<Hive> {
            return KnowledgeBaseApiFp(configuration).getHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Listhives
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<Hive>> {
            return KnowledgeBaseApiFp(configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updatehive
         * @param {string} hiveId 
         * @param {BackendDbModelsHiveContent} backendDbModelsHiveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1(hiveId: string, backendDbModelsHiveContent: BackendDbModelsHiveContent, options?: any): AxiosPromise<Hive> {
            return KnowledgeBaseApiFp(configuration).updateHiveV1(hiveId, backendDbModelsHiveContent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KnowledgeBaseApi - object-oriented interface
 * @export
 * @class KnowledgeBaseApi
 * @extends {BaseAPI}
 */
export class KnowledgeBaseApi extends BaseAPI {
    /**
     * 
     * @summary Createhive
     * @param {BackendDtoModelsHiveContent} backendDtoModelsHiveContent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseApi
     */
    public createHiveV1(backendDtoModelsHiveContent: BackendDtoModelsHiveContent, options?: any) {
        return KnowledgeBaseApiFp(this.configuration).createHiveV1(backendDtoModelsHiveContent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletehive
     * @param {string} hiveId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseApi
     */
    public deleteHiveV1(hiveId: string, options?: any) {
        return KnowledgeBaseApiFp(this.configuration).deleteHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gethive
     * @param {string} hiveId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseApi
     */
    public getHiveV1(hiveId: string, options?: any) {
        return KnowledgeBaseApiFp(this.configuration).getHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Listhives
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseApi
     */
    public listHivesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return KnowledgeBaseApiFp(this.configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updatehive
     * @param {string} hiveId 
     * @param {BackendDbModelsHiveContent} backendDbModelsHiveContent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseApi
     */
    public updateHiveV1(hiveId: string, backendDbModelsHiveContent: BackendDbModelsHiveContent, options?: any) {
        return KnowledgeBaseApiFp(this.configuration).updateHiveV1(hiveId, backendDbModelsHiveContent, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Getmetrics
         * @param {BatchMetricsRequests} batchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1MetricsPost: async (batchMetricsRequests: BatchMetricsRequests, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchMetricsRequests' is not null or undefined
            if (batchMetricsRequests === null || batchMetricsRequests === undefined) {
                throw new RequiredError('batchMetricsRequests','Required parameter batchMetricsRequests was null or undefined when calling getMetricsV1MetricsPost.');
            }
            const localVarPath = `/v1/metrics`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof batchMetricsRequests !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(batchMetricsRequests !== undefined ? batchMetricsRequests : {}) : (batchMetricsRequests || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getoverallstats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallStatsV1StatsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/stats`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Getmetrics
         * @param {BatchMetricsRequests} batchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetricsV1MetricsPost(batchMetricsRequests: BatchMetricsRequests, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchMetricsResponse>> {
            const localVarAxiosArgs = await MetricsApiAxiosParamCreator(configuration).getMetricsV1MetricsPost(batchMetricsRequests, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Getoverallstats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOverallStatsV1StatsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsResponse>> {
            const localVarAxiosArgs = await MetricsApiAxiosParamCreator(configuration).getOverallStatsV1StatsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Getmetrics
         * @param {BatchMetricsRequests} batchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1MetricsPost(batchMetricsRequests: BatchMetricsRequests, options?: any): AxiosPromise<BatchMetricsResponse> {
            return MetricsApiFp(configuration).getMetricsV1MetricsPost(batchMetricsRequests, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getoverallstats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallStatsV1StatsGet(options?: any): AxiosPromise<StatsResponse> {
            return MetricsApiFp(configuration).getOverallStatsV1StatsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * 
     * @summary Getmetrics
     * @param {BatchMetricsRequests} batchMetricsRequests 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetricsV1MetricsPost(batchMetricsRequests: BatchMetricsRequests, options?: any) {
        return MetricsApiFp(this.configuration).getMetricsV1MetricsPost(batchMetricsRequests, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Getoverallstats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getOverallStatsV1StatsGet(options?: any) {
        return MetricsApiFp(this.configuration).getOverallStatsV1StatsGet(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Createproduct
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductV1: async (productInput: ProductInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productInput' is not null or undefined
            if (productInput === null || productInput === undefined) {
                throw new RequiredError('productInput','Required parameter productInput was null or undefined when calling createProductV1.');
            }
            const localVarPath = `/v1/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof productInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(productInput !== undefined ? productInput : {}) : (productInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deleteproduct
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductV1: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getproduct
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductV1: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Listagentsofproduct
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfProductV1: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling listAgentsOfProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}/agents`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Listproducts
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Array<string>} [tags] 
         * @param {Array<string>} [productIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (productIds) {
                localVarQueryParameter['product_ids'] = productIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updateproduct
         * @param {string} productId 
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductV1: async (productId: string, productInput: ProductInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling updateProductV1.');
            }
            // verify required parameter 'productInput' is not null or undefined
            if (productInput === null || productInput === undefined) {
                throw new RequiredError('productInput','Required parameter productInput was null or undefined when calling updateProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof productInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(productInput !== undefined ? productInput : {}) : (productInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Createproduct
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProductV1(productInput: ProductInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOutput>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).createProductV1(productInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deleteproduct
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductV1(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).deleteProductV1(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Getproduct
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductV1(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOutput>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).getProductV1(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Listagentsofproduct
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAgentsOfProductV1(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AIAgentOutput>>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).listAgentsOfProductV1(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Listproducts
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Array<string>} [tags] 
         * @param {Array<string>} [productIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProductsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductOutput>>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updateproduct
         * @param {string} productId 
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProductV1(productId: string, productInput: ProductInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOutput>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).updateProductV1(productId, productInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Createproduct
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductV1(productInput: ProductInput, options?: any): AxiosPromise<ProductOutput> {
            return ProductsApiFp(configuration).createProductV1(productInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deleteproduct
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductV1(productId: string, options?: any): AxiosPromise<BaseResponse> {
            return ProductsApiFp(configuration).deleteProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getproduct
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductV1(productId: string, options?: any): AxiosPromise<ProductOutput> {
            return ProductsApiFp(configuration).getProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Listagentsofproduct
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfProductV1(productId: string, options?: any): AxiosPromise<Array<AIAgentOutput>> {
            return ProductsApiFp(configuration).listAgentsOfProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Listproducts
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Array<string>} [tags] 
         * @param {Array<string>} [productIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options?: any): AxiosPromise<Array<ProductOutput>> {
            return ProductsApiFp(configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updateproduct
         * @param {string} productId 
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductV1(productId: string, productInput: ProductInput, options?: any): AxiosPromise<ProductOutput> {
            return ProductsApiFp(configuration).updateProductV1(productId, productInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * 
     * @summary Createproduct
     * @param {ProductInput} productInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public createProductV1(productInput: ProductInput, options?: any) {
        return ProductsApiFp(this.configuration).createProductV1(productInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deleteproduct
     * @param {string} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProductV1(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).deleteProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Getproduct
     * @param {string} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductV1(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).getProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Listagentsofproduct
     * @param {string} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listAgentsOfProductV1(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).listAgentsOfProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Listproducts
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {Array<string>} [tags] 
     * @param {Array<string>} [productIds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listProductsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options?: any) {
        return ProductsApiFp(this.configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updateproduct
     * @param {string} productId 
     * @param {ProductInput} productInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProductV1(productId: string, productInput: ProductInput, options?: any) {
        return ProductsApiFp(this.configuration).updateProductV1(productId, productInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ProspectsApi - axios parameter creator
 * @export
 */
export const ProspectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new prospect.
         * @summary Createprospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProspectV1: async (prospectInput: ProspectInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectInput' is not null or undefined
            if (prospectInput === null || prospectInput === undefined) {
                throw new RequiredError('prospectInput','Required parameter prospectInput was null or undefined when calling createProspectV1.');
            }
            const localVarPath = `/v1/prospects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof prospectInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(prospectInput !== undefined ? prospectInput : {}) : (prospectInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific prospect by ID.
         * @summary Deleteprospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProspectV1: async (prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling deleteProspectV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a specific prospect by ID.
         * @summary Getprospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProspectV1: async (prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling getProspectV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all prospects under the user\'s organization
         * @summary Listprospects
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProspectsV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/prospects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a specific prospect by ID.
         * @summary Updateprospect
         * @param {string} prospectId 
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProspectV1: async (prospectId: string, prospectInput: ProspectInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling updateProspectV1.');
            }
            // verify required parameter 'prospectInput' is not null or undefined
            if (prospectInput === null || prospectInput === undefined) {
                throw new RequiredError('prospectInput','Required parameter prospectInput was null or undefined when calling updateProspectV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof prospectInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(prospectInput !== undefined ? prospectInput : {}) : (prospectInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProspectsApi - functional programming interface
 * @export
 */
export const ProspectsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new prospect.
         * @summary Createprospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProspectV1(prospectInput: ProspectInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProspectOutput>> {
            const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(configuration).createProspectV1(prospectInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a specific prospect by ID.
         * @summary Deleteprospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProspectV1(prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(configuration).deleteProspectV1(prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches a specific prospect by ID.
         * @summary Getprospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProspectV1(prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProspectOutput>> {
            const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(configuration).getProspectV1(prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all prospects under the user\'s organization
         * @summary Listprospects
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProspectsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProspectOutput>>> {
            const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(configuration).listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a specific prospect by ID.
         * @summary Updateprospect
         * @param {string} prospectId 
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProspectV1(prospectId: string, prospectInput: ProspectInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProspectOutput>> {
            const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(configuration).updateProspectV1(prospectId, prospectInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProspectsApi - factory interface
 * @export
 */
export const ProspectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a new prospect.
         * @summary Createprospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProspectV1(prospectInput: ProspectInput, options?: any): AxiosPromise<ProspectOutput> {
            return ProspectsApiFp(configuration).createProspectV1(prospectInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific prospect by ID.
         * @summary Deleteprospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProspectV1(prospectId: string, options?: any): AxiosPromise<BaseResponse> {
            return ProspectsApiFp(configuration).deleteProspectV1(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a specific prospect by ID.
         * @summary Getprospect
         * @param {string} prospectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProspectV1(prospectId: string, options?: any): AxiosPromise<ProspectOutput> {
            return ProspectsApiFp(configuration).getProspectV1(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all prospects under the user\'s organization
         * @summary Listprospects
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProspectsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<ProspectOutput>> {
            return ProspectsApiFp(configuration).listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a specific prospect by ID.
         * @summary Updateprospect
         * @param {string} prospectId 
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProspectV1(prospectId: string, prospectInput: ProspectInput, options?: any): AxiosPromise<ProspectOutput> {
            return ProspectsApiFp(configuration).updateProspectV1(prospectId, prospectInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProspectsApi - object-oriented interface
 * @export
 * @class ProspectsApi
 * @extends {BaseAPI}
 */
export class ProspectsApi extends BaseAPI {
    /**
     * Creates a new prospect.
     * @summary Createprospect
     * @param {ProspectInput} prospectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public createProspectV1(prospectInput: ProspectInput, options?: any) {
        return ProspectsApiFp(this.configuration).createProspectV1(prospectInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific prospect by ID.
     * @summary Deleteprospect
     * @param {string} prospectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public deleteProspectV1(prospectId: string, options?: any) {
        return ProspectsApiFp(this.configuration).deleteProspectV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a specific prospect by ID.
     * @summary Getprospect
     * @param {string} prospectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public getProspectV1(prospectId: string, options?: any) {
        return ProspectsApiFp(this.configuration).getProspectV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all prospects under the user\'s organization
     * @summary Listprospects
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public listProspectsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return ProspectsApiFp(this.configuration).listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a specific prospect by ID.
     * @summary Updateprospect
     * @param {string} prospectId 
     * @param {ProspectInput} prospectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public updateProspectV1(prospectId: string, prospectInput: ProspectInput, options?: any) {
        return ProspectsApiFp(this.configuration).updateProspectV1(prospectId, prospectInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UIApi - axios parameter creator
 * @export
 */
export const UIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Action Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionTemplatesV1: async (language?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ui/action-templates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Products
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Array<string>} [tags] 
         * @param {Array<string>} [productIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ui/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (productIds) {
                localVarQueryParameter['product_ids'] = productIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Prompt Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptTemplatesV1: async (language?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ui/prompt-templates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Role Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleTemplatesV1: async (language?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ui/role-templates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UIApi - functional programming interface
 * @export
 */
export const UIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Action Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActionTemplatesV1(language?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BackendDtoModelsAction>>> {
            const localVarAxiosArgs = await UIApiAxiosParamCreator(configuration).listActionTemplatesV1(language, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Products
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Array<string>} [tags] 
         * @param {Array<string>} [productIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProductsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductWithAgents>>> {
            const localVarAxiosArgs = await UIApiAxiosParamCreator(configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Prompt Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPromptTemplatesV1(language?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: PromptTemplate; }>> {
            const localVarAxiosArgs = await UIApiAxiosParamCreator(configuration).listPromptTemplatesV1(language, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Role Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoleTemplatesV1(language?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleTemplate>>> {
            const localVarAxiosArgs = await UIApiAxiosParamCreator(configuration).listRoleTemplatesV1(language, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UIApi - factory interface
 * @export
 */
export const UIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary List Action Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionTemplatesV1(language?: string, options?: any): AxiosPromise<Array<BackendDtoModelsAction>> {
            return UIApiFp(configuration).listActionTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Products
         * @param {string} [searchBy] 
         * @param {string} [searchValue] 
         * @param {string} [status] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Array<string>} [tags] 
         * @param {Array<string>} [productIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options?: any): AxiosPromise<Array<ProductWithAgents>> {
            return UIApiFp(configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Prompt Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptTemplatesV1(language?: string, options?: any): AxiosPromise<{ [key: string]: PromptTemplate; }> {
            return UIApiFp(configuration).listPromptTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Role Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleTemplatesV1(language?: string, options?: any): AxiosPromise<Array<RoleTemplate>> {
            return UIApiFp(configuration).listRoleTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UIApi - object-oriented interface
 * @export
 * @class UIApi
 * @extends {BaseAPI}
 */
export class UIApi extends BaseAPI {
    /**
     * 
     * @summary List Action Templates
     * @param {string} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    public listActionTemplatesV1(language?: string, options?: any) {
        return UIApiFp(this.configuration).listActionTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Products
     * @param {string} [searchBy] 
     * @param {string} [searchValue] 
     * @param {string} [status] 
     * @param {string} [sortBy] 
     * @param {SortOrder} [sortOrder] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {Array<string>} [tags] 
     * @param {Array<string>} [productIds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    public listProductsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options?: any) {
        return UIApiFp(this.configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Prompt Templates
     * @param {string} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    public listPromptTemplatesV1(language?: string, options?: any) {
        return UIApiFp(this.configuration).listPromptTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Role Templates
     * @param {string} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    public listRoleTemplatesV1(language?: string, options?: any) {
        return UIApiFp(this.configuration).listRoleTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * VoiceModelsApi - axios parameter creator
 * @export
 */
export const VoiceModelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Listvoicemodels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceModelsV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/voice-models`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoiceModelsApi - functional programming interface
 * @export
 */
export const VoiceModelsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Listvoicemodels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVoiceModelsV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VoiceModel>>> {
            const localVarAxiosArgs = await VoiceModelsApiAxiosParamCreator(configuration).listVoiceModelsV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VoiceModelsApi - factory interface
 * @export
 */
export const VoiceModelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Listvoicemodels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceModelsV1(options?: any): AxiosPromise<Array<VoiceModel>> {
            return VoiceModelsApiFp(configuration).listVoiceModelsV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VoiceModelsApi - object-oriented interface
 * @export
 * @class VoiceModelsApi
 * @extends {BaseAPI}
 */
export class VoiceModelsApi extends BaseAPI {
    /**
     * 
     * @summary Listvoicemodels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceModelsApi
     */
    public listVoiceModelsV1(options?: any) {
        return VoiceModelsApiFp(this.configuration).listVoiceModelsV1(options).then((request) => request(this.axios, this.basePath));
    }

}


